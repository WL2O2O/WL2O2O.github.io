{"meta":{"version":1,"warehouse":"4.0.2"},"models":{"Asset":[{"_id":"themes/fluid/source/silian.txt","path":"silian.txt","modified":1,"renderable":1},{"_id":"themes/fluid/source/css/gitalk.css","path":"css/gitalk.css","modified":1,"renderable":1},{"_id":"themes/fluid/source/css/highlight-dark.styl","path":"css/highlight-dark.styl","modified":1,"renderable":1},{"_id":"themes/fluid/source/css/highlight.styl","path":"css/highlight.styl","modified":1,"renderable":1},{"_id":"themes/fluid/source/css/main.styl","path":"css/main.styl","modified":1,"renderable":1},{"_id":"themes/fluid/source/img/avatar.png","path":"img/avatar.png","modified":1,"renderable":1},{"_id":"themes/fluid/source/img/default.png","path":"img/default.png","modified":1,"renderable":1},{"_id":"themes/fluid/source/img/default1.png","path":"img/default1.png","modified":1,"renderable":1},{"_id":"themes/fluid/source/img/example.png","path":"img/example.png","modified":1,"renderable":1},{"_id":"themes/fluid/source/img/gitee.png","path":"img/gitee.png","modified":1,"renderable":1},{"_id":"themes/fluid/source/img/fluid.ico","path":"img/fluid.ico","modified":1,"renderable":1},{"_id":"themes/fluid/source/img/github.png","path":"img/github.png","modified":1,"renderable":1},{"_id":"themes/fluid/source/img/loading.gif","path":"img/loading.gif","modified":1,"renderable":1},{"_id":"themes/fluid/source/img/police_beian.png","path":"img/police_beian.png","modified":1,"renderable":1},{"_id":"themes/fluid/source/img/yuque.png","path":"img/yuque.png","modified":1,"renderable":1},{"_id":"themes/fluid/source/js/boot.js","path":"js/boot.js","modified":1,"renderable":1},{"_id":"themes/fluid/source/js/color-schema.js","path":"js/color-schema.js","modified":1,"renderable":1},{"_id":"themes/fluid/source/js/events.js","path":"js/events.js","modified":1,"renderable":1},{"_id":"themes/fluid/source/js/img-lazyload.js","path":"js/img-lazyload.js","modified":1,"renderable":1},{"_id":"themes/fluid/source/js/leancloud.js","path":"js/leancloud.js","modified":1,"renderable":1},{"_id":"themes/fluid/source/js/local-search.js","path":"js/local-search.js","modified":1,"renderable":1},{"_id":"themes/fluid/source/js/plugins.js","path":"js/plugins.js","modified":1,"renderable":1},{"_id":"themes/fluid/source/js/utils.js","path":"js/utils.js","modified":1,"renderable":1},{"_id":"themes/fluid/source/xml/local-search.xml","path":"xml/local-search.xml","modified":1,"renderable":1}],"Cache":[{"_id":"source/_posts/001.两数之和.md","hash":"e6b845fe27bbe87af16ba4f6db114f08b912e347","modified":1700969374868},{"_id":"source/_posts/CampousLostAndFound.md","hash":"ad4d8c8fd6d14def50c2cec32e3ec81ad4ea6e1a","modified":1700970075050},{"_id":"source/_posts/Bugsss.md","hash":"fa3a351388ab385fd91a1049f6fbd61b7da04eab","modified":1700970026348},{"_id":"source/_posts/026.删除有序数组中的重复项.md","hash":"e8e4a39d0e650d2c64a3593fd3af71ebaf101eed","modified":1700969423226},{"_id":"source/_posts/DMDatabase.md","hash":"232993363aef93e5d1abd25ef4a07bd788482cb3","modified":1697439539246},{"_id":"source/_posts/JZ06PrintLinkedList.md","hash":"86e9ff97328c44b4c04bf7480f77e3735bcc3b53","modified":1700036986758},{"_id":"source/_posts/JVM.md","hash":"40cfa7491ad367ab5977e3a8af025d381efc1730","modified":1700040075716},{"_id":"source/_posts/JZ24ReverseLinkedList.md","hash":"a9b66c23a9e6375b9ee2011575db22197c80f39e","modified":1700036974980},{"_id":"source/_posts/Educoder.md","hash":"7bfcf5a6c3ab2e9ae6f9b07bca2fad6a6566c8db","modified":1700040005116},{"_id":"source/_posts/LCR-003-比特位计数.md","hash":"f77ecb58785b61fa4784148883d1622c532b9fa9","modified":1700037024366},{"_id":"source/_posts/LCR-002-二进制求和.md","hash":"4b5eced9fb4a52255b41b1dcc185023703b8afa8","modified":1700036957996},{"_id":"source/_posts/Linux.md","hash":"659860200803880d03e6b5370c201350ed98bc97","modified":1699866235971},{"_id":"source/_posts/Polymorphism.md","hash":"5c405e475432d38632e8f0630652ccd787e0bb99","modified":1700040122276},{"_id":"source/_posts/LCR-136-删除链表结点.md","hash":"875da77ad52c7e8fcfd7fa0370e988e84be7fe82","modified":1700037035079},{"_id":"source/_posts/MyLanqiaoNote.md","hash":"b8488c54e30fbf847f54f6f73112d0db96f95d07","modified":1700312564094},{"_id":"source/_posts/Redis.md","hash":"1aa00641cf35748e4e79ff47265d841fb1270f16","modified":1697439539264},{"_id":"source/_posts/SSM.md","hash":"52b7bc327a117caf0ffb42415494b6a029455c7a","modified":1700037711171},{"_id":"source/_posts/abstractandinterface.md","hash":"4b77de89f5847a62085cc75d5826980ca17de02b","modified":1700039945853},{"_id":"source/_posts/aggregateSearch.md","hash":"9b1c1aa06a783880490ef58fa7a4df50bcfe6cb1","modified":1700969468271},{"_id":"source/_posts/bilibili.md","hash":"837650c38f76600539b9bf2c3a7872caf17c6d2e","modified":1700969977259},{"_id":"source/_posts/collection.md","hash":"8462cea0c8314256e687f5203a9c90c8aff9562a","modified":1700970182850},{"_id":"source/_posts/csh.md","hash":"de671e75070f49986902eb496a08a328f231bbe8","modified":1697439539281},{"_id":"source/_posts/css.md","hash":"a845a7ef28d0846e682076be9c1e747616e275a9","modified":1697439539279},{"_id":"source/_posts/git.md","hash":"c20dcdcb820b9844feb6561172c21d37d41e0560","modified":1700985810925},{"_id":"source/_posts/helloHexo.md","hash":"a327db4ff2a03191922f5906ffba90804dce2f15","modified":1700986238062},{"_id":"source/_posts/helloVuepress.md","hash":"1b52f1e9c11fa1b5e9000facb411b9788c06f147","modified":1697439539286},{"_id":"source/_posts/hiOffer.md","hash":"83af3b6bde9d8287645cddf9f5c8e1c3bba729fd","modified":1697439539288},{"_id":"source/_posts/howtomakeproject.md","hash":"1303b8c1fbb88bc817738a82e581e95ebe4a89e2","modified":1698118148694},{"_id":"source/_posts/library.md","hash":"5ebee5f4870e45fd83bde6cd0f27f19377bc4685","modified":1697439539293},{"_id":"source/_posts/log4j.md","hash":"53ead01c41d909832e6af301aeaf20d3f4d3e74a","modified":1697439539291},{"_id":"source/_posts/netblog.md","hash":"e8d4dec4fb0bc492e67dc31ec697d2b5e1501c6f","modified":1701307082058},{"_id":"source/_posts/mysql.md","hash":"555c9996a19e0bc57ffe5739bfaf9164904e0d4f","modified":1700037506206},{"_id":"source/_posts/love.md","hash":"5c35f2d0099adb1acac902a7d0210efaef05b6c6","modified":1697439539294},{"_id":"source/_posts/netty.md","hash":"fdcb40681352c7d78ae9a5159eeec2ba9ef0cd8d","modified":1700037524047},{"_id":"source/_posts/object.md","hash":"ed5d94f18497dedf666320dc1953f0e1331e4a5d","modified":1697439539303},{"_id":"source/_posts/oj.md","hash":"3ec7ecb67154b099753d61d67b429d3387638b7b","modified":1700654610702},{"_id":"source/_posts/plan-a.md","hash":"66008ee128e730269a8a8182f4ed07457937a4ba","modified":1697439539307},{"_id":"source/_posts/头歌实践教学平台-Linux网络实战（一）-DNS配置（Ubuntu系统）.md","hash":"acc212699fbf89636cd82912ad12fad2530e5e38","modified":1701307147700},{"_id":"source/_posts/shangyitong.md","hash":"9e80d7d5adfaff089cda1a902cb0071a8c176169","modified":1700037891632},{"_id":"source/_posts/tip.md","hash":"b669af606510a8f83810f38c7d321fc7cc703746","modified":1700912466082},{"_id":"source/_posts/transaction.md","hash":"e128792a69d54547599b8823ce90e795d6a04fe5","modified":1700037951992},{"_id":"source/_posts/Java-Essay.md","hash":"28a1d24d371517289d53dcc6857df4c5f10d5015","modified":1700413140512},{"_id":"source/_posts/api.md","hash":"0bad8ec797e77ef210731e4925e98144dc42f143","modified":1700037344831},{"_id":"source/_posts/面渣八股.md","hash":"a5b430b61421a5dd7ed79272edc85af0c336051e","modified":1700492097009},{"_id":"source/about/index.md","hash":"c39746b456c27ab190db5ce35f4307ed95b36d3a","modified":1700051109321},{"_id":"themes/fluid/source/css/_pages/_tag/tag.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1676651100574},{"_id":"themes/fluid/.gitignore","hash":"ae3bfcb89777657c5dfb5169d91445dcb0e5ab98","modified":1676651095167},{"_id":"themes/fluid/.editorconfig","hash":"33218fbd623feb43edf5f99f15965392cecc44a6","modified":1676651095058},{"_id":"themes/fluid/.gitattributes","hash":"a54f902957d49356376b59287b894b1a3d7a003f","modified":1676651095136},{"_id":"themes/fluid/LICENSE","hash":"26f9356fd6e84b5a88df6d9014378f41b65ba209","modified":1676651095199},{"_id":"themes/fluid/package.json","hash":"30e3f4ccfef8474c05cf0b1eb02e91bd0a152807","modified":1676651095308},{"_id":"themes/fluid/.eslintrc","hash":"4bc2b19ce2b8c4d242f97d4ccf2d741e68ab0097","modified":1676651095105},{"_id":"themes/fluid/README.md","hash":"6d752df6f2278033dc2512a7d5be22c8a8eb665a","modified":1676651095231},{"_id":"themes/fluid/_config.yml","hash":"0ed06adabffc46e15d0866541cbfa54a5ea729bf","modified":1676934817134},{"_id":"themes/fluid/languages/de.yml","hash":"0e7d455d9e004ff15d8924b7a0c35cea25ee5b1d","modified":1676651095575},{"_id":"themes/fluid/README_en.md","hash":"8c874f309e346fffa392e174385b5cc08510f218","modified":1676651095261},{"_id":"themes/fluid/languages/en.yml","hash":"cb11b39f44ea069652c9647179606b6cecc98d50","modified":1676651095606},{"_id":"themes/fluid/languages/eo.yml","hash":"a556251cc50a5680578c03f1efbf252b1f4ab860","modified":1676651095625},{"_id":"themes/fluid/languages/ja.yml","hash":"3dd6d20f8d26585a7c154a8e59fe8d5d902f4c6a","modified":1676651095684},{"_id":"themes/fluid/languages/ru.yml","hash":"7dc78f22696649a4c68dc65a9b52d9a992fa82a0","modified":1676651095700},{"_id":"themes/fluid/languages/es.yml","hash":"7112594259c88c04714be152af7fd377687dad40","modified":1676651095653},{"_id":"themes/fluid/languages/zh-CN.yml","hash":"f96a22f989897ecddc69d5867a206e1cf6b8f610","modified":1676651095734},{"_id":"themes/fluid/languages/zh-HK.yml","hash":"80ed400a7adaa92ea54fc7f5d534c9af795bed00","modified":1676651095748},{"_id":"themes/fluid/layout/archive.ejs","hash":"7c1f44005849791feae4abaa10fae4cb983d3277","modified":1676651095904},{"_id":"themes/fluid/languages/zh-TW.yml","hash":"596d031dff3826ae8e4ffc8931fff28977b73247","modified":1676651095783},{"_id":"themes/fluid/layout/404.ejs","hash":"b84d575c7b7f778b4cb64e89ad3d0aed4a896820","modified":1676651095811},{"_id":"themes/fluid/layout/categories.ejs","hash":"13859726c27b6c79b5876ec174176d0f9c1ee164","modified":1676651095949},{"_id":"themes/fluid/layout/category.ejs","hash":"f099161b738a16a32253f42085b5444f902018ed","modified":1676651095985},{"_id":"themes/fluid/layout/about.ejs","hash":"163bee643e6a38912d3ae70923c83c48d57222e7","modified":1676651095873},{"_id":"themes/fluid/layout/layout.ejs","hash":"7e0023474128fbe4d68c467704c41f1712432415","modified":1692499292413},{"_id":"themes/fluid/layout/page.ejs","hash":"ed5007a3feb8f14d3d2843271bfb298eb0c56219","modified":1676651096172},{"_id":"themes/fluid/layout/links.ejs","hash":"1cac32ec4579aaf7b9fa39d317497331d4c5e1dd","modified":1676651096141},{"_id":"themes/fluid/layout/tag.ejs","hash":"9d686364c4d16a1a9219471623af452035c5b966","modified":1676651096295},{"_id":"themes/fluid/layout/index.ejs","hash":"db000a6a0cec19d32a6e7e94cd4c478500d9c5ac","modified":1700035030370},{"_id":"themes/fluid/layout/tags.ejs","hash":"1d06af34b6cf1d8a20d2eb565e309326ceba309f","modified":1676651096330},{"_id":"themes/fluid/source/silian.txt","hash":"5a0acdb8eb3889bc4b39d82849c7020d8bbcd391","modified":1700617416085},{"_id":"themes/fluid/layout/_partials/archive-list.ejs","hash":"7520fbf91f762207c2ab06b2c293235cd5b23905","modified":1676651096371},{"_id":"themes/fluid/layout/_partials/category-chains.ejs","hash":"18309584aab83bc4deb20723ebad832149dd2e24","modified":1676651096417},{"_id":"themes/fluid/layout/_partials/comments.ejs","hash":"d707c47b2638c94e489bc43d4cfd098b7c58447f","modified":1676651096519},{"_id":"themes/fluid/layout/post.ejs","hash":"c2864715fc6ca3715dd74db1058d33921dc2f940","modified":1699978806750},{"_id":"themes/fluid/layout/_partials/analytics.ejs","hash":"a30bb3013c12f26e4de79ed9e394389a17988b0e","modified":1692505928844},{"_id":"themes/fluid/layout/_partials/css.ejs","hash":"85f6e051550907681ab4ed2e268ac8f6e9ebf931","modified":1676651096575},{"_id":"themes/fluid/layout/_partials/footer.ejs","hash":"e9a018322fc566366ab2ba28d1d8a8e9197692da","modified":1700588555753},{"_id":"themes/fluid/layout/_partials/head.ejs","hash":"975920426c72976aaafe1dbe56e010ee5f03c706","modified":1700588870958},{"_id":"themes/fluid/layout/_partials/header.ejs","hash":"0d5e397d30051e5fbabe7b47cfd1f1e6a5820af1","modified":1676651096702},{"_id":"themes/fluid/layout/_partials/category-list.ejs","hash":"f8d2f1907450e61968e6d54443e9be8138196a77","modified":1676651096488},{"_id":"themes/fluid/layout/_partials/paginator.ejs","hash":"0f38a2c238169edcb63fc46c23bfc529ff3859b7","modified":1676651096803},{"_id":"themes/fluid/scripts/filters/locals.js","hash":"58d0fec976f6b1d35e7ea03edc45414088acf05c","modified":1676651098602},{"_id":"themes/fluid/scripts/filters/post-filter.js","hash":"d516b9db63067f9ea9c72cc75ae4ff358417e77d","modified":1676651098634},{"_id":"themes/fluid/scripts/events/index.js","hash":"79de5a379b28cad759a49048351c7f6b8915bd7d","modified":1676651098287},{"_id":"themes/fluid/scripts/filters/default-injects.js","hash":"b2013ae8e189cd07ebc8a2ff48a78e153345210f","modified":1676651098565},{"_id":"themes/fluid/scripts/generators/local-search.js","hash":"fc2c50405b771b06b7f6cfc4e9de97b992691555","modified":1676651098669},{"_id":"themes/fluid/scripts/generators/pages.js","hash":"d9971f15fbb6b775e3d31a1b9b45011959395010","modified":1676651098704},{"_id":"themes/fluid/scripts/helpers/export-config.js","hash":"47e6dba7652a621a54067413490a11c8a89e3d7b","modified":1676651098800},{"_id":"themes/fluid/scripts/helpers/date.js","hash":"9bda6382f61b40a20c24af466fe10c8366ebb74c","modified":1676651098731},{"_id":"themes/fluid/scripts/helpers/engine.js","hash":"d3a231d106795ce99cb0bc77eb65f9ae44515933","modified":1676651098761},{"_id":"themes/fluid/scripts/helpers/import.js","hash":"ca53e8dbf7d44cfd372cfa79ac60f35a7d5b0076","modified":1676651098823},{"_id":"themes/fluid/scripts/helpers/page.js","hash":"4607607445233b3029ef20ed5e91de0da0a7f9c5","modified":1676651098886},{"_id":"themes/fluid/scripts/helpers/injects.js","hash":"1ad2ae6b11bd8806ee7dd6eb7140d8b54a95d613","modified":1676651098862},{"_id":"themes/fluid/scripts/helpers/scope.js","hash":"d41d9d658fcb54964b388598e996747aadb85b0f","modified":1676651098921},{"_id":"themes/fluid/scripts/helpers/utils.js","hash":"226f99b465ff513de075a8e78b321d6cb62592ca","modified":1676651098982},{"_id":"themes/fluid/scripts/helpers/url.js","hash":"2a6a8288176d0e0f6ec008056bf2745a86e8943e","modified":1676651098952},{"_id":"themes/fluid/scripts/tags/checkbox.js","hash":"4938610c3543a921a341bc074626d511cb1a4b45","modified":1676651099078},{"_id":"themes/fluid/scripts/helpers/wordcount.js","hash":"4543b8954c5c2ca91191cc0d53cf071b3f26faaa","modified":1676651099012},{"_id":"themes/fluid/scripts/tags/button.js","hash":"3eb43a8cdea0a64576ad6b31b4df6c2bf5698d4c","modified":1676651099047},{"_id":"themes/fluid/scripts/tags/label.js","hash":"f05a6d32cca79535b22907dc03edb9d3fa2d8176","modified":1676651099126},{"_id":"themes/fluid/scripts/tags/group-image.js","hash":"4aeebb797026f1df25646a5d69f7fde79b1bcd26","modified":1676651099108},{"_id":"themes/fluid/scripts/tags/mermaid.js","hash":"75160561e1ef3603b6d2ad2938464ab1cb77fd38","modified":1676651099165},{"_id":"themes/fluid/scripts/tags/note.js","hash":"f52f3a005b41f48b4da274ac64710177c8d4502f","modified":1676651099193},{"_id":"themes/fluid/scripts/utils/compare-versions.js","hash":"dbbc928c914fc2bd242cd66aa0c45971aec13a5d","modified":1676651099234},{"_id":"themes/fluid/scripts/utils/object.js","hash":"33b57e4decdc5e75c518859f168c8ba80b2c665b","modified":1676651099265},{"_id":"themes/fluid/scripts/utils/resolve.js","hash":"8c4a8b62aa8608f12f1e9046231dff04859dc3e9","modified":1676651099293},{"_id":"themes/fluid/layout/_partials/search.ejs","hash":"70e1c929e084ca8a2648cedabf29b372511ea2b8","modified":1676651096883},{"_id":"themes/fluid/scripts/utils/url-join.js","hash":"718aab5e7b2059a06b093ca738de420d9afa44ba","modified":1676651099329},{"_id":"themes/fluid/source/css/highlight-dark.styl","hash":"45695ef75c31a4aa57324dd408b7e2327a337018","modified":1676651099411},{"_id":"themes/fluid/source/css/highlight.styl","hash":"a9efc52a646a9e585439c768557e3e3c9e3326dc","modified":1676651099439},{"_id":"themes/fluid/source/css/main.styl","hash":"855ae5fe229c51afa57f7645f6997a27a705d7e4","modified":1676651099476},{"_id":"themes/fluid/source/css/gitalk.css","hash":"a57b3cc8e04a0a4a27aefa07facf5b5e7bca0e76","modified":1676651099378},{"_id":"themes/fluid/source/img/avatar.png","hash":"479bbc5ac5e9f6e17e9b6d47954d5a998162b649","modified":1658295291461},{"_id":"themes/fluid/layout/_partials/scripts.ejs","hash":"da5810785105e5075861593c7ac22c7aa9665a72","modified":1676651096858},{"_id":"themes/fluid/layout/_partials/markdown-plugins.ejs","hash":"fc4bdf7de0cf1a66d0e5e4fba1b31d6f7ed49468","modified":1676651096778},{"_id":"themes/fluid/source/img/example.png","hash":"b28effacb8e3a9efabb82202611c2bbac907860b","modified":1692444598779},{"_id":"themes/fluid/source/img/loading.gif","hash":"2d2fc0f947940f98c21afafef39ecf226a2e8d55","modified":1676651100747},{"_id":"themes/fluid/source/img/gitee.png","hash":"b47a340dfebf63f5a9e702c1316b4f7f942fefb3","modified":1694402052215},{"_id":"themes/fluid/source/img/police_beian.png","hash":"90efded6baa2dde599a9d6b1387973e8e64923ea","modified":1676651100782},{"_id":"themes/fluid/source/img/github.png","hash":"37dc28357897187b6dd9986ffe2026fe2de2f1c8","modified":1694398208658},{"_id":"themes/fluid/source/img/yuque.png","hash":"46965757aa7c28be00cd920e4317ff79b3f7b3b0","modified":1700557271539},{"_id":"themes/fluid/source/js/boot.js","hash":"38bd26c6b7acdafda86dda3560e6a3ca488d3c76","modified":1676651100810},{"_id":"themes/fluid/source/js/img-lazyload.js","hash":"cbdeca434ec4da51f488c821d51b4d23c73294af","modified":1676651100922},{"_id":"themes/fluid/source/js/color-schema.js","hash":"76a198f8721352ebeaf5b2ef2f4db00612da4796","modified":1676651100849},{"_id":"themes/fluid/source/js/events.js","hash":"89e3561488a618ed0caeb9edf18e441978e29c25","modified":1676651100889},{"_id":"themes/fluid/source/js/leancloud.js","hash":"eff77c7a5c399fcaefda48884980571e15243fc9","modified":1676651100954},{"_id":"themes/fluid/source/js/local-search.js","hash":"cebcda5991b6a9ab9307c69542389ce9013f04f7","modified":1676651100984},{"_id":"themes/fluid/source/xml/local-search.xml","hash":"8c96ba6a064705602ce28d096fd7dd9069630a55","modified":1676651101104},{"_id":"themes/fluid/source/js/plugins.js","hash":"c34916291e392a774ff3e85c55badb83e8661297","modified":1676651101021},{"_id":"themes/fluid/source/js/utils.js","hash":"45cc86f099db0a2c36ad49711ce66c2d598a2ab1","modified":1676651101047},{"_id":"themes/fluid/layout/_partials/comments/changyan.ejs","hash":"c9b2d68ed3d375f1953e7007307d2a3f75ed6249","modified":1676651096930},{"_id":"themes/fluid/layout/_partials/comments/cusdis.ejs","hash":"5f9dc012be27040bbe874d0c093c0d53958cc987","modified":1676651096967},{"_id":"themes/fluid/layout/_partials/comments/disqus.ejs","hash":"aab4a4d24c55231a37db308ae94414319cecdd9b","modified":1676651097009},{"_id":"themes/fluid/layout/_partials/comments/gitalk.ejs","hash":"843bc141a4545eb20d1c92fb63c85d459b4271ec","modified":1676651097073},{"_id":"themes/fluid/layout/_partials/comments/giscus.ejs","hash":"95f8b866b158eff9352c381c243b332a155a5110","modified":1676651097042},{"_id":"themes/fluid/layout/_partials/comments/livere.ejs","hash":"2264758fed57542a7389c7aa9f00f1aefa17eb87","modified":1676651097137},{"_id":"themes/fluid/layout/_partials/comments/utterances.ejs","hash":"c7ccf7f28308334a6da6f5425b141a24b5eca0e2","modified":1676651097247},{"_id":"themes/fluid/layout/_partials/comments/remark42.ejs","hash":"d4e9532feeb02aed61bd15eda536b5b631454dac","modified":1676651097178},{"_id":"themes/fluid/layout/_partials/comments/twikoo.ejs","hash":"e6820fb7f13662c42f8433ec95404238f4c1860c","modified":1676651097215},{"_id":"themes/fluid/layout/_partials/comments/waline.ejs","hash":"12727da7cf3ac83443270f550be4d1c06135b52b","modified":1676651097331},{"_id":"themes/fluid/layout/_partials/comments/valine.ejs","hash":"19ba937553dddd317f827d682661a1066a7b1f30","modified":1676651097292},{"_id":"themes/fluid/layout/_partials/footer/beian.ejs","hash":"520830bb44f5d5ee33879d251a345f197dd0cdce","modified":1676656348904},{"_id":"themes/fluid/layout/_partials/footer/statistics.ejs","hash":"454d8dd4c39f9494ebeb03ca0746f5bc122af76a","modified":1676651097443},{"_id":"themes/fluid/layout/_partials/header/banner.ejs","hash":"e07757b59e7b89eea213d0e595cb5932f812fd32","modified":1676651097483},{"_id":"themes/fluid/layout/_partials/plugins/code-widget.ejs","hash":"3a505cba37942badf62a56bbb8b605b72af330aa","modified":1676651097673},{"_id":"themes/fluid/layout/_partials/plugins/anchorjs.ejs","hash":"40181442d3a2b8734783a0ad7caf2d2522e3f2ab","modified":1676651097644},{"_id":"themes/fluid/layout/_partials/plugins/fancybox.ejs","hash":"9d1ea2a46b8c8ad8c168594d578f40764818ef13","modified":1676651097736},{"_id":"themes/fluid/layout/_partials/plugins/encrypt.ejs","hash":"e3713fa78e0fc14a239360b020068d8513573ae4","modified":1676651097706},{"_id":"themes/fluid/layout/_partials/plugins/highlight.ejs","hash":"7529dd215b09d3557804333942377b9e20fa554e","modified":1676651097767},{"_id":"themes/fluid/scripts/events/lib/compatible-configs.js","hash":"ef474d1fa5bbafc52619ced0f9dc7eaf2affb363","modified":1676651098320},{"_id":"themes/fluid/layout/_partials/header/navigation.ejs","hash":"870db75e4e403a840c4463dfeed2c9114846e7cc","modified":1676651097545},{"_id":"themes/fluid/layout/_partials/plugins/math.ejs","hash":"dcbf9a381ee76f2f1f75fcbc22c50a502ec85023","modified":1676651097819},{"_id":"themes/fluid/layout/_partials/plugins/mermaid.ejs","hash":"e49506e9895e255e0e53f34a11d325f83109c1b0","modified":1676651097855},{"_id":"themes/fluid/scripts/events/lib/footnote.js","hash":"2ec2ae03c79bb1ae7ac3fcf7e00fb52d1af2898d","modified":1676651098360},{"_id":"themes/fluid/scripts/events/lib/hello.js","hash":"44c5eb97b98813a07c659d6afedd17fad63b1821","modified":1676651098382},{"_id":"themes/fluid/scripts/events/lib/highlight.js","hash":"0f02df2244e275595e72163498d42f42bcf0de5e","modified":1676651098413},{"_id":"themes/fluid/scripts/events/lib/injects.js","hash":"5ae4b07204683e54b5a1b74e931702bbce2ac23e","modified":1676651098446},{"_id":"themes/fluid/scripts/events/lib/lazyload.js","hash":"9ba0d4bc224e22af8a5a48d6ff13e5a0fcfee2a4","modified":1676651098478},{"_id":"themes/fluid/layout/_partials/plugins/typed.ejs","hash":"51faef29f8e464bcb2e73049b428b88c8dd8b40a","modified":1676651097940},{"_id":"themes/fluid/layout/_partials/plugins/analytics.ejs","hash":"1327395a4dde1ea06c476b047fb110bcd269149f","modified":1676651097609},{"_id":"themes/fluid/scripts/events/lib/merge-configs.js","hash":"7c944c43b2ece5dd84859bd9d1fe955d13427387","modified":1676651098524},{"_id":"themes/fluid/layout/_partials/plugins/nprogress.ejs","hash":"4c2d39ce816b8a6dcd6b53113c8695f8bd650a23","modified":1676651097893},{"_id":"themes/fluid/layout/_partials/post/category-bar.ejs","hash":"8772bce97ed297e7a88523f4e939ed6436c22f87","modified":1676651097974},{"_id":"themes/fluid/layout/_partials/post/sidebar-left.ejs","hash":"9992c99b3eb728ad195970e1b84d665f2c8691c4","modified":1676651098177},{"_id":"themes/fluid/layout/_partials/post/meta-bottom.ejs","hash":"7079b27a7bc15a7dfa9209f6be6051bdec49ebad","modified":1676651098074},{"_id":"themes/fluid/layout/_partials/post/sidebar-right.ejs","hash":"d5fcc9b60e02f869a29a8c17a16a6028ecc1e6d8","modified":1676651098211},{"_id":"themes/fluid/layout/_partials/post/copyright.ejs","hash":"9d13392cea94b66d86422ad17c66e5ae67ce1d32","modified":1676651098035},{"_id":"themes/fluid/source/css/_functions/base.styl","hash":"2e46f3f4e2c9fe34c1ff1c598738fc7349ae8188","modified":1676651099502},{"_id":"themes/fluid/source/css/_variables/base.styl","hash":"4ed5f0ae105ef4c7dd92eaf652ceda176c38e502","modified":1676651100637},{"_id":"themes/fluid/layout/_partials/post/toc.ejs","hash":"635a89060fbf72eeda066fc4bd0a97462f069417","modified":1676651098249},{"_id":"themes/fluid/source/css/_mixins/base.styl","hash":"542e306ee9494e8a78e44d6d7d409605d94caeb3","modified":1676651099534},{"_id":"themes/fluid/source/css/_pages/pages.styl","hash":"b8e887bc7fb3b765a1f8ec9448eff8603a41984f","modified":1676651099565},{"_id":"themes/fluid/source/css/_pages/_about/about.styl","hash":"97fe42516ea531fdad771489b68aa8b2a7f6ae46","modified":1676651099598},{"_id":"themes/fluid/source/css/_pages/_archive/archive.styl","hash":"c475e6681546d30350eaed11f23081ecae80c375","modified":1676651099645},{"_id":"themes/fluid/source/css/_pages/_base/base.styl","hash":"643284c567665f96915f0b64e59934dda315f74d","modified":1676651099677},{"_id":"themes/fluid/source/css/_pages/_base/keyframes.styl","hash":"94065ea50f5bef7566d184f2422f6ac20866ba22","modified":1676651099755},{"_id":"themes/fluid/source/css/_pages/_base/inline.styl","hash":"411a3fa3f924a87e00ff04d18b5c83283b049a4d","modified":1676651099724},{"_id":"themes/fluid/source/css/_pages/_base/color-schema.styl","hash":"61279540c2623ea4bf93e40613d41380839b92d3","modified":1676651099708},{"_id":"themes/fluid/source/css/_pages/_category/category-bar.styl","hash":"cc6df43fef6bb3efecbfdd8b9e467424a1dea581","modified":1676651100258},{"_id":"themes/fluid/layout/_partials/post/meta-top.ejs","hash":"ce6e9f578f4faa45840abddf8f46af3f4b69c177","modified":1676651098146},{"_id":"themes/fluid/source/css/_pages/_category/category-chain.styl","hash":"0cdf7ef50dfd0669d3b257821384ff31cd81b7c9","modified":1676651100278},{"_id":"themes/fluid/source/css/_pages/_category/category-list.styl","hash":"7edfe1b571ecca7d08f5f4dbcf76f4ffdcfbf0b5","modified":1676651100306},{"_id":"themes/fluid/source/css/_pages/_index/index.styl","hash":"0acbd71633bcc7191672ea4e1b2277bea350d73b","modified":1676651100353},{"_id":"themes/fluid/source/css/_pages/_post/comment.styl","hash":"780f3788e7357bcd3f3262d781cb91bb53976a93","modified":1676651100432},{"_id":"themes/fluid/source/css/_pages/_links/links.styl","hash":"5c7f2044e3f1da05a3229537c06bd879836f8d6e","modified":1676651100391},{"_id":"themes/fluid/source/css/_pages/_post/highlight.styl","hash":"4df764d298fe556e501db4afc2b05686fe6ebcfb","modified":1676651100465},{"_id":"themes/fluid/source/css/_pages/_post/post-page.styl","hash":"127bb5391370afe7fef2a297084d76406bc5e902","modified":1676651100513},{"_id":"themes/fluid/source/css/_pages/_post/markdown.styl","hash":"1e3d3a82721e7c10bcfcecec6d81cf2979039452","modified":1676651100492},{"_id":"themes/fluid/source/css/_pages/_tag/tags.styl","hash":"65bfc01c76abc927fa1a23bf2422892b0d566c3f","modified":1676651100605},{"_id":"themes/fluid/source/css/_pages/_base/_widget/anchorjs.styl","hash":"e0cebda4a6f499aff75e71417d88caa7ceb13b94","modified":1676651099788},{"_id":"themes/fluid/source/css/_pages/_post/post-tag.styl","hash":"27f70062415ccf66a9b6f4952db124fc1471fda5","modified":1676651100542},{"_id":"themes/fluid/source/css/_pages/_base/_widget/code-widget.styl","hash":"b66ab013f0f37d724a149b85b3c7432afcf460ad","modified":1676651099881},{"_id":"themes/fluid/source/css/_pages/_base/_widget/banner.styl","hash":"7a0bd629bc234fc75e3cc8e3715ffada92f09e73","modified":1676651099818},{"_id":"themes/fluid/source/css/_pages/_base/_widget/footer.styl","hash":"2caaca71dd1ff63d583099ed817677dd267b457e","modified":1676651099934},{"_id":"themes/fluid/source/css/_pages/_base/_widget/board.styl","hash":"4397037fc3f0033dbe546c33cd9dbdabd8cb1632","modified":1676651099849},{"_id":"themes/fluid/source/css/_pages/_base/_widget/footnote.styl","hash":"ae9289cc89649af2042907f8a003303b987f3404","modified":1676651099961},{"_id":"themes/fluid/source/css/_pages/_base/_widget/copyright.styl","hash":"26f71a9cd60d96bb0cb5bbdf58150b8e524d9707","modified":1676651099896},{"_id":"themes/fluid/source/css/_pages/_base/_widget/header.styl","hash":"c4459248c66ea1326feed021179b847ae91d465f","modified":1676651099991},{"_id":"themes/fluid/source/css/_pages/_base/_widget/noscript.styl","hash":"0cf2f2bb44f456150d428016675d5876a9d2e2aa","modified":1676651100070},{"_id":"themes/fluid/source/css/_pages/_base/_widget/modal.styl","hash":"adf6c1e5c8e1fb41c77ce6e2258001df61245aa2","modified":1676651100024},{"_id":"themes/fluid/source/css/_pages/_base/_widget/ngrogress.styl","hash":"5d225357b4a58d46118e6616377168336ed44cb2","modified":1676651100054},{"_id":"themes/fluid/source/css/_pages/_base/_widget/pagination.styl","hash":"8bb1b68e5f3552cb48c2ffa31edbc53646a8fb4c","modified":1676651100101},{"_id":"themes/fluid/source/css/_pages/_base/_widget/qrcode.styl","hash":"78704a94c0436097abfb0e0a57abeb3429c749b7","modified":1676651100132},{"_id":"themes/fluid/source/css/_pages/_base/_widget/search.styl","hash":"10f7e91a91e681fb9fe46f9df7707b9ef78707c8","modified":1676651100195},{"_id":"themes/fluid/source/css/_pages/_base/_widget/scroll-btn.styl","hash":"f0e429a27fa8a7658fcbddbb4d4dbe4afa12499a","modified":1676651100167},{"_id":"themes/fluid/source/img/fluid.ico","hash":"6084d6b670b00c812ef1711288c5bf9193ec777d","modified":1642436818000},{"_id":"themes/fluid/source/css/_pages/_base/_widget/toc.styl","hash":"9e7452aa2372153f25d7a4675c9d36d281a65d24","modified":1676651100211},{"_id":"themes/fluid/source/img/default.png","hash":"1a56769ce0c8946fce4a52079415cc037e891090","modified":1646327282935},{"_id":"themes/fluid/source/img/default1.png","hash":"e594845b17cdf2ac65f05b137dfd8565c6817be5","modified":1628328638000},{"_id":"public/img/avatar.png","hash":"2d11b547232cd11143e741179bc8891fc275e3df","modified":1701307165080},{"_id":"public/img/default.png","hash":"794642b5c423679f76911903bcb78288d6b9e53c","modified":1701307165080},{"_id":"public/img/default1.png","hash":"5e75b4c3f7368f05b0dfcf8fd50ec93fce5bb8d8","modified":1701307165080},{"_id":"public/img/example.png","hash":"534bbffe16460cfd459c9684dbaacf7929c75452","modified":1701307165080},{"_id":"public/img/gitee.png","hash":"5437c1a6cbddf1cd8f02461826420b8238bedf23","modified":1701307165080},{"_id":"public/img/github.png","hash":"463e6e412c38b6684d712ceec77b6b3e619c22ae","modified":1701307165080},{"_id":"public/img/yuque.png","hash":"79f17fda26b24bda6eacfa1c23788384bfc412d6","modified":1701307165080},{"_id":"public/baidusitemap.xml","hash":"4b7dc2a0407883835e32f587e28e5d925b177eb8","modified":1701307165080},{"_id":"public/sitemap.xml","hash":"d4cab9b7734781b7406d682c3cbca02520e22eae","modified":1701307165080},{"_id":"public/sitemap.txt","hash":"1e31897f568bc3dd29b6d40748fa65a2f5a1b47f","modified":1701307165080},{"_id":"public/local-search.xml","hash":"20705f331e4df4e4816e096a1a4a77234e94586c","modified":1701307165080},{"_id":"public/about/index.html","hash":"8492d1cf68d34644037944e796440802d99505d5","modified":1701307165080},{"_id":"public/archives/index.html","hash":"cae7604ab319cf809004f434b381b0795b983f40","modified":1701307165080},{"_id":"public/archives/page/2/index.html","hash":"889b8e33abd96c44c539f2cc729da793fa59ea12","modified":1701307165080},{"_id":"public/archives/page/3/index.html","hash":"21612924c05310aa5410545ee1f5454afc34223d","modified":1701307165080},{"_id":"public/archives/page/4/index.html","hash":"36ca53c9ed40b6747133f1b0ab88c76a7b76d268","modified":1701307165080},{"_id":"public/archives/2021/index.html","hash":"7c6d24d3f1e91bbce443331f3089a29ef19de917","modified":1701307165080},{"_id":"public/archives/2021/02/index.html","hash":"7625ff4426d99ea373ed73fa571f0539779c90df","modified":1701307165080},{"_id":"public/archives/2021/09/index.html","hash":"b8be107a61f22dbe217c37e45db9adc3f7cb544e","modified":1701307165080},{"_id":"public/archives/2021/12/index.html","hash":"a12dee877dfe24a087a31d1083d90c2b341f44c3","modified":1701307165080},{"_id":"public/archives/2022/index.html","hash":"d25f99cec0a191d91420740906f5d9169b062d17","modified":1701307165080},{"_id":"public/archives/2022/page/2/index.html","hash":"0ec1f6a7fd041e9b988290765a8b6c97b2ff93b0","modified":1701307165080},{"_id":"public/archives/2022/01/index.html","hash":"339b84b45eb8db5285456493ed9c22d32e0a5d64","modified":1701307165080},{"_id":"public/archives/2022/05/index.html","hash":"264bf6e7792745417aab32e6f82f2057c0aca8fe","modified":1701307165080},{"_id":"public/archives/2022/09/index.html","hash":"71468d33a47b02a33eaba8a8097980045d733d70","modified":1701307165080},{"_id":"public/archives/2022/10/index.html","hash":"4b1fd2ffe684e99876c834b12be673c9b8026cd4","modified":1701307165080},{"_id":"public/archives/2022/11/index.html","hash":"5964c9eb8ecfff0dc6a8d1fac51ffa77631f6e00","modified":1701307165080},{"_id":"public/archives/2022/12/index.html","hash":"59b28b1fad02d69bb0c8f38d31343be71b556c60","modified":1701307165080},{"_id":"public/archives/2023/index.html","hash":"5d58d8925de269e9f886ae7446afc8b1e600bf64","modified":1701307165080},{"_id":"public/archives/2023/page/2/index.html","hash":"022cd9cee650830d6a04ee80a83dc3b665b2548b","modified":1701307165080},{"_id":"public/archives/2023/page/3/index.html","hash":"3088d07d671d7a8a276c92b230c440b9bbca0dc4","modified":1701307165080},{"_id":"public/archives/2023/01/index.html","hash":"9e1ee8676115843c186d8d955ec7bac34692d965","modified":1701307165080},{"_id":"public/archives/2023/02/index.html","hash":"7238806866301acd2ddedcebd83f88164854ae7c","modified":1701307165080},{"_id":"public/archives/2023/03/index.html","hash":"f86646a3e531a8cb2f7bb55ce4241be90641cd6a","modified":1701307165080},{"_id":"public/archives/2023/05/index.html","hash":"72bdc45f4db4ec7410c9634a8a90f1256d17046a","modified":1701307165080},{"_id":"public/archives/2023/06/index.html","hash":"c15b11942e8b4a2991e0a3a950b92913c9da5e7e","modified":1701307165080},{"_id":"public/archives/2023/07/index.html","hash":"7ec3ec82dffcac4748ddfbf887a4df2ebf0f2fa9","modified":1701307165080},{"_id":"public/archives/2023/08/index.html","hash":"4f501c35ca06c724e4ecc6c1f05713618ccadae5","modified":1701307165080},{"_id":"public/archives/2023/09/index.html","hash":"81c992e935dc92ecb242358b5e9696fd62d3fe90","modified":1701307165080},{"_id":"public/archives/2023/10/index.html","hash":"36687dad3c293394bbee14b6ec8b82f874c83808","modified":1701307165080},{"_id":"public/archives/2023/11/index.html","hash":"91b711ec57c81f35e8b5927a8f934300c0c75c50","modified":1701307165080},{"_id":"public/categories/算法/index.html","hash":"85786cb0719abbccddba2bdc012c62009d695cb5","modified":1701307165080},{"_id":"public/categories/Bugs/index.html","hash":"31ab5e84424133864284ec2b4d9b403f9bbb865c","modified":1701307165080},{"_id":"public/categories/Project/index.html","hash":"f4b74ab36c86e813b67ccf3447e91840f8346fa2","modified":1701307165080},{"_id":"public/categories/Database/index.html","hash":"4f10ddd1ab0f7d609320d0fec459d114482b2736","modified":1701307165080},{"_id":"public/categories/Java-notes/index.html","hash":"92cddad56b3513bf44ad5ae8fac7bcb7f48230a7","modified":1701307165080},{"_id":"public/categories/JVM/index.html","hash":"dd96f6e4c2159f578757cb689d9bae4e0e167b65","modified":1701307165080},{"_id":"public/categories/Linux/index.html","hash":"b764be771b984d02516d14090bf1aedb159107c7","modified":1701307165080},{"_id":"public/categories/Blog/index.html","hash":"a9fa5959bc52bfa5cdf5fe0b3633b66728b4189f","modified":1701307165080},{"_id":"public/categories/前端/index.html","hash":"8605f6476b3185839593e1d0a46a2160c2216b8d","modified":1701307165080},{"_id":"public/categories/Git/index.html","hash":"40c1a5db5adba37910c9c90f3fd2f0c4b4f051b3","modified":1701307165080},{"_id":"public/categories/框架/index.html","hash":"ea3a90352a436222f55ab5f81e399e500dc66591","modified":1701307165080},{"_id":"public/tags/leetcode/index.html","hash":"f99ce60c935ea8266dbe753c508dcc5b52975915","modified":1701307165080},{"_id":"public/tags/数组双指针/index.html","hash":"83e7ed16c1b68e65dbaee33e056e57832c583366","modified":1701307165080},{"_id":"public/tags/Bugs/index.html","hash":"5d261cd73421fc10ed02d460a9730ab2e6935b6b","modified":1701307165080},{"_id":"public/tags/Spring-Boot/index.html","hash":"f99f4e8cf4a698b1471fc6d83958be5e98914fe2","modified":1701307165080},{"_id":"public/tags/JSP/index.html","hash":"24e7582867d16650916131a87b71a3e37c1b9a9c","modified":1701307165080},{"_id":"public/tags/SSM/index.html","hash":"c61cd66a860649d2241bcae8e14bbcfe7802e7fe","modified":1701307165080},{"_id":"public/tags/MySQL/index.html","hash":"455b53d8d6d59e7d68ff566e50ea5912a8cbacf2","modified":1701307165080},{"_id":"public/tags/jquery/index.html","hash":"a2be2d353193255336f86eed6c488ae00afee1cd","modified":1701307165080},{"_id":"public/tags/ajax/index.html","hash":"977a0aa8d51afc305a4d325a2e24e06f05a48419","modified":1701307165080},{"_id":"public/tags/DM/index.html","hash":"1494f6e132715ebc81916da64e61ea661e636f8a","modified":1701307165080},{"_id":"public/tags/educoder/index.html","hash":"b43a0e8ca30185e5a66ae65db7a9fdac1bfd0d78","modified":1701307165080},{"_id":"public/tags/Java基础/index.html","hash":"0b1a7f550da2d1ea2c4fb435a99cc7c4c397d02c","modified":1701307165080},{"_id":"public/tags/链表/index.html","hash":"fc0f9a627a3e1b476d6983c4d9881027f8251c5e","modified":1701307165080},{"_id":"public/tags/递归/index.html","hash":"caa6875a3739c38ae71454256446fb5b80f1e07d","modified":1701307165080},{"_id":"public/tags/ArrayList/index.html","hash":"5ddc4d0f66f3db0108fdb19b8f1fc98bd96f6b87","modified":1701307165080},{"_id":"public/tags/链表反转/index.html","hash":"1e9255bbcf825e3a06cc6beb379c60fae27d0a02","modified":1701307165080},{"_id":"public/tags/迭代/index.html","hash":"df80fac422e854407b15dc34d8c9ee59ce83dbd2","modified":1701307165080},{"_id":"public/tags/BigInteger/index.html","hash":"211e7ceab1f2a95e9e4532782d6b634f07dc2733","modified":1701307165080},{"_id":"public/tags/java-math/index.html","hash":"dc33ea021407d40a1334c45c0b7e5eac30cf05c1","modified":1701307165080},{"_id":"public/tags/进制转换/index.html","hash":"fa73a729eaa539c127755de82fb8ab59f35bb46d","modified":1701307165080},{"_id":"public/tags/“-”运算/index.html","hash":"9fe1de06edd34f7b89a8694250d8fb89d289508b","modified":1701307165080},{"_id":"public/tags/Linux/index.html","hash":"69d57e34ad784ec0f1315d7e52dd4e8f58ca52e0","modified":1701307165080},{"_id":"public/tags/位运算/index.html","hash":"d8035a439925662f03372948da37c1b60f6e1a38","modified":1701307165080},{"_id":"public/tags/Polymorphism/index.html","hash":"76ef0708a1062f3b6ae59ddc1ea21acc2e2579c5","modified":1701307165080},{"_id":"public/tags/蓝桥杯/index.html","hash":"99395a4d141b9e4b48ceabfdb107c8d7d10c09b4","modified":1701307165080},{"_id":"public/tags/Redis/index.html","hash":"fd400937895e2354c99ebdfb091a65c4236ca99d","modified":1701307165080},{"_id":"public/tags/Vue/index.html","hash":"e6c794ed22819ad11e70c1e589ac564d303d76fe","modified":1701307165080},{"_id":"public/tags/Ant-Design-Vue/index.html","hash":"c152f99bcdbcf554c6e9435a32bd8d67e2c35508","modified":1701307165080},{"_id":"public/tags/Lodash/index.html","hash":"0b3645196582824c7e47f2cfdb5f0b872eb030c4","modified":1701307165080},{"_id":"public/tags/ES/index.html","hash":"a19fdcecf16e5ad9dc68d1b911a938717681b07e","modified":1701307165080},{"_id":"public/tags/SpringBoot/index.html","hash":"faff9efd523d7a72a248024c9b5514a298fa8445","modified":1701307165080},{"_id":"public/tags/Mysql/index.html","hash":"fcc2971799c3dac5c0515c55e0bf6924c5a2d270","modified":1701307165080},{"_id":"public/tags/MyBatis/index.html","hash":"cc18c6335a1355f95cd4baceca79d3b57b7e1360","modified":1701307165080},{"_id":"public/tags/Maven/index.html","hash":"494fae54101cee25d3415ceac864ca53b23c73c3","modified":1701307165080},{"_id":"public/tags/Ant-Design-Pro/index.html","hash":"8885b3ffb2d69f5ac2329a4272bc185064166202","modified":1701307165080},{"_id":"public/tags/React/index.html","hash":"ab8ff56a5a3abf2b8aa02d01209505f7e48280e8","modified":1701307165080},{"_id":"public/tags/Ant-Design-Pro-Components/index.html","hash":"7272192d0a069c0ec09fddaf8652564a9f290ee8","modified":1701307165080},{"_id":"public/tags/Umi/index.html","hash":"9f49904333e79fab3eb9fa045952cbab371cfffd","modified":1701307165080},{"_id":"public/tags/Umi-Request/index.html","hash":"89f6c3a99f68e87c5d64cba42193c2ef7798d811","modified":1701307165080},{"_id":"public/tags/SDK开发/index.html","hash":"47403564b315fbc86a2794f4c5d45c6e38cf5dab","modified":1701307165080},{"_id":"public/tags/CSS/index.html","hash":"3de662f6476793f76819b3e0291055c27999186c","modified":1701307165080},{"_id":"public/tags/Git/index.html","hash":"52b54982d769c760c453795ce461a2dcf541e768","modified":1701307165080},{"_id":"public/tags/网站搭建/index.html","hash":"c712302bf4b240de2e36a10894ce61c3a4fc79c0","modified":1701307165080},{"_id":"public/tags/架构师/index.html","hash":"86a70154ce0c6171bda0fefb1786eaf980e60017","modified":1701307165080},{"_id":"public/tags/云上书库/index.html","hash":"2c80363cde1eeafb57b0dcd522dda04d588240b6","modified":1701307165080},{"_id":"public/tags/Logging-Services/index.html","hash":"7cc1743c32027250f98789f6d1d5f868c1d4fc31","modified":1701307165080},{"_id":"public/tags/Netty/index.html","hash":"5ea66690b2f539c6a2516c102b0f6aea67a9ef1b","modified":1701307165080},{"_id":"public/tags/Object类/index.html","hash":"17878791cf2eafe069e0a1bec6d2c1f3f9a023aa","modified":1701307165080},{"_id":"public/tags/plan/index.html","hash":"12d0bb25653781299ea3e0363c1894024895260c","modified":1701307165080},{"_id":"public/tags/Spring-Cloud-GateWay/index.html","hash":"b7de758d3b0ea77c69927cabc9281945fbaaf147","modified":1701307165080},{"_id":"public/tags/feign/index.html","hash":"c1ae947407f7e2643ff9ab73562620d479f3b8ac","modified":1701307165080},{"_id":"public/tags/nacos/index.html","hash":"fd00d5b6464049785cd3c84a164320a4325ea55b","modified":1701307165080},{"_id":"public/tags/MongoDB/index.html","hash":"0c570cbdefe958dd7db3d0f1085585286f7ddf9c","modified":1701307165080},{"_id":"public/tags/JWT/index.html","hash":"4706366f29a4aa13aa0ffd356411a10842a3efaa","modified":1701307165080},{"_id":"public/tags/EasyExcell/index.html","hash":"abda5e48e0d3907b6580fb04fed1904c7f731106","modified":1701307165080},{"_id":"public/tags/快捷键/index.html","hash":"ac1bc8198a3667c9f000feeacc50e8dda796718d","modified":1701307165080},{"_id":"public/tags/技巧/index.html","hash":"49a69e2dcfd81a7f095ab16c0f41e2a622570d08","modified":1701307165080},{"_id":"public/tags/Linux-DNS/index.html","hash":"d385ce427b4575b02146f61368f66f6700005e25","modified":1701307165080},{"_id":"public/tags/面渣逆袭/index.html","hash":"0dba898cee8bdc0e7b71cbbbf8f2556914dfdb0e","modified":1701307165080},{"_id":"public/tags/八股文/index.html","hash":"a05485e22ad8b09d5af52cfd57e373bb8c494c77","modified":1701307165080},{"_id":"public/404.html","hash":"e67134cf2659e5725171e65c3ec1f82cbf601ac6","modified":1701307165080},{"_id":"public/tags/index.html","hash":"0447158591a92e31873e3d4fb499ba3393a9fa0e","modified":1701307165080},{"_id":"public/links/index.html","hash":"066dd959dcc378c496c0e6659ebd03c5e65a5bf1","modified":1701307165080},{"_id":"public/2023/11/16/面渣八股/index.html","hash":"3aefb6a0817ddce575cd0c4d6caf42c613e9bd88","modified":1701307165080},{"_id":"public/2023/10/24/LCR-003-比特位计数/index.html","hash":"835eeadac810a1fe519ecb98c1dd890fb5b3a90d","modified":1701307165080},{"_id":"public/2023/10/16/LCR-136-删除链表结点/index.html","hash":"892b85e669cb70eb0540ed80cf2d521ff51bfeab","modified":1701307165080},{"_id":"public/2023/10/16/Polymorphism/index.html","hash":"28a5704858a8f1a7787cb05fca85eec77822a714","modified":1701307165080},{"_id":"public/2023/10/07/abstractandinterface/index.html","hash":"90bf1ef38deb817f8a1f70c1ca8b0840b616b463","modified":1701307165080},{"_id":"public/2023/09/23/hiOffer/index.html","hash":"c7163a46e06d6fd0fd114972784fadf340b545b2","modified":1701307165080},{"_id":"public/2023/09/22/log4j/index.html","hash":"42c0a77f8bb1b7592bf58721aed9c0bdfd432dd0","modified":1701307165080},{"_id":"public/2023/09/10/LCR-002-二进制求和/index.html","hash":"265d18257c3225b2cdfa5a8edf5b89e4feb92fcb","modified":1701307165080},{"_id":"public/2023/09/07/Bugsss/index.html","hash":"6b3b8b25529f5b175468a89fdbf10b7214512580","modified":1701307165080},{"_id":"public/2023/09/01/csh/index.html","hash":"45db269f809ccb057679822dbfde1c1358332aa0","modified":1701307165080},{"_id":"public/2023/08/24/plan-a/index.html","hash":"6f148aabdad0bf61c080890bc16e8790b0316330","modified":1701307165080},{"_id":"public/2023/08/22/netblog/index.html","hash":"fb1680f0d1b78177a28eab8bc224e5099ad4ca50","modified":1701307165080},{"_id":"public/2023/08/21/oj/index.html","hash":"0298b3b4a38cac15e581595249a10101ed017d91","modified":1701307165080},{"_id":"public/2023/08/07/DMDatabase/index.html","hash":"10c475cbe110fa61f119552171922e30350f53ab","modified":1701307165080},{"_id":"public/2023/08/01/library/index.html","hash":"841b1b4fde81744a41547ddc1b41e8727ccbb195","modified":1701307165080},{"_id":"public/2023/08/01/aggregateSearch/index.html","hash":"d5a7345ff941531a72f65b924012d20a922077a9","modified":1701307165080},{"_id":"public/2023/07/02/howtomakeproject/index.html","hash":"cd8e2e2c7471a73987cb4dfe1a32d7040a3209b3","modified":1701307165080},{"_id":"public/2023/06/03/api/index.html","hash":"898de94d0916b004ae44d4b6916278188c5ccf82","modified":1701307165080},{"_id":"public/2023/06/01/JZ06PrintLinkedList/index.html","hash":"5de04ae3cc0b131bdaf64482e55e5e854345cc87","modified":1701307165080},{"_id":"public/2023/06/01/JZ24ReverseLinkedList/index.html","hash":"c41b56529137a8d6436cd9faed137c22f6a937d3","modified":1701307165080},{"_id":"public/2023/05/21/love/index.html","hash":"35be95df3ba6f7596fabaa935ed61c3eb371f6b5","modified":1701307165080},{"_id":"public/2023/05/11/MyLanqiaoNote/index.html","hash":"dc8dcf873db58e66ed6b5e5e08ae918735093801","modified":1701307165080},{"_id":"public/2023/03/12/CampousLostAndFound/index.html","hash":"5519f4189a36105c40e08b385ff66b0548ff8847","modified":1701307165080},{"_id":"public/2023/02/23/transaction/index.html","hash":"a72b4396aa8128c419979210c312eca0d2fe65d6","modified":1701307165080},{"_id":"public/2023/01/07/JVM/index.html","hash":"bbc780fe1fd052907e52a1c5e2c2492fa853f25e","modified":1701307165080},{"_id":"public/2023/01/06/mysql/index.html","hash":"161321e8e99764afc0982d7801674bbe40ae0c28","modified":1701307165080},{"_id":"public/2022/12/23/bilibili/index.html","hash":"f1f37f71402c6f3b2a802a7473ef741cc95d0c29","modified":1701307165080},{"_id":"public/2022/11/07/helloVuepress/index.html","hash":"f67b4cc8edee03b671318a8aadda540527dd4a5b","modified":1701307165080},{"_id":"public/2022/11/01/netty/index.html","hash":"daabc6e71ec4a3b0b45bc26cc2bec7d7134d04c5","modified":1701307165080},{"_id":"public/2022/10/27/Redis/index.html","hash":"0e86107070e42d2af6bc1a53b6747ee7d7242d23","modified":1701307165080},{"_id":"public/2022/10/07/git/index.html","hash":"45e35714fbe945765c5599f39d24a275720fcb4b","modified":1701307165080},{"_id":"public/2022/09/10/css/index.html","hash":"3ee19601670cc5311b85bf844916e52acba18936","modified":1701307165080},{"_id":"public/2022/09/07/Educoder/index.html","hash":"5eaf09017562bee4f518e48fb1e806ae802554fc","modified":1701307165080},{"_id":"public/2022/09/07/Java-Essay/index.html","hash":"8a6235869b6c44fb503baefb7600d869a2015295","modified":1701307165080},{"_id":"public/2022/09/07/Linux/index.html","hash":"ef92e00dbd48ddd71bfedfea8c3c74e3f968ac0d","modified":1701307165080},{"_id":"public/2022/09/07/collection/index.html","hash":"e93fbf836da882d29acd98f7f8178b0bbc0aa905","modified":1701307165080},{"_id":"public/2022/09/07/tip/index.html","hash":"9b0ac4f85524104a6c0a6c902d3c1721a53443e1","modified":1701307165080},{"_id":"public/2022/05/31/shangyitong/index.html","hash":"987a6bec8a4b96a6227dae384a6e6fc6fd303f01","modified":1701307165080},{"_id":"public/2022/05/04/头歌实践教学平台-Linux网络实战（一）-DNS配置（Ubuntu系统）/index.html","hash":"b8283f8c3dc3904b54cd44fc038972d7c7d1b020","modified":1701307165080},{"_id":"public/2022/01/03/object/index.html","hash":"2ec65286575aafbf59adc4bac9a2b495835ca134","modified":1701307165080},{"_id":"public/2021/12/27/SSM/index.html","hash":"01e429d7b6d68850c1aebb5816ea11de3e8617ff","modified":1701307165080},{"_id":"public/2021/09/07/helloHexo/index.html","hash":"cd12edff8cc59182fffe79283f473b904c7abbef","modified":1701307165080},{"_id":"public/2021/02/08/026.删除有序数组中的重复项/index.html","hash":"85ab8b86c57a6563e42f28eecc03144c88b65c14","modified":1701307165080},{"_id":"public/2021/02/07/001.两数之和/index.html","hash":"09abdbb0f6e297efed28cc547939c72a21eed050","modified":1701307165080},{"_id":"public/index.html","hash":"987f7188129ea415fa9277c3a4a2c05bb8dde67f","modified":1701307165080},{"_id":"public/page/2/index.html","hash":"19e622459cf4eca71fe25acf52040635e876ac72","modified":1701307165080},{"_id":"public/page/3/index.html","hash":"bd98ca7827229a424d02fa88b617f0979760fa34","modified":1701307165080},{"_id":"public/page/4/index.html","hash":"bb8a02b96b9299f65adf3bb60fffdcff36ace385","modified":1701307165080},{"_id":"public/categories/index.html","hash":"82964269cba03348d480731d608c9db50475ae44","modified":1701307165080},{"_id":"public/silian.txt","hash":"5a0acdb8eb3889bc4b39d82849c7020d8bbcd391","modified":1701307165080},{"_id":"public/img/loading.gif","hash":"2d2fc0f947940f98c21afafef39ecf226a2e8d55","modified":1701307165080},{"_id":"public/img/police_beian.png","hash":"90efded6baa2dde599a9d6b1387973e8e64923ea","modified":1701307165080},{"_id":"public/xml/local-search.xml","hash":"8c96ba6a064705602ce28d096fd7dd9069630a55","modified":1701307165080},{"_id":"public/assets/algolia/algoliasearchLite.min.js","hash":"284416885e4e80e27fa4eae6fc305f4de15b914c","modified":1701307165080},{"_id":"public/assets/algolia/algoliasearchLite.js","hash":"e56ad6b82caf69066de545201014291fc961635e","modified":1701307165080},{"_id":"public/assets/algolia/algoliasearch.min.js","hash":"a3b131a9a47ccc16f4dd8988fabb6d306548db2f","modified":1701307165080},{"_id":"public/css/gitalk.css","hash":"2234d7496740d11b5b53aaaef9155dcb2c6f3f73","modified":1701307165080},{"_id":"public/css/highlight-dark.css","hash":"5ab9082a6fd29f7f8ffad02a606967bb841a2ab4","modified":1701307165080},{"_id":"public/css/highlight.css","hash":"54b718c687ce8460e10d501c1eb53a8098942c1e","modified":1701307165080},{"_id":"public/js/color-schema.js","hash":"7206d8fd71867a26c6616b60be1eff385e52c060","modified":1701307165080},{"_id":"public/js/boot.js","hash":"f82f9de36c6d046fd69471af5d1e916e5004e823","modified":1701307165080},{"_id":"public/js/events.js","hash":"4dd2306eb0301fe9f356a0d18f499a50e6bbd712","modified":1701307165080},{"_id":"public/js/img-lazyload.js","hash":"c694f85e95a7ab62ac4dfc3fd90ac317331f68ea","modified":1701307165080},{"_id":"public/js/local-search.js","hash":"7040036144d35c8945c793c52da493ae9536d7cd","modified":1701307165080},{"_id":"public/js/leancloud.js","hash":"0bdb6d430ad4c41112b9d7db785a4169740f2521","modified":1701307165080},{"_id":"public/js/plugins.js","hash":"346a6a24966f7dcde0036f69720bc645eddbc8b4","modified":1701307165080},{"_id":"public/js/utils.js","hash":"faacb21746e76451e13900d7072d4a99c1741f97","modified":1701307165080},{"_id":"public/css/main.css","hash":"ea6a486976d40d5e21b8e558e76c43a932b15135","modified":1701307165080},{"_id":"public/img/fluid.ico","hash":"6084d6b670b00c812ef1711288c5bf9193ec777d","modified":1701307165080},{"_id":"public/assets/algolia/algoliasearch.js","hash":"6948fcdf071e4983e784e8c458cf201536f77792","modified":1701307165080}],"Category":[{"name":"算法","_id":"clpkiczia0003fkfo9m8udeyr"},{"name":"Bugs","_id":"clpkiczij000cfkfo9igcfz4l"},{"name":"Project","_id":"clpkiczim000kfkfo1getdz6f"},{"name":"Database","_id":"clpkiczip000qfkfo2plw1u7i"},{"name":"Java notes","_id":"clpkiczis000yfkfo8jw2aeaz"},{"name":"JVM","_id":"clpkicziv0017fkfob5nk5op0"},{"name":"Linux","_id":"clpkicziy001ifkfo77udby0u"},{"name":"Blog","_id":"clpkiczj1001pfkfo7sqpewc7"},{"name":"前端","_id":"clpkiczj50020fkfo74jyfpdv"},{"name":"Git","_id":"clpkiczj70029fkfo2sso5bhe"},{"name":"框架","_id":"clpkiczjd002pfkfo76wk7yus"}],"Data":[],"Page":[{"title":"关于本站","layout":"about","date":"2023-08-19T10:13:14.000Z","_content":"\n> 写在前面：\n>\n> 盖德尔本盖，是一名24届的菜狗一只。喜欢记录，喜欢探索未知领域。\n\n### 我的博客之路\n\n20年入学时，便发表了我的第一篇博客，还是关于C语言的，还清楚的记得当时给自己定的目标：从小白到精通，然后贴了一张`helloworld`的运行截图，哈哈哈哈，大概`helloworld`就是每个程序员梦开始的地方吧！\n\n19年高考失利，20年再战，最终479分只上了一所双非二本。经过了一年的复读，我想着我本应该比同寝、同班同学更自律些吧，但是结果似乎并不然。初入大学，确实是接触到了许多新鲜的事物，我也在逐渐改善自己内向的性格，同时也丧失了以前的自律。但是从大一到大三，我能明显的感觉出来，我的逻辑性思维起码相较他们，还是比较成熟的，鉴于此再加上我完美主义的性格，在这几年的大学生活中也收获到了不少。\n\n慢慢的，开始看一些计算机领域的技术性文章，也就是`CSDN`嘛，是我博客之路的起点。开始观摩别人的优秀文章的写作风格，然后发表自己的文章，做任何事情都是有风口浪尖的，这句话可谓是屡试不爽。抓住机遇很重要！抓住机遇很重要！抓住机遇！\n\n21年在家人的推荐下，开始摸索搭建自己的`hexo`博客，刚开始是一点都不懂的是什么，总是自以为是，就开始一步一步照着教程开始搭建，其实这样的逻辑并不好，我们做一件事情之前，首先应该经过充分的了解，也就是知己知彼百战不殆这个道理。果不其然搭建过程中碰到了很多问题，也印证了一句话：自己的人生都是一步一个脚印走出来的，我们总是喜欢在失败中成长。一次次干掉重新搭建，最终也算是基本搭建好了，然后就放着没有怎么完善了。\n\n22年年底，接触到了沉默王二（二哥）和程序员鱼皮、guide哥等CS领域的大V，受到二哥Java程序员进阶之路和知识星球的的启发与鼓舞，心想怎么会有这么完善的小网站，CS领域的学生看到后，谁看谁不迷糊？于是我也想搭建一个自己的基于`vuepress`的个人博客，加上自己有搭建`hexo博客`的经验，搭建起来还是很顺利的，上手很快，目前模块功能正在逐步完善中~，越整越花里胡哨，还是喜欢简约风，`vuepress`网站就暂时当作一个小型知识库了。\n\n最后，与你共勉：优秀的人总有他优秀的原因！一起加油吧！\n\n","source":"about/index.md","raw":"---\ntitle: 关于本站\nlayout: about\ndate: 2023-08-19 18:13:14\n---\n\n> 写在前面：\n>\n> 盖德尔本盖，是一名24届的菜狗一只。喜欢记录，喜欢探索未知领域。\n\n### 我的博客之路\n\n20年入学时，便发表了我的第一篇博客，还是关于C语言的，还清楚的记得当时给自己定的目标：从小白到精通，然后贴了一张`helloworld`的运行截图，哈哈哈哈，大概`helloworld`就是每个程序员梦开始的地方吧！\n\n19年高考失利，20年再战，最终479分只上了一所双非二本。经过了一年的复读，我想着我本应该比同寝、同班同学更自律些吧，但是结果似乎并不然。初入大学，确实是接触到了许多新鲜的事物，我也在逐渐改善自己内向的性格，同时也丧失了以前的自律。但是从大一到大三，我能明显的感觉出来，我的逻辑性思维起码相较他们，还是比较成熟的，鉴于此再加上我完美主义的性格，在这几年的大学生活中也收获到了不少。\n\n慢慢的，开始看一些计算机领域的技术性文章，也就是`CSDN`嘛，是我博客之路的起点。开始观摩别人的优秀文章的写作风格，然后发表自己的文章，做任何事情都是有风口浪尖的，这句话可谓是屡试不爽。抓住机遇很重要！抓住机遇很重要！抓住机遇！\n\n21年在家人的推荐下，开始摸索搭建自己的`hexo`博客，刚开始是一点都不懂的是什么，总是自以为是，就开始一步一步照着教程开始搭建，其实这样的逻辑并不好，我们做一件事情之前，首先应该经过充分的了解，也就是知己知彼百战不殆这个道理。果不其然搭建过程中碰到了很多问题，也印证了一句话：自己的人生都是一步一个脚印走出来的，我们总是喜欢在失败中成长。一次次干掉重新搭建，最终也算是基本搭建好了，然后就放着没有怎么完善了。\n\n22年年底，接触到了沉默王二（二哥）和程序员鱼皮、guide哥等CS领域的大V，受到二哥Java程序员进阶之路和知识星球的的启发与鼓舞，心想怎么会有这么完善的小网站，CS领域的学生看到后，谁看谁不迷糊？于是我也想搭建一个自己的基于`vuepress`的个人博客，加上自己有搭建`hexo博客`的经验，搭建起来还是很顺利的，上手很快，目前模块功能正在逐步完善中~，越整越花里胡哨，还是喜欢简约风，`vuepress`网站就暂时当作一个小型知识库了。\n\n最后，与你共勉：优秀的人总有他优秀的原因！一起加油吧！\n\n","updated":"2023-11-15T12:25:09.321Z","path":"about/index.html","comments":1,"_id":"clpkiczi10000fkfo6s9cfeti","content":"<blockquote>\n<p>写在前面：</p>\n<p>盖德尔本盖，是一名24届的菜狗一只。喜欢记录，喜欢探索未知领域。</p>\n</blockquote>\n<h3 id=\"我的博客之路\"><a href=\"#我的博客之路\" class=\"headerlink\" title=\"我的博客之路\"></a>我的博客之路</h3><p>20年入学时，便发表了我的第一篇博客，还是关于C语言的，还清楚的记得当时给自己定的目标：从小白到精通，然后贴了一张<code>helloworld</code>的运行截图，哈哈哈哈，大概<code>helloworld</code>就是每个程序员梦开始的地方吧！</p>\n<p>19年高考失利，20年再战，最终479分只上了一所双非二本。经过了一年的复读，我想着我本应该比同寝、同班同学更自律些吧，但是结果似乎并不然。初入大学，确实是接触到了许多新鲜的事物，我也在逐渐改善自己内向的性格，同时也丧失了以前的自律。但是从大一到大三，我能明显的感觉出来，我的逻辑性思维起码相较他们，还是比较成熟的，鉴于此再加上我完美主义的性格，在这几年的大学生活中也收获到了不少。</p>\n<p>慢慢的，开始看一些计算机领域的技术性文章，也就是<code>CSDN</code>嘛，是我博客之路的起点。开始观摩别人的优秀文章的写作风格，然后发表自己的文章，做任何事情都是有风口浪尖的，这句话可谓是屡试不爽。抓住机遇很重要！抓住机遇很重要！抓住机遇！</p>\n<p>21年在家人的推荐下，开始摸索搭建自己的<code>hexo</code>博客，刚开始是一点都不懂的是什么，总是自以为是，就开始一步一步照着教程开始搭建，其实这样的逻辑并不好，我们做一件事情之前，首先应该经过充分的了解，也就是知己知彼百战不殆这个道理。果不其然搭建过程中碰到了很多问题，也印证了一句话：自己的人生都是一步一个脚印走出来的，我们总是喜欢在失败中成长。一次次干掉重新搭建，最终也算是基本搭建好了，然后就放着没有怎么完善了。</p>\n<p>22年年底，接触到了沉默王二（二哥）和程序员鱼皮、guide哥等CS领域的大V，受到二哥Java程序员进阶之路和知识星球的的启发与鼓舞，心想怎么会有这么完善的小网站，CS领域的学生看到后，谁看谁不迷糊？于是我也想搭建一个自己的基于<code>vuepress</code>的个人博客，加上自己有搭建<code>hexo博客</code>的经验，搭建起来还是很顺利的，上手很快，目前模块功能正在逐步完善中~，越整越花里胡哨，还是喜欢简约风，<code>vuepress</code>网站就暂时当作一个小型知识库了。</p>\n<p>最后，与你共勉：优秀的人总有他优秀的原因！一起加油吧！</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>写在前面：</p>\n<p>盖德尔本盖，是一名24届的菜狗一只。喜欢记录，喜欢探索未知领域。</p>\n</blockquote>\n<h3 id=\"我的博客之路\"><a href=\"#我的博客之路\" class=\"headerlink\" title=\"我的博客之路\"></a>我的博客之路</h3><p>20年入学时，便发表了我的第一篇博客，还是关于C语言的，还清楚的记得当时给自己定的目标：从小白到精通，然后贴了一张<code>helloworld</code>的运行截图，哈哈哈哈，大概<code>helloworld</code>就是每个程序员梦开始的地方吧！</p>\n<p>19年高考失利，20年再战，最终479分只上了一所双非二本。经过了一年的复读，我想着我本应该比同寝、同班同学更自律些吧，但是结果似乎并不然。初入大学，确实是接触到了许多新鲜的事物，我也在逐渐改善自己内向的性格，同时也丧失了以前的自律。但是从大一到大三，我能明显的感觉出来，我的逻辑性思维起码相较他们，还是比较成熟的，鉴于此再加上我完美主义的性格，在这几年的大学生活中也收获到了不少。</p>\n<p>慢慢的，开始看一些计算机领域的技术性文章，也就是<code>CSDN</code>嘛，是我博客之路的起点。开始观摩别人的优秀文章的写作风格，然后发表自己的文章，做任何事情都是有风口浪尖的，这句话可谓是屡试不爽。抓住机遇很重要！抓住机遇很重要！抓住机遇！</p>\n<p>21年在家人的推荐下，开始摸索搭建自己的<code>hexo</code>博客，刚开始是一点都不懂的是什么，总是自以为是，就开始一步一步照着教程开始搭建，其实这样的逻辑并不好，我们做一件事情之前，首先应该经过充分的了解，也就是知己知彼百战不殆这个道理。果不其然搭建过程中碰到了很多问题，也印证了一句话：自己的人生都是一步一个脚印走出来的，我们总是喜欢在失败中成长。一次次干掉重新搭建，最终也算是基本搭建好了，然后就放着没有怎么完善了。</p>\n<p>22年年底，接触到了沉默王二（二哥）和程序员鱼皮、guide哥等CS领域的大V，受到二哥Java程序员进阶之路和知识星球的的启发与鼓舞，心想怎么会有这么完善的小网站，CS领域的学生看到后，谁看谁不迷糊？于是我也想搭建一个自己的基于<code>vuepress</code>的个人博客，加上自己有搭建<code>hexo博客</code>的经验，搭建起来还是很顺利的，上手很快，目前模块功能正在逐步完善中~，越整越花里胡哨，还是喜欢简约风，<code>vuepress</code>网站就暂时当作一个小型知识库了。</p>\n<p>最后，与你共勉：优秀的人总有他优秀的原因！一起加油吧！</p>\n"}],"Post":[{"title":"001-leetcode","index_img":"https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311151627628.png","excerpt":"今天来搞一搞力扣的经典001劝退题，有人相爱，有人夜里开车看海，有人`leetcode`第一题都做不出来。滴~~~今天不玩梗，玩代码！","abbrlink":7265,"date":"2021-02-07T01:56:58.000Z","_content":"\n* `leetCode：`001.两数之和\n\n* `describution:`\n\n >给定一个整数数组 `nums` 和一个整数目标值 `target`，请你在该数组中找出 **和为目标值** *`target`* 的那 **两个** 整数，并返回它们的数组下标。\n >\n >你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。\n >\n >你可以按任意顺序返回答案。\n >\n >\n >\n >**示例 1：**\n >\n >```\n >输入：nums = [2,7,11,15], target = 9\n >输出：[0,1]\n >解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。\n >```\n >\n >**示例 2：**\n >\n >```\n >输入：nums = [3,2,4], target = 6\n >输出：[1,2]\n >```\n >\n >**示例 3：**\n >\n >```\n >输入：nums = [3,3], target = 6\n >输出：[0,1]\n >```\n >\n > \n >\n >**提示：**\n >\n >- `2 <= nums.length <= 104`\n >- `-109 <= nums[i] <= 109`\n >- `-109 <= target <= 109`\n >- **只会存在一个有效答案**\n\n`技巧：`数组双指针\n\n`思路：`使用哈希表作为辅助数据结构，可以在 O(n) 的时间复杂度内完成或者使用数组双指针团灭 nSum 问题。\n\n`code1：`（哈希表的解法）\n\n```java\npublic int[] twoSum(int[] nums, int target) {\n    Map<Integer, Integer> map = new HashMap<>();\n    for (int i = 0; i < nums.length; i++) {\n        int complement = target - nums[i];\n        if (map.containsKey(complement)) {\n            return new int[] {map.get(complement), i};\n        }\n        map.put(nums[i], i);\n    }\n    return new int[0];\n}\n```\n\n`code2：`（非全部AC解法：数组双指针，例如遇到重复的数组元素）\n\n```java\npublic int[] twoSum(int[] nums, int target) {\n    // 复制原数组\n    int[] copy = Arrays.copyOf(nums, nums.length);\n    // 先对数组排序\n    Arrays.sort(nums);\n    // 左右指针\n    int lo = 0, hi = nums.length - 1;\n    while (lo < hi) {\n        int sum = nums[lo] + nums[hi];\n        if (sum < target) {\n            lo++;\n        } else if (sum > target) {\n            hi--;\n        } else {\n            // 找到了一组解，需要再次遍历原数组找到对应的下标\n            int[] result = new int[2];\n            for (int i = 0; i < copy.length; i++) {\n                if (copy[i] == nums[lo]) {\n                    result[0] = i;\n                } else if (copy[i] == nums[hi]) {\n                    result[1] = i;\n                }\n            }\n            return result;\n        }\n    }\n    // 误解返空\n    return new int[]{};\n}\n```\n\n`结束语：`类似于`nSum`的问题还有很多，诸如此，都可以使用数组双指针的技巧来巧妙解决，以上`code2`可以作为`nSum`问题的一个模板，除了 `twoSum` 问题，力扣上面还有 `3Sum`，`4Sum`,总之，`nSum` 问题就是给定一个数组 `nums` 和一个 `target`，然后从 `nums` 选择 `n` 个数，使得`n`个数字之和为 `target`。力扣第 167 题 [两数之和 II](https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/)也完全可以用数组双指针来求解，下期见🏊‍♂️\n","source":"_posts/001.两数之和.md","raw":"---\ntitle: 001-leetcode\nindex_img: https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311151627628.png\nexcerpt: 今天来搞一搞力扣的经典001劝退题，有人相爱，有人夜里开车看海，有人`leetcode`第一题都做不出来。滴~~~今天不玩梗，玩代码！\ncategories:\n  - 算法\ntags:\n  - leetcode\n  - 数组双指针\nabbrlink: 7265\ndate: 2021-02-07 09:56:58\n---\n\n* `leetCode：`001.两数之和\n\n* `describution:`\n\n >给定一个整数数组 `nums` 和一个整数目标值 `target`，请你在该数组中找出 **和为目标值** *`target`* 的那 **两个** 整数，并返回它们的数组下标。\n >\n >你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。\n >\n >你可以按任意顺序返回答案。\n >\n >\n >\n >**示例 1：**\n >\n >```\n >输入：nums = [2,7,11,15], target = 9\n >输出：[0,1]\n >解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。\n >```\n >\n >**示例 2：**\n >\n >```\n >输入：nums = [3,2,4], target = 6\n >输出：[1,2]\n >```\n >\n >**示例 3：**\n >\n >```\n >输入：nums = [3,3], target = 6\n >输出：[0,1]\n >```\n >\n > \n >\n >**提示：**\n >\n >- `2 <= nums.length <= 104`\n >- `-109 <= nums[i] <= 109`\n >- `-109 <= target <= 109`\n >- **只会存在一个有效答案**\n\n`技巧：`数组双指针\n\n`思路：`使用哈希表作为辅助数据结构，可以在 O(n) 的时间复杂度内完成或者使用数组双指针团灭 nSum 问题。\n\n`code1：`（哈希表的解法）\n\n```java\npublic int[] twoSum(int[] nums, int target) {\n    Map<Integer, Integer> map = new HashMap<>();\n    for (int i = 0; i < nums.length; i++) {\n        int complement = target - nums[i];\n        if (map.containsKey(complement)) {\n            return new int[] {map.get(complement), i};\n        }\n        map.put(nums[i], i);\n    }\n    return new int[0];\n}\n```\n\n`code2：`（非全部AC解法：数组双指针，例如遇到重复的数组元素）\n\n```java\npublic int[] twoSum(int[] nums, int target) {\n    // 复制原数组\n    int[] copy = Arrays.copyOf(nums, nums.length);\n    // 先对数组排序\n    Arrays.sort(nums);\n    // 左右指针\n    int lo = 0, hi = nums.length - 1;\n    while (lo < hi) {\n        int sum = nums[lo] + nums[hi];\n        if (sum < target) {\n            lo++;\n        } else if (sum > target) {\n            hi--;\n        } else {\n            // 找到了一组解，需要再次遍历原数组找到对应的下标\n            int[] result = new int[2];\n            for (int i = 0; i < copy.length; i++) {\n                if (copy[i] == nums[lo]) {\n                    result[0] = i;\n                } else if (copy[i] == nums[hi]) {\n                    result[1] = i;\n                }\n            }\n            return result;\n        }\n    }\n    // 误解返空\n    return new int[]{};\n}\n```\n\n`结束语：`类似于`nSum`的问题还有很多，诸如此，都可以使用数组双指针的技巧来巧妙解决，以上`code2`可以作为`nSum`问题的一个模板，除了 `twoSum` 问题，力扣上面还有 `3Sum`，`4Sum`,总之，`nSum` 问题就是给定一个数组 `nums` 和一个 `target`，然后从 `nums` 选择 `n` 个数，使得`n`个数字之和为 `target`。力扣第 167 题 [两数之和 II](https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/)也完全可以用数组双指针来求解，下期见🏊‍♂️\n","slug":"001.两数之和","published":1,"updated":"2023-11-26T03:29:34.868Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clpkiczi50001fkfo0wuc9ogi","content":"<ul>\n<li><p><code>leetCode：</code>001.两数之和</p>\n</li>\n<li><p><code>describution:</code></p>\n</li>\n</ul>\n<blockquote>\n<p>给定一个整数数组 <code>nums</code> 和一个整数目标值 <code>target</code>，请你在该数组中找出 <strong>和为目标值</strong> <em><code>target</code></em> 的那 <strong>两个</strong> 整数，并返回它们的数组下标。</p>\n<p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p>\n<p>你可以按任意顺序返回答案。</p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight inform7\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs inform7\">&gt;输入：nums = <span class=\"hljs-comment\">[2,7,11,15]</span>, target = 9<br>&gt;输出：<span class=\"hljs-comment\">[0,1]</span><br>&gt;解释：因为 nums<span class=\"hljs-comment\">[0]</span> + nums<span class=\"hljs-comment\">[1]</span> == 9 ，返回 <span class=\"hljs-comment\">[0, 1]</span> 。<br></code></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight inform7\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs inform7\">&gt;输入：nums = <span class=\"hljs-comment\">[3,2,4]</span>, target = 6<br>&gt;输出：<span class=\"hljs-comment\">[1,2]</span><br></code></pre></td></tr></table></figure>\n\n<p><strong>示例 3：</strong></p>\n<figure class=\"highlight inform7\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs inform7\">&gt;输入：nums = <span class=\"hljs-comment\">[3,3]</span>, target = 6<br>&gt;输出：<span class=\"hljs-comment\">[0,1]</span><br></code></pre></td></tr></table></figure>\n\n\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>2 &lt;= nums.length &lt;= 104</code></li>\n<li><code>-109 &lt;= nums[i] &lt;= 109</code></li>\n<li><code>-109 &lt;= target &lt;= 109</code></li>\n<li><strong>只会存在一个有效答案</strong></li>\n</ul>\n</blockquote>\n<p><code>技巧：</code>数组双指针</p>\n<p><code>思路：</code>使用哈希表作为辅助数据结构，可以在 O(n) 的时间复杂度内完成或者使用数组双指针团灭 nSum 问题。</p>\n<p><code>code1：</code>（哈希表的解法）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-type\">int</span>[] twoSum(<span class=\"hljs-type\">int</span>[] nums, <span class=\"hljs-type\">int</span> target) &#123;<br>    Map&lt;Integer, Integer&gt; map = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">HashMap</span>&lt;&gt;();<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">i</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span>; i &lt; nums.length; i++) &#123;<br>        <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">complement</span> <span class=\"hljs-operator\">=</span> target - nums[i];<br>        <span class=\"hljs-keyword\">if</span> (map.containsKey(complement)) &#123;<br>            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">int</span>[] &#123;map.get(complement), i&#125;;<br>        &#125;<br>        map.put(nums[i], i);<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">int</span>[<span class=\"hljs-number\">0</span>];<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><code>code2：</code>（非全部AC解法：数组双指针，例如遇到重复的数组元素）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-type\">int</span>[] twoSum(<span class=\"hljs-type\">int</span>[] nums, <span class=\"hljs-type\">int</span> target) &#123;<br>    <span class=\"hljs-comment\">// 复制原数组</span><br>    <span class=\"hljs-type\">int</span>[] copy = Arrays.copyOf(nums, nums.length);<br>    <span class=\"hljs-comment\">// 先对数组排序</span><br>    Arrays.sort(nums);<br>    <span class=\"hljs-comment\">// 左右指针</span><br>    <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">lo</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span>, hi = nums.length - <span class=\"hljs-number\">1</span>;<br>    <span class=\"hljs-keyword\">while</span> (lo &lt; hi) &#123;<br>        <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">sum</span> <span class=\"hljs-operator\">=</span> nums[lo] + nums[hi];<br>        <span class=\"hljs-keyword\">if</span> (sum &lt; target) &#123;<br>            lo++;<br>        &#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (sum &gt; target) &#123;<br>            hi--;<br>        &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>            <span class=\"hljs-comment\">// 找到了一组解，需要再次遍历原数组找到对应的下标</span><br>            <span class=\"hljs-type\">int</span>[] result = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">int</span>[<span class=\"hljs-number\">2</span>];<br>            <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">i</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span>; i &lt; copy.length; i++) &#123;<br>                <span class=\"hljs-keyword\">if</span> (copy[i] == nums[lo]) &#123;<br>                    result[<span class=\"hljs-number\">0</span>] = i;<br>                &#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (copy[i] == nums[hi]) &#123;<br>                    result[<span class=\"hljs-number\">1</span>] = i;<br>                &#125;<br>            &#125;<br>            <span class=\"hljs-keyword\">return</span> result;<br>        &#125;<br>    &#125;<br>    <span class=\"hljs-comment\">// 误解返空</span><br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">int</span>[]&#123;&#125;;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><code>结束语：</code>类似于<code>nSum</code>的问题还有很多，诸如此，都可以使用数组双指针的技巧来巧妙解决，以上<code>code2</code>可以作为<code>nSum</code>问题的一个模板，除了 <code>twoSum</code> 问题，力扣上面还有 <code>3Sum</code>，<code>4Sum</code>,总之，<code>nSum</code> 问题就是给定一个数组 <code>nums</code> 和一个 <code>target</code>，然后从 <code>nums</code> 选择 <code>n</code> 个数，使得<code>n</code>个数字之和为 <code>target</code>。力扣第 167 题 <a href=\"https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/\">两数之和 II</a>也完全可以用数组双指针来求解，下期见🏊‍♂️</p>\n","site":{"data":{}},"more":"<ul>\n<li><p><code>leetCode：</code>001.两数之和</p>\n</li>\n<li><p><code>describution:</code></p>\n</li>\n</ul>\n<blockquote>\n<p>给定一个整数数组 <code>nums</code> 和一个整数目标值 <code>target</code>，请你在该数组中找出 <strong>和为目标值</strong> <em><code>target</code></em> 的那 <strong>两个</strong> 整数，并返回它们的数组下标。</p>\n<p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p>\n<p>你可以按任意顺序返回答案。</p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight inform7\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs inform7\">&gt;输入：nums = <span class=\"hljs-comment\">[2,7,11,15]</span>, target = 9<br>&gt;输出：<span class=\"hljs-comment\">[0,1]</span><br>&gt;解释：因为 nums<span class=\"hljs-comment\">[0]</span> + nums<span class=\"hljs-comment\">[1]</span> == 9 ，返回 <span class=\"hljs-comment\">[0, 1]</span> 。<br></code></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight inform7\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs inform7\">&gt;输入：nums = <span class=\"hljs-comment\">[3,2,4]</span>, target = 6<br>&gt;输出：<span class=\"hljs-comment\">[1,2]</span><br></code></pre></td></tr></table></figure>\n\n<p><strong>示例 3：</strong></p>\n<figure class=\"highlight inform7\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs inform7\">&gt;输入：nums = <span class=\"hljs-comment\">[3,3]</span>, target = 6<br>&gt;输出：<span class=\"hljs-comment\">[0,1]</span><br></code></pre></td></tr></table></figure>\n\n\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>2 &lt;= nums.length &lt;= 104</code></li>\n<li><code>-109 &lt;= nums[i] &lt;= 109</code></li>\n<li><code>-109 &lt;= target &lt;= 109</code></li>\n<li><strong>只会存在一个有效答案</strong></li>\n</ul>\n</blockquote>\n<p><code>技巧：</code>数组双指针</p>\n<p><code>思路：</code>使用哈希表作为辅助数据结构，可以在 O(n) 的时间复杂度内完成或者使用数组双指针团灭 nSum 问题。</p>\n<p><code>code1：</code>（哈希表的解法）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-type\">int</span>[] twoSum(<span class=\"hljs-type\">int</span>[] nums, <span class=\"hljs-type\">int</span> target) &#123;<br>    Map&lt;Integer, Integer&gt; map = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">HashMap</span>&lt;&gt;();<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">i</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span>; i &lt; nums.length; i++) &#123;<br>        <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">complement</span> <span class=\"hljs-operator\">=</span> target - nums[i];<br>        <span class=\"hljs-keyword\">if</span> (map.containsKey(complement)) &#123;<br>            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">int</span>[] &#123;map.get(complement), i&#125;;<br>        &#125;<br>        map.put(nums[i], i);<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">int</span>[<span class=\"hljs-number\">0</span>];<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><code>code2：</code>（非全部AC解法：数组双指针，例如遇到重复的数组元素）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-type\">int</span>[] twoSum(<span class=\"hljs-type\">int</span>[] nums, <span class=\"hljs-type\">int</span> target) &#123;<br>    <span class=\"hljs-comment\">// 复制原数组</span><br>    <span class=\"hljs-type\">int</span>[] copy = Arrays.copyOf(nums, nums.length);<br>    <span class=\"hljs-comment\">// 先对数组排序</span><br>    Arrays.sort(nums);<br>    <span class=\"hljs-comment\">// 左右指针</span><br>    <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">lo</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span>, hi = nums.length - <span class=\"hljs-number\">1</span>;<br>    <span class=\"hljs-keyword\">while</span> (lo &lt; hi) &#123;<br>        <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">sum</span> <span class=\"hljs-operator\">=</span> nums[lo] + nums[hi];<br>        <span class=\"hljs-keyword\">if</span> (sum &lt; target) &#123;<br>            lo++;<br>        &#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (sum &gt; target) &#123;<br>            hi--;<br>        &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>            <span class=\"hljs-comment\">// 找到了一组解，需要再次遍历原数组找到对应的下标</span><br>            <span class=\"hljs-type\">int</span>[] result = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">int</span>[<span class=\"hljs-number\">2</span>];<br>            <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">i</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span>; i &lt; copy.length; i++) &#123;<br>                <span class=\"hljs-keyword\">if</span> (copy[i] == nums[lo]) &#123;<br>                    result[<span class=\"hljs-number\">0</span>] = i;<br>                &#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (copy[i] == nums[hi]) &#123;<br>                    result[<span class=\"hljs-number\">1</span>] = i;<br>                &#125;<br>            &#125;<br>            <span class=\"hljs-keyword\">return</span> result;<br>        &#125;<br>    &#125;<br>    <span class=\"hljs-comment\">// 误解返空</span><br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">int</span>[]&#123;&#125;;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><code>结束语：</code>类似于<code>nSum</code>的问题还有很多，诸如此，都可以使用数组双指针的技巧来巧妙解决，以上<code>code2</code>可以作为<code>nSum</code>问题的一个模板，除了 <code>twoSum</code> 问题，力扣上面还有 <code>3Sum</code>，<code>4Sum</code>,总之，<code>nSum</code> 问题就是给定一个数组 <code>nums</code> 和一个 <code>target</code>，然后从 <code>nums</code> 选择 <code>n</code> 个数，使得<code>n</code>个数字之和为 <code>target</code>。力扣第 167 题 <a href=\"https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/\">两数之和 II</a>也完全可以用数组双指针来求解，下期见🏊‍♂️</p>\n"},{"title":"026-leetcode","index_img":"https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311151627628.png","excerpt":"今天来搞一搞LeetCode 026-删除有序数组中的重复项","abbrlink":32475,"date":"2021-02-08T01:23:13.000Z","_content":"# 删除有序数组中的重复项\n* `leetCode：`026.删除有序数组中的重复项\n\n* `describution:`\n\n  >给你一个 升序排列 的数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。元素的 相对顺序 应该保持 一致 。\n  >\n  >\n  >\n  >由于在某些语言中不能改变数组的长度，所以必须将结果放在数组nums的第一部分。更规范地说，如果在删除重复项之后有 k 个元素，那么 nums 的前 k 个元素应该保存最终结果。\n  >将最终结果插入 nums 的前 k 个位置后返回 k 。\n  >不要使用额外的空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。\n  >\n  >\n  >\n  >判题标准:\n  >系统会用下面的代码来测试你的题解:\n  >int[] nums = [...]; // 输入数组\n  >int[] expectedNums = [...]; // 长度正确的期望答案\n  >int k = removeDuplicates(nums); // 调用\n  >assert k == expectedNums.length;\n  >for (int i = 0; i < k; i++) {\n  >assert nums[i] == expectedNums[i];\n  >}\n  >如果所有断言都通过，那么您的题解将被 通过。\n  >\n  >\n  >\n  >示例 1：\n  >输入：nums = [1,1,2]\n  >输出：2, nums = [1,2,_]\n  >解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。\n  >\n  >\n  >\n  >示例 2：\n  >输入：nums = [0,0,1,1,1,2,2,3,3,4]\n  >输出：5, nums = [0,1,2,3,4]\n  >解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。\n  >\n  >\n  >\n  >提示：\n  >1 <= nums.length <= 3 * 104\n  >-104 <= nums[i] <= 104\n  >nums 已按 升序 排列\n\n* `技巧：`数组双指针\n\n* `思路：`准备一胖一瘦水桶，沿着数组顺序，遍历数组中每一个元素，从索引0出发，先将索引为0的value装进小水桶。瘦水桶先出发，一次前进一步，若遇到相同的元素，则继续前进，若遇到与前一个元素不同的元素，诶，扭头告诉胖水桶把新元素装进去（小水桶负责侦察，胖水桶负责办事），就这样一直前进。思路是否清晰？\n\n* `code：`\n\n  ```java\n  class Solution{\n  \tpublic int removeDuplicates(int[] nums) {\n  \t\tif(nums.length == 0) return 0;\n  \t\tint fast = 0,slow = 0;\n  \t\twhile(fast < nums.length){\n              // 判断下一个是否为新元素\n  \t\t\tif(nums[fast] != nums[slow]){\n  \t\t\t\t// last++; 简化代码，将新元素传入last的下一个位置\n  \t\t\t\tnums[++slow] = nums[fast];\n  \t\t\t}\n              // 不是新元素，大水桶继续前行\n  \t\t\tfast++;\n  \t\t}\n          // 返回如题要求的K值\n  \t\treturn slow++;\n  \t}\n  }\n  ```\n\n* `结束语：`菜狗幸福而又美好的一天结束啦！\n\n","source":"_posts/026.删除有序数组中的重复项.md","raw":"---\ntitle: 026-leetcode\nindex_img: https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311151627628.png\ncategories:\n  - 算法\ntags:\n  - leetcode\n  - 数组双指针\nexcerpt: 今天来搞一搞LeetCode 026-删除有序数组中的重复项\nabbrlink: 32475\ndate: 2021-02-08 09:23:13\n---\n# 删除有序数组中的重复项\n* `leetCode：`026.删除有序数组中的重复项\n\n* `describution:`\n\n  >给你一个 升序排列 的数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。元素的 相对顺序 应该保持 一致 。\n  >\n  >\n  >\n  >由于在某些语言中不能改变数组的长度，所以必须将结果放在数组nums的第一部分。更规范地说，如果在删除重复项之后有 k 个元素，那么 nums 的前 k 个元素应该保存最终结果。\n  >将最终结果插入 nums 的前 k 个位置后返回 k 。\n  >不要使用额外的空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。\n  >\n  >\n  >\n  >判题标准:\n  >系统会用下面的代码来测试你的题解:\n  >int[] nums = [...]; // 输入数组\n  >int[] expectedNums = [...]; // 长度正确的期望答案\n  >int k = removeDuplicates(nums); // 调用\n  >assert k == expectedNums.length;\n  >for (int i = 0; i < k; i++) {\n  >assert nums[i] == expectedNums[i];\n  >}\n  >如果所有断言都通过，那么您的题解将被 通过。\n  >\n  >\n  >\n  >示例 1：\n  >输入：nums = [1,1,2]\n  >输出：2, nums = [1,2,_]\n  >解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。\n  >\n  >\n  >\n  >示例 2：\n  >输入：nums = [0,0,1,1,1,2,2,3,3,4]\n  >输出：5, nums = [0,1,2,3,4]\n  >解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。\n  >\n  >\n  >\n  >提示：\n  >1 <= nums.length <= 3 * 104\n  >-104 <= nums[i] <= 104\n  >nums 已按 升序 排列\n\n* `技巧：`数组双指针\n\n* `思路：`准备一胖一瘦水桶，沿着数组顺序，遍历数组中每一个元素，从索引0出发，先将索引为0的value装进小水桶。瘦水桶先出发，一次前进一步，若遇到相同的元素，则继续前进，若遇到与前一个元素不同的元素，诶，扭头告诉胖水桶把新元素装进去（小水桶负责侦察，胖水桶负责办事），就这样一直前进。思路是否清晰？\n\n* `code：`\n\n  ```java\n  class Solution{\n  \tpublic int removeDuplicates(int[] nums) {\n  \t\tif(nums.length == 0) return 0;\n  \t\tint fast = 0,slow = 0;\n  \t\twhile(fast < nums.length){\n              // 判断下一个是否为新元素\n  \t\t\tif(nums[fast] != nums[slow]){\n  \t\t\t\t// last++; 简化代码，将新元素传入last的下一个位置\n  \t\t\t\tnums[++slow] = nums[fast];\n  \t\t\t}\n              // 不是新元素，大水桶继续前行\n  \t\t\tfast++;\n  \t\t}\n          // 返回如题要求的K值\n  \t\treturn slow++;\n  \t}\n  }\n  ```\n\n* `结束语：`菜狗幸福而又美好的一天结束啦！\n\n","slug":"026.删除有序数组中的重复项","published":1,"updated":"2023-11-26T03:30:23.226Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clpkiczi80002fkfo0qsf326y","content":"<h1 id=\"删除有序数组中的重复项\"><a href=\"#删除有序数组中的重复项\" class=\"headerlink\" title=\"删除有序数组中的重复项\"></a>删除有序数组中的重复项</h1><ul>\n<li><p><code>leetCode：</code>026.删除有序数组中的重复项</p>\n</li>\n<li><p><code>describution:</code></p>\n<blockquote>\n<p>给你一个 升序排列 的数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。元素的 相对顺序 应该保持 一致 。</p>\n<p>由于在某些语言中不能改变数组的长度，所以必须将结果放在数组nums的第一部分。更规范地说，如果在删除重复项之后有 k 个元素，那么 nums 的前 k 个元素应该保存最终结果。<br>将最终结果插入 nums 的前 k 个位置后返回 k 。<br>不要使用额外的空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。</p>\n<p>判题标准:<br>系统会用下面的代码来测试你的题解:<br>int[] nums = […]; // 输入数组<br>int[] expectedNums = […]; // 长度正确的期望答案<br>int k = removeDuplicates(nums); // 调用<br>assert k == expectedNums.length;<br>for (int i = 0; i &lt; k; i++) {<br>assert nums[i] == expectedNums[i];<br>}<br>如果所有断言都通过，那么您的题解将被 通过。</p>\n<p>示例 1：<br>输入：nums = [1,1,2]<br>输出：2, nums = [1,2,_]<br>解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。</p>\n<p>示例 2：<br>输入：nums = [0,0,1,1,1,2,2,3,3,4]<br>输出：5, nums = [0,1,2,3,4]<br>解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。</p>\n<p>提示：<br>1 &lt;= nums.length &lt;= 3 * 104<br>-104 &lt;= nums[i] &lt;= 104<br>nums 已按 升序 排列</p>\n</blockquote>\n</li>\n<li><p><code>技巧：</code>数组双指针</p>\n</li>\n<li><p><code>思路：</code>准备一胖一瘦水桶，沿着数组顺序，遍历数组中每一个元素，从索引0出发，先将索引为0的value装进小水桶。瘦水桶先出发，一次前进一步，若遇到相同的元素，则继续前进，若遇到与前一个元素不同的元素，诶，扭头告诉胖水桶把新元素装进去（小水桶负责侦察，胖水桶负责办事），就这样一直前进。思路是否清晰？</p>\n</li>\n<li><p><code>code：</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>&#123;<br>\t<span class=\"hljs-keyword\">public</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">removeDuplicates</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span>[] nums)</span> &#123;<br>\t\t<span class=\"hljs-keyword\">if</span>(nums.length == <span class=\"hljs-number\">0</span>) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>\t\t<span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">fast</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span>,slow = <span class=\"hljs-number\">0</span>;<br>\t\t<span class=\"hljs-keyword\">while</span>(fast &lt; nums.length)&#123;<br>            <span class=\"hljs-comment\">// 判断下一个是否为新元素</span><br>\t\t\t<span class=\"hljs-keyword\">if</span>(nums[fast] != nums[slow])&#123;<br>\t\t\t\t<span class=\"hljs-comment\">// last++; 简化代码，将新元素传入last的下一个位置</span><br>\t\t\t\tnums[++slow] = nums[fast];<br>\t\t\t&#125;<br>            <span class=\"hljs-comment\">// 不是新元素，大水桶继续前行</span><br>\t\t\tfast++;<br>\t\t&#125;<br>        <span class=\"hljs-comment\">// 返回如题要求的K值</span><br>\t\t<span class=\"hljs-keyword\">return</span> slow++;<br>\t&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>\n<li><p><code>结束语：</code>菜狗幸福而又美好的一天结束啦！</p>\n</li>\n</ul>\n","site":{"data":{}},"more":"<h1 id=\"删除有序数组中的重复项\"><a href=\"#删除有序数组中的重复项\" class=\"headerlink\" title=\"删除有序数组中的重复项\"></a>删除有序数组中的重复项</h1><ul>\n<li><p><code>leetCode：</code>026.删除有序数组中的重复项</p>\n</li>\n<li><p><code>describution:</code></p>\n<blockquote>\n<p>给你一个 升序排列 的数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。元素的 相对顺序 应该保持 一致 。</p>\n<p>由于在某些语言中不能改变数组的长度，所以必须将结果放在数组nums的第一部分。更规范地说，如果在删除重复项之后有 k 个元素，那么 nums 的前 k 个元素应该保存最终结果。<br>将最终结果插入 nums 的前 k 个位置后返回 k 。<br>不要使用额外的空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。</p>\n<p>判题标准:<br>系统会用下面的代码来测试你的题解:<br>int[] nums = […]; // 输入数组<br>int[] expectedNums = […]; // 长度正确的期望答案<br>int k = removeDuplicates(nums); // 调用<br>assert k == expectedNums.length;<br>for (int i = 0; i &lt; k; i++) {<br>assert nums[i] == expectedNums[i];<br>}<br>如果所有断言都通过，那么您的题解将被 通过。</p>\n<p>示例 1：<br>输入：nums = [1,1,2]<br>输出：2, nums = [1,2,_]<br>解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。</p>\n<p>示例 2：<br>输入：nums = [0,0,1,1,1,2,2,3,3,4]<br>输出：5, nums = [0,1,2,3,4]<br>解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。</p>\n<p>提示：<br>1 &lt;= nums.length &lt;= 3 * 104<br>-104 &lt;= nums[i] &lt;= 104<br>nums 已按 升序 排列</p>\n</blockquote>\n</li>\n<li><p><code>技巧：</code>数组双指针</p>\n</li>\n<li><p><code>思路：</code>准备一胖一瘦水桶，沿着数组顺序，遍历数组中每一个元素，从索引0出发，先将索引为0的value装进小水桶。瘦水桶先出发，一次前进一步，若遇到相同的元素，则继续前进，若遇到与前一个元素不同的元素，诶，扭头告诉胖水桶把新元素装进去（小水桶负责侦察，胖水桶负责办事），就这样一直前进。思路是否清晰？</p>\n</li>\n<li><p><code>code：</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>&#123;<br>\t<span class=\"hljs-keyword\">public</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">removeDuplicates</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span>[] nums)</span> &#123;<br>\t\t<span class=\"hljs-keyword\">if</span>(nums.length == <span class=\"hljs-number\">0</span>) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>\t\t<span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">fast</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span>,slow = <span class=\"hljs-number\">0</span>;<br>\t\t<span class=\"hljs-keyword\">while</span>(fast &lt; nums.length)&#123;<br>            <span class=\"hljs-comment\">// 判断下一个是否为新元素</span><br>\t\t\t<span class=\"hljs-keyword\">if</span>(nums[fast] != nums[slow])&#123;<br>\t\t\t\t<span class=\"hljs-comment\">// last++; 简化代码，将新元素传入last的下一个位置</span><br>\t\t\t\tnums[++slow] = nums[fast];<br>\t\t\t&#125;<br>            <span class=\"hljs-comment\">// 不是新元素，大水桶继续前行</span><br>\t\t\tfast++;<br>\t\t&#125;<br>        <span class=\"hljs-comment\">// 返回如题要求的K值</span><br>\t\t<span class=\"hljs-keyword\">return</span> slow++;<br>\t&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>\n<li><p><code>结束语：</code>菜狗幸福而又美好的一天结束啦！</p>\n</li>\n</ul>\n"},{"title":"Bugs宝典","index_img":"https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202308211859336.jpg","excerpt":"分享一下平时遇到的Bugs以及解决方案，来看看有没有让你肠子都悔青的Bugs","abbrlink":53599,"date":"2023-09-07T00:58:32.000Z","_content":"\n## Git篇\n\n1. `git pull gitee`出现问题\n\n> You asked to pull from the remote 'gitee', but did not specify\n> a branch. Because this is not the default configured remote\n> for your current branch, you must specify a branch on the command line.\n\n**解决办法：**\n\n首先，主要是命令使用不规范导致，应该是`gitee pull gitee(远程仓库别名) + master（分支名） `\n\n其次，针对以上错误，也可以编辑工作目录下的`.git/config文件`文件内容，增加如下代码：\n\n```xml\n[branch \"master\"]\n  remote = origin\n  merge = refs/heads/master\n```\n\n2. Failed to connect to github.com port 443 after xxxxx ms: Timed out\n\n> 网络错误问题，使用全局代理有时并不能解决\n>\n> **解决办法：**配置远程仓库地址时，使用SSH以代替Https连接，亲测有效。\n>\n> 参考文献：[【Git】Github 上传文件到远程仓库时，经常发生网络错误，一个比较稳定的连接方法及我的示例](https://blog.csdn.net/wzk4869/article/details/131626483)\n\n3. github图床上传的图片显示失败\n\n**解决办法：**\n\n`TODO:`\n\n4. ssh免密设置后，仍提示输入密码，报错如下：\n\n   > [root@localhost ~]# ssh -vvv XXX.XX.X.XXX\n   > OpenSSH_6.4, [OpenSSL](https://so.csdn.net/so/search?q=OpenSSL&spm=1001.2101.3001.7020) 1.0.1e-fips 11 Feb 2013\n   > debug1: Reading [configuration](https://so.csdn.net/so/search?q=configuration&spm=1001.2101.3001.7020) data /etc/ssh/ssh_config\n   > debug1: /etc/ssh/ssh_config line 51: Applying options for *\n   > debug2: ssh_connect: needpriv 0\n   > debug1: Connecting to XXX.XX.X.XXX [XXX.XX.X.XXX] port 22.\n   > debug1: Connection established.\n   > debug1: permanently_set_uid: 0/0\n   > debug3: Incorrect RSA1 identifier\n   > debug3: Could not load \"/root/.ssh/id_rsa\" as a RSA1 public key\n   > debug1: identity file /root/.ssh/id_rsa type 1\n   > debug1: identity file /root/.ssh/id_rsa-cert type -1\n   > debug1: identity file /root/.ssh/id_dsa type -1\n   > debug1: identity file /root/.ssh/id_dsa-cert type -1\n   > debug1: identity file /root/.ssh/id_ecdsa type -1\n   > debug1: identity file /root/.ssh/id_ecdsa-cert type -1\n   > debug1: Enabling compatibility mode for protocol 2.0\n   > debug1: Local version string SSH-2.0-OpenSSH_6.4\n   > debug1: Remote protocol version 2.0, remote software version OpenSSH_6.4\n   > debug1: match: OpenSSH_6.4 pat [OpenSSH](https://so.csdn.net/so/search?q=OpenSSH&spm=1001.2101.3001.7020)*\n\n   想必看到这里，但凡想想，应该就会想，难道是密钥的问题？密钥不对？或者就是权限问题？\n\n   🆗，回想一下我们学习Linux的时候，讲过一个SELinux，不知是否还有印象。那么什么是SELinux呢?\n\n   > **[安全增强式 Linux](https://zh.wikipedia.org/wiki/%E5%AE%89%E5%85%A8%E5%A2%9E%E5%BC%BA%E5%BC%8FLinux)，即`SELinux`(Security-Enhanced Linux)是一个** **`Linux`** **内核的安全模块，其提供了访问控制安全策略机制，包括了强制访问控制**(Mandatory Access Control，MAC)。\n\n   \n\n   **解决办法：**\n\n   ```\n   # 查看当前模式。如果为disabled即是关闭状态，我们需要讲安全模式打开\n   $ getenforce\n   ```\n\n   ![image-20230824174357178](https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202308241743908.png)\n\n   ```\n   # vi /etc/selinux/config打开selinux配置文件\n   $ vi /etc/selinux/config\n   ```\n\n   ![image-20230824175528202](https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202308241755769.png)\n\n​\t参考链接：https://blog.csdn.net/u012026446/article/details/81318188\n\n## 项目篇\n\n* ### API项目\n\n1. 粗心大意导致的错误（前后对比）\n\n> ```\n> <CreateModal\n>      columns={columns}\n>      onCancel={() => {\n>        // 注意这里\n>        handleUpdateModalOpen(false);\n>      }}\n>      onSubmit={(values) => {\n>        handleAdd(values);\n>      }}\n>      visible={createModalOpen}\n> />\n> ```\n\n> ```\n> <CreateModal\n>   columns={columns}\n>   onCancel={() => {\n>     handleModalOpen(false);\n>   }}\n>   onSubmit={(values) => {\n>     handleAdd(values);\n>   }}\n>   visible={createModalOpen} \n> />\n> ```\n\n2. 终于又碰到了一个bugssss！！！头疼得很！--controller类更改运行不生效\n\n   发生在Spring Boot API项目的模拟接口项目：更改controller类后，发现重新运行之后页面没有改变，更改无效，此时需要对maven重新打jar包，更改才会生效，ChatGPT说是因为热部署的问题。\n\n   bug缘由：早在我把模拟接口项目整个粘贴到后端项目中时就已经存在bug了，之前没有发现，尝试把这个项目单独拎出来的话没问题。\n\n   **解决方法：**\n\n   * 我先试试是不是maven的module没有配置好（因为是直接把模拟接口项目直接粘贴到后端项目中了）\n   * 后续整合网管业务的时候，遇到了项目包名不一致的问题，然后在包名重命名中出现了n个问题，最后迫不得已将项目重构了，然后在项目中直接创建module是没有问题的，因此证实了上述猜想中的module没有配置好！\n\n3. 当Springboot项目中引入了Mabatis，但是没有进行配置，会导致项目运行的时候报错：找不到配置，如图：\n\n   ![image-20230803205650059](https://cdn.jsdelivr.net/gh/wl2o2o/blogCdn/img/202308032056940.png)\n\n\t* **解决方法**:在启动类上添加一个排除数据库配置的注解：\n\t\n\t  > \n\n\n\n## 工具篇\n\n### pnpm\n\n\n\n\n\n### HuTool\n\n```shell\ncn.hutool.core.io.IORuntimeException: ConnectException: Connection refused: connect\n\n\tat cn.hutool.http.HttpRequest.send(HttpRequest.java:1328)\n\tat cn.hutool.http.HttpRequest.doExecute(HttpRequest.java:1176)\n\tcn.hutool.http.HttpRequest.send(HttpRequest.java:1323)\n\t... 73 more\n\nDisconnected from the target VM, address: '127.0.0.1:6928', transport: 'socket'\n\nProcess finished with exit code -1\n```\n\n**解决方法：**\n\n​\t待补充！！！\n\n\n\n### Nacos\n\n#### 找不到相关Service服务\n\n* 消费者与提供者项目包名不一致导致找不到service服务\n\n> 遇到一个`nocos`小BUG：\n>\n> Dubbo整合nocos的时候，提供者与消费者的包名不一样，这时，提供者将接口的信息注册到nacos文档时，用到的是provider的包名路径，如果出现消费者的包名路径与提供者的包名不同的时候，这时消费者就会报错找不到提供者的Service服务，如图：\n>\n> ![image-20230731193204173](https://cdn.jsdelivr.net/gh/wl2o2o/blogCdn/img/202307311932647.png)\n\n#### 端口被占用\n\n> netstat -ano | findstr 8848\n>\n> taskkill /pid 1244 /f\n\n![解除端口占用的命令](https://cdn.jsdelivr.net/gh/wl2o2o/blogCdn/img/202308040415943.png)\n\n* `maven`\n\n> 问题1：\n>\n\n​\tSpring Boot项目涉及到多个模块时，应该怎么办？\n\n​\t方案一：\n\n​\t\t类似于maven项目的多模块编译\n\n​\t方案二：\n\n​\t\t将pom文件设置为maven项目\n\n​\t\t<img src=\"https://cdn.jsdelivr.net/gh/wl2o2o/blogCdn/img/202308010328505.png\" alt=\"将pom文件设置为maven项目\" style=\"zoom:33%;\" />\n\n> 问题2：\n>\n\n​\t自己开发`SDK`时，pom文件中忘记去掉`<build></build>`标签时，当使用maven执行install命令时，maven会报错：没有可执行的main。\n\n​\t如图：\n\n​\t![image-20230802002346028](https://cdn.jsdelivr.net/gh/wl2o2o/blogCdn/img/202308020023072.png)\n\n> 问题3：\n>\n\n​\t想用maven的多模块编译，父模块用`<models>`子模块用`<parent>`，用下面的依赖配置，是没问题的，\n\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    <modelVersion>4.0.0</modelVersion>\n\n    <parent>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-parent</artifactId>\n        <version>2.7.7</version>\n        <relativePath/> <!-- lookup parent from repository -->\n    </parent>\n\n    <groupId>com.csguider</groupId>\n    <artifactId>smartapi-gateway</artifactId>\n    <version>0.0.1-SNAPSHOT</version>\n\n    <name>smartapi-gateway</name>\n    <description>Demo project for Spring Boot</description>\n\n    <properties>\n        <java.version>1.8</java.version>\n        <spring-cloud.version>2021.0.5</spring-cloud.version>\n    </properties>\n\n    <dependencies>\n        <!-- https://mvnrepository.com/artifact/org.apache.dubbo/dubbo -->\n        <dependency>\n            <groupId>org.apache.dubbo</groupId>\n            <artifactId>dubbo</artifactId>\n            <version>3.0.9</version>\n        </dependency>\n        <dependency>\n            <groupId>com.alibaba.nacos</groupId>\n            <artifactId>nacos-client</artifactId>\n            <version>2.1.0</version>\n        </dependency>\n\n        <dependency>\n            <groupId>org.springframework.cloud</groupId>\n            <artifactId>spring-cloud-starter-gateway</artifactId>\n        </dependency>\n\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-devtools</artifactId>\n            <scope>runtime</scope>\n            <optional>true</optional>\n        </dependency>\n\n        <dependency>\n            <groupId>org.projectlombok</groupId>\n            <artifactId>lombok</artifactId>\n            <optional>true</optional>\n        </dependency>\n\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-test</artifactId>\n            <scope>test</scope>\n        </dependency>\n        <!--这个依赖引入先打个注释，是通过快捷键自动引入的。<scope>这个标签先打个标签,表示作用域-->\n        <dependency>\n            <groupId>com.csguider</groupId>\n            <artifactId>smartapi-client-sdk</artifactId>\n            <version>0.0.1-SNAPSHOT</version>\n        </dependency>\n    </dependencies>\n    <dependencyManagement>\n        <dependencies>\n            <dependency>\n                <groupId>org.springframework.cloud</groupId>\n                <artifactId>spring-cloud-dependencies</artifactId>\n                <version>${spring-cloud.version}</version>\n                <type>pom</type>\n                <scope>import</scope>\n            </dependency>\n        </dependencies>\n    </dependencyManagement>\n\n    <build>\n        <plugins>\n            <plugin>\n                <groupId>org.springframework.boot</groupId>\n                <artifactId>spring-boot-maven-plugin</artifactId>\n                <configuration>\n                    <excludes>\n                        <exclude>\n                            <groupId>org.projectlombok</groupId>\n                            <artifactId>lombok</artifactId>\n                        </exclude>\n                    </excludes>\n                </configuration>\n            </plugin>\n        </plugins>\n    </build>\n\n</project>\n```\n\n当我把parent换成父类时，会报错：\n\n![](https://cdn.jsdelivr.net/gh/wl2o2o/blogCdn/img/202308020207946.png)\n\n* 解决方法：\n\n> * set spring.main.web-application-type=reactive\n>\n> `spring.main.web-application-type=reactive` 是针对 Spring Boot 2.x版本引入的一个配置属性，用于指定应用程序的类型。它有两个可能的值：`servlet`（默认值）和`reactive`。\n>\n> 当将 `spring.main.web-application-type` 设置为 `reactive` 时，您的应用程序将使用反应式编程模型。这意味着您的应用程序将使用 WebFlux 框架，而不是传统的 Servlet 框架。\n>\n> 使用反应式编程模型可以提供更好的性能和可扩展性，因为它使用了非阻塞的 I/O 和事件驱动的编程模型。这种模型特别适用于高并发和异步处理场景。\n>\n> 要使用反应式编程模型，您需要相应地更新您的应用程序代码，以便使用 WebFlux 相关的的基础设施和 API。例如，您需要使用 `@Controller` 替换 `@ControllerAdvice`，并使用 `ServerWebExchange` 对象访问 HTTP 请求和响应。\n>\n> 总之，将 `spring.main.web-application-type` 设置为 `reactive` 将使您的应用程序使用 WebFlux 框架，以获得更好的性能和可扩展性。但请注意，您需要对应用程序代码进行相应的更改，以适应反应式编程模型。\n>\n> 要设置 `spring.main.web-application-type` 为 `reactive`，您需要在应用的配置文件 `application.yml` 或 `application.properties` 中添加以下配置1：\n>\n> ```\n> spring:\n> \tmain:\n>     \tweb-application-type: reactive\n> ```\n>\n> 这样，您告诉 Spring Boot 应用程序使用响应式的 Web 应用类型。同时，请注意，您需要相应地更新您的应用程序代码，以使用 WebFlux 相关的基础设施和 API，例如使用 `@Controller` 替换 `@ControllerAdvice`，并使用 `ServerWebExchange` 对象访问 HTTP 请求和响应1。\n\n","source":"_posts/Bugsss.md","raw":"---\ntitle: Bugs宝典\nindex_img: >-\n  https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202308211859336.jpg\nexcerpt: 分享一下平时遇到的Bugs以及解决方案，来看看有没有让你肠子都悔青的Bugs\ncategories:\n  - Bugs\ntags:\n  - Bugs\nabbrlink: 53599\ndate: 2023-09-07 08:58:32\n---\n\n## Git篇\n\n1. `git pull gitee`出现问题\n\n> You asked to pull from the remote 'gitee', but did not specify\n> a branch. Because this is not the default configured remote\n> for your current branch, you must specify a branch on the command line.\n\n**解决办法：**\n\n首先，主要是命令使用不规范导致，应该是`gitee pull gitee(远程仓库别名) + master（分支名） `\n\n其次，针对以上错误，也可以编辑工作目录下的`.git/config文件`文件内容，增加如下代码：\n\n```xml\n[branch \"master\"]\n  remote = origin\n  merge = refs/heads/master\n```\n\n2. Failed to connect to github.com port 443 after xxxxx ms: Timed out\n\n> 网络错误问题，使用全局代理有时并不能解决\n>\n> **解决办法：**配置远程仓库地址时，使用SSH以代替Https连接，亲测有效。\n>\n> 参考文献：[【Git】Github 上传文件到远程仓库时，经常发生网络错误，一个比较稳定的连接方法及我的示例](https://blog.csdn.net/wzk4869/article/details/131626483)\n\n3. github图床上传的图片显示失败\n\n**解决办法：**\n\n`TODO:`\n\n4. ssh免密设置后，仍提示输入密码，报错如下：\n\n   > [root@localhost ~]# ssh -vvv XXX.XX.X.XXX\n   > OpenSSH_6.4, [OpenSSL](https://so.csdn.net/so/search?q=OpenSSL&spm=1001.2101.3001.7020) 1.0.1e-fips 11 Feb 2013\n   > debug1: Reading [configuration](https://so.csdn.net/so/search?q=configuration&spm=1001.2101.3001.7020) data /etc/ssh/ssh_config\n   > debug1: /etc/ssh/ssh_config line 51: Applying options for *\n   > debug2: ssh_connect: needpriv 0\n   > debug1: Connecting to XXX.XX.X.XXX [XXX.XX.X.XXX] port 22.\n   > debug1: Connection established.\n   > debug1: permanently_set_uid: 0/0\n   > debug3: Incorrect RSA1 identifier\n   > debug3: Could not load \"/root/.ssh/id_rsa\" as a RSA1 public key\n   > debug1: identity file /root/.ssh/id_rsa type 1\n   > debug1: identity file /root/.ssh/id_rsa-cert type -1\n   > debug1: identity file /root/.ssh/id_dsa type -1\n   > debug1: identity file /root/.ssh/id_dsa-cert type -1\n   > debug1: identity file /root/.ssh/id_ecdsa type -1\n   > debug1: identity file /root/.ssh/id_ecdsa-cert type -1\n   > debug1: Enabling compatibility mode for protocol 2.0\n   > debug1: Local version string SSH-2.0-OpenSSH_6.4\n   > debug1: Remote protocol version 2.0, remote software version OpenSSH_6.4\n   > debug1: match: OpenSSH_6.4 pat [OpenSSH](https://so.csdn.net/so/search?q=OpenSSH&spm=1001.2101.3001.7020)*\n\n   想必看到这里，但凡想想，应该就会想，难道是密钥的问题？密钥不对？或者就是权限问题？\n\n   🆗，回想一下我们学习Linux的时候，讲过一个SELinux，不知是否还有印象。那么什么是SELinux呢?\n\n   > **[安全增强式 Linux](https://zh.wikipedia.org/wiki/%E5%AE%89%E5%85%A8%E5%A2%9E%E5%BC%BA%E5%BC%8FLinux)，即`SELinux`(Security-Enhanced Linux)是一个** **`Linux`** **内核的安全模块，其提供了访问控制安全策略机制，包括了强制访问控制**(Mandatory Access Control，MAC)。\n\n   \n\n   **解决办法：**\n\n   ```\n   # 查看当前模式。如果为disabled即是关闭状态，我们需要讲安全模式打开\n   $ getenforce\n   ```\n\n   ![image-20230824174357178](https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202308241743908.png)\n\n   ```\n   # vi /etc/selinux/config打开selinux配置文件\n   $ vi /etc/selinux/config\n   ```\n\n   ![image-20230824175528202](https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202308241755769.png)\n\n​\t参考链接：https://blog.csdn.net/u012026446/article/details/81318188\n\n## 项目篇\n\n* ### API项目\n\n1. 粗心大意导致的错误（前后对比）\n\n> ```\n> <CreateModal\n>      columns={columns}\n>      onCancel={() => {\n>        // 注意这里\n>        handleUpdateModalOpen(false);\n>      }}\n>      onSubmit={(values) => {\n>        handleAdd(values);\n>      }}\n>      visible={createModalOpen}\n> />\n> ```\n\n> ```\n> <CreateModal\n>   columns={columns}\n>   onCancel={() => {\n>     handleModalOpen(false);\n>   }}\n>   onSubmit={(values) => {\n>     handleAdd(values);\n>   }}\n>   visible={createModalOpen} \n> />\n> ```\n\n2. 终于又碰到了一个bugssss！！！头疼得很！--controller类更改运行不生效\n\n   发生在Spring Boot API项目的模拟接口项目：更改controller类后，发现重新运行之后页面没有改变，更改无效，此时需要对maven重新打jar包，更改才会生效，ChatGPT说是因为热部署的问题。\n\n   bug缘由：早在我把模拟接口项目整个粘贴到后端项目中时就已经存在bug了，之前没有发现，尝试把这个项目单独拎出来的话没问题。\n\n   **解决方法：**\n\n   * 我先试试是不是maven的module没有配置好（因为是直接把模拟接口项目直接粘贴到后端项目中了）\n   * 后续整合网管业务的时候，遇到了项目包名不一致的问题，然后在包名重命名中出现了n个问题，最后迫不得已将项目重构了，然后在项目中直接创建module是没有问题的，因此证实了上述猜想中的module没有配置好！\n\n3. 当Springboot项目中引入了Mabatis，但是没有进行配置，会导致项目运行的时候报错：找不到配置，如图：\n\n   ![image-20230803205650059](https://cdn.jsdelivr.net/gh/wl2o2o/blogCdn/img/202308032056940.png)\n\n\t* **解决方法**:在启动类上添加一个排除数据库配置的注解：\n\t\n\t  > \n\n\n\n## 工具篇\n\n### pnpm\n\n\n\n\n\n### HuTool\n\n```shell\ncn.hutool.core.io.IORuntimeException: ConnectException: Connection refused: connect\n\n\tat cn.hutool.http.HttpRequest.send(HttpRequest.java:1328)\n\tat cn.hutool.http.HttpRequest.doExecute(HttpRequest.java:1176)\n\tcn.hutool.http.HttpRequest.send(HttpRequest.java:1323)\n\t... 73 more\n\nDisconnected from the target VM, address: '127.0.0.1:6928', transport: 'socket'\n\nProcess finished with exit code -1\n```\n\n**解决方法：**\n\n​\t待补充！！！\n\n\n\n### Nacos\n\n#### 找不到相关Service服务\n\n* 消费者与提供者项目包名不一致导致找不到service服务\n\n> 遇到一个`nocos`小BUG：\n>\n> Dubbo整合nocos的时候，提供者与消费者的包名不一样，这时，提供者将接口的信息注册到nacos文档时，用到的是provider的包名路径，如果出现消费者的包名路径与提供者的包名不同的时候，这时消费者就会报错找不到提供者的Service服务，如图：\n>\n> ![image-20230731193204173](https://cdn.jsdelivr.net/gh/wl2o2o/blogCdn/img/202307311932647.png)\n\n#### 端口被占用\n\n> netstat -ano | findstr 8848\n>\n> taskkill /pid 1244 /f\n\n![解除端口占用的命令](https://cdn.jsdelivr.net/gh/wl2o2o/blogCdn/img/202308040415943.png)\n\n* `maven`\n\n> 问题1：\n>\n\n​\tSpring Boot项目涉及到多个模块时，应该怎么办？\n\n​\t方案一：\n\n​\t\t类似于maven项目的多模块编译\n\n​\t方案二：\n\n​\t\t将pom文件设置为maven项目\n\n​\t\t<img src=\"https://cdn.jsdelivr.net/gh/wl2o2o/blogCdn/img/202308010328505.png\" alt=\"将pom文件设置为maven项目\" style=\"zoom:33%;\" />\n\n> 问题2：\n>\n\n​\t自己开发`SDK`时，pom文件中忘记去掉`<build></build>`标签时，当使用maven执行install命令时，maven会报错：没有可执行的main。\n\n​\t如图：\n\n​\t![image-20230802002346028](https://cdn.jsdelivr.net/gh/wl2o2o/blogCdn/img/202308020023072.png)\n\n> 问题3：\n>\n\n​\t想用maven的多模块编译，父模块用`<models>`子模块用`<parent>`，用下面的依赖配置，是没问题的，\n\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    <modelVersion>4.0.0</modelVersion>\n\n    <parent>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-parent</artifactId>\n        <version>2.7.7</version>\n        <relativePath/> <!-- lookup parent from repository -->\n    </parent>\n\n    <groupId>com.csguider</groupId>\n    <artifactId>smartapi-gateway</artifactId>\n    <version>0.0.1-SNAPSHOT</version>\n\n    <name>smartapi-gateway</name>\n    <description>Demo project for Spring Boot</description>\n\n    <properties>\n        <java.version>1.8</java.version>\n        <spring-cloud.version>2021.0.5</spring-cloud.version>\n    </properties>\n\n    <dependencies>\n        <!-- https://mvnrepository.com/artifact/org.apache.dubbo/dubbo -->\n        <dependency>\n            <groupId>org.apache.dubbo</groupId>\n            <artifactId>dubbo</artifactId>\n            <version>3.0.9</version>\n        </dependency>\n        <dependency>\n            <groupId>com.alibaba.nacos</groupId>\n            <artifactId>nacos-client</artifactId>\n            <version>2.1.0</version>\n        </dependency>\n\n        <dependency>\n            <groupId>org.springframework.cloud</groupId>\n            <artifactId>spring-cloud-starter-gateway</artifactId>\n        </dependency>\n\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-devtools</artifactId>\n            <scope>runtime</scope>\n            <optional>true</optional>\n        </dependency>\n\n        <dependency>\n            <groupId>org.projectlombok</groupId>\n            <artifactId>lombok</artifactId>\n            <optional>true</optional>\n        </dependency>\n\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-test</artifactId>\n            <scope>test</scope>\n        </dependency>\n        <!--这个依赖引入先打个注释，是通过快捷键自动引入的。<scope>这个标签先打个标签,表示作用域-->\n        <dependency>\n            <groupId>com.csguider</groupId>\n            <artifactId>smartapi-client-sdk</artifactId>\n            <version>0.0.1-SNAPSHOT</version>\n        </dependency>\n    </dependencies>\n    <dependencyManagement>\n        <dependencies>\n            <dependency>\n                <groupId>org.springframework.cloud</groupId>\n                <artifactId>spring-cloud-dependencies</artifactId>\n                <version>${spring-cloud.version}</version>\n                <type>pom</type>\n                <scope>import</scope>\n            </dependency>\n        </dependencies>\n    </dependencyManagement>\n\n    <build>\n        <plugins>\n            <plugin>\n                <groupId>org.springframework.boot</groupId>\n                <artifactId>spring-boot-maven-plugin</artifactId>\n                <configuration>\n                    <excludes>\n                        <exclude>\n                            <groupId>org.projectlombok</groupId>\n                            <artifactId>lombok</artifactId>\n                        </exclude>\n                    </excludes>\n                </configuration>\n            </plugin>\n        </plugins>\n    </build>\n\n</project>\n```\n\n当我把parent换成父类时，会报错：\n\n![](https://cdn.jsdelivr.net/gh/wl2o2o/blogCdn/img/202308020207946.png)\n\n* 解决方法：\n\n> * set spring.main.web-application-type=reactive\n>\n> `spring.main.web-application-type=reactive` 是针对 Spring Boot 2.x版本引入的一个配置属性，用于指定应用程序的类型。它有两个可能的值：`servlet`（默认值）和`reactive`。\n>\n> 当将 `spring.main.web-application-type` 设置为 `reactive` 时，您的应用程序将使用反应式编程模型。这意味着您的应用程序将使用 WebFlux 框架，而不是传统的 Servlet 框架。\n>\n> 使用反应式编程模型可以提供更好的性能和可扩展性，因为它使用了非阻塞的 I/O 和事件驱动的编程模型。这种模型特别适用于高并发和异步处理场景。\n>\n> 要使用反应式编程模型，您需要相应地更新您的应用程序代码，以便使用 WebFlux 相关的的基础设施和 API。例如，您需要使用 `@Controller` 替换 `@ControllerAdvice`，并使用 `ServerWebExchange` 对象访问 HTTP 请求和响应。\n>\n> 总之，将 `spring.main.web-application-type` 设置为 `reactive` 将使您的应用程序使用 WebFlux 框架，以获得更好的性能和可扩展性。但请注意，您需要对应用程序代码进行相应的更改，以适应反应式编程模型。\n>\n> 要设置 `spring.main.web-application-type` 为 `reactive`，您需要在应用的配置文件 `application.yml` 或 `application.properties` 中添加以下配置1：\n>\n> ```\n> spring:\n> \tmain:\n>     \tweb-application-type: reactive\n> ```\n>\n> 这样，您告诉 Spring Boot 应用程序使用响应式的 Web 应用类型。同时，请注意，您需要相应地更新您的应用程序代码，以使用 WebFlux 相关的基础设施和 API，例如使用 `@Controller` 替换 `@ControllerAdvice`，并使用 `ServerWebExchange` 对象访问 HTTP 请求和响应1。\n\n","slug":"Bugsss","published":1,"updated":"2023-11-26T03:40:26.348Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clpkiczic0005fkfo93zbgbsp","content":"<h2 id=\"Git篇\"><a href=\"#Git篇\" class=\"headerlink\" title=\"Git篇\"></a>Git篇</h2><ol>\n<li><code>git pull gitee</code>出现问题</li>\n</ol>\n<blockquote>\n<p>You asked to pull from the remote ‘gitee’, but did not specify<br>a branch. Because this is not the default configured remote<br>for your current branch, you must specify a branch on the command line.</p>\n</blockquote>\n<p><strong>解决办法：</strong></p>\n<p>首先，主要是命令使用不规范导致，应该是<code>gitee pull gitee(远程仓库别名) + master（分支名） </code></p>\n<p>其次，针对以上错误，也可以编辑工作目录下的<code>.git/config文件</code>文件内容，增加如下代码：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs xml\">[branch &quot;master&quot;]<br>  remote = origin<br>  merge = refs/heads/master<br></code></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>Failed to connect to github.com port 443 after xxxxx ms: Timed out</li>\n</ol>\n<blockquote>\n<p>网络错误问题，使用全局代理有时并不能解决</p>\n<p><strong>解决办法：</strong>配置远程仓库地址时，使用SSH以代替Https连接，亲测有效。</p>\n<p>参考文献：<a href=\"https://blog.csdn.net/wzk4869/article/details/131626483\">【Git】Github 上传文件到远程仓库时，经常发生网络错误，一个比较稳定的连接方法及我的示例</a></p>\n</blockquote>\n<ol start=\"3\">\n<li>github图床上传的图片显示失败</li>\n</ol>\n<p><strong>解决办法：</strong></p>\n<p><code>TODO:</code></p>\n<ol start=\"4\">\n<li><p>ssh免密设置后，仍提示输入密码，报错如下：</p>\n<blockquote>\n<p>[root@localhost ~]# ssh -vvv XXX.XX.X.XXX<br>OpenSSH_6.4, <a href=\"https://so.csdn.net/so/search?q=OpenSSL&spm=1001.2101.3001.7020\">OpenSSL</a> 1.0.1e-fips 11 Feb 2013<br>debug1: Reading <a href=\"https://so.csdn.net/so/search?q=configuration&spm=1001.2101.3001.7020\">configuration</a> data /etc/ssh/ssh_config<br>debug1: /etc/ssh/ssh_config line 51: Applying options for *<br>debug2: ssh_connect: needpriv 0<br>debug1: Connecting to XXX.XX.X.XXX [XXX.XX.X.XXX] port 22.<br>debug1: Connection established.<br>debug1: permanently_set_uid: 0/0<br>debug3: Incorrect RSA1 identifier<br>debug3: Could not load “/root/.ssh/id_rsa” as a RSA1 public key<br>debug1: identity file /root/.ssh/id_rsa type 1<br>debug1: identity file /root/.ssh/id_rsa-cert type -1<br>debug1: identity file /root/.ssh/id_dsa type -1<br>debug1: identity file /root/.ssh/id_dsa-cert type -1<br>debug1: identity file /root/.ssh/id_ecdsa type -1<br>debug1: identity file /root/.ssh/id_ecdsa-cert type -1<br>debug1: Enabling compatibility mode for protocol 2.0<br>debug1: Local version string SSH-2.0-OpenSSH_6.4<br>debug1: Remote protocol version 2.0, remote software version OpenSSH_6.4<br>debug1: match: OpenSSH_6.4 pat <a href=\"https://so.csdn.net/so/search?q=OpenSSH&spm=1001.2101.3001.7020\">OpenSSH</a>*</p>\n</blockquote>\n<p>想必看到这里，但凡想想，应该就会想，难道是密钥的问题？密钥不对？或者就是权限问题？</p>\n<p>🆗，回想一下我们学习Linux的时候，讲过一个SELinux，不知是否还有印象。那么什么是SELinux呢?</p>\n<blockquote>\n<p><strong><a href=\"https://zh.wikipedia.org/wiki/%E5%AE%89%E5%85%A8%E5%A2%9E%E5%BC%BA%E5%BC%8FLinux\">安全增强式 Linux</a>，即<code>SELinux</code>(Security-Enhanced Linux)是一个</strong> <strong><code>Linux</code></strong> <strong>内核的安全模块，其提供了访问控制安全策略机制，包括了强制访问控制</strong>(Mandatory Access Control，MAC)。</p>\n</blockquote>\n<p><strong>解决办法：</strong></p>\n<figure class=\"highlight crystal\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs crystal\"><span class=\"hljs-comment\"># 查看当前模式。如果为disabled即是关闭状态，我们需要讲安全模式打开</span><br><span class=\"hljs-variable\">$ </span>getenforce<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202308241743908.png\" alt=\"image-20230824174357178\"></p>\n<figure class=\"highlight gradle\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs gradle\"># vi <span class=\"hljs-regexp\">/etc/</span>selinux/config打开selinux配置文件<br>$ vi <span class=\"hljs-regexp\">/etc/</span>selinux/config<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202308241755769.png\" alt=\"image-20230824175528202\"></p>\n</li>\n</ol>\n<p>​    参考链接：<a href=\"https://blog.csdn.net/u012026446/article/details/81318188\">https://blog.csdn.net/u012026446/article/details/81318188</a></p>\n<h2 id=\"项目篇\"><a href=\"#项目篇\" class=\"headerlink\" title=\"项目篇\"></a>项目篇</h2><ul>\n<li><h3 id=\"API项目\"><a href=\"#API项目\" class=\"headerlink\" title=\"API项目\"></a>API项目</h3></li>\n</ul>\n<ol>\n<li>粗心大意导致的错误（前后对比）</li>\n</ol>\n<blockquote>\n<figure class=\"highlight abnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs abnf\">&lt;CreateModal<br>     columns<span class=\"hljs-operator\">=</span>&#123;columns&#125;<br>     onCancel<span class=\"hljs-operator\">=</span>&#123;() <span class=\"hljs-operator\">=</span>&gt; &#123;<br>       // 注意这里<br>       handleUpdateModalOpen(false)<span class=\"hljs-comment\">;</span><br>     &#125;&#125;<br>     onSubmit<span class=\"hljs-operator\">=</span>&#123;(values) <span class=\"hljs-operator\">=</span>&gt; &#123;<br>       handleAdd(values)<span class=\"hljs-comment\">;</span><br>     &#125;&#125;<br>     visible<span class=\"hljs-operator\">=</span>&#123;createModalOpen&#125;<br>/&gt;<br></code></pre></td></tr></table></figure>\n</blockquote>\n<blockquote>\n<figure class=\"highlight abnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs abnf\">&lt;CreateModal<br>  columns<span class=\"hljs-operator\">=</span>&#123;columns&#125;<br>  onCancel<span class=\"hljs-operator\">=</span>&#123;() <span class=\"hljs-operator\">=</span>&gt; &#123;<br>    handleModalOpen(false)<span class=\"hljs-comment\">;</span><br>  &#125;&#125;<br>  onSubmit<span class=\"hljs-operator\">=</span>&#123;(values) <span class=\"hljs-operator\">=</span>&gt; &#123;<br>    handleAdd(values)<span class=\"hljs-comment\">;</span><br>  &#125;&#125;<br>  visible<span class=\"hljs-operator\">=</span>&#123;createModalOpen&#125; <br>/&gt;<br></code></pre></td></tr></table></figure>\n</blockquote>\n<ol start=\"2\">\n<li><p>终于又碰到了一个bugssss！！！头疼得很！–controller类更改运行不生效</p>\n<p>发生在Spring Boot API项目的模拟接口项目：更改controller类后，发现重新运行之后页面没有改变，更改无效，此时需要对maven重新打jar包，更改才会生效，ChatGPT说是因为热部署的问题。</p>\n<p>bug缘由：早在我把模拟接口项目整个粘贴到后端项目中时就已经存在bug了，之前没有发现，尝试把这个项目单独拎出来的话没问题。</p>\n<p><strong>解决方法：</strong></p>\n<ul>\n<li>我先试试是不是maven的module没有配置好（因为是直接把模拟接口项目直接粘贴到后端项目中了）</li>\n<li>后续整合网管业务的时候，遇到了项目包名不一致的问题，然后在包名重命名中出现了n个问题，最后迫不得已将项目重构了，然后在项目中直接创建module是没有问题的，因此证实了上述猜想中的module没有配置好！</li>\n</ul>\n</li>\n<li><p>当Springboot项目中引入了Mabatis，但是没有进行配置，会导致项目运行的时候报错：找不到配置，如图：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/wl2o2o/blogCdn/img/202308032056940.png\" alt=\"image-20230803205650059\"></p>\n<ul>\n<li><strong>解决方法</strong>:在启动类上添加一个排除数据库配置的注解：<blockquote>\n</blockquote>\n</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"工具篇\"><a href=\"#工具篇\" class=\"headerlink\" title=\"工具篇\"></a>工具篇</h2><h3 id=\"pnpm\"><a href=\"#pnpm\" class=\"headerlink\" title=\"pnpm\"></a>pnpm</h3><h3 id=\"HuTool\"><a href=\"#HuTool\" class=\"headerlink\" title=\"HuTool\"></a>HuTool</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">cn.hutool.core.io.IORuntimeException: ConnectException: Connection refused: connect<br><br>\tat cn.hutool.http.HttpRequest.send(HttpRequest.java:1328)<br>\tat cn.hutool.http.HttpRequest.doExecute(HttpRequest.java:1176)<br>\tcn.hutool.http.HttpRequest.send(HttpRequest.java:1323)<br>\t... 73 more<br><br>Disconnected from the target VM, address: &#x27;127.0.0.1:6928&#x27;, transport: &#x27;socket&#x27;<br><br>Process finished with exit code -1<br></code></pre></td></tr></table></figure>\n\n<p><strong>解决方法：</strong></p>\n<p>​    待补充！！！</p>\n<h3 id=\"Nacos\"><a href=\"#Nacos\" class=\"headerlink\" title=\"Nacos\"></a>Nacos</h3><h4 id=\"找不到相关Service服务\"><a href=\"#找不到相关Service服务\" class=\"headerlink\" title=\"找不到相关Service服务\"></a>找不到相关Service服务</h4><ul>\n<li>消费者与提供者项目包名不一致导致找不到service服务</li>\n</ul>\n<blockquote>\n<p>遇到一个<code>nocos</code>小BUG：</p>\n<p>Dubbo整合nocos的时候，提供者与消费者的包名不一样，这时，提供者将接口的信息注册到nacos文档时，用到的是provider的包名路径，如果出现消费者的包名路径与提供者的包名不同的时候，这时消费者就会报错找不到提供者的Service服务，如图：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/wl2o2o/blogCdn/img/202307311932647.png\" alt=\"image-20230731193204173\"></p>\n</blockquote>\n<h4 id=\"端口被占用\"><a href=\"#端口被占用\" class=\"headerlink\" title=\"端口被占用\"></a>端口被占用</h4><blockquote>\n<p>netstat -ano | findstr 8848</p>\n<p>taskkill /pid 1244 /f</p>\n</blockquote>\n<p><img src=\"https://cdn.jsdelivr.net/gh/wl2o2o/blogCdn/img/202308040415943.png\" alt=\"解除端口占用的命令\"></p>\n<ul>\n<li><code>maven</code></li>\n</ul>\n<blockquote>\n<p>问题1：</p>\n</blockquote>\n<p>​    Spring Boot项目涉及到多个模块时，应该怎么办？</p>\n<p>​    方案一：</p>\n<p>​        类似于maven项目的多模块编译</p>\n<p>​    方案二：</p>\n<p>​        将pom文件设置为maven项目</p>\n<p>​        <img src=\"https://cdn.jsdelivr.net/gh/wl2o2o/blogCdn/img/202308010328505.png\" alt=\"将pom文件设置为maven项目\" style=\"zoom:33%;\" /></p>\n<blockquote>\n<p>问题2：</p>\n</blockquote>\n<p>​    自己开发<code>SDK</code>时，pom文件中忘记去掉<code>&lt;build&gt;&lt;/build&gt;</code>标签时，当使用maven执行install命令时，maven会报错：没有可执行的main。</p>\n<p>​    如图：</p>\n<p>​    <img src=\"https://cdn.jsdelivr.net/gh/wl2o2o/blogCdn/img/202308020023072.png\" alt=\"image-20230802002346028\"></p>\n<blockquote>\n<p>问题3：</p>\n</blockquote>\n<p>​    想用maven的多模块编译，父模块用<code>&lt;models&gt;</code>子模块用<code>&lt;parent&gt;</code>，用下面的依赖配置，是没问题的，</p>\n<figure class=\"highlight dust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs dust\"><span class=\"language-xml\"><span class=\"hljs-meta\">&lt;?xml version=<span class=\"hljs-string\">&quot;1.0&quot;</span> encoding=<span class=\"hljs-string\">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">project</span> <span class=\"hljs-attr\">xmlns</span>=<span class=\"hljs-string\">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class=\"hljs-attr\">xmlns:xsi</span>=<span class=\"hljs-string\">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class=\"hljs-tag\"><span class=\"language-xml\">         <span class=\"hljs-attr\">xsi:schemaLocation</span>=<span class=\"hljs-string\">&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class=\"language-xml\">    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">modelVersion</span>&gt;</span>4.0.0<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">modelVersion</span>&gt;</span></span><br><span class=\"language-xml\"></span><br><span class=\"language-xml\">    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">parent</span>&gt;</span></span><br><span class=\"language-xml\">        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span></span><br><span class=\"language-xml\">        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>spring-boot-starter-parent<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span></span><br><span class=\"language-xml\">        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>2.7.7<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span></span><br><span class=\"language-xml\">        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">relativePath</span>/&gt;</span> <span class=\"hljs-comment\">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class=\"language-xml\">    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">parent</span>&gt;</span></span><br><span class=\"language-xml\"></span><br><span class=\"language-xml\">    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>com.csguider<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span></span><br><span class=\"language-xml\">    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>smartapi-gateway<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span></span><br><span class=\"language-xml\">    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>0.0.1-SNAPSHOT<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span></span><br><span class=\"language-xml\"></span><br><span class=\"language-xml\">    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">name</span>&gt;</span>smartapi-gateway<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">name</span>&gt;</span></span><br><span class=\"language-xml\">    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">description</span>&gt;</span>Demo project for Spring Boot<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">description</span>&gt;</span></span><br><span class=\"language-xml\"></span><br><span class=\"language-xml\">    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">properties</span>&gt;</span></span><br><span class=\"language-xml\">        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">java.version</span>&gt;</span>1.8<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">java.version</span>&gt;</span></span><br><span class=\"language-xml\">        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">spring-cloud.version</span>&gt;</span>2021.0.5<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">spring-cloud.version</span>&gt;</span></span><br><span class=\"language-xml\">    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">properties</span>&gt;</span></span><br><span class=\"language-xml\"></span><br><span class=\"language-xml\">    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependencies</span>&gt;</span></span><br><span class=\"language-xml\">        <span class=\"hljs-comment\">&lt;!-- https://mvnrepository.com/artifact/org.apache.dubbo/dubbo --&gt;</span></span><br><span class=\"language-xml\">        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span></span><br><span class=\"language-xml\">            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.apache.dubbo<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span></span><br><span class=\"language-xml\">            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>dubbo<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span></span><br><span class=\"language-xml\">            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>3.0.9<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span></span><br><span class=\"language-xml\">        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span></span><br><span class=\"language-xml\">        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span></span><br><span class=\"language-xml\">            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>com.alibaba.nacos<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span></span><br><span class=\"language-xml\">            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>nacos-client<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span></span><br><span class=\"language-xml\">            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>2.1.0<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span></span><br><span class=\"language-xml\">        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span></span><br><span class=\"language-xml\"></span><br><span class=\"language-xml\">        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span></span><br><span class=\"language-xml\">            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.springframework.cloud<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span></span><br><span class=\"language-xml\">            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>spring-cloud-starter-gateway<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span></span><br><span class=\"language-xml\">        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span></span><br><span class=\"language-xml\"></span><br><span class=\"language-xml\">        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span></span><br><span class=\"language-xml\">            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span></span><br><span class=\"language-xml\">            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>spring-boot-devtools<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span></span><br><span class=\"language-xml\">            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">scope</span>&gt;</span>runtime<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">scope</span>&gt;</span></span><br><span class=\"language-xml\">            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">optional</span>&gt;</span>true<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">optional</span>&gt;</span></span><br><span class=\"language-xml\">        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span></span><br><span class=\"language-xml\"></span><br><span class=\"language-xml\">        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span></span><br><span class=\"language-xml\">            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.projectlombok<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span></span><br><span class=\"language-xml\">            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>lombok<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span></span><br><span class=\"language-xml\">            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">optional</span>&gt;</span>true<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">optional</span>&gt;</span></span><br><span class=\"language-xml\">        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span></span><br><span class=\"language-xml\"></span><br><span class=\"language-xml\">        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span></span><br><span class=\"language-xml\">            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span></span><br><span class=\"language-xml\">            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>spring-boot-starter-test<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span></span><br><span class=\"language-xml\">            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">scope</span>&gt;</span>test<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">scope</span>&gt;</span></span><br><span class=\"language-xml\">        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span></span><br><span class=\"language-xml\">        <span class=\"hljs-comment\">&lt;!--这个依赖引入先打个注释，是通过快捷键自动引入的。&lt;scope&gt;这个标签先打个标签,表示作用域--&gt;</span></span><br><span class=\"language-xml\">        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span></span><br><span class=\"language-xml\">            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>com.csguider<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span></span><br><span class=\"language-xml\">            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>smartapi-client-sdk<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span></span><br><span class=\"language-xml\">            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>0.0.1-SNAPSHOT<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span></span><br><span class=\"language-xml\">        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span></span><br><span class=\"language-xml\">    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependencies</span>&gt;</span></span><br><span class=\"language-xml\">    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependencyManagement</span>&gt;</span></span><br><span class=\"language-xml\">        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependencies</span>&gt;</span></span><br><span class=\"language-xml\">            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span></span><br><span class=\"language-xml\">                <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.springframework.cloud<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span></span><br><span class=\"language-xml\">                <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>spring-cloud-dependencies<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span></span><br><span class=\"language-xml\">                <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>$</span><span class=\"hljs-template-variable\">&#123;spring-cloud.version&#125;</span><span class=\"language-xml\"><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span></span><br><span class=\"language-xml\">                <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">type</span>&gt;</span>pom<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">type</span>&gt;</span></span><br><span class=\"language-xml\">                <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">scope</span>&gt;</span>import<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">scope</span>&gt;</span></span><br><span class=\"language-xml\">            <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span></span><br><span class=\"language-xml\">        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependencies</span>&gt;</span></span><br><span class=\"language-xml\">    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependencyManagement</span>&gt;</span></span><br><span class=\"language-xml\"></span><br><span class=\"language-xml\">    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">build</span>&gt;</span></span><br><span class=\"language-xml\">        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">plugins</span>&gt;</span></span><br><span class=\"language-xml\">            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">plugin</span>&gt;</span></span><br><span class=\"language-xml\">                <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span></span><br><span class=\"language-xml\">                <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span></span><br><span class=\"language-xml\">                <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">configuration</span>&gt;</span></span><br><span class=\"language-xml\">                    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">excludes</span>&gt;</span></span><br><span class=\"language-xml\">                        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">exclude</span>&gt;</span></span><br><span class=\"language-xml\">                            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.projectlombok<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span></span><br><span class=\"language-xml\">                            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>lombok<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span></span><br><span class=\"language-xml\">                        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">exclude</span>&gt;</span></span><br><span class=\"language-xml\">                    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">excludes</span>&gt;</span></span><br><span class=\"language-xml\">                <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">configuration</span>&gt;</span></span><br><span class=\"language-xml\">            <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">plugin</span>&gt;</span></span><br><span class=\"language-xml\">        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">plugins</span>&gt;</span></span><br><span class=\"language-xml\">    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">build</span>&gt;</span></span><br><span class=\"language-xml\"></span><br><span class=\"language-xml\"><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">project</span>&gt;</span></span><br></code></pre></td></tr></table></figure>\n\n<p>当我把parent换成父类时，会报错：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/wl2o2o/blogCdn/img/202308020207946.png\"></p>\n<ul>\n<li>解决方法：</li>\n</ul>\n<blockquote>\n<ul>\n<li>set spring.main.web-application-type=reactive</li>\n</ul>\n<p><code>spring.main.web-application-type=reactive</code> 是针对 Spring Boot 2.x版本引入的一个配置属性，用于指定应用程序的类型。它有两个可能的值：<code>servlet</code>（默认值）和<code>reactive</code>。</p>\n<p>当将 <code>spring.main.web-application-type</code> 设置为 <code>reactive</code> 时，您的应用程序将使用反应式编程模型。这意味着您的应用程序将使用 WebFlux 框架，而不是传统的 Servlet 框架。</p>\n<p>使用反应式编程模型可以提供更好的性能和可扩展性，因为它使用了非阻塞的 I/O 和事件驱动的编程模型。这种模型特别适用于高并发和异步处理场景。</p>\n<p>要使用反应式编程模型，您需要相应地更新您的应用程序代码，以便使用 WebFlux 相关的的基础设施和 API。例如，您需要使用 <code>@Controller</code> 替换 <code>@ControllerAdvice</code>，并使用 <code>ServerWebExchange</code> 对象访问 HTTP 请求和响应。</p>\n<p>总之，将 <code>spring.main.web-application-type</code> 设置为 <code>reactive</code> 将使您的应用程序使用 WebFlux 框架，以获得更好的性能和可扩展性。但请注意，您需要对应用程序代码进行相应的更改，以适应反应式编程模型。</p>\n<p>要设置 <code>spring.main.web-application-type</code> 为 <code>reactive</code>，您需要在应用的配置文件 <code>application.yml</code> 或 <code>application.properties</code> 中添加以下配置1：</p>\n<figure class=\"highlight nestedtext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs nestedtext\"><span class=\"hljs-attribute\">spring</span><span class=\"hljs-punctuation\">:</span><br>\t<span class=\"hljs-attribute\">main</span><span class=\"hljs-punctuation\">:</span><br>    \t<span class=\"hljs-attribute\">web-application-type</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">reactive</span><br></code></pre></td></tr></table></figure>\n\n<p>这样，您告诉 Spring Boot 应用程序使用响应式的 Web 应用类型。同时，请注意，您需要相应地更新您的应用程序代码，以使用 WebFlux 相关的基础设施和 API，例如使用 <code>@Controller</code> 替换 <code>@ControllerAdvice</code>，并使用 <code>ServerWebExchange</code> 对象访问 HTTP 请求和响应1。</p>\n</blockquote>\n","site":{"data":{}},"more":"<h2 id=\"Git篇\"><a href=\"#Git篇\" class=\"headerlink\" title=\"Git篇\"></a>Git篇</h2><ol>\n<li><code>git pull gitee</code>出现问题</li>\n</ol>\n<blockquote>\n<p>You asked to pull from the remote ‘gitee’, but did not specify<br>a branch. Because this is not the default configured remote<br>for your current branch, you must specify a branch on the command line.</p>\n</blockquote>\n<p><strong>解决办法：</strong></p>\n<p>首先，主要是命令使用不规范导致，应该是<code>gitee pull gitee(远程仓库别名) + master（分支名） </code></p>\n<p>其次，针对以上错误，也可以编辑工作目录下的<code>.git/config文件</code>文件内容，增加如下代码：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs xml\">[branch &quot;master&quot;]<br>  remote = origin<br>  merge = refs/heads/master<br></code></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>Failed to connect to github.com port 443 after xxxxx ms: Timed out</li>\n</ol>\n<blockquote>\n<p>网络错误问题，使用全局代理有时并不能解决</p>\n<p><strong>解决办法：</strong>配置远程仓库地址时，使用SSH以代替Https连接，亲测有效。</p>\n<p>参考文献：<a href=\"https://blog.csdn.net/wzk4869/article/details/131626483\">【Git】Github 上传文件到远程仓库时，经常发生网络错误，一个比较稳定的连接方法及我的示例</a></p>\n</blockquote>\n<ol start=\"3\">\n<li>github图床上传的图片显示失败</li>\n</ol>\n<p><strong>解决办法：</strong></p>\n<p><code>TODO:</code></p>\n<ol start=\"4\">\n<li><p>ssh免密设置后，仍提示输入密码，报错如下：</p>\n<blockquote>\n<p>[root@localhost ~]# ssh -vvv XXX.XX.X.XXX<br>OpenSSH_6.4, <a href=\"https://so.csdn.net/so/search?q=OpenSSL&spm=1001.2101.3001.7020\">OpenSSL</a> 1.0.1e-fips 11 Feb 2013<br>debug1: Reading <a href=\"https://so.csdn.net/so/search?q=configuration&spm=1001.2101.3001.7020\">configuration</a> data /etc/ssh/ssh_config<br>debug1: /etc/ssh/ssh_config line 51: Applying options for *<br>debug2: ssh_connect: needpriv 0<br>debug1: Connecting to XXX.XX.X.XXX [XXX.XX.X.XXX] port 22.<br>debug1: Connection established.<br>debug1: permanently_set_uid: 0/0<br>debug3: Incorrect RSA1 identifier<br>debug3: Could not load “/root/.ssh/id_rsa” as a RSA1 public key<br>debug1: identity file /root/.ssh/id_rsa type 1<br>debug1: identity file /root/.ssh/id_rsa-cert type -1<br>debug1: identity file /root/.ssh/id_dsa type -1<br>debug1: identity file /root/.ssh/id_dsa-cert type -1<br>debug1: identity file /root/.ssh/id_ecdsa type -1<br>debug1: identity file /root/.ssh/id_ecdsa-cert type -1<br>debug1: Enabling compatibility mode for protocol 2.0<br>debug1: Local version string SSH-2.0-OpenSSH_6.4<br>debug1: Remote protocol version 2.0, remote software version OpenSSH_6.4<br>debug1: match: OpenSSH_6.4 pat <a href=\"https://so.csdn.net/so/search?q=OpenSSH&spm=1001.2101.3001.7020\">OpenSSH</a>*</p>\n</blockquote>\n<p>想必看到这里，但凡想想，应该就会想，难道是密钥的问题？密钥不对？或者就是权限问题？</p>\n<p>🆗，回想一下我们学习Linux的时候，讲过一个SELinux，不知是否还有印象。那么什么是SELinux呢?</p>\n<blockquote>\n<p><strong><a href=\"https://zh.wikipedia.org/wiki/%E5%AE%89%E5%85%A8%E5%A2%9E%E5%BC%BA%E5%BC%8FLinux\">安全增强式 Linux</a>，即<code>SELinux</code>(Security-Enhanced Linux)是一个</strong> <strong><code>Linux</code></strong> <strong>内核的安全模块，其提供了访问控制安全策略机制，包括了强制访问控制</strong>(Mandatory Access Control，MAC)。</p>\n</blockquote>\n<p><strong>解决办法：</strong></p>\n<figure class=\"highlight crystal\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs crystal\"><span class=\"hljs-comment\"># 查看当前模式。如果为disabled即是关闭状态，我们需要讲安全模式打开</span><br><span class=\"hljs-variable\">$ </span>getenforce<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202308241743908.png\" alt=\"image-20230824174357178\"></p>\n<figure class=\"highlight gradle\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs gradle\"># vi <span class=\"hljs-regexp\">/etc/</span>selinux/config打开selinux配置文件<br>$ vi <span class=\"hljs-regexp\">/etc/</span>selinux/config<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202308241755769.png\" alt=\"image-20230824175528202\"></p>\n</li>\n</ol>\n<p>​    参考链接：<a href=\"https://blog.csdn.net/u012026446/article/details/81318188\">https://blog.csdn.net/u012026446/article/details/81318188</a></p>\n<h2 id=\"项目篇\"><a href=\"#项目篇\" class=\"headerlink\" title=\"项目篇\"></a>项目篇</h2><ul>\n<li><h3 id=\"API项目\"><a href=\"#API项目\" class=\"headerlink\" title=\"API项目\"></a>API项目</h3></li>\n</ul>\n<ol>\n<li>粗心大意导致的错误（前后对比）</li>\n</ol>\n<blockquote>\n<figure class=\"highlight abnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs abnf\">&lt;CreateModal<br>     columns<span class=\"hljs-operator\">=</span>&#123;columns&#125;<br>     onCancel<span class=\"hljs-operator\">=</span>&#123;() <span class=\"hljs-operator\">=</span>&gt; &#123;<br>       // 注意这里<br>       handleUpdateModalOpen(false)<span class=\"hljs-comment\">;</span><br>     &#125;&#125;<br>     onSubmit<span class=\"hljs-operator\">=</span>&#123;(values) <span class=\"hljs-operator\">=</span>&gt; &#123;<br>       handleAdd(values)<span class=\"hljs-comment\">;</span><br>     &#125;&#125;<br>     visible<span class=\"hljs-operator\">=</span>&#123;createModalOpen&#125;<br>/&gt;<br></code></pre></td></tr></table></figure>\n</blockquote>\n<blockquote>\n<figure class=\"highlight abnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs abnf\">&lt;CreateModal<br>  columns<span class=\"hljs-operator\">=</span>&#123;columns&#125;<br>  onCancel<span class=\"hljs-operator\">=</span>&#123;() <span class=\"hljs-operator\">=</span>&gt; &#123;<br>    handleModalOpen(false)<span class=\"hljs-comment\">;</span><br>  &#125;&#125;<br>  onSubmit<span class=\"hljs-operator\">=</span>&#123;(values) <span class=\"hljs-operator\">=</span>&gt; &#123;<br>    handleAdd(values)<span class=\"hljs-comment\">;</span><br>  &#125;&#125;<br>  visible<span class=\"hljs-operator\">=</span>&#123;createModalOpen&#125; <br>/&gt;<br></code></pre></td></tr></table></figure>\n</blockquote>\n<ol start=\"2\">\n<li><p>终于又碰到了一个bugssss！！！头疼得很！–controller类更改运行不生效</p>\n<p>发生在Spring Boot API项目的模拟接口项目：更改controller类后，发现重新运行之后页面没有改变，更改无效，此时需要对maven重新打jar包，更改才会生效，ChatGPT说是因为热部署的问题。</p>\n<p>bug缘由：早在我把模拟接口项目整个粘贴到后端项目中时就已经存在bug了，之前没有发现，尝试把这个项目单独拎出来的话没问题。</p>\n<p><strong>解决方法：</strong></p>\n<ul>\n<li>我先试试是不是maven的module没有配置好（因为是直接把模拟接口项目直接粘贴到后端项目中了）</li>\n<li>后续整合网管业务的时候，遇到了项目包名不一致的问题，然后在包名重命名中出现了n个问题，最后迫不得已将项目重构了，然后在项目中直接创建module是没有问题的，因此证实了上述猜想中的module没有配置好！</li>\n</ul>\n</li>\n<li><p>当Springboot项目中引入了Mabatis，但是没有进行配置，会导致项目运行的时候报错：找不到配置，如图：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/wl2o2o/blogCdn/img/202308032056940.png\" alt=\"image-20230803205650059\"></p>\n<ul>\n<li><strong>解决方法</strong>:在启动类上添加一个排除数据库配置的注解：<blockquote>\n</blockquote>\n</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"工具篇\"><a href=\"#工具篇\" class=\"headerlink\" title=\"工具篇\"></a>工具篇</h2><h3 id=\"pnpm\"><a href=\"#pnpm\" class=\"headerlink\" title=\"pnpm\"></a>pnpm</h3><h3 id=\"HuTool\"><a href=\"#HuTool\" class=\"headerlink\" title=\"HuTool\"></a>HuTool</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">cn.hutool.core.io.IORuntimeException: ConnectException: Connection refused: connect<br><br>\tat cn.hutool.http.HttpRequest.send(HttpRequest.java:1328)<br>\tat cn.hutool.http.HttpRequest.doExecute(HttpRequest.java:1176)<br>\tcn.hutool.http.HttpRequest.send(HttpRequest.java:1323)<br>\t... 73 more<br><br>Disconnected from the target VM, address: &#x27;127.0.0.1:6928&#x27;, transport: &#x27;socket&#x27;<br><br>Process finished with exit code -1<br></code></pre></td></tr></table></figure>\n\n<p><strong>解决方法：</strong></p>\n<p>​    待补充！！！</p>\n<h3 id=\"Nacos\"><a href=\"#Nacos\" class=\"headerlink\" title=\"Nacos\"></a>Nacos</h3><h4 id=\"找不到相关Service服务\"><a href=\"#找不到相关Service服务\" class=\"headerlink\" title=\"找不到相关Service服务\"></a>找不到相关Service服务</h4><ul>\n<li>消费者与提供者项目包名不一致导致找不到service服务</li>\n</ul>\n<blockquote>\n<p>遇到一个<code>nocos</code>小BUG：</p>\n<p>Dubbo整合nocos的时候，提供者与消费者的包名不一样，这时，提供者将接口的信息注册到nacos文档时，用到的是provider的包名路径，如果出现消费者的包名路径与提供者的包名不同的时候，这时消费者就会报错找不到提供者的Service服务，如图：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/wl2o2o/blogCdn/img/202307311932647.png\" alt=\"image-20230731193204173\"></p>\n</blockquote>\n<h4 id=\"端口被占用\"><a href=\"#端口被占用\" class=\"headerlink\" title=\"端口被占用\"></a>端口被占用</h4><blockquote>\n<p>netstat -ano | findstr 8848</p>\n<p>taskkill /pid 1244 /f</p>\n</blockquote>\n<p><img src=\"https://cdn.jsdelivr.net/gh/wl2o2o/blogCdn/img/202308040415943.png\" alt=\"解除端口占用的命令\"></p>\n<ul>\n<li><code>maven</code></li>\n</ul>\n<blockquote>\n<p>问题1：</p>\n</blockquote>\n<p>​    Spring Boot项目涉及到多个模块时，应该怎么办？</p>\n<p>​    方案一：</p>\n<p>​        类似于maven项目的多模块编译</p>\n<p>​    方案二：</p>\n<p>​        将pom文件设置为maven项目</p>\n<p>​        <img src=\"https://cdn.jsdelivr.net/gh/wl2o2o/blogCdn/img/202308010328505.png\" alt=\"将pom文件设置为maven项目\" style=\"zoom:33%;\" /></p>\n<blockquote>\n<p>问题2：</p>\n</blockquote>\n<p>​    自己开发<code>SDK</code>时，pom文件中忘记去掉<code>&lt;build&gt;&lt;/build&gt;</code>标签时，当使用maven执行install命令时，maven会报错：没有可执行的main。</p>\n<p>​    如图：</p>\n<p>​    <img src=\"https://cdn.jsdelivr.net/gh/wl2o2o/blogCdn/img/202308020023072.png\" alt=\"image-20230802002346028\"></p>\n<blockquote>\n<p>问题3：</p>\n</blockquote>\n<p>​    想用maven的多模块编译，父模块用<code>&lt;models&gt;</code>子模块用<code>&lt;parent&gt;</code>，用下面的依赖配置，是没问题的，</p>\n<figure class=\"highlight dust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs dust\"><span class=\"language-xml\"><span class=\"hljs-meta\">&lt;?xml version=<span class=\"hljs-string\">&quot;1.0&quot;</span> encoding=<span class=\"hljs-string\">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">project</span> <span class=\"hljs-attr\">xmlns</span>=<span class=\"hljs-string\">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class=\"hljs-attr\">xmlns:xsi</span>=<span class=\"hljs-string\">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class=\"hljs-tag\"><span class=\"language-xml\">         <span class=\"hljs-attr\">xsi:schemaLocation</span>=<span class=\"hljs-string\">&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class=\"language-xml\">    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">modelVersion</span>&gt;</span>4.0.0<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">modelVersion</span>&gt;</span></span><br><span class=\"language-xml\"></span><br><span class=\"language-xml\">    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">parent</span>&gt;</span></span><br><span class=\"language-xml\">        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span></span><br><span class=\"language-xml\">        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>spring-boot-starter-parent<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span></span><br><span class=\"language-xml\">        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>2.7.7<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span></span><br><span class=\"language-xml\">        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">relativePath</span>/&gt;</span> <span class=\"hljs-comment\">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class=\"language-xml\">    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">parent</span>&gt;</span></span><br><span class=\"language-xml\"></span><br><span class=\"language-xml\">    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>com.csguider<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span></span><br><span class=\"language-xml\">    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>smartapi-gateway<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span></span><br><span class=\"language-xml\">    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>0.0.1-SNAPSHOT<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span></span><br><span class=\"language-xml\"></span><br><span class=\"language-xml\">    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">name</span>&gt;</span>smartapi-gateway<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">name</span>&gt;</span></span><br><span class=\"language-xml\">    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">description</span>&gt;</span>Demo project for Spring Boot<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">description</span>&gt;</span></span><br><span class=\"language-xml\"></span><br><span class=\"language-xml\">    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">properties</span>&gt;</span></span><br><span class=\"language-xml\">        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">java.version</span>&gt;</span>1.8<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">java.version</span>&gt;</span></span><br><span class=\"language-xml\">        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">spring-cloud.version</span>&gt;</span>2021.0.5<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">spring-cloud.version</span>&gt;</span></span><br><span class=\"language-xml\">    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">properties</span>&gt;</span></span><br><span class=\"language-xml\"></span><br><span class=\"language-xml\">    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependencies</span>&gt;</span></span><br><span class=\"language-xml\">        <span class=\"hljs-comment\">&lt;!-- https://mvnrepository.com/artifact/org.apache.dubbo/dubbo --&gt;</span></span><br><span class=\"language-xml\">        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span></span><br><span class=\"language-xml\">            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.apache.dubbo<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span></span><br><span class=\"language-xml\">            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>dubbo<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span></span><br><span class=\"language-xml\">            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>3.0.9<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span></span><br><span class=\"language-xml\">        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span></span><br><span class=\"language-xml\">        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span></span><br><span class=\"language-xml\">            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>com.alibaba.nacos<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span></span><br><span class=\"language-xml\">            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>nacos-client<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span></span><br><span class=\"language-xml\">            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>2.1.0<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span></span><br><span class=\"language-xml\">        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span></span><br><span class=\"language-xml\"></span><br><span class=\"language-xml\">        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span></span><br><span class=\"language-xml\">            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.springframework.cloud<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span></span><br><span class=\"language-xml\">            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>spring-cloud-starter-gateway<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span></span><br><span class=\"language-xml\">        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span></span><br><span class=\"language-xml\"></span><br><span class=\"language-xml\">        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span></span><br><span class=\"language-xml\">            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span></span><br><span class=\"language-xml\">            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>spring-boot-devtools<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span></span><br><span class=\"language-xml\">            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">scope</span>&gt;</span>runtime<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">scope</span>&gt;</span></span><br><span class=\"language-xml\">            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">optional</span>&gt;</span>true<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">optional</span>&gt;</span></span><br><span class=\"language-xml\">        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span></span><br><span class=\"language-xml\"></span><br><span class=\"language-xml\">        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span></span><br><span class=\"language-xml\">            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.projectlombok<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span></span><br><span class=\"language-xml\">            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>lombok<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span></span><br><span class=\"language-xml\">            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">optional</span>&gt;</span>true<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">optional</span>&gt;</span></span><br><span class=\"language-xml\">        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span></span><br><span class=\"language-xml\"></span><br><span class=\"language-xml\">        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span></span><br><span class=\"language-xml\">            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span></span><br><span class=\"language-xml\">            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>spring-boot-starter-test<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span></span><br><span class=\"language-xml\">            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">scope</span>&gt;</span>test<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">scope</span>&gt;</span></span><br><span class=\"language-xml\">        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span></span><br><span class=\"language-xml\">        <span class=\"hljs-comment\">&lt;!--这个依赖引入先打个注释，是通过快捷键自动引入的。&lt;scope&gt;这个标签先打个标签,表示作用域--&gt;</span></span><br><span class=\"language-xml\">        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span></span><br><span class=\"language-xml\">            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>com.csguider<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span></span><br><span class=\"language-xml\">            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>smartapi-client-sdk<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span></span><br><span class=\"language-xml\">            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>0.0.1-SNAPSHOT<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span></span><br><span class=\"language-xml\">        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span></span><br><span class=\"language-xml\">    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependencies</span>&gt;</span></span><br><span class=\"language-xml\">    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependencyManagement</span>&gt;</span></span><br><span class=\"language-xml\">        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependencies</span>&gt;</span></span><br><span class=\"language-xml\">            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span></span><br><span class=\"language-xml\">                <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.springframework.cloud<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span></span><br><span class=\"language-xml\">                <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>spring-cloud-dependencies<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span></span><br><span class=\"language-xml\">                <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>$</span><span class=\"hljs-template-variable\">&#123;spring-cloud.version&#125;</span><span class=\"language-xml\"><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span></span><br><span class=\"language-xml\">                <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">type</span>&gt;</span>pom<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">type</span>&gt;</span></span><br><span class=\"language-xml\">                <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">scope</span>&gt;</span>import<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">scope</span>&gt;</span></span><br><span class=\"language-xml\">            <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span></span><br><span class=\"language-xml\">        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependencies</span>&gt;</span></span><br><span class=\"language-xml\">    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependencyManagement</span>&gt;</span></span><br><span class=\"language-xml\"></span><br><span class=\"language-xml\">    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">build</span>&gt;</span></span><br><span class=\"language-xml\">        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">plugins</span>&gt;</span></span><br><span class=\"language-xml\">            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">plugin</span>&gt;</span></span><br><span class=\"language-xml\">                <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span></span><br><span class=\"language-xml\">                <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span></span><br><span class=\"language-xml\">                <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">configuration</span>&gt;</span></span><br><span class=\"language-xml\">                    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">excludes</span>&gt;</span></span><br><span class=\"language-xml\">                        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">exclude</span>&gt;</span></span><br><span class=\"language-xml\">                            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.projectlombok<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span></span><br><span class=\"language-xml\">                            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>lombok<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span></span><br><span class=\"language-xml\">                        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">exclude</span>&gt;</span></span><br><span class=\"language-xml\">                    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">excludes</span>&gt;</span></span><br><span class=\"language-xml\">                <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">configuration</span>&gt;</span></span><br><span class=\"language-xml\">            <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">plugin</span>&gt;</span></span><br><span class=\"language-xml\">        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">plugins</span>&gt;</span></span><br><span class=\"language-xml\">    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">build</span>&gt;</span></span><br><span class=\"language-xml\"></span><br><span class=\"language-xml\"><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">project</span>&gt;</span></span><br></code></pre></td></tr></table></figure>\n\n<p>当我把parent换成父类时，会报错：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/wl2o2o/blogCdn/img/202308020207946.png\"></p>\n<ul>\n<li>解决方法：</li>\n</ul>\n<blockquote>\n<ul>\n<li>set spring.main.web-application-type=reactive</li>\n</ul>\n<p><code>spring.main.web-application-type=reactive</code> 是针对 Spring Boot 2.x版本引入的一个配置属性，用于指定应用程序的类型。它有两个可能的值：<code>servlet</code>（默认值）和<code>reactive</code>。</p>\n<p>当将 <code>spring.main.web-application-type</code> 设置为 <code>reactive</code> 时，您的应用程序将使用反应式编程模型。这意味着您的应用程序将使用 WebFlux 框架，而不是传统的 Servlet 框架。</p>\n<p>使用反应式编程模型可以提供更好的性能和可扩展性，因为它使用了非阻塞的 I/O 和事件驱动的编程模型。这种模型特别适用于高并发和异步处理场景。</p>\n<p>要使用反应式编程模型，您需要相应地更新您的应用程序代码，以便使用 WebFlux 相关的的基础设施和 API。例如，您需要使用 <code>@Controller</code> 替换 <code>@ControllerAdvice</code>，并使用 <code>ServerWebExchange</code> 对象访问 HTTP 请求和响应。</p>\n<p>总之，将 <code>spring.main.web-application-type</code> 设置为 <code>reactive</code> 将使您的应用程序使用 WebFlux 框架，以获得更好的性能和可扩展性。但请注意，您需要对应用程序代码进行相应的更改，以适应反应式编程模型。</p>\n<p>要设置 <code>spring.main.web-application-type</code> 为 <code>reactive</code>，您需要在应用的配置文件 <code>application.yml</code> 或 <code>application.properties</code> 中添加以下配置1：</p>\n<figure class=\"highlight nestedtext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs nestedtext\"><span class=\"hljs-attribute\">spring</span><span class=\"hljs-punctuation\">:</span><br>\t<span class=\"hljs-attribute\">main</span><span class=\"hljs-punctuation\">:</span><br>    \t<span class=\"hljs-attribute\">web-application-type</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">reactive</span><br></code></pre></td></tr></table></figure>\n\n<p>这样，您告诉 Spring Boot 应用程序使用响应式的 Web 应用类型。同时，请注意，您需要相应地更新您的应用程序代码，以使用 WebFlux 相关的基础设施和 API，例如使用 <code>@Controller</code> 替换 <code>@ControllerAdvice</code>，并使用 <code>ServerWebExchange</code> 对象访问 HTTP 请求和响应1。</p>\n</blockquote>\n"},{"title":"校园失物招领系统","index_img":"https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311151627644.png","excerpt":"基于SSM框架设计的校园失物招领聊天交流系统","abbrlink":12489,"date":"2023-03-12T07:31:03.000Z","_content":"# 我的JSP课程设计大作业\n\n1. **项目简介**\n\n   * 项目名称：基于`SSM`框架设计的校园失物招领聊天交流系统\n\n   - 项目目的：构建一个在线失物招领的平台\n   - 技术栈：使用`SSM`框架，`jsp`、`js`、`jquery`、`ajax`等前端技术，采用`MySQL`数据库\n   - 功能模块：登陆注册验证码后台验证、发布失物、失物与用户评论回复实体相互关联、聊天室对于用户的权限管理、发送图片和表情等功能、打印后台管理信息excel表格\n\n2. **系统架构**\n\n   - 前端技术：`jsp`、`js`、`jquery`、`ajax`等\n   - 后端：`SSM框架`、`websocket`等。\n   - 数据库：使用`MySQL`作为项目的数据存储。\n   - 其他技术：`前后端分页ajax`、`websocketsession`等。\n\n3. **功能模块介绍**\n\n   - 登陆注册验证码后台验证：用户可以通过注册和登录功能进行操作，在注册和登录时需要通过验证码进行验证，保证系统安全。\n   - 发布失物：用户可以发布失物信息，包括失物名称、描述、图片等信息。\n   - 失物与用户评论回复实体相互关联：用户可以对失物信息进行评论和回复，实现了失物与用户评论回复实体相互关联。\n   - 聊天室对于用户的权限管理：聊天室对于用户的权限管理包括设置管理员、禁言和踢出群聊等功能，保证聊天室的秩序和安全。\n   - 发送图片、表情等功能：用户可以在聊天室中发送图片、表情等内容，丰富了聊天室的交互方式。\n   - 打印后台管理信息excel表格：管理员可以通过打印后台管理信息excel表格功能，方便地查看后台管理信息。\n\n4. **数据库设计**\n\n   项目的数据库设计，包括数据表的设计和数据表之间的关系。本项目主要包含以下数据表：\n\n   - 用户表（user）：包含用户ID、用户名、密码、QQ号码、电子邮件地址、角色和开始时间字段。\n   - 留言表（thanks_letter）：包含留言ID、发布时间、留言标题、留言内容和用户ID字段。该表与用户表通过外键uid关联。\n   - 回复表（reply）：包含回复ID、发布时间、回复内容、评论ID、被回复用户ID和回复用户ID字段。该表与用户表和评论表通过外键关联。\n   - 求助信息表（help_info）：包含求助信息ID、发布时间、求助信息标题、求助信息内容和用户ID字段。该表与用户表通过外键uid关联。\n   - 物品表（goods）：包含物品ID、信息类型、物品标题、发布时间、物品名称、物品类型、发生地点、发生时间、图片URL、状态、用户ID和管理员ID字段。该表与用户表通过外键uid关联。\n   - 评论表（comment）：包含评论ID、发布时间、评论内容、物品ID和用户ID字段。该表与用户表和物品表通过外键关联。\n   - 领取归还表（answer_user）：包含领取归还ID、用户名、QQ号码、电子邮件地址和物品ID字段。该表与物品表通过外键goods_id关联。\n\n5. **项目演示**\n\n   运行演示。\n\n6. **总结与展望**\n\n   项目总结、分析项目的优点和不足之处、提出项目的改进方向和未来发展计划。\n\n源码地址：https://gitee.com/WLei224/jsp.git","source":"_posts/CampousLostAndFound.md","raw":"---\ntitle: 校园失物招领系统\nindex_img: https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311151627644.png\nexcerpt: 基于SSM框架设计的校园失物招领聊天交流系统\ncategories:\n  - Project\ntags:\n  - Spring Boot\n  - JSP\n  - SSM\n  - MySQL\n  - jquery\n  - ajax\nabbrlink: 12489\ndate: 2023-03-12 15:31:03\n---\n# 我的JSP课程设计大作业\n\n1. **项目简介**\n\n   * 项目名称：基于`SSM`框架设计的校园失物招领聊天交流系统\n\n   - 项目目的：构建一个在线失物招领的平台\n   - 技术栈：使用`SSM`框架，`jsp`、`js`、`jquery`、`ajax`等前端技术，采用`MySQL`数据库\n   - 功能模块：登陆注册验证码后台验证、发布失物、失物与用户评论回复实体相互关联、聊天室对于用户的权限管理、发送图片和表情等功能、打印后台管理信息excel表格\n\n2. **系统架构**\n\n   - 前端技术：`jsp`、`js`、`jquery`、`ajax`等\n   - 后端：`SSM框架`、`websocket`等。\n   - 数据库：使用`MySQL`作为项目的数据存储。\n   - 其他技术：`前后端分页ajax`、`websocketsession`等。\n\n3. **功能模块介绍**\n\n   - 登陆注册验证码后台验证：用户可以通过注册和登录功能进行操作，在注册和登录时需要通过验证码进行验证，保证系统安全。\n   - 发布失物：用户可以发布失物信息，包括失物名称、描述、图片等信息。\n   - 失物与用户评论回复实体相互关联：用户可以对失物信息进行评论和回复，实现了失物与用户评论回复实体相互关联。\n   - 聊天室对于用户的权限管理：聊天室对于用户的权限管理包括设置管理员、禁言和踢出群聊等功能，保证聊天室的秩序和安全。\n   - 发送图片、表情等功能：用户可以在聊天室中发送图片、表情等内容，丰富了聊天室的交互方式。\n   - 打印后台管理信息excel表格：管理员可以通过打印后台管理信息excel表格功能，方便地查看后台管理信息。\n\n4. **数据库设计**\n\n   项目的数据库设计，包括数据表的设计和数据表之间的关系。本项目主要包含以下数据表：\n\n   - 用户表（user）：包含用户ID、用户名、密码、QQ号码、电子邮件地址、角色和开始时间字段。\n   - 留言表（thanks_letter）：包含留言ID、发布时间、留言标题、留言内容和用户ID字段。该表与用户表通过外键uid关联。\n   - 回复表（reply）：包含回复ID、发布时间、回复内容、评论ID、被回复用户ID和回复用户ID字段。该表与用户表和评论表通过外键关联。\n   - 求助信息表（help_info）：包含求助信息ID、发布时间、求助信息标题、求助信息内容和用户ID字段。该表与用户表通过外键uid关联。\n   - 物品表（goods）：包含物品ID、信息类型、物品标题、发布时间、物品名称、物品类型、发生地点、发生时间、图片URL、状态、用户ID和管理员ID字段。该表与用户表通过外键uid关联。\n   - 评论表（comment）：包含评论ID、发布时间、评论内容、物品ID和用户ID字段。该表与用户表和物品表通过外键关联。\n   - 领取归还表（answer_user）：包含领取归还ID、用户名、QQ号码、电子邮件地址和物品ID字段。该表与物品表通过外键goods_id关联。\n\n5. **项目演示**\n\n   运行演示。\n\n6. **总结与展望**\n\n   项目总结、分析项目的优点和不足之处、提出项目的改进方向和未来发展计划。\n\n源码地址：https://gitee.com/WLei224/jsp.git","slug":"CampousLostAndFound","published":1,"updated":"2023-11-26T03:41:15.050Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clpkiczid0006fkfofnw5et4t","content":"<h1 id=\"我的JSP课程设计大作业\"><a href=\"#我的JSP课程设计大作业\" class=\"headerlink\" title=\"我的JSP课程设计大作业\"></a>我的JSP课程设计大作业</h1><ol>\n<li><p><strong>项目简介</strong></p>\n<ul>\n<li>项目名称：基于<code>SSM</code>框架设计的校园失物招领聊天交流系统</li>\n</ul>\n<ul>\n<li>项目目的：构建一个在线失物招领的平台</li>\n<li>技术栈：使用<code>SSM</code>框架，<code>jsp</code>、<code>js</code>、<code>jquery</code>、<code>ajax</code>等前端技术，采用<code>MySQL</code>数据库</li>\n<li>功能模块：登陆注册验证码后台验证、发布失物、失物与用户评论回复实体相互关联、聊天室对于用户的权限管理、发送图片和表情等功能、打印后台管理信息excel表格</li>\n</ul>\n</li>\n<li><p><strong>系统架构</strong></p>\n<ul>\n<li>前端技术：<code>jsp</code>、<code>js</code>、<code>jquery</code>、<code>ajax</code>等</li>\n<li>后端：<code>SSM框架</code>、<code>websocket</code>等。</li>\n<li>数据库：使用<code>MySQL</code>作为项目的数据存储。</li>\n<li>其他技术：<code>前后端分页ajax</code>、<code>websocketsession</code>等。</li>\n</ul>\n</li>\n<li><p><strong>功能模块介绍</strong></p>\n<ul>\n<li>登陆注册验证码后台验证：用户可以通过注册和登录功能进行操作，在注册和登录时需要通过验证码进行验证，保证系统安全。</li>\n<li>发布失物：用户可以发布失物信息，包括失物名称、描述、图片等信息。</li>\n<li>失物与用户评论回复实体相互关联：用户可以对失物信息进行评论和回复，实现了失物与用户评论回复实体相互关联。</li>\n<li>聊天室对于用户的权限管理：聊天室对于用户的权限管理包括设置管理员、禁言和踢出群聊等功能，保证聊天室的秩序和安全。</li>\n<li>发送图片、表情等功能：用户可以在聊天室中发送图片、表情等内容，丰富了聊天室的交互方式。</li>\n<li>打印后台管理信息excel表格：管理员可以通过打印后台管理信息excel表格功能，方便地查看后台管理信息。</li>\n</ul>\n</li>\n<li><p><strong>数据库设计</strong></p>\n<p>项目的数据库设计，包括数据表的设计和数据表之间的关系。本项目主要包含以下数据表：</p>\n<ul>\n<li>用户表（user）：包含用户ID、用户名、密码、QQ号码、电子邮件地址、角色和开始时间字段。</li>\n<li>留言表（thanks_letter）：包含留言ID、发布时间、留言标题、留言内容和用户ID字段。该表与用户表通过外键uid关联。</li>\n<li>回复表（reply）：包含回复ID、发布时间、回复内容、评论ID、被回复用户ID和回复用户ID字段。该表与用户表和评论表通过外键关联。</li>\n<li>求助信息表（help_info）：包含求助信息ID、发布时间、求助信息标题、求助信息内容和用户ID字段。该表与用户表通过外键uid关联。</li>\n<li>物品表（goods）：包含物品ID、信息类型、物品标题、发布时间、物品名称、物品类型、发生地点、发生时间、图片URL、状态、用户ID和管理员ID字段。该表与用户表通过外键uid关联。</li>\n<li>评论表（comment）：包含评论ID、发布时间、评论内容、物品ID和用户ID字段。该表与用户表和物品表通过外键关联。</li>\n<li>领取归还表（answer_user）：包含领取归还ID、用户名、QQ号码、电子邮件地址和物品ID字段。该表与物品表通过外键goods_id关联。</li>\n</ul>\n</li>\n<li><p><strong>项目演示</strong></p>\n<p>运行演示。</p>\n</li>\n<li><p><strong>总结与展望</strong></p>\n<p>项目总结、分析项目的优点和不足之处、提出项目的改进方向和未来发展计划。</p>\n</li>\n</ol>\n<p>源码地址：<a href=\"https://gitee.com/WLei224/jsp.git\">https://gitee.com/WLei224/jsp.git</a></p>\n","site":{"data":{}},"more":"<h1 id=\"我的JSP课程设计大作业\"><a href=\"#我的JSP课程设计大作业\" class=\"headerlink\" title=\"我的JSP课程设计大作业\"></a>我的JSP课程设计大作业</h1><ol>\n<li><p><strong>项目简介</strong></p>\n<ul>\n<li>项目名称：基于<code>SSM</code>框架设计的校园失物招领聊天交流系统</li>\n</ul>\n<ul>\n<li>项目目的：构建一个在线失物招领的平台</li>\n<li>技术栈：使用<code>SSM</code>框架，<code>jsp</code>、<code>js</code>、<code>jquery</code>、<code>ajax</code>等前端技术，采用<code>MySQL</code>数据库</li>\n<li>功能模块：登陆注册验证码后台验证、发布失物、失物与用户评论回复实体相互关联、聊天室对于用户的权限管理、发送图片和表情等功能、打印后台管理信息excel表格</li>\n</ul>\n</li>\n<li><p><strong>系统架构</strong></p>\n<ul>\n<li>前端技术：<code>jsp</code>、<code>js</code>、<code>jquery</code>、<code>ajax</code>等</li>\n<li>后端：<code>SSM框架</code>、<code>websocket</code>等。</li>\n<li>数据库：使用<code>MySQL</code>作为项目的数据存储。</li>\n<li>其他技术：<code>前后端分页ajax</code>、<code>websocketsession</code>等。</li>\n</ul>\n</li>\n<li><p><strong>功能模块介绍</strong></p>\n<ul>\n<li>登陆注册验证码后台验证：用户可以通过注册和登录功能进行操作，在注册和登录时需要通过验证码进行验证，保证系统安全。</li>\n<li>发布失物：用户可以发布失物信息，包括失物名称、描述、图片等信息。</li>\n<li>失物与用户评论回复实体相互关联：用户可以对失物信息进行评论和回复，实现了失物与用户评论回复实体相互关联。</li>\n<li>聊天室对于用户的权限管理：聊天室对于用户的权限管理包括设置管理员、禁言和踢出群聊等功能，保证聊天室的秩序和安全。</li>\n<li>发送图片、表情等功能：用户可以在聊天室中发送图片、表情等内容，丰富了聊天室的交互方式。</li>\n<li>打印后台管理信息excel表格：管理员可以通过打印后台管理信息excel表格功能，方便地查看后台管理信息。</li>\n</ul>\n</li>\n<li><p><strong>数据库设计</strong></p>\n<p>项目的数据库设计，包括数据表的设计和数据表之间的关系。本项目主要包含以下数据表：</p>\n<ul>\n<li>用户表（user）：包含用户ID、用户名、密码、QQ号码、电子邮件地址、角色和开始时间字段。</li>\n<li>留言表（thanks_letter）：包含留言ID、发布时间、留言标题、留言内容和用户ID字段。该表与用户表通过外键uid关联。</li>\n<li>回复表（reply）：包含回复ID、发布时间、回复内容、评论ID、被回复用户ID和回复用户ID字段。该表与用户表和评论表通过外键关联。</li>\n<li>求助信息表（help_info）：包含求助信息ID、发布时间、求助信息标题、求助信息内容和用户ID字段。该表与用户表通过外键uid关联。</li>\n<li>物品表（goods）：包含物品ID、信息类型、物品标题、发布时间、物品名称、物品类型、发生地点、发生时间、图片URL、状态、用户ID和管理员ID字段。该表与用户表通过外键uid关联。</li>\n<li>评论表（comment）：包含评论ID、发布时间、评论内容、物品ID和用户ID字段。该表与用户表和物品表通过外键关联。</li>\n<li>领取归还表（answer_user）：包含领取归还ID、用户名、QQ号码、电子邮件地址和物品ID字段。该表与物品表通过外键goods_id关联。</li>\n</ul>\n</li>\n<li><p><strong>项目演示</strong></p>\n<p>运行演示。</p>\n</li>\n<li><p><strong>总结与展望</strong></p>\n<p>项目总结、分析项目的优点和不足之处、提出项目的改进方向和未来发展计划。</p>\n</li>\n</ol>\n<p>源码地址：<a href=\"https://gitee.com/WLei224/jsp.git\">https://gitee.com/WLei224/jsp.git</a></p>\n"},{"title":"达梦数据库","abbrlink":26937,"date":"2023-08-07T00:58:32.000Z","_content":"\n# 达梦数据库\n\n> ***INTRODUCE:***达梦数据是国内领先的数据库产品开发服务商，致力于成为国际顶尖的全栈数据产品及解决方案提供商。公司拥有核心源代码的自主知识产权，并已完成数十项国家级或省部级科研开发项目与奖项。其产品在金融、能源、航空、通信、党政机关等数十个领域得到应用，2019年至2021年公司产品市占率位居中国数据库管理系统市场国内数据库厂商前列。\n\n## 达梦线上实验室仿真\n\n欢迎来到达梦数据库线上实验室。\n\n如果您是初次接触达梦数据库，我们强烈建议您加入本次线上实验室的试玩旅程。在这里，您将置身于达梦公司自主研发的新一代大型通用关系型数据库 DM8 的仿真环境中，通过 “用户权限”，“操作数据表”，“检索数据”，“创建索引”，“事务特性” 五大板块，初步体验 DM8 的基本特性。同时我们也提供了创建物化视图、存储过程等一系列“SQL 高级特性”供高级玩家探索。\n\n**实验环境：**\n\n操作系统：CentOS Linux release 7.3.1611 (Core)\n\n达梦数据库实例：DM Database Server 64 V8\n\n> ### 检查数据库版本及服务状态\n\n**查看数据库运行状态：**\n\n```sql\nselect status$ as 状态 from v$instance;\n```\n\n**运行结果：**\n\n![](https://eco.dameng.com/tour/markdown/assets/2-1_db_status.png)\n\n**查看数据库版本：**\n\n```sql\nselect banner as 版本信息 from v$version;\n```\n\n**运行结果：**\n\n![](https://eco.dameng.com/tour/markdown/assets/2-2_db_version.png)\n\n> ### 创建用户并授权\n\n* **创建用户：**\n\n```sql\ncreate user root identified by \"123456789\";\n```\n\n* **授予基本权限：**\n\n```sql\ngrant resource to root;\n```\n\n* **授予用户对指定表的查询权限：**\n\n```sql\ngrant select on user.employee to root;\n```\n\n* **查看用户信息：**\n\n```sql\nselect username,account_status,created from dba_users where username = 'root';\n```\n\n> ### 切换用户\n\n* **切换用户：**\n\n```sql\nconn username/password;\n```\n\n* **查看当前登录用户：**\n\n```sql\nselect user from DUAL;\n```\n\n![查询当前登录用户图](https://cdn.jsdelivr.net/gh/wl2o2o/blogCdn/img/202306071107172.png)\n\n> ### 创建表并添加约束\n\n* **创建职员表：**\n\n```sql\ncreate table employee(\n\temployee_id INTEGER,\n    employee_name vachar2(20) not null,\n    hire_date DATE,\n    salary INTEGER,\n    department_id INTEGER NOT NULL\n)\n```\n\n* **创建部门表：**\n\n```sql\nCREATE TABLE department(\n  department_id INTEGER PRIMARY KEY,\n  department_name VARCHAR(30) NOT NULL\n);\n```\n\n* **更新表中字段可以为空：**\n\n```sql\nALTER TABLE department MODIFY department_name VARCHAR(30);\n```\n\n* **非空约束**\n\n```sql\nALTER TABLE employee MODIFY( hire_date not null);\n```\n\n* **主键约束**\n\n```sql\nalter table employee add constraint pk_empid primary key(employee_id);\n```\n\n* **外键约束**\n\n```sql\nalter table employee add constraint fk_dept foreign key(department_id) references department(department_id);\n```\n\n* **查看表结构**\n\n```sql\nDESC employee;\n```\n\n* **查看表的主键外键**\n\n```sql\nSELECT table_name, constraint_name, constraint_type FROM\n     all_constraints WHERE owner='DM' AND table_name='EMPLOYEE';\n```\n\n> ### 验证数据表的CRUD功能\n\n* **插入数据**\n\n```sql\ninsert into department values(1,'数据库产品中心');\n```\n\n* **修改数据**\n\n```sql\nupdate department set department_id = 2;\n```\n\n* **提交事务**\n\n```sql\ncommit;\n```\n\n* **修改数据**\n\n```sql\nupdate employee set salary = 20000 where employee_id = 1;\n```\n\n* **验证更新表记录能力**\n\n```sql\nSELECT salary,employee_name,employee_id FROM employee;\n```\n\n* **删除数据**\n\n```sql\ndelete from employee;\ndelete from employee where employee_id = 1;\n```\n\n* **验证删除表数据能力**\n\n```sql\nselect * from employee;\n```\n\n> ### 批量插入及选择排序\n\n达梦数据库支持各种数据检索功能，本小节首先批量插入数据，然后验证基本的选择排序功能。\n\n* **批量插入数据**\n\n```sql\nCREATE TABLE t1 AS\n     SELECT rownum AS id,\n       trunc(dbms_random.value(0, 100)) AS random_id,\n       dbms_random.string('x', 20) AS random_string\n     FROM dual\n     connect BY level <= 100000;\n```\n\n创建一个名为 `t1` 的新表，并向其中批量插入 100,000 条随机数据。\n\n具体地，这个 SQL 语句包含以下几个部分：\n\n1. `CREATE TABLE t1 AS SELECT ...`：创建一个名为 `t1` 的新表，并使用 `SELECT` 语句从 `dual` 表生成数据。\n2. `rownum AS id`：使用 `rownum` 函数生成一个序号列，并将其命名为 `id`。\n3. `trunc(dbms_random.value(0, 100)) AS random_id`：使用 `dbms_random.value` 函数生成一个在 0 和 100 之间的随机数，并将其取整后命名为 `random_id`。\n4. `dbms_random.string('x', 20) AS random_string`：使用 `dbms_random.string` 函数生成一个长度为 20 的随机字符串，并将其命名为 `random_string`。\n5. `FROM dual connect BY level <= 100000`：使用 `dual` 表和 `connect by level` 语句生成 100,000 条数据。\n\n在 `FROM` 子句中，使用 `DUAL` 表生成单行数据，然后使用 `CONNECT BY` 语法生成 100,000 行数据。在 `CONNECT BY` 子句中，使用 `LEVEL` 函数生成一个序号列，并使用 `LEVEL` 函数的值来控制生成的行数。\n\n在 `SELECT` 子句中，使用 `dbms_random` 包中的函数生成随机数和随机字符串，并使用 `trunc` 函数对随机数取整。最后，将生成的数据插入到新表 `t1` 中。\n\n需要注意的是，在达梦数据库中，语法和函数可能与 Oracle 数据库不同，请根据具体情况选择合适的语法和函数。\n\n* 查看插入的数据\n\n使用count(*) 聚集函数统计t1表中的总数据记录\n\n```sql\nSELECT COUNT(*) FROM t1;\n```\n\n* 排序数据\n\n```sql\nSELECT * FROM t1 where random_id<50 ORDER BY id DESC;\n```\n\n\n> 验证分组查询\n\n* 批量插入数据\n\n```sql\nINSERT INTO department (department_id, department_name)\n     SELECT department_id, department_name FROM dmhr.department;\n     \nINSERT INTO employee\n     (employee_id, employee_name, hire_date, salary, department_id)\n     SELECT employee_id, employee_name, hire_date, salary,\n     department_id FROM dmhr.employee;\n     \ncommit;\n```\n\n* 分组查询\n\n```sql\nSELECT dept.department_name as 部门, count(*) as 人数\n     FROM employee emp, department dept\n     where emp.department_id=dept.department_id\n     GROUP BY dept.department_name\n     HAVING count(*) > 20;\n```\n\n> 创建视图\n\n达梦数据库支持标准的视图功能，本小节将验证其对标准视图的支持能力。\n\n* 定义视图\n\n需要查询薪资大于 10000 且入职时间大于等于 2013 年 8 月 1 日 员工的部门名称、姓名、薪资、入职时间。\n\n```sql\nCREATE OR replace VIEW v1 AS\n     SELECT dept.department_name, emp.employee_name,\n     emp.salary,emp.hire_date\n     FROM employee emp, department dept\n     WHERE salary > 10000\n     AND hire_date >= '2013-08-01'\n     AND emp.department_id = dept.department_id;\n```\n\n**视图的作用：**\n\n它的作用是从 employee 和 department 两个表中筛选出满足一定条件的记录，并将它们合并成一个结果集。具体来说，这个视图包含了四个字段，分别是：\n\n- department_name：部门名称，来自 department 表；\n- employee_name：员工姓名，来自 employee 表；\n- salary：员工薪水，来自 employee 表；\n- hire_date：员工入职日期，来自 employee 表。\n\n通过这个视图，我们就可以方便地查询所有**符合以上三个条件的员工的信息**，包括他们所在的部门、姓名、薪水和入职日期。视图可以看做是一个虚拟的表格，它不存储任何数据，而是通过查询操作来获取数据的。因此，我们可以像查询普通表格一样来查询这个视图，而不用关心它是如何生成的。\n\n* 通过视图简化查询符合多个条件的数据\n\n```sql\nSELECT * FROM v1 WHERE hire_date > '2014-09-01';\n```\n\n> 创建索引\n\n验证达梦数据库如何创建及删除索引，并通过索引提升查询效率。\n\n创建普通索引\n\n```sql\ncreate index ind_emp_salary on employee(salary);\n```\n\n\n\n\n\n> 事务\n\n以下是常用的达梦数据库事务相关语句：\n\n​\t1.开始事务：`START TRANSACTION` 或者 `BEGIN TRANSACTION`\n\n```\nSTART TRANSACTION;\n-- 事务执行的 SQL 语句\nCOMMIT;\n```\n\n​\t2.回滚事务：`ROLLBACK`\n\n```\nSTART TRANSACTION;\n-- 事务执行的 SQL 语句\nROLLBACK;\n```\n\n​\t3.提交事务：`COMMIT`\n\n```\nSTART TRANSACTION;\n-- 事务执行的 SQL 语句\nCOMMIT;\n```\n\n​\t4.设置事务隔离级别：`SET TRANSACTION ISOLATION LEVEL`\n\n```\nSET TRANSACTION ISOLATION LEVEL READ COMMITTED;\n```\n\n​\t5.保存点：`SAVEPOINT` 和 `ROLLBACK TO SAVEPOINT`\n\n```\nSTART TRANSACTION;\n-- 事务执行的 SQL 语句\nSAVEPOINT my_savepoint;\n-- 更多 SQL 语句\nROLLBACK TO SAVEPOINT my_savepoint;\n-- 更多 SQL 语句\nCOMMIT;\n```\n\n​\t6.设置事务的名称：`SAVEPOINT`\n\n```\nSAVEPOINT my_savepoint;\n-- 更多 SQL 语句\nROLLBACK TO my_savepoint;\n-- 更多 SQL 语句\nCOMMIT;\n```\n\n以上是常用的达梦数据库事务相关语句，您可以根据实际需求选择使用。请注意，在使用事务时，还需要注意锁定和事务隔离级别等问题，以避免出现并发问题和数据不一致的情况。\n\n待补充... ...","source":"_posts/DMDatabase.md","raw":"---\ntitle: 达梦数据库\ncategories:\n  - Database\ntags:\n  - DM\nabbrlink: 26937\ndate: 2023-08-07 08:58:32\n---\n\n# 达梦数据库\n\n> ***INTRODUCE:***达梦数据是国内领先的数据库产品开发服务商，致力于成为国际顶尖的全栈数据产品及解决方案提供商。公司拥有核心源代码的自主知识产权，并已完成数十项国家级或省部级科研开发项目与奖项。其产品在金融、能源、航空、通信、党政机关等数十个领域得到应用，2019年至2021年公司产品市占率位居中国数据库管理系统市场国内数据库厂商前列。\n\n## 达梦线上实验室仿真\n\n欢迎来到达梦数据库线上实验室。\n\n如果您是初次接触达梦数据库，我们强烈建议您加入本次线上实验室的试玩旅程。在这里，您将置身于达梦公司自主研发的新一代大型通用关系型数据库 DM8 的仿真环境中，通过 “用户权限”，“操作数据表”，“检索数据”，“创建索引”，“事务特性” 五大板块，初步体验 DM8 的基本特性。同时我们也提供了创建物化视图、存储过程等一系列“SQL 高级特性”供高级玩家探索。\n\n**实验环境：**\n\n操作系统：CentOS Linux release 7.3.1611 (Core)\n\n达梦数据库实例：DM Database Server 64 V8\n\n> ### 检查数据库版本及服务状态\n\n**查看数据库运行状态：**\n\n```sql\nselect status$ as 状态 from v$instance;\n```\n\n**运行结果：**\n\n![](https://eco.dameng.com/tour/markdown/assets/2-1_db_status.png)\n\n**查看数据库版本：**\n\n```sql\nselect banner as 版本信息 from v$version;\n```\n\n**运行结果：**\n\n![](https://eco.dameng.com/tour/markdown/assets/2-2_db_version.png)\n\n> ### 创建用户并授权\n\n* **创建用户：**\n\n```sql\ncreate user root identified by \"123456789\";\n```\n\n* **授予基本权限：**\n\n```sql\ngrant resource to root;\n```\n\n* **授予用户对指定表的查询权限：**\n\n```sql\ngrant select on user.employee to root;\n```\n\n* **查看用户信息：**\n\n```sql\nselect username,account_status,created from dba_users where username = 'root';\n```\n\n> ### 切换用户\n\n* **切换用户：**\n\n```sql\nconn username/password;\n```\n\n* **查看当前登录用户：**\n\n```sql\nselect user from DUAL;\n```\n\n![查询当前登录用户图](https://cdn.jsdelivr.net/gh/wl2o2o/blogCdn/img/202306071107172.png)\n\n> ### 创建表并添加约束\n\n* **创建职员表：**\n\n```sql\ncreate table employee(\n\temployee_id INTEGER,\n    employee_name vachar2(20) not null,\n    hire_date DATE,\n    salary INTEGER,\n    department_id INTEGER NOT NULL\n)\n```\n\n* **创建部门表：**\n\n```sql\nCREATE TABLE department(\n  department_id INTEGER PRIMARY KEY,\n  department_name VARCHAR(30) NOT NULL\n);\n```\n\n* **更新表中字段可以为空：**\n\n```sql\nALTER TABLE department MODIFY department_name VARCHAR(30);\n```\n\n* **非空约束**\n\n```sql\nALTER TABLE employee MODIFY( hire_date not null);\n```\n\n* **主键约束**\n\n```sql\nalter table employee add constraint pk_empid primary key(employee_id);\n```\n\n* **外键约束**\n\n```sql\nalter table employee add constraint fk_dept foreign key(department_id) references department(department_id);\n```\n\n* **查看表结构**\n\n```sql\nDESC employee;\n```\n\n* **查看表的主键外键**\n\n```sql\nSELECT table_name, constraint_name, constraint_type FROM\n     all_constraints WHERE owner='DM' AND table_name='EMPLOYEE';\n```\n\n> ### 验证数据表的CRUD功能\n\n* **插入数据**\n\n```sql\ninsert into department values(1,'数据库产品中心');\n```\n\n* **修改数据**\n\n```sql\nupdate department set department_id = 2;\n```\n\n* **提交事务**\n\n```sql\ncommit;\n```\n\n* **修改数据**\n\n```sql\nupdate employee set salary = 20000 where employee_id = 1;\n```\n\n* **验证更新表记录能力**\n\n```sql\nSELECT salary,employee_name,employee_id FROM employee;\n```\n\n* **删除数据**\n\n```sql\ndelete from employee;\ndelete from employee where employee_id = 1;\n```\n\n* **验证删除表数据能力**\n\n```sql\nselect * from employee;\n```\n\n> ### 批量插入及选择排序\n\n达梦数据库支持各种数据检索功能，本小节首先批量插入数据，然后验证基本的选择排序功能。\n\n* **批量插入数据**\n\n```sql\nCREATE TABLE t1 AS\n     SELECT rownum AS id,\n       trunc(dbms_random.value(0, 100)) AS random_id,\n       dbms_random.string('x', 20) AS random_string\n     FROM dual\n     connect BY level <= 100000;\n```\n\n创建一个名为 `t1` 的新表，并向其中批量插入 100,000 条随机数据。\n\n具体地，这个 SQL 语句包含以下几个部分：\n\n1. `CREATE TABLE t1 AS SELECT ...`：创建一个名为 `t1` 的新表，并使用 `SELECT` 语句从 `dual` 表生成数据。\n2. `rownum AS id`：使用 `rownum` 函数生成一个序号列，并将其命名为 `id`。\n3. `trunc(dbms_random.value(0, 100)) AS random_id`：使用 `dbms_random.value` 函数生成一个在 0 和 100 之间的随机数，并将其取整后命名为 `random_id`。\n4. `dbms_random.string('x', 20) AS random_string`：使用 `dbms_random.string` 函数生成一个长度为 20 的随机字符串，并将其命名为 `random_string`。\n5. `FROM dual connect BY level <= 100000`：使用 `dual` 表和 `connect by level` 语句生成 100,000 条数据。\n\n在 `FROM` 子句中，使用 `DUAL` 表生成单行数据，然后使用 `CONNECT BY` 语法生成 100,000 行数据。在 `CONNECT BY` 子句中，使用 `LEVEL` 函数生成一个序号列，并使用 `LEVEL` 函数的值来控制生成的行数。\n\n在 `SELECT` 子句中，使用 `dbms_random` 包中的函数生成随机数和随机字符串，并使用 `trunc` 函数对随机数取整。最后，将生成的数据插入到新表 `t1` 中。\n\n需要注意的是，在达梦数据库中，语法和函数可能与 Oracle 数据库不同，请根据具体情况选择合适的语法和函数。\n\n* 查看插入的数据\n\n使用count(*) 聚集函数统计t1表中的总数据记录\n\n```sql\nSELECT COUNT(*) FROM t1;\n```\n\n* 排序数据\n\n```sql\nSELECT * FROM t1 where random_id<50 ORDER BY id DESC;\n```\n\n\n> 验证分组查询\n\n* 批量插入数据\n\n```sql\nINSERT INTO department (department_id, department_name)\n     SELECT department_id, department_name FROM dmhr.department;\n     \nINSERT INTO employee\n     (employee_id, employee_name, hire_date, salary, department_id)\n     SELECT employee_id, employee_name, hire_date, salary,\n     department_id FROM dmhr.employee;\n     \ncommit;\n```\n\n* 分组查询\n\n```sql\nSELECT dept.department_name as 部门, count(*) as 人数\n     FROM employee emp, department dept\n     where emp.department_id=dept.department_id\n     GROUP BY dept.department_name\n     HAVING count(*) > 20;\n```\n\n> 创建视图\n\n达梦数据库支持标准的视图功能，本小节将验证其对标准视图的支持能力。\n\n* 定义视图\n\n需要查询薪资大于 10000 且入职时间大于等于 2013 年 8 月 1 日 员工的部门名称、姓名、薪资、入职时间。\n\n```sql\nCREATE OR replace VIEW v1 AS\n     SELECT dept.department_name, emp.employee_name,\n     emp.salary,emp.hire_date\n     FROM employee emp, department dept\n     WHERE salary > 10000\n     AND hire_date >= '2013-08-01'\n     AND emp.department_id = dept.department_id;\n```\n\n**视图的作用：**\n\n它的作用是从 employee 和 department 两个表中筛选出满足一定条件的记录，并将它们合并成一个结果集。具体来说，这个视图包含了四个字段，分别是：\n\n- department_name：部门名称，来自 department 表；\n- employee_name：员工姓名，来自 employee 表；\n- salary：员工薪水，来自 employee 表；\n- hire_date：员工入职日期，来自 employee 表。\n\n通过这个视图，我们就可以方便地查询所有**符合以上三个条件的员工的信息**，包括他们所在的部门、姓名、薪水和入职日期。视图可以看做是一个虚拟的表格，它不存储任何数据，而是通过查询操作来获取数据的。因此，我们可以像查询普通表格一样来查询这个视图，而不用关心它是如何生成的。\n\n* 通过视图简化查询符合多个条件的数据\n\n```sql\nSELECT * FROM v1 WHERE hire_date > '2014-09-01';\n```\n\n> 创建索引\n\n验证达梦数据库如何创建及删除索引，并通过索引提升查询效率。\n\n创建普通索引\n\n```sql\ncreate index ind_emp_salary on employee(salary);\n```\n\n\n\n\n\n> 事务\n\n以下是常用的达梦数据库事务相关语句：\n\n​\t1.开始事务：`START TRANSACTION` 或者 `BEGIN TRANSACTION`\n\n```\nSTART TRANSACTION;\n-- 事务执行的 SQL 语句\nCOMMIT;\n```\n\n​\t2.回滚事务：`ROLLBACK`\n\n```\nSTART TRANSACTION;\n-- 事务执行的 SQL 语句\nROLLBACK;\n```\n\n​\t3.提交事务：`COMMIT`\n\n```\nSTART TRANSACTION;\n-- 事务执行的 SQL 语句\nCOMMIT;\n```\n\n​\t4.设置事务隔离级别：`SET TRANSACTION ISOLATION LEVEL`\n\n```\nSET TRANSACTION ISOLATION LEVEL READ COMMITTED;\n```\n\n​\t5.保存点：`SAVEPOINT` 和 `ROLLBACK TO SAVEPOINT`\n\n```\nSTART TRANSACTION;\n-- 事务执行的 SQL 语句\nSAVEPOINT my_savepoint;\n-- 更多 SQL 语句\nROLLBACK TO SAVEPOINT my_savepoint;\n-- 更多 SQL 语句\nCOMMIT;\n```\n\n​\t6.设置事务的名称：`SAVEPOINT`\n\n```\nSAVEPOINT my_savepoint;\n-- 更多 SQL 语句\nROLLBACK TO my_savepoint;\n-- 更多 SQL 语句\nCOMMIT;\n```\n\n以上是常用的达梦数据库事务相关语句，您可以根据实际需求选择使用。请注意，在使用事务时，还需要注意锁定和事务隔离级别等问题，以避免出现并发问题和数据不一致的情况。\n\n待补充... ...","slug":"DMDatabase","published":1,"updated":"2023-10-16T06:58:59.246Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clpkiczie0007fkfo7qat1aez","content":"<h1 id=\"达梦数据库\"><a href=\"#达梦数据库\" class=\"headerlink\" title=\"达梦数据库\"></a>达梦数据库</h1><blockquote>\n<p>***INTRODUCE:***达梦数据是国内领先的数据库产品开发服务商，致力于成为国际顶尖的全栈数据产品及解决方案提供商。公司拥有核心源代码的自主知识产权，并已完成数十项国家级或省部级科研开发项目与奖项。其产品在金融、能源、航空、通信、党政机关等数十个领域得到应用，2019年至2021年公司产品市占率位居中国数据库管理系统市场国内数据库厂商前列。</p>\n</blockquote>\n<h2 id=\"达梦线上实验室仿真\"><a href=\"#达梦线上实验室仿真\" class=\"headerlink\" title=\"达梦线上实验室仿真\"></a>达梦线上实验室仿真</h2><p>欢迎来到达梦数据库线上实验室。</p>\n<p>如果您是初次接触达梦数据库，我们强烈建议您加入本次线上实验室的试玩旅程。在这里，您将置身于达梦公司自主研发的新一代大型通用关系型数据库 DM8 的仿真环境中，通过 “用户权限”，“操作数据表”，“检索数据”，“创建索引”，“事务特性” 五大板块，初步体验 DM8 的基本特性。同时我们也提供了创建物化视图、存储过程等一系列“SQL 高级特性”供高级玩家探索。</p>\n<p><strong>实验环境：</strong></p>\n<p>操作系统：CentOS Linux release 7.3.1611 (Core)</p>\n<p>达梦数据库实例：DM Database Server 64 V8</p>\n<blockquote>\n<h3 id=\"检查数据库版本及服务状态\"><a href=\"#检查数据库版本及服务状态\" class=\"headerlink\" title=\"检查数据库版本及服务状态\"></a>检查数据库版本及服务状态</h3></blockquote>\n<p><strong>查看数据库运行状态：</strong></p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">select</span> status$ <span class=\"hljs-keyword\">as</span> 状态 <span class=\"hljs-keyword\">from</span> v$instance;<br></code></pre></td></tr></table></figure>\n\n<p><strong>运行结果：</strong></p>\n<p><img src=\"https://eco.dameng.com/tour/markdown/assets/2-1_db_status.png\"></p>\n<p><strong>查看数据库版本：</strong></p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">select</span> banner <span class=\"hljs-keyword\">as</span> 版本信息 <span class=\"hljs-keyword\">from</span> v$version;<br></code></pre></td></tr></table></figure>\n\n<p><strong>运行结果：</strong></p>\n<p><img src=\"https://eco.dameng.com/tour/markdown/assets/2-2_db_version.png\"></p>\n<blockquote>\n<h3 id=\"创建用户并授权\"><a href=\"#创建用户并授权\" class=\"headerlink\" title=\"创建用户并授权\"></a>创建用户并授权</h3></blockquote>\n<ul>\n<li><strong>创建用户：</strong></li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">create</span> <span class=\"hljs-keyword\">user</span> root identified <span class=\"hljs-keyword\">by</span> &quot;123456789&quot;;<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>授予基本权限：</strong></li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">grant</span> resource <span class=\"hljs-keyword\">to</span> root;<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>授予用户对指定表的查询权限：</strong></li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">grant</span> <span class=\"hljs-keyword\">select</span> <span class=\"hljs-keyword\">on</span> user.employee <span class=\"hljs-keyword\">to</span> root;<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>查看用户信息：</strong></li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">select</span> username,account_status,created <span class=\"hljs-keyword\">from</span> dba_users <span class=\"hljs-keyword\">where</span> username <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&#x27;root&#x27;</span>;<br></code></pre></td></tr></table></figure>\n\n<blockquote>\n<h3 id=\"切换用户\"><a href=\"#切换用户\" class=\"headerlink\" title=\"切换用户\"></a>切换用户</h3></blockquote>\n<ul>\n<li><strong>切换用户：</strong></li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\">conn username<span class=\"hljs-operator\">/</span>password;<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>查看当前登录用户：</strong></li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">select</span> <span class=\"hljs-keyword\">user</span> <span class=\"hljs-keyword\">from</span> DUAL;<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://cdn.jsdelivr.net/gh/wl2o2o/blogCdn/img/202306071107172.png\" alt=\"查询当前登录用户图\"></p>\n<blockquote>\n<h3 id=\"创建表并添加约束\"><a href=\"#创建表并添加约束\" class=\"headerlink\" title=\"创建表并添加约束\"></a>创建表并添加约束</h3></blockquote>\n<ul>\n<li><strong>创建职员表：</strong></li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">create</span> <span class=\"hljs-keyword\">table</span> employee(<br>\temployee_id <span class=\"hljs-type\">INTEGER</span>,<br>    employee_name vachar2(<span class=\"hljs-number\">20</span>) <span class=\"hljs-keyword\">not</span> <span class=\"hljs-keyword\">null</span>,<br>    hire_date <span class=\"hljs-type\">DATE</span>,<br>    salary <span class=\"hljs-type\">INTEGER</span>,<br>    department_id <span class=\"hljs-type\">INTEGER</span> <span class=\"hljs-keyword\">NOT</span> <span class=\"hljs-keyword\">NULL</span><br>)<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>创建部门表：</strong></li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">CREATE</span> <span class=\"hljs-keyword\">TABLE</span> department(<br>  department_id <span class=\"hljs-type\">INTEGER</span> <span class=\"hljs-keyword\">PRIMARY</span> KEY,<br>  department_name <span class=\"hljs-type\">VARCHAR</span>(<span class=\"hljs-number\">30</span>) <span class=\"hljs-keyword\">NOT</span> <span class=\"hljs-keyword\">NULL</span><br>);<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>更新表中字段可以为空：</strong></li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">ALTER</span> <span class=\"hljs-keyword\">TABLE</span> department MODIFY department_name <span class=\"hljs-type\">VARCHAR</span>(<span class=\"hljs-number\">30</span>);<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>非空约束</strong></li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">ALTER</span> <span class=\"hljs-keyword\">TABLE</span> employee MODIFY( hire_date <span class=\"hljs-keyword\">not</span> <span class=\"hljs-keyword\">null</span>);<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>主键约束</strong></li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">alter</span> <span class=\"hljs-keyword\">table</span> employee <span class=\"hljs-keyword\">add</span> <span class=\"hljs-keyword\">constraint</span> pk_empid <span class=\"hljs-keyword\">primary</span> key(employee_id);<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>外键约束</strong></li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">alter</span> <span class=\"hljs-keyword\">table</span> employee <span class=\"hljs-keyword\">add</span> <span class=\"hljs-keyword\">constraint</span> fk_dept <span class=\"hljs-keyword\">foreign</span> key(department_id) <span class=\"hljs-keyword\">references</span> department(department_id);<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>查看表结构</strong></li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">DESC</span> employee;<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>查看表的主键外键</strong></li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">SELECT</span> table_name, constraint_name, constraint_type <span class=\"hljs-keyword\">FROM</span><br>     all_constraints <span class=\"hljs-keyword\">WHERE</span> owner<span class=\"hljs-operator\">=</span><span class=\"hljs-string\">&#x27;DM&#x27;</span> <span class=\"hljs-keyword\">AND</span> table_name<span class=\"hljs-operator\">=</span><span class=\"hljs-string\">&#x27;EMPLOYEE&#x27;</span>;<br></code></pre></td></tr></table></figure>\n\n<blockquote>\n<h3 id=\"验证数据表的CRUD功能\"><a href=\"#验证数据表的CRUD功能\" class=\"headerlink\" title=\"验证数据表的CRUD功能\"></a>验证数据表的CRUD功能</h3></blockquote>\n<ul>\n<li><strong>插入数据</strong></li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">insert</span> <span class=\"hljs-keyword\">into</span> department <span class=\"hljs-keyword\">values</span>(<span class=\"hljs-number\">1</span>,<span class=\"hljs-string\">&#x27;数据库产品中心&#x27;</span>);<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>修改数据</strong></li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">update</span> department <span class=\"hljs-keyword\">set</span> department_id <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">2</span>;<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>提交事务</strong></li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">commit</span>;<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>修改数据</strong></li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">update</span> employee <span class=\"hljs-keyword\">set</span> salary <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">20000</span> <span class=\"hljs-keyword\">where</span> employee_id <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">1</span>;<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>验证更新表记录能力</strong></li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">SELECT</span> salary,employee_name,employee_id <span class=\"hljs-keyword\">FROM</span> employee;<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>删除数据</strong></li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">delete</span> <span class=\"hljs-keyword\">from</span> employee;<br><span class=\"hljs-keyword\">delete</span> <span class=\"hljs-keyword\">from</span> employee <span class=\"hljs-keyword\">where</span> employee_id <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">1</span>;<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>验证删除表数据能力</strong></li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">select</span> <span class=\"hljs-operator\">*</span> <span class=\"hljs-keyword\">from</span> employee;<br></code></pre></td></tr></table></figure>\n\n<blockquote>\n<h3 id=\"批量插入及选择排序\"><a href=\"#批量插入及选择排序\" class=\"headerlink\" title=\"批量插入及选择排序\"></a>批量插入及选择排序</h3></blockquote>\n<p>达梦数据库支持各种数据检索功能，本小节首先批量插入数据，然后验证基本的选择排序功能。</p>\n<ul>\n<li><strong>批量插入数据</strong></li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">CREATE</span> <span class=\"hljs-keyword\">TABLE</span> t1 <span class=\"hljs-keyword\">AS</span><br>     <span class=\"hljs-keyword\">SELECT</span> rownum <span class=\"hljs-keyword\">AS</span> id,<br>       trunc(dbms_random.value(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">100</span>)) <span class=\"hljs-keyword\">AS</span> random_id,<br>       dbms_random.string(<span class=\"hljs-string\">&#x27;x&#x27;</span>, <span class=\"hljs-number\">20</span>) <span class=\"hljs-keyword\">AS</span> random_string<br>     <span class=\"hljs-keyword\">FROM</span> dual<br>     <span class=\"hljs-keyword\">connect</span> <span class=\"hljs-keyword\">BY</span> level <span class=\"hljs-operator\">&lt;=</span> <span class=\"hljs-number\">100000</span>;<br></code></pre></td></tr></table></figure>\n\n<p>创建一个名为 <code>t1</code> 的新表，并向其中批量插入 100,000 条随机数据。</p>\n<p>具体地，这个 SQL 语句包含以下几个部分：</p>\n<ol>\n<li><code>CREATE TABLE t1 AS SELECT ...</code>：创建一个名为 <code>t1</code> 的新表，并使用 <code>SELECT</code> 语句从 <code>dual</code> 表生成数据。</li>\n<li><code>rownum AS id</code>：使用 <code>rownum</code> 函数生成一个序号列，并将其命名为 <code>id</code>。</li>\n<li><code>trunc(dbms_random.value(0, 100)) AS random_id</code>：使用 <code>dbms_random.value</code> 函数生成一个在 0 和 100 之间的随机数，并将其取整后命名为 <code>random_id</code>。</li>\n<li><code>dbms_random.string(&#39;x&#39;, 20) AS random_string</code>：使用 <code>dbms_random.string</code> 函数生成一个长度为 20 的随机字符串，并将其命名为 <code>random_string</code>。</li>\n<li><code>FROM dual connect BY level &lt;= 100000</code>：使用 <code>dual</code> 表和 <code>connect by level</code> 语句生成 100,000 条数据。</li>\n</ol>\n<p>在 <code>FROM</code> 子句中，使用 <code>DUAL</code> 表生成单行数据，然后使用 <code>CONNECT BY</code> 语法生成 100,000 行数据。在 <code>CONNECT BY</code> 子句中，使用 <code>LEVEL</code> 函数生成一个序号列，并使用 <code>LEVEL</code> 函数的值来控制生成的行数。</p>\n<p>在 <code>SELECT</code> 子句中，使用 <code>dbms_random</code> 包中的函数生成随机数和随机字符串，并使用 <code>trunc</code> 函数对随机数取整。最后，将生成的数据插入到新表 <code>t1</code> 中。</p>\n<p>需要注意的是，在达梦数据库中，语法和函数可能与 Oracle 数据库不同，请根据具体情况选择合适的语法和函数。</p>\n<ul>\n<li>查看插入的数据</li>\n</ul>\n<p>使用count(*) 聚集函数统计t1表中的总数据记录</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">SELECT</span> <span class=\"hljs-built_in\">COUNT</span>(<span class=\"hljs-operator\">*</span>) <span class=\"hljs-keyword\">FROM</span> t1;<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li>排序数据</li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">SELECT</span> <span class=\"hljs-operator\">*</span> <span class=\"hljs-keyword\">FROM</span> t1 <span class=\"hljs-keyword\">where</span> random_id<span class=\"hljs-operator\">&lt;</span><span class=\"hljs-number\">50</span> <span class=\"hljs-keyword\">ORDER</span> <span class=\"hljs-keyword\">BY</span> id <span class=\"hljs-keyword\">DESC</span>;<br></code></pre></td></tr></table></figure>\n\n\n<blockquote>\n<p>验证分组查询</p>\n</blockquote>\n<ul>\n<li>批量插入数据</li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">INSERT</span> <span class=\"hljs-keyword\">INTO</span> department (department_id, department_name)<br>     <span class=\"hljs-keyword\">SELECT</span> department_id, department_name <span class=\"hljs-keyword\">FROM</span> dmhr.department;<br>     <br><span class=\"hljs-keyword\">INSERT</span> <span class=\"hljs-keyword\">INTO</span> employee<br>     (employee_id, employee_name, hire_date, salary, department_id)<br>     <span class=\"hljs-keyword\">SELECT</span> employee_id, employee_name, hire_date, salary,<br>     department_id <span class=\"hljs-keyword\">FROM</span> dmhr.employee;<br>     <br><span class=\"hljs-keyword\">commit</span>;<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li>分组查询</li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">SELECT</span> dept.department_name <span class=\"hljs-keyword\">as</span> 部门, <span class=\"hljs-built_in\">count</span>(<span class=\"hljs-operator\">*</span>) <span class=\"hljs-keyword\">as</span> 人数<br>     <span class=\"hljs-keyword\">FROM</span> employee emp, department dept<br>     <span class=\"hljs-keyword\">where</span> emp.department_id<span class=\"hljs-operator\">=</span>dept.department_id<br>     <span class=\"hljs-keyword\">GROUP</span> <span class=\"hljs-keyword\">BY</span> dept.department_name<br>     <span class=\"hljs-keyword\">HAVING</span> <span class=\"hljs-built_in\">count</span>(<span class=\"hljs-operator\">*</span>) <span class=\"hljs-operator\">&gt;</span> <span class=\"hljs-number\">20</span>;<br></code></pre></td></tr></table></figure>\n\n<blockquote>\n<p>创建视图</p>\n</blockquote>\n<p>达梦数据库支持标准的视图功能，本小节将验证其对标准视图的支持能力。</p>\n<ul>\n<li>定义视图</li>\n</ul>\n<p>需要查询薪资大于 10000 且入职时间大于等于 2013 年 8 月 1 日 员工的部门名称、姓名、薪资、入职时间。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">CREATE</span> <span class=\"hljs-keyword\">OR</span> replace <span class=\"hljs-keyword\">VIEW</span> v1 <span class=\"hljs-keyword\">AS</span><br>     <span class=\"hljs-keyword\">SELECT</span> dept.department_name, emp.employee_name,<br>     emp.salary,emp.hire_date<br>     <span class=\"hljs-keyword\">FROM</span> employee emp, department dept<br>     <span class=\"hljs-keyword\">WHERE</span> salary <span class=\"hljs-operator\">&gt;</span> <span class=\"hljs-number\">10000</span><br>     <span class=\"hljs-keyword\">AND</span> hire_date <span class=\"hljs-operator\">&gt;=</span> <span class=\"hljs-string\">&#x27;2013-08-01&#x27;</span><br>     <span class=\"hljs-keyword\">AND</span> emp.department_id <span class=\"hljs-operator\">=</span> dept.department_id;<br></code></pre></td></tr></table></figure>\n\n<p><strong>视图的作用：</strong></p>\n<p>它的作用是从 employee 和 department 两个表中筛选出满足一定条件的记录，并将它们合并成一个结果集。具体来说，这个视图包含了四个字段，分别是：</p>\n<ul>\n<li>department_name：部门名称，来自 department 表；</li>\n<li>employee_name：员工姓名，来自 employee 表；</li>\n<li>salary：员工薪水，来自 employee 表；</li>\n<li>hire_date：员工入职日期，来自 employee 表。</li>\n</ul>\n<p>通过这个视图，我们就可以方便地查询所有<strong>符合以上三个条件的员工的信息</strong>，包括他们所在的部门、姓名、薪水和入职日期。视图可以看做是一个虚拟的表格，它不存储任何数据，而是通过查询操作来获取数据的。因此，我们可以像查询普通表格一样来查询这个视图，而不用关心它是如何生成的。</p>\n<ul>\n<li>通过视图简化查询符合多个条件的数据</li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">SELECT</span> <span class=\"hljs-operator\">*</span> <span class=\"hljs-keyword\">FROM</span> v1 <span class=\"hljs-keyword\">WHERE</span> hire_date <span class=\"hljs-operator\">&gt;</span> <span class=\"hljs-string\">&#x27;2014-09-01&#x27;</span>;<br></code></pre></td></tr></table></figure>\n\n<blockquote>\n<p>创建索引</p>\n</blockquote>\n<p>验证达梦数据库如何创建及删除索引，并通过索引提升查询效率。</p>\n<p>创建普通索引</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">create</span> index ind_emp_salary <span class=\"hljs-keyword\">on</span> employee(salary);<br></code></pre></td></tr></table></figure>\n\n\n\n\n\n<blockquote>\n<p>事务</p>\n</blockquote>\n<p>以下是常用的达梦数据库事务相关语句：</p>\n<p>​    1.开始事务：<code>START TRANSACTION</code> 或者 <code>BEGIN TRANSACTION</code></p>\n<figure class=\"highlight pgsql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs pgsql\"><span class=\"hljs-keyword\">START</span> <span class=\"hljs-keyword\">TRANSACTION</span>;<br><span class=\"hljs-comment\">-- 事务执行的 SQL 语句</span><br><span class=\"hljs-keyword\">COMMIT</span>;<br></code></pre></td></tr></table></figure>\n\n<p>​    2.回滚事务：<code>ROLLBACK</code></p>\n<figure class=\"highlight pgsql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs pgsql\"><span class=\"hljs-keyword\">START</span> <span class=\"hljs-keyword\">TRANSACTION</span>;<br><span class=\"hljs-comment\">-- 事务执行的 SQL 语句</span><br><span class=\"hljs-keyword\">ROLLBACK</span>;<br></code></pre></td></tr></table></figure>\n\n<p>​    3.提交事务：<code>COMMIT</code></p>\n<figure class=\"highlight pgsql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs pgsql\"><span class=\"hljs-keyword\">START</span> <span class=\"hljs-keyword\">TRANSACTION</span>;<br><span class=\"hljs-comment\">-- 事务执行的 SQL 语句</span><br><span class=\"hljs-keyword\">COMMIT</span>;<br></code></pre></td></tr></table></figure>\n\n<p>​    4.设置事务隔离级别：<code>SET TRANSACTION ISOLATION LEVEL</code></p>\n<figure class=\"highlight pgsql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs pgsql\"><span class=\"hljs-keyword\">SET</span> <span class=\"hljs-keyword\">TRANSACTION</span> <span class=\"hljs-keyword\">ISOLATION</span> <span class=\"hljs-keyword\">LEVEL</span> <span class=\"hljs-keyword\">READ</span> <span class=\"hljs-keyword\">COMMITTED</span>;<br></code></pre></td></tr></table></figure>\n\n<p>​    5.保存点：<code>SAVEPOINT</code> 和 <code>ROLLBACK TO SAVEPOINT</code></p>\n<figure class=\"highlight pgsql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs pgsql\"><span class=\"hljs-keyword\">START</span> <span class=\"hljs-keyword\">TRANSACTION</span>;<br><span class=\"hljs-comment\">-- 事务执行的 SQL 语句</span><br><span class=\"hljs-keyword\">SAVEPOINT</span> my_savepoint;<br><span class=\"hljs-comment\">-- 更多 SQL 语句</span><br><span class=\"hljs-keyword\">ROLLBACK</span> <span class=\"hljs-keyword\">TO</span> <span class=\"hljs-keyword\">SAVEPOINT</span> my_savepoint;<br><span class=\"hljs-comment\">-- 更多 SQL 语句</span><br><span class=\"hljs-keyword\">COMMIT</span>;<br></code></pre></td></tr></table></figure>\n\n<p>​    6.设置事务的名称：<code>SAVEPOINT</code></p>\n<figure class=\"highlight pgsql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs pgsql\"><span class=\"hljs-keyword\">SAVEPOINT</span> my_savepoint;<br><span class=\"hljs-comment\">-- 更多 SQL 语句</span><br><span class=\"hljs-keyword\">ROLLBACK</span> <span class=\"hljs-keyword\">TO</span> my_savepoint;<br><span class=\"hljs-comment\">-- 更多 SQL 语句</span><br><span class=\"hljs-keyword\">COMMIT</span>;<br></code></pre></td></tr></table></figure>\n\n<p>以上是常用的达梦数据库事务相关语句，您可以根据实际需求选择使用。请注意，在使用事务时，还需要注意锁定和事务隔离级别等问题，以避免出现并发问题和数据不一致的情况。</p>\n<p>待补充… …</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"达梦数据库\"><a href=\"#达梦数据库\" class=\"headerlink\" title=\"达梦数据库\"></a>达梦数据库</h1><blockquote>\n<p>***INTRODUCE:***达梦数据是国内领先的数据库产品开发服务商，致力于成为国际顶尖的全栈数据产品及解决方案提供商。公司拥有核心源代码的自主知识产权，并已完成数十项国家级或省部级科研开发项目与奖项。其产品在金融、能源、航空、通信、党政机关等数十个领域得到应用，2019年至2021年公司产品市占率位居中国数据库管理系统市场国内数据库厂商前列。</p>\n</blockquote>\n<h2 id=\"达梦线上实验室仿真\"><a href=\"#达梦线上实验室仿真\" class=\"headerlink\" title=\"达梦线上实验室仿真\"></a>达梦线上实验室仿真</h2><p>欢迎来到达梦数据库线上实验室。</p>\n<p>如果您是初次接触达梦数据库，我们强烈建议您加入本次线上实验室的试玩旅程。在这里，您将置身于达梦公司自主研发的新一代大型通用关系型数据库 DM8 的仿真环境中，通过 “用户权限”，“操作数据表”，“检索数据”，“创建索引”，“事务特性” 五大板块，初步体验 DM8 的基本特性。同时我们也提供了创建物化视图、存储过程等一系列“SQL 高级特性”供高级玩家探索。</p>\n<p><strong>实验环境：</strong></p>\n<p>操作系统：CentOS Linux release 7.3.1611 (Core)</p>\n<p>达梦数据库实例：DM Database Server 64 V8</p>\n<blockquote>\n<h3 id=\"检查数据库版本及服务状态\"><a href=\"#检查数据库版本及服务状态\" class=\"headerlink\" title=\"检查数据库版本及服务状态\"></a>检查数据库版本及服务状态</h3></blockquote>\n<p><strong>查看数据库运行状态：</strong></p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">select</span> status$ <span class=\"hljs-keyword\">as</span> 状态 <span class=\"hljs-keyword\">from</span> v$instance;<br></code></pre></td></tr></table></figure>\n\n<p><strong>运行结果：</strong></p>\n<p><img src=\"https://eco.dameng.com/tour/markdown/assets/2-1_db_status.png\"></p>\n<p><strong>查看数据库版本：</strong></p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">select</span> banner <span class=\"hljs-keyword\">as</span> 版本信息 <span class=\"hljs-keyword\">from</span> v$version;<br></code></pre></td></tr></table></figure>\n\n<p><strong>运行结果：</strong></p>\n<p><img src=\"https://eco.dameng.com/tour/markdown/assets/2-2_db_version.png\"></p>\n<blockquote>\n<h3 id=\"创建用户并授权\"><a href=\"#创建用户并授权\" class=\"headerlink\" title=\"创建用户并授权\"></a>创建用户并授权</h3></blockquote>\n<ul>\n<li><strong>创建用户：</strong></li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">create</span> <span class=\"hljs-keyword\">user</span> root identified <span class=\"hljs-keyword\">by</span> &quot;123456789&quot;;<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>授予基本权限：</strong></li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">grant</span> resource <span class=\"hljs-keyword\">to</span> root;<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>授予用户对指定表的查询权限：</strong></li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">grant</span> <span class=\"hljs-keyword\">select</span> <span class=\"hljs-keyword\">on</span> user.employee <span class=\"hljs-keyword\">to</span> root;<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>查看用户信息：</strong></li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">select</span> username,account_status,created <span class=\"hljs-keyword\">from</span> dba_users <span class=\"hljs-keyword\">where</span> username <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&#x27;root&#x27;</span>;<br></code></pre></td></tr></table></figure>\n\n<blockquote>\n<h3 id=\"切换用户\"><a href=\"#切换用户\" class=\"headerlink\" title=\"切换用户\"></a>切换用户</h3></blockquote>\n<ul>\n<li><strong>切换用户：</strong></li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\">conn username<span class=\"hljs-operator\">/</span>password;<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>查看当前登录用户：</strong></li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">select</span> <span class=\"hljs-keyword\">user</span> <span class=\"hljs-keyword\">from</span> DUAL;<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://cdn.jsdelivr.net/gh/wl2o2o/blogCdn/img/202306071107172.png\" alt=\"查询当前登录用户图\"></p>\n<blockquote>\n<h3 id=\"创建表并添加约束\"><a href=\"#创建表并添加约束\" class=\"headerlink\" title=\"创建表并添加约束\"></a>创建表并添加约束</h3></blockquote>\n<ul>\n<li><strong>创建职员表：</strong></li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">create</span> <span class=\"hljs-keyword\">table</span> employee(<br>\temployee_id <span class=\"hljs-type\">INTEGER</span>,<br>    employee_name vachar2(<span class=\"hljs-number\">20</span>) <span class=\"hljs-keyword\">not</span> <span class=\"hljs-keyword\">null</span>,<br>    hire_date <span class=\"hljs-type\">DATE</span>,<br>    salary <span class=\"hljs-type\">INTEGER</span>,<br>    department_id <span class=\"hljs-type\">INTEGER</span> <span class=\"hljs-keyword\">NOT</span> <span class=\"hljs-keyword\">NULL</span><br>)<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>创建部门表：</strong></li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">CREATE</span> <span class=\"hljs-keyword\">TABLE</span> department(<br>  department_id <span class=\"hljs-type\">INTEGER</span> <span class=\"hljs-keyword\">PRIMARY</span> KEY,<br>  department_name <span class=\"hljs-type\">VARCHAR</span>(<span class=\"hljs-number\">30</span>) <span class=\"hljs-keyword\">NOT</span> <span class=\"hljs-keyword\">NULL</span><br>);<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>更新表中字段可以为空：</strong></li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">ALTER</span> <span class=\"hljs-keyword\">TABLE</span> department MODIFY department_name <span class=\"hljs-type\">VARCHAR</span>(<span class=\"hljs-number\">30</span>);<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>非空约束</strong></li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">ALTER</span> <span class=\"hljs-keyword\">TABLE</span> employee MODIFY( hire_date <span class=\"hljs-keyword\">not</span> <span class=\"hljs-keyword\">null</span>);<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>主键约束</strong></li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">alter</span> <span class=\"hljs-keyword\">table</span> employee <span class=\"hljs-keyword\">add</span> <span class=\"hljs-keyword\">constraint</span> pk_empid <span class=\"hljs-keyword\">primary</span> key(employee_id);<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>外键约束</strong></li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">alter</span> <span class=\"hljs-keyword\">table</span> employee <span class=\"hljs-keyword\">add</span> <span class=\"hljs-keyword\">constraint</span> fk_dept <span class=\"hljs-keyword\">foreign</span> key(department_id) <span class=\"hljs-keyword\">references</span> department(department_id);<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>查看表结构</strong></li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">DESC</span> employee;<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>查看表的主键外键</strong></li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">SELECT</span> table_name, constraint_name, constraint_type <span class=\"hljs-keyword\">FROM</span><br>     all_constraints <span class=\"hljs-keyword\">WHERE</span> owner<span class=\"hljs-operator\">=</span><span class=\"hljs-string\">&#x27;DM&#x27;</span> <span class=\"hljs-keyword\">AND</span> table_name<span class=\"hljs-operator\">=</span><span class=\"hljs-string\">&#x27;EMPLOYEE&#x27;</span>;<br></code></pre></td></tr></table></figure>\n\n<blockquote>\n<h3 id=\"验证数据表的CRUD功能\"><a href=\"#验证数据表的CRUD功能\" class=\"headerlink\" title=\"验证数据表的CRUD功能\"></a>验证数据表的CRUD功能</h3></blockquote>\n<ul>\n<li><strong>插入数据</strong></li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">insert</span> <span class=\"hljs-keyword\">into</span> department <span class=\"hljs-keyword\">values</span>(<span class=\"hljs-number\">1</span>,<span class=\"hljs-string\">&#x27;数据库产品中心&#x27;</span>);<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>修改数据</strong></li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">update</span> department <span class=\"hljs-keyword\">set</span> department_id <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">2</span>;<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>提交事务</strong></li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">commit</span>;<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>修改数据</strong></li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">update</span> employee <span class=\"hljs-keyword\">set</span> salary <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">20000</span> <span class=\"hljs-keyword\">where</span> employee_id <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">1</span>;<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>验证更新表记录能力</strong></li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">SELECT</span> salary,employee_name,employee_id <span class=\"hljs-keyword\">FROM</span> employee;<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>删除数据</strong></li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">delete</span> <span class=\"hljs-keyword\">from</span> employee;<br><span class=\"hljs-keyword\">delete</span> <span class=\"hljs-keyword\">from</span> employee <span class=\"hljs-keyword\">where</span> employee_id <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">1</span>;<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>验证删除表数据能力</strong></li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">select</span> <span class=\"hljs-operator\">*</span> <span class=\"hljs-keyword\">from</span> employee;<br></code></pre></td></tr></table></figure>\n\n<blockquote>\n<h3 id=\"批量插入及选择排序\"><a href=\"#批量插入及选择排序\" class=\"headerlink\" title=\"批量插入及选择排序\"></a>批量插入及选择排序</h3></blockquote>\n<p>达梦数据库支持各种数据检索功能，本小节首先批量插入数据，然后验证基本的选择排序功能。</p>\n<ul>\n<li><strong>批量插入数据</strong></li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">CREATE</span> <span class=\"hljs-keyword\">TABLE</span> t1 <span class=\"hljs-keyword\">AS</span><br>     <span class=\"hljs-keyword\">SELECT</span> rownum <span class=\"hljs-keyword\">AS</span> id,<br>       trunc(dbms_random.value(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">100</span>)) <span class=\"hljs-keyword\">AS</span> random_id,<br>       dbms_random.string(<span class=\"hljs-string\">&#x27;x&#x27;</span>, <span class=\"hljs-number\">20</span>) <span class=\"hljs-keyword\">AS</span> random_string<br>     <span class=\"hljs-keyword\">FROM</span> dual<br>     <span class=\"hljs-keyword\">connect</span> <span class=\"hljs-keyword\">BY</span> level <span class=\"hljs-operator\">&lt;=</span> <span class=\"hljs-number\">100000</span>;<br></code></pre></td></tr></table></figure>\n\n<p>创建一个名为 <code>t1</code> 的新表，并向其中批量插入 100,000 条随机数据。</p>\n<p>具体地，这个 SQL 语句包含以下几个部分：</p>\n<ol>\n<li><code>CREATE TABLE t1 AS SELECT ...</code>：创建一个名为 <code>t1</code> 的新表，并使用 <code>SELECT</code> 语句从 <code>dual</code> 表生成数据。</li>\n<li><code>rownum AS id</code>：使用 <code>rownum</code> 函数生成一个序号列，并将其命名为 <code>id</code>。</li>\n<li><code>trunc(dbms_random.value(0, 100)) AS random_id</code>：使用 <code>dbms_random.value</code> 函数生成一个在 0 和 100 之间的随机数，并将其取整后命名为 <code>random_id</code>。</li>\n<li><code>dbms_random.string(&#39;x&#39;, 20) AS random_string</code>：使用 <code>dbms_random.string</code> 函数生成一个长度为 20 的随机字符串，并将其命名为 <code>random_string</code>。</li>\n<li><code>FROM dual connect BY level &lt;= 100000</code>：使用 <code>dual</code> 表和 <code>connect by level</code> 语句生成 100,000 条数据。</li>\n</ol>\n<p>在 <code>FROM</code> 子句中，使用 <code>DUAL</code> 表生成单行数据，然后使用 <code>CONNECT BY</code> 语法生成 100,000 行数据。在 <code>CONNECT BY</code> 子句中，使用 <code>LEVEL</code> 函数生成一个序号列，并使用 <code>LEVEL</code> 函数的值来控制生成的行数。</p>\n<p>在 <code>SELECT</code> 子句中，使用 <code>dbms_random</code> 包中的函数生成随机数和随机字符串，并使用 <code>trunc</code> 函数对随机数取整。最后，将生成的数据插入到新表 <code>t1</code> 中。</p>\n<p>需要注意的是，在达梦数据库中，语法和函数可能与 Oracle 数据库不同，请根据具体情况选择合适的语法和函数。</p>\n<ul>\n<li>查看插入的数据</li>\n</ul>\n<p>使用count(*) 聚集函数统计t1表中的总数据记录</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">SELECT</span> <span class=\"hljs-built_in\">COUNT</span>(<span class=\"hljs-operator\">*</span>) <span class=\"hljs-keyword\">FROM</span> t1;<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li>排序数据</li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">SELECT</span> <span class=\"hljs-operator\">*</span> <span class=\"hljs-keyword\">FROM</span> t1 <span class=\"hljs-keyword\">where</span> random_id<span class=\"hljs-operator\">&lt;</span><span class=\"hljs-number\">50</span> <span class=\"hljs-keyword\">ORDER</span> <span class=\"hljs-keyword\">BY</span> id <span class=\"hljs-keyword\">DESC</span>;<br></code></pre></td></tr></table></figure>\n\n\n<blockquote>\n<p>验证分组查询</p>\n</blockquote>\n<ul>\n<li>批量插入数据</li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">INSERT</span> <span class=\"hljs-keyword\">INTO</span> department (department_id, department_name)<br>     <span class=\"hljs-keyword\">SELECT</span> department_id, department_name <span class=\"hljs-keyword\">FROM</span> dmhr.department;<br>     <br><span class=\"hljs-keyword\">INSERT</span> <span class=\"hljs-keyword\">INTO</span> employee<br>     (employee_id, employee_name, hire_date, salary, department_id)<br>     <span class=\"hljs-keyword\">SELECT</span> employee_id, employee_name, hire_date, salary,<br>     department_id <span class=\"hljs-keyword\">FROM</span> dmhr.employee;<br>     <br><span class=\"hljs-keyword\">commit</span>;<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li>分组查询</li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">SELECT</span> dept.department_name <span class=\"hljs-keyword\">as</span> 部门, <span class=\"hljs-built_in\">count</span>(<span class=\"hljs-operator\">*</span>) <span class=\"hljs-keyword\">as</span> 人数<br>     <span class=\"hljs-keyword\">FROM</span> employee emp, department dept<br>     <span class=\"hljs-keyword\">where</span> emp.department_id<span class=\"hljs-operator\">=</span>dept.department_id<br>     <span class=\"hljs-keyword\">GROUP</span> <span class=\"hljs-keyword\">BY</span> dept.department_name<br>     <span class=\"hljs-keyword\">HAVING</span> <span class=\"hljs-built_in\">count</span>(<span class=\"hljs-operator\">*</span>) <span class=\"hljs-operator\">&gt;</span> <span class=\"hljs-number\">20</span>;<br></code></pre></td></tr></table></figure>\n\n<blockquote>\n<p>创建视图</p>\n</blockquote>\n<p>达梦数据库支持标准的视图功能，本小节将验证其对标准视图的支持能力。</p>\n<ul>\n<li>定义视图</li>\n</ul>\n<p>需要查询薪资大于 10000 且入职时间大于等于 2013 年 8 月 1 日 员工的部门名称、姓名、薪资、入职时间。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">CREATE</span> <span class=\"hljs-keyword\">OR</span> replace <span class=\"hljs-keyword\">VIEW</span> v1 <span class=\"hljs-keyword\">AS</span><br>     <span class=\"hljs-keyword\">SELECT</span> dept.department_name, emp.employee_name,<br>     emp.salary,emp.hire_date<br>     <span class=\"hljs-keyword\">FROM</span> employee emp, department dept<br>     <span class=\"hljs-keyword\">WHERE</span> salary <span class=\"hljs-operator\">&gt;</span> <span class=\"hljs-number\">10000</span><br>     <span class=\"hljs-keyword\">AND</span> hire_date <span class=\"hljs-operator\">&gt;=</span> <span class=\"hljs-string\">&#x27;2013-08-01&#x27;</span><br>     <span class=\"hljs-keyword\">AND</span> emp.department_id <span class=\"hljs-operator\">=</span> dept.department_id;<br></code></pre></td></tr></table></figure>\n\n<p><strong>视图的作用：</strong></p>\n<p>它的作用是从 employee 和 department 两个表中筛选出满足一定条件的记录，并将它们合并成一个结果集。具体来说，这个视图包含了四个字段，分别是：</p>\n<ul>\n<li>department_name：部门名称，来自 department 表；</li>\n<li>employee_name：员工姓名，来自 employee 表；</li>\n<li>salary：员工薪水，来自 employee 表；</li>\n<li>hire_date：员工入职日期，来自 employee 表。</li>\n</ul>\n<p>通过这个视图，我们就可以方便地查询所有<strong>符合以上三个条件的员工的信息</strong>，包括他们所在的部门、姓名、薪水和入职日期。视图可以看做是一个虚拟的表格，它不存储任何数据，而是通过查询操作来获取数据的。因此，我们可以像查询普通表格一样来查询这个视图，而不用关心它是如何生成的。</p>\n<ul>\n<li>通过视图简化查询符合多个条件的数据</li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">SELECT</span> <span class=\"hljs-operator\">*</span> <span class=\"hljs-keyword\">FROM</span> v1 <span class=\"hljs-keyword\">WHERE</span> hire_date <span class=\"hljs-operator\">&gt;</span> <span class=\"hljs-string\">&#x27;2014-09-01&#x27;</span>;<br></code></pre></td></tr></table></figure>\n\n<blockquote>\n<p>创建索引</p>\n</blockquote>\n<p>验证达梦数据库如何创建及删除索引，并通过索引提升查询效率。</p>\n<p>创建普通索引</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">create</span> index ind_emp_salary <span class=\"hljs-keyword\">on</span> employee(salary);<br></code></pre></td></tr></table></figure>\n\n\n\n\n\n<blockquote>\n<p>事务</p>\n</blockquote>\n<p>以下是常用的达梦数据库事务相关语句：</p>\n<p>​    1.开始事务：<code>START TRANSACTION</code> 或者 <code>BEGIN TRANSACTION</code></p>\n<figure class=\"highlight pgsql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs pgsql\"><span class=\"hljs-keyword\">START</span> <span class=\"hljs-keyword\">TRANSACTION</span>;<br><span class=\"hljs-comment\">-- 事务执行的 SQL 语句</span><br><span class=\"hljs-keyword\">COMMIT</span>;<br></code></pre></td></tr></table></figure>\n\n<p>​    2.回滚事务：<code>ROLLBACK</code></p>\n<figure class=\"highlight pgsql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs pgsql\"><span class=\"hljs-keyword\">START</span> <span class=\"hljs-keyword\">TRANSACTION</span>;<br><span class=\"hljs-comment\">-- 事务执行的 SQL 语句</span><br><span class=\"hljs-keyword\">ROLLBACK</span>;<br></code></pre></td></tr></table></figure>\n\n<p>​    3.提交事务：<code>COMMIT</code></p>\n<figure class=\"highlight pgsql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs pgsql\"><span class=\"hljs-keyword\">START</span> <span class=\"hljs-keyword\">TRANSACTION</span>;<br><span class=\"hljs-comment\">-- 事务执行的 SQL 语句</span><br><span class=\"hljs-keyword\">COMMIT</span>;<br></code></pre></td></tr></table></figure>\n\n<p>​    4.设置事务隔离级别：<code>SET TRANSACTION ISOLATION LEVEL</code></p>\n<figure class=\"highlight pgsql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs pgsql\"><span class=\"hljs-keyword\">SET</span> <span class=\"hljs-keyword\">TRANSACTION</span> <span class=\"hljs-keyword\">ISOLATION</span> <span class=\"hljs-keyword\">LEVEL</span> <span class=\"hljs-keyword\">READ</span> <span class=\"hljs-keyword\">COMMITTED</span>;<br></code></pre></td></tr></table></figure>\n\n<p>​    5.保存点：<code>SAVEPOINT</code> 和 <code>ROLLBACK TO SAVEPOINT</code></p>\n<figure class=\"highlight pgsql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs pgsql\"><span class=\"hljs-keyword\">START</span> <span class=\"hljs-keyword\">TRANSACTION</span>;<br><span class=\"hljs-comment\">-- 事务执行的 SQL 语句</span><br><span class=\"hljs-keyword\">SAVEPOINT</span> my_savepoint;<br><span class=\"hljs-comment\">-- 更多 SQL 语句</span><br><span class=\"hljs-keyword\">ROLLBACK</span> <span class=\"hljs-keyword\">TO</span> <span class=\"hljs-keyword\">SAVEPOINT</span> my_savepoint;<br><span class=\"hljs-comment\">-- 更多 SQL 语句</span><br><span class=\"hljs-keyword\">COMMIT</span>;<br></code></pre></td></tr></table></figure>\n\n<p>​    6.设置事务的名称：<code>SAVEPOINT</code></p>\n<figure class=\"highlight pgsql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs pgsql\"><span class=\"hljs-keyword\">SAVEPOINT</span> my_savepoint;<br><span class=\"hljs-comment\">-- 更多 SQL 语句</span><br><span class=\"hljs-keyword\">ROLLBACK</span> <span class=\"hljs-keyword\">TO</span> my_savepoint;<br><span class=\"hljs-comment\">-- 更多 SQL 语句</span><br><span class=\"hljs-keyword\">COMMIT</span>;<br></code></pre></td></tr></table></figure>\n\n<p>以上是常用的达梦数据库事务相关语句，您可以根据实际需求选择使用。请注意，在使用事务时，还需要注意锁定和事务隔离级别等问题，以避免出现并发问题和数据不一致的情况。</p>\n<p>待补充… …</p>\n"},{"title":"Educoder","index_img":"https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311151627635.png","abbrlink":6873,"date":"2022-09-07T06:07:56.000Z","_content":"\n* *写在前面：*\n\n​\t\t\t\t【免责声明：】本笔记发表在hexo博客只便于个人学习使用，若涉及到版权，请联系个人，谢谢！\n\n# educoder头歌Java笔记\n\n\n\n## *Coding中遇到的问题合集：*\n\n““.equals(name) 和name.equals(““) 的区别：\n\n​\t\t两个都是比较“”的地址和name的地址是否指向同一个地址，即判断name是否为“”；建议用前者，因为name可能是null，此时name.equals(\"\")就会报错，而前者则会避免这个问题\n\n避免了抛出空指针异常NullPointerException。\n\n\n\nleetcode回文数：\n\n* (s.charAt(i)).get(map)  &&  map.get(s.charAt(i))，问题同上；出现了抛出空指针异常的问题，使用前者后，测试通过。\n* 遇到了char与string的类型不匹配的情况，不可强制转换，最后利用string类的replace方法替换字符串，得到了解决。\n\n​\t\t\n\n##  对象的构造方法实例\n\n```Java\nimport java.util.Scanner;\n\npublic class Test {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tString name = sc.next();\n\t\tString sex = sc.next();\n\t\t/****** Begin ******/\n\t\t//分别使用两种构造器来创建Person对象  \n\t\tPerson a=new Person();\n\t\tPerson b=new Person(name,sex);\n\t\t/****** End ******/\n\t}\n}\n//创建Person对象，并创建两种构造方法\n/****** Begin ******/\nclass Person{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tclass swap{\n\tpublic Person(){\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tpublic swap(int a,int b,int c){\n\t\tSystem.out.println(\"一个人被创建了\");\t\t\t\t\t\t\tc=a;a=b;b=c;\n\n​\t}\n​\tpublic Person(String name,String sex){\n​\t\tSystem.out.println(\"姓名：\"+name+\"，性别：\"+sex+\"，被创建了\");\n​\t}\n}\n/****** End ******/\n```\n\n千万注意！！！！！\n变量名字一定看清楚，上面的代码中，误将name写成了neme!!!!!\n\n![image-20220617145157883](C:\\Users\\WLei224\\AppData\\Roaming\\Typora\\typora-user-images\\image-20220617145157883.png)\n\n`JAVA`中`变量`的命名和前面第一章所学的`标识符`命名规则是一样的，不过还是有一些不同，总结下来规则与规范一共有六点：\n\n1. 由字母，下划线，美元符号（$），数字组成，但第一个字符不能是数字。\n\n2. 如果变量名是复合型的那么我们采用驼峰式，或者蛇形式的方式。\n   驼峰式：`teaCup`（表示茶杯的意思），`stuAge`（学生年龄）\n   蛇形式：`tea_cup`，`stu_age`\n\n3. 如果是单个单词就全小写就行了。\n\n4. 千万不要用中文拼音来表达：例如学生年龄：`xueShengNianling`。\n\n5. 在一个方法中变量名不能重复。\n\n6. 变量一定要给自己一个确定的类型。\n\n   ## JAVA中的数据类型\n\n   `Java`基本类型共有八种，基本类型可以分为三类，字符类型`char`，布尔类型`boolean`以及数值类型`byte、short、int、long、float、double`。数值类型又可以分为整数类型`byte、short、int、long`和浮点数类型`float、double`。  \n\n   `基本类型不包括String`\n\n   ## java类型转换\n\n   ![image-20220617152252543](C:\\Users\\WLei224\\AppData\\Roaming\\Typora\\typora-user-images\\image-20220617152252543.png)\n\n\n\n强制类型转换就是将：**表数范围大的数向表数范围小的进行转换**。  \n\n## ![image-20220617152333029](C:\\Users\\WLei224\\AppData\\Roaming\\Typora\\typora-user-images\\image-20220617152333029.png)\t\n\n## 怎么使用Scanner\n\n​\t\t第一种方法：\n\n1. 在类的声明之前，引入扫描仪（`Scanner`）：\n\n   `import java.util.Scanner;`\n\n2. 在方法中创建一个扫描仪 \n\n   `Scanner input = new Scanner(System.in);`\n\n   \n\n   第二种方法：\n\n   引入并创建扫描器：`java.util.Scanner s = new java.util.Scanner(System.in); `\n\n   \n\n3. 通过扫描仪获取从键盘输入的数据 \n\n   `int i = input.nextInt();`\n\n   `String s = input.next();`\n\n   \n\n   #### 三目运算符之判断是否闰年？\n\n   \n\nresult=(year%400==0 || year%4==0 && year%100!=0)? true:false;\n\n​    System.out.println(year + \"年是否为闰年:\" + result);\n\n\n\n#### 运算符优先级别排序正确的是()\n\nA、 由高向低分别是:()、 ! 、算术运算符、关系运算符、逻辑运算符、赋值 运算符;\n\n\n\n## 循环综合练习：\n\n**Java中的两种循环：**\n\n在 Java 语言中，用于循环的语句有两个，一个是 for 循环，一个是 while 循环。而 for 循环其实还有两种实现方法，对于初学者来说，或许仅知道一般的 for 循环，即：\n\n```Java\nfor(初始化条件; 限制条件; 迭代语句) {\n    // 循环体\n}\n```\n\n而不太了解高级的 for 循环，即：\n\n```Java\nfor(变量类型 变量名 : 集合) {\n    // 循环体\n}\n```\n\n在本文中，咱们就一起来了解了解这两种 for 循环的使用方法以及区别。\n**demo示例：**\n\n```Java\nimport java.util.Arrays;\n\n/**\n * @author 维C果糖\n * @create 2017-03-31-上午9:30\n */\n\npublic class ForDemo {\n    public static void main(String[] args) {\n\n        int[] arr = new int[]{2, 0, 1, 5, 11, 20};\n\n        System.out.println(\"第一种 for 循环方法：\");\n\n        for (int i = 0; i < arr.length; i++) {\n            System.out.print(arr[i] + \" \");\n        }\n\n        System.out.println();\n\n        System.out.println(\"高级的 for 循环方法：\");\n\n        for (int i : arr){\n            System.out.print(i + \" \");\n\n        }\n\n        System.out.println();\n\n        System.out.println(\"用 Arrays 的 toString() 方法打印数组：\");\n\n        System.out.println(Arrays.toString(arr));\n    }\n}\n```\n\n**运行结果：**\n\n![for](https://img-blog.csdn.net/20170331095210507?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzUyNDY2MjA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n```Java\nATM经典案例：\n\npackage step4;\n\nimport java.util.Scanner;\n\npublic class ForPractice4 {\n\n  public static void main(String[] args) {\n\n​    /*****start*****/\n\n​    Scanner input = new Scanner(System.in);     \n\n   \n\n​    System.out.println(\"欢迎使用中国人民银行ATM取款机\");     //在循环体外，只输出一次  \n\n​    \n\n​    int capital = 1000;   //总资金  \n\n​    \n\n​    while(true) {                    //循环体设为true，无限循环\n\n​      System.out.println(\"输入取款金额：\");     //循环外层控制“输入金额”\n\n​      int a = input.nextInt();                  //准备接收输入数据\n\n​    \n\n​      if(a > capital) {                        //执行判断语句，如果输出金额大于总金额，则返回返回外层循环\n\n​        System.out.println(\"目前余额：\"+capital+\"无法满足您的取款需求！\");   \n\n​        continue;                          //返回外层循环\n\n​        \n\n​      }else {                           //如果“输入金额”小于capital，则，分支判断开始\n\n​          capital = capital - a;\n\n​          \n\n​          System.out.println(\"剩余金额：\"+capital+\"，是否继续（'1'：结束，'2'：继续）：\");\n\n​            //资金等于总资金 - 取款额度\n\n​          \n\n​          int change = input.nextInt();      //控制输入“1”，“2”，判断是否结束程序\n\n​          if (change == 1) {\n\n​            System.out.println(\"取款结束！\");    //如果为1，程序终止\n\n​            break;\n\n​            \n\n​          }else {                         //如果为其他，则返回外层循环\n\n​            continue;\n\n​          }\n\n​      }\n\n​    \n\n​    }\n\n​    /*****end*****/\n\n  }\n\n}\n```\n\n\n\n## 第1关：将给定的整数进行由小至大排序\n\n```\n int a;\n\n​    if(x>y){\n\n​      a=y;\n\n​      y=x;\n\n​      x=a;\n\n​    }\n\n​    \n\n​    if(x>z){\n\n​      a=x;\n\n​      x=z;\n\n​      z=a;\n\n​    }\n\n​    if(y>z){\n\n​      a=z;\n\n​      z=y;\n\n​      y=a;\n\n​    }\n```\n\n\n\n## 关于质数：（难度级别：⭐⭐⭐）\n\n级别1：解题代码2022-07-02 23:30已解锁\n\n```java\npackage step2;\npublic class FindZhiShu {\n    public static void main(String[] args) {\n        /**********begin**********/\n//由于偶数中只有2是质数，此处直接将2的值进行输出，如下代码中查找质数时，只需考虑奇数即可\n        System.out.print(2+\" \");\n        //定义标签\n        OUT:\n        //1不是质数，2是质数但是已经打印输出，因此循环中i的值从3开始即可，i+=2是因为在循环中我们不再考虑偶数\n        for (int i = 3; i <= 1000; i+=2) {\n        //请补充程序判断i是否是质数并打印i，如果是质数按照 System.out.print(i+\" \"); 格式进行打印 \n            for (int j = 2; j < i; j++) {\n                if(i % j == 0) {\n        //如果i对j求余数等于0说明i不是质数\n                    continue OUT;\n               }  \n           }            \n            //说明i是质数 \n           System.out.print(i+\" \"); \n       } \n        /**********end**********/ \n    }  \n```\n\n\n\n```java\npackage step2;\npublic class FindZhiShu {\n\tpublic static void main(String[] args) {\n\t\t   /*\n\t\t     打印输出质数的时候务必按照如下格式：System.out.print(质数+\" \")；\n\t\t     使用print进行打印同时被打印输出的质数后加上一个空格，\n\t\t     以便于与平台提供的结果格式保持一致！\n            */   \n\t\t   /**********begin**********/\n            a:for(int i = 2;i < 1000;i++){\t\t//此循环遍历次数较多，若对代码效率有要求，则可进一步改进代码：如下：\n                for(int j = 2;j<i;j++)\n                if(i%j==0){\n                    continue a;\n                }\n                System.out.print(i+\" \");\n            }\n           /**********end**********/\t\n\t}\n}\n\t\t**********************改进之后的代码*********************\npackage step2;\npublic class FindZhiShu {\n\tpublic static void main(String[] args) {\n\t\t   /*\n\t\t     打印输出质数的时候务必按照如下格式：System.out.print(质数+\" \")；\n\t\t     使用print进行打印同时被打印输出的质数后加上一个空格，\n\t\t     以便于与平台提供的结果格式保持一致！\n            */   \n\t\t   /**********begin**********/\n\n\tSystem.out.print(\"2 \");\t//因为2是特殊的质数，又因下面循环会自动跳过偶数，因此先将2打印出来。\n\t        a:for(int i = 3;i < 1000;i+=2){\n\t            for(int j = 2;j<i;j++)\n\t            if(i%j==0){\n\t                continue a;\t\t//此方法运用了给循环做标记，以此可以对continue和break进行明确的命令指示。\n\t            }\n\t            System.out.print(i+\" \");\n\t        }\n\t       /**********end**********/\t\n\t}\n\n}\n```\n\n\n\n\n\n## 拓展知识：（break与continue）\n\n##### break关键字\n\n先来看一段代码的运行效果，如下：\n\n   ![img](https://data.educoder.net/api/attachments/189112)  \n\n可以发现只要你一直输入`1`程序就会不断的提示你输入选项，可是当你输入`2`的时候程序就会终止，你能根据这个运行结果想到要实现这个效果，需要编写什么代码吗？\n可能你已经猜到了，需要使用到`break`关键字，`break`翻译过来是“打断”的意思，放在`Java`程序中的作用就是：**结束整个循环过程**\n好了，现在来一起看看刚刚那段效果的源代码吧。\n\n   ![img](https://data.educoder.net/api/attachments/189205)  \n\n现在你应该基本了解`break`的用法了，不过我还有个小秘密要告诉你：\n\n   ![img](https://data.educoder.net/api/attachments/189207)  \n\n如果我们在循环中使用`switch`语句，那么在`switch`语句中`break`就不能结束当前循环了，而只能结束`switch`语句。\n\n##### continue关键字\n\n`continue`关键字的用途是：**结束一次循环事件，开始下一个循环事件**，也就是忽略该语句之后的语句，执行循环体的下一次循环。\n例如：  \n\n```\nint i = 0;  while(i < 4){  if(i == 2){  i++;  continue;  }  System.out.println(i);  i++;  }\n```\n\n输出结果：\n`0`\n`1`\n`3`\n\n##### static关键字\n\n​\t\t关于静态代码块你只需要记住一句话：在**类被加载的时候**运行且**只运行一次**。\n\n​\t\t静态方法不能使用类的非静态变量；\n\n​\t\t静态方法可以直接调用静态方法，但是调用普通方法只能通过对象的实例才能调用。\n\n\n\n## 数组的两种初始化方法：\n\n#### 1.静态初始化\n\n**在程序运行前就能确定数组的大小和数组中的初始数据**我们称之为静态初始化。\n例如：  \n\n```Java\nfloat[] stuScores = {80.0f,70.0f,90.0f,66.5f};  int[] nums = {80,70, 90,66};  char[] chs = {‘a’,’b’, ‘c’,’d’};  \n```\n\n#### 2.动态初始化\n\n**数组的大小或数组中数据在程序运行时才能决定**，且用到`new`这个关键字来确定数组的大小或初始数据我们称之为动态初始化。\n定义数组：`变量类型[] 数组名 = new  数据类型 [ 数组长度 ];`  \n\n![img](https://data.educoder.net/api/attachments/189931)\n\n定义数组与初始化分离：  \n\n![img](https://data.educoder.net/api/attachments/189927)\n\n赋值：\n初始化之后就可以向数组中放数据了，数组中元素都是通过下标来访问的，例如向 `stuScores`数组中存放学生成绩：  \n\n![img](https://data.educoder.net/api/attachments/189928)\n\n#### 动态创建数组并循环赋值：\n\n```Java\nint[] arr = new int[sc.nextInt()];\n\nfor(int i = 0 ; i< arr.length ; i++){\n\n   arr[i] = sc.nextInt();\n\n}\n```\n\n\n\n## 数组基础\n\n#### 如何获取数组的长度：\n\n数组的`length`属性用于记录数组中有多少个元素或存储单元，即记录数组的长度是多少。  \n\n```\nint[] nums = new int[10];//声明一个int型数组并动态初始化其大小为10\nSystem.out.println(nums.length);//显示当前数组的大小  \n```\n\n输出：`10`\n\n\n\n#### 一维数组的遍历:\n\n通俗的理解，遍历数组就是：**把数组中的元素都看一遍**。\n\n示例如下：  \n\n```Java\nint[] arr = {1,3,5,7,9};  \nfor(int i = 0 ; i<arr.length; i++){\n\tSystem.out.print(arr[i] + \",\");  \n}  \n//输出：`1,3,5,7,9`\n```\n\n#### 二维数组的遍历：\n\n```\nfor(int i =0;i<scores.length;i++){\n            for(int j=0;j<scores[i].length;j++)\t\t//此处要加上遍历的行数，，即j<scores[i].length\n            System.out.println(scores[i][j]);\n            System.out.println();\n        }\n```\n\n\n\n#### 如何获取数组的最大值：\n\n要求出数组的最大值，是不是很像是打擂台呢？  \n\n![img](https://data.educoder.net/api/attachments/193188)\n\n对于一群人我们不知道谁最厉害，所以我们准备一个擂台，并挑选第一个人为擂主（max），擂台下的人不断的（循环）来挑战擂主。\n\n\n\n#### 数据类型强制转换：\n\n测试输入：`5`，`1`，`151`，`12`，`22`，`100`；   预期输出：\n`平均值：57.2`\n`最大值：151`\n\n提示：  \n\n```\nint a = 3;  int b = 2;  System.out.println(a/b);  System.out.println((double)a/b);  \n```\n\n输出：\n`1`\n`1.5`\n\n\n\n例题如下：\n\n#### 编程要求\n\n根据提示，在右侧编辑器`Begin-End`处补充代码，计算并输出数组的平均值和最大值。\n\n```java\npackage step3;\n\nimport java.util.Scanner;\n\npublic class HelloWorld {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tint[] scores = new int[sc.nextInt()];\n\t\t\n\t\t//循环给数组赋值\n\t\tfor(int i = 0 ; i< scores.length;i++){\n\t\t\tscores[i] = sc.nextInt();\n\t\t}\n\t\t/********** Begin **********/\n\t\t//在这里计算数组scores的平均值和最大值\n\t\tint sum=0,max=0;\n        double av=0;//此处是因为提前声明了一个double变量，否则则需要强制类型转换。\n        for(int i=0;i<scores.length;i++){\n            sum+=scores[i];\n        }\n        av=sum/scores.length;\n        for(int i=0;i<scores.length;i++){\n            if(max<scores[i]){\n                max=scores[i];\n            }\n        }\n\t\tSystem.out.println(\"平均值：\" +av ); \n        //若不声明多变量，则用这句强制转换类型。\n        //System.out.println(\"平均值：\" +(double)sum/scores.length );\n\t\tSystem.out.println(\"最大值：\" +max );\n\t\t/********** End **********/\n\t}\n}\n\n```\n\n\n\n#### 获取二维数组的行列长度：\n\n二维数组定义：`int array[][] = new int[3][3];`\n获取行数： `int rowLength = array.length;`\n获取列数： `int colLength = array[0].length;`\n\n#### 二维数组的遍历\n\n```java\nclass Test{\n\tfor(int i = 0; i < array.length; i++){\n\t\tfor(int j = 0; j < array[i].length; j++){\t\t//此处要加上遍历的行数，，即j<scores[i].length\n\t\t\tSystem.out.println(array[i][j);\n\t\t}\n\t}\n}\n```\n\n\n\n#### *知识拓展*\n\n**for-each**\n\nfor-each 循环通常用于遍历数组和集合，它的使用规则比普通的 for 循环还要简单，不需要初始变量，不需要条件，不需要下标来自增或者自减。来看一下语法：\n\n\n\n```java\nfor(元素类型 元素 : 数组或集合){  \n// 要执行的代码\n}  \n```\n\n来看一下示例：\n\n\n\n```java\npublic class ForEachExample {\n    public static void main(String[] args) {\n        String[] strs = {\"沉默王二\", \"一枚有趣的程序员\"};\n\n        for (String str : strs) {\n            System.out.println(str);\n        }\n    }\n}\n```\n\n输出：\n\n\n\n```text\n沉默王二\n一枚有趣的程序员\n```\n\n#### 两数交换:\n\n两个变量数值的交换有三种换发：\n\n（1）借助中间量交换 （开发常用）\n\n理解：三个杯子，两杯装水，其中一个空杯子用作容器。\n\nint x = 10;\nint y = 20;\nint z = x;\nx = y;\ny = z;\n　（2）位移运算交换 （面试常用）\n\n理解：涉及到了异或运算符的规则：一个数对另一个数位异或两次，该数不变\n\nint x = 10;\nint y = 20;\nx = x ^ y;\ny = x ^ y;\nx = x ^ y;\n　（3）数值相加减交换\n\n理解：先求得两数的和再进行减运算\n\nint x = 10;\nint y = 20;\nx = x + y;\ny = x - y;\nx = x - y;\n\n\n\n## 排序\n\n#### 选择排序：\n\n##### 实现过程\n\n为了实现选择排序，我们需要**求出最大值**，并且和相比较的数据**交换位置**：接下来我们对数组`int[] arr = {6,5,8,0,2,9}`来进行**第一趟循环**，将最大值移动到数组的第一位。\n\n![img](https://data.educoder.net/api/attachments/191743)\n\n代码实现：  \n\n```\nint[] arr = {6,5,8,0,2,9};for (int i = 0; i < arr.length-1; i++) {      if(arr[0] < arr[i+1]){          int temp = arr[0];          arr[0] = arr[i+1];          arr[i+1] = temp;      }  }  \n```\n\n一次循环操作就可以找出数组中的最大值，并将其移动到数组的首位，所以对于一个长度为`6`的数组，我们只需要进行`5`（length-1）次上述操作即可将数组降序排序了。\n\n接下来我们进行**第二趟循环**，求第二大的值，并将其移动到数组的第二个位置。因为我们已经求出了最大值，所以这一次循环，最大值不用参与比较。  \n\n![img](https://data.educoder.net/api/attachments/191767)\n\n代码实现：  \n\n![img](https://data.educoder.net/api/attachments/191770)\n\n结果：`[9, 8, 5, 0, 2, 6]`\n\n可以发现经过两轮循环我们找出了数组中最大的两个值，并且移动他们到了数组的前两位。\n\n现在按照上述步骤就可以实现数组的排序了，不过如果我们照搬上述代码，就会有很多冗余的代码，所以需要你来改进，怎么改进是需要你思考的。\n\n**告诉你一个秘密**：使用`Arrays.toString(数组)`可以直接输出数组中的值哦！\n如下：  \n\n![img](https://data.educoder.net/api/attachments/191773)\n\n输出结果：`[6, 5, 8, 0, 2, 9]`\n\n**思考题**：\n\n本关所讲述的选择排序是一个简化版本，如果你想要学习优化版可以根据下列图片，编写出相应代码，然后在评论区贴出来哦。  \n\n![ ](https://data.educoder.net/api/attachments/192416)\n\n上图就是一个使用选择排序将一个数组中数据从小到大排序的过程，请思考如何用代码实现上述过程。\n\n原理：每一次从待排序的数据元素中选出最小的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完。\n\n------\n\n本关难度较大，但这是学习数组绕不过去的一关，多思考，多尝试，你能成功的，加油！ \n\n\n\n\n\n","source":"_posts/Educoder.md","raw":"---\ntitle: Educoder\nindex_img: https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311151627635.png\ncategories:\n  - Java notes\ntags:\n  - educoder\nabbrlink: 6873\ndate: 2022-09-07 14:07:56\n---\n\n* *写在前面：*\n\n​\t\t\t\t【免责声明：】本笔记发表在hexo博客只便于个人学习使用，若涉及到版权，请联系个人，谢谢！\n\n# educoder头歌Java笔记\n\n\n\n## *Coding中遇到的问题合集：*\n\n““.equals(name) 和name.equals(““) 的区别：\n\n​\t\t两个都是比较“”的地址和name的地址是否指向同一个地址，即判断name是否为“”；建议用前者，因为name可能是null，此时name.equals(\"\")就会报错，而前者则会避免这个问题\n\n避免了抛出空指针异常NullPointerException。\n\n\n\nleetcode回文数：\n\n* (s.charAt(i)).get(map)  &&  map.get(s.charAt(i))，问题同上；出现了抛出空指针异常的问题，使用前者后，测试通过。\n* 遇到了char与string的类型不匹配的情况，不可强制转换，最后利用string类的replace方法替换字符串，得到了解决。\n\n​\t\t\n\n##  对象的构造方法实例\n\n```Java\nimport java.util.Scanner;\n\npublic class Test {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tString name = sc.next();\n\t\tString sex = sc.next();\n\t\t/****** Begin ******/\n\t\t//分别使用两种构造器来创建Person对象  \n\t\tPerson a=new Person();\n\t\tPerson b=new Person(name,sex);\n\t\t/****** End ******/\n\t}\n}\n//创建Person对象，并创建两种构造方法\n/****** Begin ******/\nclass Person{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tclass swap{\n\tpublic Person(){\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tpublic swap(int a,int b,int c){\n\t\tSystem.out.println(\"一个人被创建了\");\t\t\t\t\t\t\tc=a;a=b;b=c;\n\n​\t}\n​\tpublic Person(String name,String sex){\n​\t\tSystem.out.println(\"姓名：\"+name+\"，性别：\"+sex+\"，被创建了\");\n​\t}\n}\n/****** End ******/\n```\n\n千万注意！！！！！\n变量名字一定看清楚，上面的代码中，误将name写成了neme!!!!!\n\n![image-20220617145157883](C:\\Users\\WLei224\\AppData\\Roaming\\Typora\\typora-user-images\\image-20220617145157883.png)\n\n`JAVA`中`变量`的命名和前面第一章所学的`标识符`命名规则是一样的，不过还是有一些不同，总结下来规则与规范一共有六点：\n\n1. 由字母，下划线，美元符号（$），数字组成，但第一个字符不能是数字。\n\n2. 如果变量名是复合型的那么我们采用驼峰式，或者蛇形式的方式。\n   驼峰式：`teaCup`（表示茶杯的意思），`stuAge`（学生年龄）\n   蛇形式：`tea_cup`，`stu_age`\n\n3. 如果是单个单词就全小写就行了。\n\n4. 千万不要用中文拼音来表达：例如学生年龄：`xueShengNianling`。\n\n5. 在一个方法中变量名不能重复。\n\n6. 变量一定要给自己一个确定的类型。\n\n   ## JAVA中的数据类型\n\n   `Java`基本类型共有八种，基本类型可以分为三类，字符类型`char`，布尔类型`boolean`以及数值类型`byte、short、int、long、float、double`。数值类型又可以分为整数类型`byte、short、int、long`和浮点数类型`float、double`。  \n\n   `基本类型不包括String`\n\n   ## java类型转换\n\n   ![image-20220617152252543](C:\\Users\\WLei224\\AppData\\Roaming\\Typora\\typora-user-images\\image-20220617152252543.png)\n\n\n\n强制类型转换就是将：**表数范围大的数向表数范围小的进行转换**。  \n\n## ![image-20220617152333029](C:\\Users\\WLei224\\AppData\\Roaming\\Typora\\typora-user-images\\image-20220617152333029.png)\t\n\n## 怎么使用Scanner\n\n​\t\t第一种方法：\n\n1. 在类的声明之前，引入扫描仪（`Scanner`）：\n\n   `import java.util.Scanner;`\n\n2. 在方法中创建一个扫描仪 \n\n   `Scanner input = new Scanner(System.in);`\n\n   \n\n   第二种方法：\n\n   引入并创建扫描器：`java.util.Scanner s = new java.util.Scanner(System.in); `\n\n   \n\n3. 通过扫描仪获取从键盘输入的数据 \n\n   `int i = input.nextInt();`\n\n   `String s = input.next();`\n\n   \n\n   #### 三目运算符之判断是否闰年？\n\n   \n\nresult=(year%400==0 || year%4==0 && year%100!=0)? true:false;\n\n​    System.out.println(year + \"年是否为闰年:\" + result);\n\n\n\n#### 运算符优先级别排序正确的是()\n\nA、 由高向低分别是:()、 ! 、算术运算符、关系运算符、逻辑运算符、赋值 运算符;\n\n\n\n## 循环综合练习：\n\n**Java中的两种循环：**\n\n在 Java 语言中，用于循环的语句有两个，一个是 for 循环，一个是 while 循环。而 for 循环其实还有两种实现方法，对于初学者来说，或许仅知道一般的 for 循环，即：\n\n```Java\nfor(初始化条件; 限制条件; 迭代语句) {\n    // 循环体\n}\n```\n\n而不太了解高级的 for 循环，即：\n\n```Java\nfor(变量类型 变量名 : 集合) {\n    // 循环体\n}\n```\n\n在本文中，咱们就一起来了解了解这两种 for 循环的使用方法以及区别。\n**demo示例：**\n\n```Java\nimport java.util.Arrays;\n\n/**\n * @author 维C果糖\n * @create 2017-03-31-上午9:30\n */\n\npublic class ForDemo {\n    public static void main(String[] args) {\n\n        int[] arr = new int[]{2, 0, 1, 5, 11, 20};\n\n        System.out.println(\"第一种 for 循环方法：\");\n\n        for (int i = 0; i < arr.length; i++) {\n            System.out.print(arr[i] + \" \");\n        }\n\n        System.out.println();\n\n        System.out.println(\"高级的 for 循环方法：\");\n\n        for (int i : arr){\n            System.out.print(i + \" \");\n\n        }\n\n        System.out.println();\n\n        System.out.println(\"用 Arrays 的 toString() 方法打印数组：\");\n\n        System.out.println(Arrays.toString(arr));\n    }\n}\n```\n\n**运行结果：**\n\n![for](https://img-blog.csdn.net/20170331095210507?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzUyNDY2MjA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n```Java\nATM经典案例：\n\npackage step4;\n\nimport java.util.Scanner;\n\npublic class ForPractice4 {\n\n  public static void main(String[] args) {\n\n​    /*****start*****/\n\n​    Scanner input = new Scanner(System.in);     \n\n   \n\n​    System.out.println(\"欢迎使用中国人民银行ATM取款机\");     //在循环体外，只输出一次  \n\n​    \n\n​    int capital = 1000;   //总资金  \n\n​    \n\n​    while(true) {                    //循环体设为true，无限循环\n\n​      System.out.println(\"输入取款金额：\");     //循环外层控制“输入金额”\n\n​      int a = input.nextInt();                  //准备接收输入数据\n\n​    \n\n​      if(a > capital) {                        //执行判断语句，如果输出金额大于总金额，则返回返回外层循环\n\n​        System.out.println(\"目前余额：\"+capital+\"无法满足您的取款需求！\");   \n\n​        continue;                          //返回外层循环\n\n​        \n\n​      }else {                           //如果“输入金额”小于capital，则，分支判断开始\n\n​          capital = capital - a;\n\n​          \n\n​          System.out.println(\"剩余金额：\"+capital+\"，是否继续（'1'：结束，'2'：继续）：\");\n\n​            //资金等于总资金 - 取款额度\n\n​          \n\n​          int change = input.nextInt();      //控制输入“1”，“2”，判断是否结束程序\n\n​          if (change == 1) {\n\n​            System.out.println(\"取款结束！\");    //如果为1，程序终止\n\n​            break;\n\n​            \n\n​          }else {                         //如果为其他，则返回外层循环\n\n​            continue;\n\n​          }\n\n​      }\n\n​    \n\n​    }\n\n​    /*****end*****/\n\n  }\n\n}\n```\n\n\n\n## 第1关：将给定的整数进行由小至大排序\n\n```\n int a;\n\n​    if(x>y){\n\n​      a=y;\n\n​      y=x;\n\n​      x=a;\n\n​    }\n\n​    \n\n​    if(x>z){\n\n​      a=x;\n\n​      x=z;\n\n​      z=a;\n\n​    }\n\n​    if(y>z){\n\n​      a=z;\n\n​      z=y;\n\n​      y=a;\n\n​    }\n```\n\n\n\n## 关于质数：（难度级别：⭐⭐⭐）\n\n级别1：解题代码2022-07-02 23:30已解锁\n\n```java\npackage step2;\npublic class FindZhiShu {\n    public static void main(String[] args) {\n        /**********begin**********/\n//由于偶数中只有2是质数，此处直接将2的值进行输出，如下代码中查找质数时，只需考虑奇数即可\n        System.out.print(2+\" \");\n        //定义标签\n        OUT:\n        //1不是质数，2是质数但是已经打印输出，因此循环中i的值从3开始即可，i+=2是因为在循环中我们不再考虑偶数\n        for (int i = 3; i <= 1000; i+=2) {\n        //请补充程序判断i是否是质数并打印i，如果是质数按照 System.out.print(i+\" \"); 格式进行打印 \n            for (int j = 2; j < i; j++) {\n                if(i % j == 0) {\n        //如果i对j求余数等于0说明i不是质数\n                    continue OUT;\n               }  \n           }            \n            //说明i是质数 \n           System.out.print(i+\" \"); \n       } \n        /**********end**********/ \n    }  \n```\n\n\n\n```java\npackage step2;\npublic class FindZhiShu {\n\tpublic static void main(String[] args) {\n\t\t   /*\n\t\t     打印输出质数的时候务必按照如下格式：System.out.print(质数+\" \")；\n\t\t     使用print进行打印同时被打印输出的质数后加上一个空格，\n\t\t     以便于与平台提供的结果格式保持一致！\n            */   \n\t\t   /**********begin**********/\n            a:for(int i = 2;i < 1000;i++){\t\t//此循环遍历次数较多，若对代码效率有要求，则可进一步改进代码：如下：\n                for(int j = 2;j<i;j++)\n                if(i%j==0){\n                    continue a;\n                }\n                System.out.print(i+\" \");\n            }\n           /**********end**********/\t\n\t}\n}\n\t\t**********************改进之后的代码*********************\npackage step2;\npublic class FindZhiShu {\n\tpublic static void main(String[] args) {\n\t\t   /*\n\t\t     打印输出质数的时候务必按照如下格式：System.out.print(质数+\" \")；\n\t\t     使用print进行打印同时被打印输出的质数后加上一个空格，\n\t\t     以便于与平台提供的结果格式保持一致！\n            */   \n\t\t   /**********begin**********/\n\n\tSystem.out.print(\"2 \");\t//因为2是特殊的质数，又因下面循环会自动跳过偶数，因此先将2打印出来。\n\t        a:for(int i = 3;i < 1000;i+=2){\n\t            for(int j = 2;j<i;j++)\n\t            if(i%j==0){\n\t                continue a;\t\t//此方法运用了给循环做标记，以此可以对continue和break进行明确的命令指示。\n\t            }\n\t            System.out.print(i+\" \");\n\t        }\n\t       /**********end**********/\t\n\t}\n\n}\n```\n\n\n\n\n\n## 拓展知识：（break与continue）\n\n##### break关键字\n\n先来看一段代码的运行效果，如下：\n\n   ![img](https://data.educoder.net/api/attachments/189112)  \n\n可以发现只要你一直输入`1`程序就会不断的提示你输入选项，可是当你输入`2`的时候程序就会终止，你能根据这个运行结果想到要实现这个效果，需要编写什么代码吗？\n可能你已经猜到了，需要使用到`break`关键字，`break`翻译过来是“打断”的意思，放在`Java`程序中的作用就是：**结束整个循环过程**\n好了，现在来一起看看刚刚那段效果的源代码吧。\n\n   ![img](https://data.educoder.net/api/attachments/189205)  \n\n现在你应该基本了解`break`的用法了，不过我还有个小秘密要告诉你：\n\n   ![img](https://data.educoder.net/api/attachments/189207)  \n\n如果我们在循环中使用`switch`语句，那么在`switch`语句中`break`就不能结束当前循环了，而只能结束`switch`语句。\n\n##### continue关键字\n\n`continue`关键字的用途是：**结束一次循环事件，开始下一个循环事件**，也就是忽略该语句之后的语句，执行循环体的下一次循环。\n例如：  \n\n```\nint i = 0;  while(i < 4){  if(i == 2){  i++;  continue;  }  System.out.println(i);  i++;  }\n```\n\n输出结果：\n`0`\n`1`\n`3`\n\n##### static关键字\n\n​\t\t关于静态代码块你只需要记住一句话：在**类被加载的时候**运行且**只运行一次**。\n\n​\t\t静态方法不能使用类的非静态变量；\n\n​\t\t静态方法可以直接调用静态方法，但是调用普通方法只能通过对象的实例才能调用。\n\n\n\n## 数组的两种初始化方法：\n\n#### 1.静态初始化\n\n**在程序运行前就能确定数组的大小和数组中的初始数据**我们称之为静态初始化。\n例如：  \n\n```Java\nfloat[] stuScores = {80.0f,70.0f,90.0f,66.5f};  int[] nums = {80,70, 90,66};  char[] chs = {‘a’,’b’, ‘c’,’d’};  \n```\n\n#### 2.动态初始化\n\n**数组的大小或数组中数据在程序运行时才能决定**，且用到`new`这个关键字来确定数组的大小或初始数据我们称之为动态初始化。\n定义数组：`变量类型[] 数组名 = new  数据类型 [ 数组长度 ];`  \n\n![img](https://data.educoder.net/api/attachments/189931)\n\n定义数组与初始化分离：  \n\n![img](https://data.educoder.net/api/attachments/189927)\n\n赋值：\n初始化之后就可以向数组中放数据了，数组中元素都是通过下标来访问的，例如向 `stuScores`数组中存放学生成绩：  \n\n![img](https://data.educoder.net/api/attachments/189928)\n\n#### 动态创建数组并循环赋值：\n\n```Java\nint[] arr = new int[sc.nextInt()];\n\nfor(int i = 0 ; i< arr.length ; i++){\n\n   arr[i] = sc.nextInt();\n\n}\n```\n\n\n\n## 数组基础\n\n#### 如何获取数组的长度：\n\n数组的`length`属性用于记录数组中有多少个元素或存储单元，即记录数组的长度是多少。  \n\n```\nint[] nums = new int[10];//声明一个int型数组并动态初始化其大小为10\nSystem.out.println(nums.length);//显示当前数组的大小  \n```\n\n输出：`10`\n\n\n\n#### 一维数组的遍历:\n\n通俗的理解，遍历数组就是：**把数组中的元素都看一遍**。\n\n示例如下：  \n\n```Java\nint[] arr = {1,3,5,7,9};  \nfor(int i = 0 ; i<arr.length; i++){\n\tSystem.out.print(arr[i] + \",\");  \n}  \n//输出：`1,3,5,7,9`\n```\n\n#### 二维数组的遍历：\n\n```\nfor(int i =0;i<scores.length;i++){\n            for(int j=0;j<scores[i].length;j++)\t\t//此处要加上遍历的行数，，即j<scores[i].length\n            System.out.println(scores[i][j]);\n            System.out.println();\n        }\n```\n\n\n\n#### 如何获取数组的最大值：\n\n要求出数组的最大值，是不是很像是打擂台呢？  \n\n![img](https://data.educoder.net/api/attachments/193188)\n\n对于一群人我们不知道谁最厉害，所以我们准备一个擂台，并挑选第一个人为擂主（max），擂台下的人不断的（循环）来挑战擂主。\n\n\n\n#### 数据类型强制转换：\n\n测试输入：`5`，`1`，`151`，`12`，`22`，`100`；   预期输出：\n`平均值：57.2`\n`最大值：151`\n\n提示：  \n\n```\nint a = 3;  int b = 2;  System.out.println(a/b);  System.out.println((double)a/b);  \n```\n\n输出：\n`1`\n`1.5`\n\n\n\n例题如下：\n\n#### 编程要求\n\n根据提示，在右侧编辑器`Begin-End`处补充代码，计算并输出数组的平均值和最大值。\n\n```java\npackage step3;\n\nimport java.util.Scanner;\n\npublic class HelloWorld {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tint[] scores = new int[sc.nextInt()];\n\t\t\n\t\t//循环给数组赋值\n\t\tfor(int i = 0 ; i< scores.length;i++){\n\t\t\tscores[i] = sc.nextInt();\n\t\t}\n\t\t/********** Begin **********/\n\t\t//在这里计算数组scores的平均值和最大值\n\t\tint sum=0,max=0;\n        double av=0;//此处是因为提前声明了一个double变量，否则则需要强制类型转换。\n        for(int i=0;i<scores.length;i++){\n            sum+=scores[i];\n        }\n        av=sum/scores.length;\n        for(int i=0;i<scores.length;i++){\n            if(max<scores[i]){\n                max=scores[i];\n            }\n        }\n\t\tSystem.out.println(\"平均值：\" +av ); \n        //若不声明多变量，则用这句强制转换类型。\n        //System.out.println(\"平均值：\" +(double)sum/scores.length );\n\t\tSystem.out.println(\"最大值：\" +max );\n\t\t/********** End **********/\n\t}\n}\n\n```\n\n\n\n#### 获取二维数组的行列长度：\n\n二维数组定义：`int array[][] = new int[3][3];`\n获取行数： `int rowLength = array.length;`\n获取列数： `int colLength = array[0].length;`\n\n#### 二维数组的遍历\n\n```java\nclass Test{\n\tfor(int i = 0; i < array.length; i++){\n\t\tfor(int j = 0; j < array[i].length; j++){\t\t//此处要加上遍历的行数，，即j<scores[i].length\n\t\t\tSystem.out.println(array[i][j);\n\t\t}\n\t}\n}\n```\n\n\n\n#### *知识拓展*\n\n**for-each**\n\nfor-each 循环通常用于遍历数组和集合，它的使用规则比普通的 for 循环还要简单，不需要初始变量，不需要条件，不需要下标来自增或者自减。来看一下语法：\n\n\n\n```java\nfor(元素类型 元素 : 数组或集合){  \n// 要执行的代码\n}  \n```\n\n来看一下示例：\n\n\n\n```java\npublic class ForEachExample {\n    public static void main(String[] args) {\n        String[] strs = {\"沉默王二\", \"一枚有趣的程序员\"};\n\n        for (String str : strs) {\n            System.out.println(str);\n        }\n    }\n}\n```\n\n输出：\n\n\n\n```text\n沉默王二\n一枚有趣的程序员\n```\n\n#### 两数交换:\n\n两个变量数值的交换有三种换发：\n\n（1）借助中间量交换 （开发常用）\n\n理解：三个杯子，两杯装水，其中一个空杯子用作容器。\n\nint x = 10;\nint y = 20;\nint z = x;\nx = y;\ny = z;\n　（2）位移运算交换 （面试常用）\n\n理解：涉及到了异或运算符的规则：一个数对另一个数位异或两次，该数不变\n\nint x = 10;\nint y = 20;\nx = x ^ y;\ny = x ^ y;\nx = x ^ y;\n　（3）数值相加减交换\n\n理解：先求得两数的和再进行减运算\n\nint x = 10;\nint y = 20;\nx = x + y;\ny = x - y;\nx = x - y;\n\n\n\n## 排序\n\n#### 选择排序：\n\n##### 实现过程\n\n为了实现选择排序，我们需要**求出最大值**，并且和相比较的数据**交换位置**：接下来我们对数组`int[] arr = {6,5,8,0,2,9}`来进行**第一趟循环**，将最大值移动到数组的第一位。\n\n![img](https://data.educoder.net/api/attachments/191743)\n\n代码实现：  \n\n```\nint[] arr = {6,5,8,0,2,9};for (int i = 0; i < arr.length-1; i++) {      if(arr[0] < arr[i+1]){          int temp = arr[0];          arr[0] = arr[i+1];          arr[i+1] = temp;      }  }  \n```\n\n一次循环操作就可以找出数组中的最大值，并将其移动到数组的首位，所以对于一个长度为`6`的数组，我们只需要进行`5`（length-1）次上述操作即可将数组降序排序了。\n\n接下来我们进行**第二趟循环**，求第二大的值，并将其移动到数组的第二个位置。因为我们已经求出了最大值，所以这一次循环，最大值不用参与比较。  \n\n![img](https://data.educoder.net/api/attachments/191767)\n\n代码实现：  \n\n![img](https://data.educoder.net/api/attachments/191770)\n\n结果：`[9, 8, 5, 0, 2, 6]`\n\n可以发现经过两轮循环我们找出了数组中最大的两个值，并且移动他们到了数组的前两位。\n\n现在按照上述步骤就可以实现数组的排序了，不过如果我们照搬上述代码，就会有很多冗余的代码，所以需要你来改进，怎么改进是需要你思考的。\n\n**告诉你一个秘密**：使用`Arrays.toString(数组)`可以直接输出数组中的值哦！\n如下：  \n\n![img](https://data.educoder.net/api/attachments/191773)\n\n输出结果：`[6, 5, 8, 0, 2, 9]`\n\n**思考题**：\n\n本关所讲述的选择排序是一个简化版本，如果你想要学习优化版可以根据下列图片，编写出相应代码，然后在评论区贴出来哦。  \n\n![ ](https://data.educoder.net/api/attachments/192416)\n\n上图就是一个使用选择排序将一个数组中数据从小到大排序的过程，请思考如何用代码实现上述过程。\n\n原理：每一次从待排序的数据元素中选出最小的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完。\n\n------\n\n本关难度较大，但这是学习数组绕不过去的一关，多思考，多尝试，你能成功的，加油！ \n\n\n\n\n\n","slug":"Educoder","published":1,"updated":"2023-11-15T09:20:05.116Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clpkiczih000afkfo3ex10wnn","content":"<ul>\n<li><em>写在前面：</em></li>\n</ul>\n<p>​                【免责声明：】本笔记发表在hexo博客只便于个人学习使用，若涉及到版权，请联系个人，谢谢！</p>\n<h1 id=\"educoder头歌Java笔记\"><a href=\"#educoder头歌Java笔记\" class=\"headerlink\" title=\"educoder头歌Java笔记\"></a>educoder头歌Java笔记</h1><h2 id=\"Coding中遇到的问题合集：\"><a href=\"#Coding中遇到的问题合集：\" class=\"headerlink\" title=\"Coding中遇到的问题合集：\"></a><em>Coding中遇到的问题合集：</em></h2><p>““.equals(name) 和name.equals(““) 的区别：</p>\n<p>​        两个都是比较“”的地址和name的地址是否指向同一个地址，即判断name是否为“”；建议用前者，因为name可能是null，此时name.equals(“”)就会报错，而前者则会避免这个问题</p>\n<p>避免了抛出空指针异常NullPointerException。</p>\n<p>leetcode回文数：</p>\n<ul>\n<li>(s.charAt(i)).get(map)  &amp;&amp;  map.get(s.charAt(i))，问题同上；出现了抛出空指针异常的问题，使用前者后，测试通过。</li>\n<li>遇到了char与string的类型不匹配的情况，不可强制转换，最后利用string类的replace方法替换字符串，得到了解决。</li>\n</ul>\n<p>​        </p>\n<h2 id=\"对象的构造方法实例\"><a href=\"#对象的构造方法实例\" class=\"headerlink\" title=\"对象的构造方法实例\"></a>对象的构造方法实例</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Java\"><span class=\"hljs-keyword\">import</span> java.util.Scanner;<br><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Test</span> &#123;<br>\t<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> &#123;<br>\t\t<span class=\"hljs-type\">Scanner</span> <span class=\"hljs-variable\">sc</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Scanner</span>(System.in);<br>\t\t<span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">name</span> <span class=\"hljs-operator\">=</span> sc.next();<br>\t\t<span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">sex</span> <span class=\"hljs-operator\">=</span> sc.next();<br>\t\t<span class=\"hljs-comment\">/****** Begin ******/</span><br>\t\t<span class=\"hljs-comment\">//分别使用两种构造器来创建Person对象  </span><br>\t\tPerson a=<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Person</span>();<br>\t\tPerson b=<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Person</span>(name,sex);<br>\t\t<span class=\"hljs-comment\">/****** End ******/</span><br>\t&#125;<br>&#125;<br><span class=\"hljs-comment\">//创建Person对象，并创建两种构造方法</span><br><span class=\"hljs-comment\">/****** Begin ******/</span><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Person</span>&#123;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">swap</span>&#123;<br>\t<span class=\"hljs-keyword\">public</span> <span class=\"hljs-title function_\">Person</span><span class=\"hljs-params\">()</span>&#123;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t<span class=\"hljs-keyword\">public</span> <span class=\"hljs-title function_\">swap</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> a,<span class=\"hljs-type\">int</span> b,<span class=\"hljs-type\">int</span> c)</span>&#123;<br>\t\tSystem.out.println(<span class=\"hljs-string\">&quot;一个人被创建了&quot;</span>);\t\t\t\t\t\t\tc=a;a=b;b=c;<br><br>​\t&#125;<br>​\t<span class=\"hljs-keyword\">public</span> <span class=\"hljs-title function_\">Person</span><span class=\"hljs-params\">(String name,String sex)</span>&#123;<br>​\t\tSystem.out.println(<span class=\"hljs-string\">&quot;姓名：&quot;</span>+name+<span class=\"hljs-string\">&quot;，性别：&quot;</span>+sex+<span class=\"hljs-string\">&quot;，被创建了&quot;</span>);<br>​\t&#125;<br>&#125;<br><span class=\"hljs-comment\">/****** End ******/</span><br></code></pre></td></tr></table></figure>\n\n<p>千万注意！！！！！<br>变量名字一定看清楚，上面的代码中，误将name写成了neme!!!!!</p>\n<p><img src=\"C:\\Users\\WLei224\\AppData\\Roaming\\Typora\\typora-user-images\\image-20220617145157883.png\" alt=\"image-20220617145157883\"></p>\n<p><code>JAVA</code>中<code>变量</code>的命名和前面第一章所学的<code>标识符</code>命名规则是一样的，不过还是有一些不同，总结下来规则与规范一共有六点：</p>\n<ol>\n<li><p>由字母，下划线，美元符号（$），数字组成，但第一个字符不能是数字。</p>\n</li>\n<li><p>如果变量名是复合型的那么我们采用驼峰式，或者蛇形式的方式。<br>驼峰式：<code>teaCup</code>（表示茶杯的意思），<code>stuAge</code>（学生年龄）<br>蛇形式：<code>tea_cup</code>，<code>stu_age</code></p>\n</li>\n<li><p>如果是单个单词就全小写就行了。</p>\n</li>\n<li><p>千万不要用中文拼音来表达：例如学生年龄：<code>xueShengNianling</code>。</p>\n</li>\n<li><p>在一个方法中变量名不能重复。</p>\n</li>\n<li><p>变量一定要给自己一个确定的类型。</p>\n<h2 id=\"JAVA中的数据类型\"><a href=\"#JAVA中的数据类型\" class=\"headerlink\" title=\"JAVA中的数据类型\"></a>JAVA中的数据类型</h2><p><code>Java</code>基本类型共有八种，基本类型可以分为三类，字符类型<code>char</code>，布尔类型<code>boolean</code>以及数值类型<code>byte、short、int、long、float、double</code>。数值类型又可以分为整数类型<code>byte、short、int、long</code>和浮点数类型<code>float、double</code>。  </p>\n<p><code>基本类型不包括String</code></p>\n<h2 id=\"java类型转换\"><a href=\"#java类型转换\" class=\"headerlink\" title=\"java类型转换\"></a>java类型转换</h2><p><img src=\"C:\\Users\\WLei224\\AppData\\Roaming\\Typora\\typora-user-images\\image-20220617152252543.png\" alt=\"image-20220617152252543\"></p>\n</li>\n</ol>\n<p>强制类型转换就是将：<strong>表数范围大的数向表数范围小的进行转换</strong>。  </p>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a><img src=\"C:\\Users\\WLei224\\AppData\\Roaming\\Typora\\typora-user-images\\image-20220617152333029.png\" alt=\"image-20220617152333029\"></h2><h2 id=\"怎么使用Scanner\"><a href=\"#怎么使用Scanner\" class=\"headerlink\" title=\"怎么使用Scanner\"></a>怎么使用Scanner</h2><p>​        第一种方法：</p>\n<ol>\n<li><p>在类的声明之前，引入扫描仪（<code>Scanner</code>）：</p>\n<p><code>import java.util.Scanner;</code></p>\n</li>\n<li><p>在方法中创建一个扫描仪 </p>\n<p><code>Scanner input = new Scanner(System.in);</code></p>\n<p>第二种方法：</p>\n<p>引入并创建扫描器：<code>java.util.Scanner s = new java.util.Scanner(System.in); </code></p>\n</li>\n<li><p>通过扫描仪获取从键盘输入的数据 </p>\n<p><code>int i = input.nextInt();</code></p>\n<p><code>String s = input.next();</code></p>\n<h4 id=\"三目运算符之判断是否闰年？\"><a href=\"#三目运算符之判断是否闰年？\" class=\"headerlink\" title=\"三目运算符之判断是否闰年？\"></a>三目运算符之判断是否闰年？</h4></li>\n</ol>\n<p>result=(year%400==0 || year%4==0 &amp;&amp; year%100!=0)? true:false;</p>\n<p>​    System.out.println(year + “年是否为闰年:” + result);</p>\n<h4 id=\"运算符优先级别排序正确的是\"><a href=\"#运算符优先级别排序正确的是\" class=\"headerlink\" title=\"运算符优先级别排序正确的是()\"></a>运算符优先级别排序正确的是()</h4><p>A、 由高向低分别是:()、 ! 、算术运算符、关系运算符、逻辑运算符、赋值 运算符;</p>\n<h2 id=\"循环综合练习：\"><a href=\"#循环综合练习：\" class=\"headerlink\" title=\"循环综合练习：\"></a>循环综合练习：</h2><p><strong>Java中的两种循环：</strong></p>\n<p>在 Java 语言中，用于循环的语句有两个，一个是 for 循环，一个是 while 循环。而 for 循环其实还有两种实现方法，对于初学者来说，或许仅知道一般的 for 循环，即：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Java\"><span class=\"hljs-keyword\">for</span>(初始化条件; 限制条件; 迭代语句) &#123;<br>    <span class=\"hljs-comment\">// 循环体</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>而不太了解高级的 for 循环，即：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Java\"><span class=\"hljs-keyword\">for</span>(变量类型 变量名 : 集合) &#123;<br>    <span class=\"hljs-comment\">// 循环体</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>在本文中，咱们就一起来了解了解这两种 for 循环的使用方法以及区别。<br><strong>demo示例：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Java\"><span class=\"hljs-keyword\">import</span> java.util.Arrays;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * <span class=\"hljs-doctag\">@author</span> 维C果糖</span><br><span class=\"hljs-comment\"> * <span class=\"hljs-doctag\">@create</span> 2017-03-31-上午9:30</span><br><span class=\"hljs-comment\"> */</span><br><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ForDemo</span> &#123;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> &#123;<br><br>        <span class=\"hljs-type\">int</span>[] arr = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">int</span>[]&#123;<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">11</span>, <span class=\"hljs-number\">20</span>&#125;;<br><br>        System.out.println(<span class=\"hljs-string\">&quot;第一种 for 循环方法：&quot;</span>);<br><br>        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">i</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span>; i &lt; arr.length; i++) &#123;<br>            System.out.print(arr[i] + <span class=\"hljs-string\">&quot; &quot;</span>);<br>        &#125;<br><br>        System.out.println();<br><br>        System.out.println(<span class=\"hljs-string\">&quot;高级的 for 循环方法：&quot;</span>);<br><br>        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i : arr)&#123;<br>            System.out.print(i + <span class=\"hljs-string\">&quot; &quot;</span>);<br><br>        &#125;<br><br>        System.out.println();<br><br>        System.out.println(<span class=\"hljs-string\">&quot;用 Arrays 的 toString() 方法打印数组：&quot;</span>);<br><br>        System.out.println(Arrays.toString(arr));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><strong>运行结果：</strong></p>\n<p><img src=\"https://img-blog.csdn.net/20170331095210507?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzUyNDY2MjA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"for\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Java\">ATM经典案例：<br><br><span class=\"hljs-keyword\">package</span> step4;<br><br><span class=\"hljs-keyword\">import</span> java.util.Scanner;<br><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ForPractice4</span> &#123;<br><br>  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> &#123;<br><br>​    <span class=\"hljs-comment\">/*****start*****/</span><br><br>​    <span class=\"hljs-type\">Scanner</span> <span class=\"hljs-variable\">input</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Scanner</span>(System.in);     <br><br>   <br><br>​    System.out.println(<span class=\"hljs-string\">&quot;欢迎使用中国人民银行ATM取款机&quot;</span>);     <span class=\"hljs-comment\">//在循环体外，只输出一次  </span><br><br>​    <br><br>​    <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">capital</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">1000</span>;   <span class=\"hljs-comment\">//总资金  </span><br><br>​    <br><br>​    <span class=\"hljs-keyword\">while</span>(<span class=\"hljs-literal\">true</span>) &#123;                    <span class=\"hljs-comment\">//循环体设为true，无限循环</span><br><br>​      System.out.println(<span class=\"hljs-string\">&quot;输入取款金额：&quot;</span>);     <span class=\"hljs-comment\">//循环外层控制“输入金额”</span><br><br>​      <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">a</span> <span class=\"hljs-operator\">=</span> input.nextInt();                  <span class=\"hljs-comment\">//准备接收输入数据</span><br><br>​    <br><br>​      <span class=\"hljs-keyword\">if</span>(a &gt; capital) &#123;                        <span class=\"hljs-comment\">//执行判断语句，如果输出金额大于总金额，则返回返回外层循环</span><br><br>​        System.out.println(<span class=\"hljs-string\">&quot;目前余额：&quot;</span>+capital+<span class=\"hljs-string\">&quot;无法满足您的取款需求！&quot;</span>);   <br><br>​        <span class=\"hljs-keyword\">continue</span>;                          <span class=\"hljs-comment\">//返回外层循环</span><br><br>​        <br><br>​      &#125;<span class=\"hljs-keyword\">else</span> &#123;                           <span class=\"hljs-comment\">//如果“输入金额”小于capital，则，分支判断开始</span><br><br>​          capital = capital - a;<br><br>​          <br><br>​          System.out.println(<span class=\"hljs-string\">&quot;剩余金额：&quot;</span>+capital+<span class=\"hljs-string\">&quot;，是否继续（&#x27;1&#x27;：结束，&#x27;2&#x27;：继续）：&quot;</span>);<br><br>​            <span class=\"hljs-comment\">//资金等于总资金 - 取款额度</span><br><br>​          <br><br>​          <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">change</span> <span class=\"hljs-operator\">=</span> input.nextInt();      <span class=\"hljs-comment\">//控制输入“1”，“2”，判断是否结束程序</span><br><br>​          <span class=\"hljs-keyword\">if</span> (change == <span class=\"hljs-number\">1</span>) &#123;<br><br>​            System.out.println(<span class=\"hljs-string\">&quot;取款结束！&quot;</span>);    <span class=\"hljs-comment\">//如果为1，程序终止</span><br><br>​            <span class=\"hljs-keyword\">break</span>;<br><br>​            <br><br>​          &#125;<span class=\"hljs-keyword\">else</span> &#123;                         <span class=\"hljs-comment\">//如果为其他，则返回外层循环</span><br><br>​            <span class=\"hljs-keyword\">continue</span>;<br><br>​          &#125;<br><br>​      &#125;<br><br>​    <br><br>​    &#125;<br><br>​    <span class=\"hljs-comment\">/*****end*****/</span><br><br>  &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"第1关：将给定的整数进行由小至大排序\"><a href=\"#第1关：将给定的整数进行由小至大排序\" class=\"headerlink\" title=\"第1关：将给定的整数进行由小至大排序\"></a>第1关：将给定的整数进行由小至大排序</h2><figure class=\"highlight abnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs abnf\"> int a<span class=\"hljs-comment\">;</span><br><br>​    if(x&gt;y)&#123;<br><br>​      a<span class=\"hljs-operator\">=</span>y<span class=\"hljs-comment\">;</span><br><br>​      y<span class=\"hljs-operator\">=</span>x<span class=\"hljs-comment\">;</span><br><br>​      x<span class=\"hljs-operator\">=</span>a<span class=\"hljs-comment\">;</span><br><br>​    &#125;<br><br>​    <br><br>​    if(x&gt;z)&#123;<br><br>​      a<span class=\"hljs-operator\">=</span>x<span class=\"hljs-comment\">;</span><br><br>​      x<span class=\"hljs-operator\">=</span>z<span class=\"hljs-comment\">;</span><br><br>​      z<span class=\"hljs-operator\">=</span>a<span class=\"hljs-comment\">;</span><br><br>​    &#125;<br><br>​    if(y&gt;z)&#123;<br><br>​      a<span class=\"hljs-operator\">=</span>z<span class=\"hljs-comment\">;</span><br><br>​      z<span class=\"hljs-operator\">=</span>y<span class=\"hljs-comment\">;</span><br><br>​      y<span class=\"hljs-operator\">=</span>a<span class=\"hljs-comment\">;</span><br><br>​    &#125;<br></code></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"关于质数：（难度级别：⭐⭐⭐）\"><a href=\"#关于质数：（难度级别：⭐⭐⭐）\" class=\"headerlink\" title=\"关于质数：（难度级别：⭐⭐⭐）\"></a>关于质数：（难度级别：⭐⭐⭐）</h2><p>级别1：解题代码2022-07-02 23:30已解锁</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">package</span> step2;<br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">FindZhiShu</span> &#123;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> &#123;<br>        <span class=\"hljs-comment\">/**********begin**********/</span><br><span class=\"hljs-comment\">//由于偶数中只有2是质数，此处直接将2的值进行输出，如下代码中查找质数时，只需考虑奇数即可</span><br>        System.out.print(<span class=\"hljs-number\">2</span>+<span class=\"hljs-string\">&quot; &quot;</span>);<br>        <span class=\"hljs-comment\">//定义标签</span><br>        OUT:<br>        <span class=\"hljs-comment\">//1不是质数，2是质数但是已经打印输出，因此循环中i的值从3开始即可，i+=2是因为在循环中我们不再考虑偶数</span><br>        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">i</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">3</span>; i &lt;= <span class=\"hljs-number\">1000</span>; i+=<span class=\"hljs-number\">2</span>) &#123;<br>        <span class=\"hljs-comment\">//请补充程序判断i是否是质数并打印i，如果是质数按照 System.out.print(i+&quot; &quot;); 格式进行打印 </span><br>            <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">j</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">2</span>; j &lt; i; j++) &#123;<br>                <span class=\"hljs-keyword\">if</span>(i % j == <span class=\"hljs-number\">0</span>) &#123;<br>        <span class=\"hljs-comment\">//如果i对j求余数等于0说明i不是质数</span><br>                    <span class=\"hljs-keyword\">continue</span> OUT;<br>               &#125;  <br>           &#125;            <br>            <span class=\"hljs-comment\">//说明i是质数 </span><br>           System.out.print(i+<span class=\"hljs-string\">&quot; &quot;</span>); <br>       &#125; <br>        <span class=\"hljs-comment\">/**********end**********/</span> <br>    &#125;  <br></code></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">package</span> step2;<br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">FindZhiShu</span> &#123;<br>\t<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> &#123;<br>\t\t   <span class=\"hljs-comment\">/*</span><br><span class=\"hljs-comment\">\t\t     打印输出质数的时候务必按照如下格式：System.out.print(质数+&quot; &quot;)；</span><br><span class=\"hljs-comment\">\t\t     使用print进行打印同时被打印输出的质数后加上一个空格，</span><br><span class=\"hljs-comment\">\t\t     以便于与平台提供的结果格式保持一致！</span><br><span class=\"hljs-comment\">            */</span>   <br>\t\t   <span class=\"hljs-comment\">/**********begin**********/</span><br>            a:<span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">i</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">2</span>;i &lt; <span class=\"hljs-number\">1000</span>;i++)&#123;\t\t<span class=\"hljs-comment\">//此循环遍历次数较多，若对代码效率有要求，则可进一步改进代码：如下：</span><br>                <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">j</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">2</span>;j&lt;i;j++)<br>                <span class=\"hljs-keyword\">if</span>(i%j==<span class=\"hljs-number\">0</span>)&#123;<br>                    <span class=\"hljs-keyword\">continue</span> a;<br>                &#125;<br>                System.out.print(i+<span class=\"hljs-string\">&quot; &quot;</span>);<br>            &#125;<br>           <span class=\"hljs-comment\">/**********end**********/</span>\t<br>\t&#125;<br>&#125;<br>\t\t**********************改进之后的代码*********************<br><span class=\"hljs-keyword\">package</span> step2;<br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">FindZhiShu</span> &#123;<br>\t<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> &#123;<br>\t\t   <span class=\"hljs-comment\">/*</span><br><span class=\"hljs-comment\">\t\t     打印输出质数的时候务必按照如下格式：System.out.print(质数+&quot; &quot;)；</span><br><span class=\"hljs-comment\">\t\t     使用print进行打印同时被打印输出的质数后加上一个空格，</span><br><span class=\"hljs-comment\">\t\t     以便于与平台提供的结果格式保持一致！</span><br><span class=\"hljs-comment\">            */</span>   <br>\t\t   <span class=\"hljs-comment\">/**********begin**********/</span><br><br>\tSystem.out.print(<span class=\"hljs-string\">&quot;2 &quot;</span>);\t<span class=\"hljs-comment\">//因为2是特殊的质数，又因下面循环会自动跳过偶数，因此先将2打印出来。</span><br>\t        a:<span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">i</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">3</span>;i &lt; <span class=\"hljs-number\">1000</span>;i+=<span class=\"hljs-number\">2</span>)&#123;<br>\t            <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">j</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">2</span>;j&lt;i;j++)<br>\t            <span class=\"hljs-keyword\">if</span>(i%j==<span class=\"hljs-number\">0</span>)&#123;<br>\t                <span class=\"hljs-keyword\">continue</span> a;\t\t<span class=\"hljs-comment\">//此方法运用了给循环做标记，以此可以对continue和break进行明确的命令指示。</span><br>\t            &#125;<br>\t            System.out.print(i+<span class=\"hljs-string\">&quot; &quot;</span>);<br>\t        &#125;<br>\t       <span class=\"hljs-comment\">/**********end**********/</span>\t<br>\t&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>\n\n\n\n\n\n<h2 id=\"拓展知识：（break与continue）\"><a href=\"#拓展知识：（break与continue）\" class=\"headerlink\" title=\"拓展知识：（break与continue）\"></a>拓展知识：（break与continue）</h2><h5 id=\"break关键字\"><a href=\"#break关键字\" class=\"headerlink\" title=\"break关键字\"></a>break关键字</h5><p>先来看一段代码的运行效果，如下：</p>\n<p>   <img src=\"https://data.educoder.net/api/attachments/189112\" alt=\"img\">  </p>\n<p>可以发现只要你一直输入<code>1</code>程序就会不断的提示你输入选项，可是当你输入<code>2</code>的时候程序就会终止，你能根据这个运行结果想到要实现这个效果，需要编写什么代码吗？<br>可能你已经猜到了，需要使用到<code>break</code>关键字，<code>break</code>翻译过来是“打断”的意思，放在<code>Java</code>程序中的作用就是：<strong>结束整个循环过程</strong><br>好了，现在来一起看看刚刚那段效果的源代码吧。</p>\n<p>   <img src=\"https://data.educoder.net/api/attachments/189205\" alt=\"img\">  </p>\n<p>现在你应该基本了解<code>break</code>的用法了，不过我还有个小秘密要告诉你：</p>\n<p>   <img src=\"https://data.educoder.net/api/attachments/189207\" alt=\"img\">  </p>\n<p>如果我们在循环中使用<code>switch</code>语句，那么在<code>switch</code>语句中<code>break</code>就不能结束当前循环了，而只能结束<code>switch</code>语句。</p>\n<h5 id=\"continue关键字\"><a href=\"#continue关键字\" class=\"headerlink\" title=\"continue关键字\"></a>continue关键字</h5><p><code>continue</code>关键字的用途是：<strong>结束一次循环事件，开始下一个循环事件</strong>，也就是忽略该语句之后的语句，执行循环体的下一次循环。<br>例如：  </p>\n<figure class=\"highlight pgsql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs pgsql\"><span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>;  <span class=\"hljs-keyword\">while</span>(i &lt; <span class=\"hljs-number\">4</span>)&#123;  <span class=\"hljs-keyword\">if</span>(i == <span class=\"hljs-number\">2</span>)&#123;  i++;  <span class=\"hljs-keyword\">continue</span>;  &#125;  <span class=\"hljs-keyword\">System</span>.<span class=\"hljs-keyword\">out</span>.println(i);  i++;  &#125;<br></code></pre></td></tr></table></figure>\n\n<p>输出结果：<br><code>0</code><br><code>1</code><br><code>3</code></p>\n<h5 id=\"static关键字\"><a href=\"#static关键字\" class=\"headerlink\" title=\"static关键字\"></a>static关键字</h5><p>​        关于静态代码块你只需要记住一句话：在<strong>类被加载的时候</strong>运行且<strong>只运行一次</strong>。</p>\n<p>​        静态方法不能使用类的非静态变量；</p>\n<p>​        静态方法可以直接调用静态方法，但是调用普通方法只能通过对象的实例才能调用。</p>\n<h2 id=\"数组的两种初始化方法：\"><a href=\"#数组的两种初始化方法：\" class=\"headerlink\" title=\"数组的两种初始化方法：\"></a>数组的两种初始化方法：</h2><h4 id=\"1-静态初始化\"><a href=\"#1-静态初始化\" class=\"headerlink\" title=\"1.静态初始化\"></a>1.静态初始化</h4><p><strong>在程序运行前就能确定数组的大小和数组中的初始数据</strong>我们称之为静态初始化。<br>例如：  </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Java\"><span class=\"hljs-type\">float</span>[] stuScores = &#123;<span class=\"hljs-number\">80.0f</span>,<span class=\"hljs-number\">70.0f</span>,<span class=\"hljs-number\">90.0f</span>,<span class=\"hljs-number\">66.5f</span>&#125;;  <span class=\"hljs-type\">int</span>[] nums = &#123;<span class=\"hljs-number\">80</span>,<span class=\"hljs-number\">70</span>, <span class=\"hljs-number\">90</span>,<span class=\"hljs-number\">66</span>&#125;;  <span class=\"hljs-type\">char</span>[] chs = &#123;‘a’,’b’, ‘c’,’d’&#125;;  <br></code></pre></td></tr></table></figure>\n\n<h4 id=\"2-动态初始化\"><a href=\"#2-动态初始化\" class=\"headerlink\" title=\"2.动态初始化\"></a>2.动态初始化</h4><p><strong>数组的大小或数组中数据在程序运行时才能决定</strong>，且用到<code>new</code>这个关键字来确定数组的大小或初始数据我们称之为动态初始化。<br>定义数组：<code>变量类型[] 数组名 = new  数据类型 [ 数组长度 ];</code>  </p>\n<p><img src=\"https://data.educoder.net/api/attachments/189931\" alt=\"img\"></p>\n<p>定义数组与初始化分离：  </p>\n<p><img src=\"https://data.educoder.net/api/attachments/189927\" alt=\"img\"></p>\n<p>赋值：<br>初始化之后就可以向数组中放数据了，数组中元素都是通过下标来访问的，例如向 <code>stuScores</code>数组中存放学生成绩：  </p>\n<p><img src=\"https://data.educoder.net/api/attachments/189928\" alt=\"img\"></p>\n<h4 id=\"动态创建数组并循环赋值：\"><a href=\"#动态创建数组并循环赋值：\" class=\"headerlink\" title=\"动态创建数组并循环赋值：\"></a>动态创建数组并循环赋值：</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Java\"><span class=\"hljs-type\">int</span>[] arr = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">int</span>[sc.nextInt()];<br><br><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">i</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span> ; i&lt; arr.length ; i++)&#123;<br><br>   arr[i] = sc.nextInt();<br><br>&#125;<br></code></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"数组基础\"><a href=\"#数组基础\" class=\"headerlink\" title=\"数组基础\"></a>数组基础</h2><h4 id=\"如何获取数组的长度：\"><a href=\"#如何获取数组的长度：\" class=\"headerlink\" title=\"如何获取数组的长度：\"></a>如何获取数组的长度：</h4><p>数组的<code>length</code>属性用于记录数组中有多少个元素或存储单元，即记录数组的长度是多少。  </p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs csharp\"><span class=\"hljs-built_in\">int</span>[] nums = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">int</span>[<span class=\"hljs-number\">10</span>];<span class=\"hljs-comment\">//声明一个int型数组并动态初始化其大小为10</span><br>System.<span class=\"hljs-keyword\">out</span>.println(nums.length);<span class=\"hljs-comment\">//显示当前数组的大小  </span><br></code></pre></td></tr></table></figure>\n\n<p>输出：<code>10</code></p>\n<h4 id=\"一维数组的遍历\"><a href=\"#一维数组的遍历\" class=\"headerlink\" title=\"一维数组的遍历:\"></a>一维数组的遍历:</h4><p>通俗的理解，遍历数组就是：<strong>把数组中的元素都看一遍</strong>。</p>\n<p>示例如下：  </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Java\"><span class=\"hljs-type\">int</span>[] arr = &#123;<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">5</span>,<span class=\"hljs-number\">7</span>,<span class=\"hljs-number\">9</span>&#125;;  <br><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">i</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span> ; i&lt;arr.length; i++)&#123;<br>\tSystem.out.print(arr[i] + <span class=\"hljs-string\">&quot;,&quot;</span>);  <br>&#125;  <br><span class=\"hljs-comment\">//输出：`1,3,5,7,9`</span><br></code></pre></td></tr></table></figure>\n\n<h4 id=\"二维数组的遍历：\"><a href=\"#二维数组的遍历：\" class=\"headerlink\" title=\"二维数组的遍历：\"></a>二维数组的遍历：</h4><figure class=\"highlight glsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs glsl\"><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i =<span class=\"hljs-number\">0</span>;i&lt;scores.<span class=\"hljs-built_in\">length</span>;i++)&#123;<br>            <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> j=<span class=\"hljs-number\">0</span>;j&lt;scores[i].<span class=\"hljs-built_in\">length</span>;j++)\t\t<span class=\"hljs-comment\">//此处要加上遍历的行数，，即j&lt;scores[i].length</span><br>            System.<span class=\"hljs-keyword\">out</span>.println(scores[i][j]);<br>            System.<span class=\"hljs-keyword\">out</span>.println();<br>        &#125;<br></code></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"如何获取数组的最大值：\"><a href=\"#如何获取数组的最大值：\" class=\"headerlink\" title=\"如何获取数组的最大值：\"></a>如何获取数组的最大值：</h4><p>要求出数组的最大值，是不是很像是打擂台呢？  </p>\n<p><img src=\"https://data.educoder.net/api/attachments/193188\" alt=\"img\"></p>\n<p>对于一群人我们不知道谁最厉害，所以我们准备一个擂台，并挑选第一个人为擂主（max），擂台下的人不断的（循环）来挑战擂主。</p>\n<h4 id=\"数据类型强制转换：\"><a href=\"#数据类型强制转换：\" class=\"headerlink\" title=\"数据类型强制转换：\"></a>数据类型强制转换：</h4><p>测试输入：<code>5</code>，<code>1</code>，<code>151</code>，<code>12</code>，<code>22</code>，<code>100</code>；   预期输出：<br><code>平均值：57.2</code><br><code>最大值：151</code></p>\n<p>提示：  </p>\n<figure class=\"highlight pgsql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs pgsql\"><span class=\"hljs-type\">int</span> a = <span class=\"hljs-number\">3</span>;  <span class=\"hljs-type\">int</span> b = <span class=\"hljs-number\">2</span>;  <span class=\"hljs-keyword\">System</span>.<span class=\"hljs-keyword\">out</span>.println(a/b);  <span class=\"hljs-keyword\">System</span>.<span class=\"hljs-keyword\">out</span>.println((<span class=\"hljs-type\">double</span>)a/b);  <br></code></pre></td></tr></table></figure>\n\n<p>输出：<br><code>1</code><br><code>1.5</code></p>\n<p>例题如下：</p>\n<h4 id=\"编程要求\"><a href=\"#编程要求\" class=\"headerlink\" title=\"编程要求\"></a>编程要求</h4><p>根据提示，在右侧编辑器<code>Begin-End</code>处补充代码，计算并输出数组的平均值和最大值。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">package</span> step3;<br><br><span class=\"hljs-keyword\">import</span> java.util.Scanner;<br><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">HelloWorld</span> &#123;<br>\t<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> &#123;<br>\t\t<span class=\"hljs-type\">Scanner</span> <span class=\"hljs-variable\">sc</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Scanner</span>(System.in);<br>\t\t<br>\t\t<span class=\"hljs-type\">int</span>[] scores = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">int</span>[sc.nextInt()];<br>\t\t<br>\t\t<span class=\"hljs-comment\">//循环给数组赋值</span><br>\t\t<span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">i</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span> ; i&lt; scores.length;i++)&#123;<br>\t\t\tscores[i] = sc.nextInt();<br>\t\t&#125;<br>\t\t<span class=\"hljs-comment\">/********** Begin **********/</span><br>\t\t<span class=\"hljs-comment\">//在这里计算数组scores的平均值和最大值</span><br>\t\t<span class=\"hljs-type\">int</span> sum=<span class=\"hljs-number\">0</span>,max=<span class=\"hljs-number\">0</span>;<br>        <span class=\"hljs-type\">double</span> av=<span class=\"hljs-number\">0</span>;<span class=\"hljs-comment\">//此处是因为提前声明了一个double变量，否则则需要强制类型转换。</span><br>        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;scores.length;i++)&#123;<br>            sum+=scores[i];<br>        &#125;<br>        av=sum/scores.length;<br>        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;scores.length;i++)&#123;<br>            <span class=\"hljs-keyword\">if</span>(max&lt;scores[i])&#123;<br>                max=scores[i];<br>            &#125;<br>        &#125;<br>\t\tSystem.out.println(<span class=\"hljs-string\">&quot;平均值：&quot;</span> +av ); <br>        <span class=\"hljs-comment\">//若不声明多变量，则用这句强制转换类型。</span><br>        <span class=\"hljs-comment\">//System.out.println(&quot;平均值：&quot; +(double)sum/scores.length );</span><br>\t\tSystem.out.println(<span class=\"hljs-string\">&quot;最大值：&quot;</span> +max );<br>\t\t<span class=\"hljs-comment\">/********** End **********/</span><br>\t&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"获取二维数组的行列长度：\"><a href=\"#获取二维数组的行列长度：\" class=\"headerlink\" title=\"获取二维数组的行列长度：\"></a>获取二维数组的行列长度：</h4><p>二维数组定义：<code>int array[][] = new int[3][3];</code><br>获取行数： <code>int rowLength = array.length;</code><br>获取列数： <code>int colLength = array[0].length;</code></p>\n<h4 id=\"二维数组的遍历\"><a href=\"#二维数组的遍历\" class=\"headerlink\" title=\"二维数组的遍历\"></a>二维数组的遍历</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Test</span>&#123;<br>\t<span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">i</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span>; i &lt; array.length; i++)&#123;<br>\t\t<span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">j</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span>; j &lt; array[i].length; j++)&#123;\t\t<span class=\"hljs-comment\">//此处要加上遍历的行数，，即j&lt;scores[i].length</span><br>\t\t\tSystem.out.println(array[i][j);<br>\t\t&#125;<br>\t&#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"知识拓展\"><a href=\"#知识拓展\" class=\"headerlink\" title=\"知识拓展\"></a><em>知识拓展</em></h4><p><strong>for-each</strong></p>\n<p>for-each 循环通常用于遍历数组和集合，它的使用规则比普通的 for 循环还要简单，不需要初始变量，不需要条件，不需要下标来自增或者自减。来看一下语法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">for</span>(元素类型 元素 : 数组或集合)&#123;  <br><span class=\"hljs-comment\">// 要执行的代码</span><br>&#125;  <br></code></pre></td></tr></table></figure>\n\n<p>来看一下示例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ForEachExample</span> &#123;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> &#123;<br>        String[] strs = &#123;<span class=\"hljs-string\">&quot;沉默王二&quot;</span>, <span class=\"hljs-string\">&quot;一枚有趣的程序员&quot;</span>&#125;;<br><br>        <span class=\"hljs-keyword\">for</span> (String str : strs) &#123;<br>            System.out.println(str);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>输出：</p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs text\">沉默王二<br>一枚有趣的程序员<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"两数交换\"><a href=\"#两数交换\" class=\"headerlink\" title=\"两数交换:\"></a>两数交换:</h4><p>两个变量数值的交换有三种换发：</p>\n<p>（1）借助中间量交换 （开发常用）</p>\n<p>理解：三个杯子，两杯装水，其中一个空杯子用作容器。</p>\n<p>int x = 10;<br>int y = 20;<br>int z = x;<br>x = y;<br>y = z;<br>　（2）位移运算交换 （面试常用）</p>\n<p>理解：涉及到了异或运算符的规则：一个数对另一个数位异或两次，该数不变</p>\n<p>int x = 10;<br>int y = 20;<br>x = x ^ y;<br>y = x ^ y;<br>x = x ^ y;<br>　（3）数值相加减交换</p>\n<p>理解：先求得两数的和再进行减运算</p>\n<p>int x = 10;<br>int y = 20;<br>x = x + y;<br>y = x - y;<br>x = x - y;</p>\n<h2 id=\"排序\"><a href=\"#排序\" class=\"headerlink\" title=\"排序\"></a>排序</h2><h4 id=\"选择排序：\"><a href=\"#选择排序：\" class=\"headerlink\" title=\"选择排序：\"></a>选择排序：</h4><h5 id=\"实现过程\"><a href=\"#实现过程\" class=\"headerlink\" title=\"实现过程\"></a>实现过程</h5><p>为了实现选择排序，我们需要<strong>求出最大值</strong>，并且和相比较的数据<strong>交换位置</strong>：接下来我们对数组<code>int[] arr = &#123;6,5,8,0,2,9&#125;</code>来进行<strong>第一趟循环</strong>，将最大值移动到数组的第一位。</p>\n<p><img src=\"https://data.educoder.net/api/attachments/191743\" alt=\"img\"></p>\n<p>代码实现：  </p>\n<figure class=\"highlight apache\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs apache\"><span class=\"hljs-attribute\">int</span>[] arr = &#123;<span class=\"hljs-number\">6</span>,<span class=\"hljs-number\">5</span>,<span class=\"hljs-number\">8</span>,<span class=\"hljs-number\">0</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">9</span>&#125;;for (int i = <span class=\"hljs-number\">0</span>; i &lt; arr.length-<span class=\"hljs-number\">1</span>; i++) &#123;      if(arr[<span class=\"hljs-number\">0</span>] &lt; arr[i+<span class=\"hljs-number\">1</span>])&#123;          int temp = arr[<span class=\"hljs-number\">0</span>];          arr[<span class=\"hljs-number\">0</span>] = arr[i+<span class=\"hljs-number\">1</span>];          arr[i+<span class=\"hljs-number\">1</span>] = temp;      &#125;  &#125;  <br></code></pre></td></tr></table></figure>\n\n<p>一次循环操作就可以找出数组中的最大值，并将其移动到数组的首位，所以对于一个长度为<code>6</code>的数组，我们只需要进行<code>5</code>（length-1）次上述操作即可将数组降序排序了。</p>\n<p>接下来我们进行<strong>第二趟循环</strong>，求第二大的值，并将其移动到数组的第二个位置。因为我们已经求出了最大值，所以这一次循环，最大值不用参与比较。  </p>\n<p><img src=\"https://data.educoder.net/api/attachments/191767\" alt=\"img\"></p>\n<p>代码实现：  </p>\n<p><img src=\"https://data.educoder.net/api/attachments/191770\" alt=\"img\"></p>\n<p>结果：<code>[9, 8, 5, 0, 2, 6]</code></p>\n<p>可以发现经过两轮循环我们找出了数组中最大的两个值，并且移动他们到了数组的前两位。</p>\n<p>现在按照上述步骤就可以实现数组的排序了，不过如果我们照搬上述代码，就会有很多冗余的代码，所以需要你来改进，怎么改进是需要你思考的。</p>\n<p><strong>告诉你一个秘密</strong>：使用<code>Arrays.toString(数组)</code>可以直接输出数组中的值哦！<br>如下：  </p>\n<p><img src=\"https://data.educoder.net/api/attachments/191773\" alt=\"img\"></p>\n<p>输出结果：<code>[6, 5, 8, 0, 2, 9]</code></p>\n<p><strong>思考题</strong>：</p>\n<p>本关所讲述的选择排序是一个简化版本，如果你想要学习优化版可以根据下列图片，编写出相应代码，然后在评论区贴出来哦。  </p>\n<p><img src=\"https://data.educoder.net/api/attachments/192416\" alt=\" \"></p>\n<p>上图就是一个使用选择排序将一个数组中数据从小到大排序的过程，请思考如何用代码实现上述过程。</p>\n<p>原理：每一次从待排序的数据元素中选出最小的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完。</p>\n<hr>\n<p>本关难度较大，但这是学习数组绕不过去的一关，多思考，多尝试，你能成功的，加油！ </p>\n","site":{"data":{}},"excerpt":"","more":"<ul>\n<li><em>写在前面：</em></li>\n</ul>\n<p>​                【免责声明：】本笔记发表在hexo博客只便于个人学习使用，若涉及到版权，请联系个人，谢谢！</p>\n<h1 id=\"educoder头歌Java笔记\"><a href=\"#educoder头歌Java笔记\" class=\"headerlink\" title=\"educoder头歌Java笔记\"></a>educoder头歌Java笔记</h1><h2 id=\"Coding中遇到的问题合集：\"><a href=\"#Coding中遇到的问题合集：\" class=\"headerlink\" title=\"Coding中遇到的问题合集：\"></a><em>Coding中遇到的问题合集：</em></h2><p>““.equals(name) 和name.equals(““) 的区别：</p>\n<p>​        两个都是比较“”的地址和name的地址是否指向同一个地址，即判断name是否为“”；建议用前者，因为name可能是null，此时name.equals(“”)就会报错，而前者则会避免这个问题</p>\n<p>避免了抛出空指针异常NullPointerException。</p>\n<p>leetcode回文数：</p>\n<ul>\n<li>(s.charAt(i)).get(map)  &amp;&amp;  map.get(s.charAt(i))，问题同上；出现了抛出空指针异常的问题，使用前者后，测试通过。</li>\n<li>遇到了char与string的类型不匹配的情况，不可强制转换，最后利用string类的replace方法替换字符串，得到了解决。</li>\n</ul>\n<p>​        </p>\n<h2 id=\"对象的构造方法实例\"><a href=\"#对象的构造方法实例\" class=\"headerlink\" title=\"对象的构造方法实例\"></a>对象的构造方法实例</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Java\"><span class=\"hljs-keyword\">import</span> java.util.Scanner;<br><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Test</span> &#123;<br>\t<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> &#123;<br>\t\t<span class=\"hljs-type\">Scanner</span> <span class=\"hljs-variable\">sc</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Scanner</span>(System.in);<br>\t\t<span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">name</span> <span class=\"hljs-operator\">=</span> sc.next();<br>\t\t<span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">sex</span> <span class=\"hljs-operator\">=</span> sc.next();<br>\t\t<span class=\"hljs-comment\">/****** Begin ******/</span><br>\t\t<span class=\"hljs-comment\">//分别使用两种构造器来创建Person对象  </span><br>\t\tPerson a=<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Person</span>();<br>\t\tPerson b=<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Person</span>(name,sex);<br>\t\t<span class=\"hljs-comment\">/****** End ******/</span><br>\t&#125;<br>&#125;<br><span class=\"hljs-comment\">//创建Person对象，并创建两种构造方法</span><br><span class=\"hljs-comment\">/****** Begin ******/</span><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Person</span>&#123;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">swap</span>&#123;<br>\t<span class=\"hljs-keyword\">public</span> <span class=\"hljs-title function_\">Person</span><span class=\"hljs-params\">()</span>&#123;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t<span class=\"hljs-keyword\">public</span> <span class=\"hljs-title function_\">swap</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> a,<span class=\"hljs-type\">int</span> b,<span class=\"hljs-type\">int</span> c)</span>&#123;<br>\t\tSystem.out.println(<span class=\"hljs-string\">&quot;一个人被创建了&quot;</span>);\t\t\t\t\t\t\tc=a;a=b;b=c;<br><br>​\t&#125;<br>​\t<span class=\"hljs-keyword\">public</span> <span class=\"hljs-title function_\">Person</span><span class=\"hljs-params\">(String name,String sex)</span>&#123;<br>​\t\tSystem.out.println(<span class=\"hljs-string\">&quot;姓名：&quot;</span>+name+<span class=\"hljs-string\">&quot;，性别：&quot;</span>+sex+<span class=\"hljs-string\">&quot;，被创建了&quot;</span>);<br>​\t&#125;<br>&#125;<br><span class=\"hljs-comment\">/****** End ******/</span><br></code></pre></td></tr></table></figure>\n\n<p>千万注意！！！！！<br>变量名字一定看清楚，上面的代码中，误将name写成了neme!!!!!</p>\n<p><img src=\"C:\\Users\\WLei224\\AppData\\Roaming\\Typora\\typora-user-images\\image-20220617145157883.png\" alt=\"image-20220617145157883\"></p>\n<p><code>JAVA</code>中<code>变量</code>的命名和前面第一章所学的<code>标识符</code>命名规则是一样的，不过还是有一些不同，总结下来规则与规范一共有六点：</p>\n<ol>\n<li><p>由字母，下划线，美元符号（$），数字组成，但第一个字符不能是数字。</p>\n</li>\n<li><p>如果变量名是复合型的那么我们采用驼峰式，或者蛇形式的方式。<br>驼峰式：<code>teaCup</code>（表示茶杯的意思），<code>stuAge</code>（学生年龄）<br>蛇形式：<code>tea_cup</code>，<code>stu_age</code></p>\n</li>\n<li><p>如果是单个单词就全小写就行了。</p>\n</li>\n<li><p>千万不要用中文拼音来表达：例如学生年龄：<code>xueShengNianling</code>。</p>\n</li>\n<li><p>在一个方法中变量名不能重复。</p>\n</li>\n<li><p>变量一定要给自己一个确定的类型。</p>\n<h2 id=\"JAVA中的数据类型\"><a href=\"#JAVA中的数据类型\" class=\"headerlink\" title=\"JAVA中的数据类型\"></a>JAVA中的数据类型</h2><p><code>Java</code>基本类型共有八种，基本类型可以分为三类，字符类型<code>char</code>，布尔类型<code>boolean</code>以及数值类型<code>byte、short、int、long、float、double</code>。数值类型又可以分为整数类型<code>byte、short、int、long</code>和浮点数类型<code>float、double</code>。  </p>\n<p><code>基本类型不包括String</code></p>\n<h2 id=\"java类型转换\"><a href=\"#java类型转换\" class=\"headerlink\" title=\"java类型转换\"></a>java类型转换</h2><p><img src=\"C:\\Users\\WLei224\\AppData\\Roaming\\Typora\\typora-user-images\\image-20220617152252543.png\" alt=\"image-20220617152252543\"></p>\n</li>\n</ol>\n<p>强制类型转换就是将：<strong>表数范围大的数向表数范围小的进行转换</strong>。  </p>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a><img src=\"C:\\Users\\WLei224\\AppData\\Roaming\\Typora\\typora-user-images\\image-20220617152333029.png\" alt=\"image-20220617152333029\"></h2><h2 id=\"怎么使用Scanner\"><a href=\"#怎么使用Scanner\" class=\"headerlink\" title=\"怎么使用Scanner\"></a>怎么使用Scanner</h2><p>​        第一种方法：</p>\n<ol>\n<li><p>在类的声明之前，引入扫描仪（<code>Scanner</code>）：</p>\n<p><code>import java.util.Scanner;</code></p>\n</li>\n<li><p>在方法中创建一个扫描仪 </p>\n<p><code>Scanner input = new Scanner(System.in);</code></p>\n<p>第二种方法：</p>\n<p>引入并创建扫描器：<code>java.util.Scanner s = new java.util.Scanner(System.in); </code></p>\n</li>\n<li><p>通过扫描仪获取从键盘输入的数据 </p>\n<p><code>int i = input.nextInt();</code></p>\n<p><code>String s = input.next();</code></p>\n<h4 id=\"三目运算符之判断是否闰年？\"><a href=\"#三目运算符之判断是否闰年？\" class=\"headerlink\" title=\"三目运算符之判断是否闰年？\"></a>三目运算符之判断是否闰年？</h4></li>\n</ol>\n<p>result=(year%400==0 || year%4==0 &amp;&amp; year%100!=0)? true:false;</p>\n<p>​    System.out.println(year + “年是否为闰年:” + result);</p>\n<h4 id=\"运算符优先级别排序正确的是\"><a href=\"#运算符优先级别排序正确的是\" class=\"headerlink\" title=\"运算符优先级别排序正确的是()\"></a>运算符优先级别排序正确的是()</h4><p>A、 由高向低分别是:()、 ! 、算术运算符、关系运算符、逻辑运算符、赋值 运算符;</p>\n<h2 id=\"循环综合练习：\"><a href=\"#循环综合练习：\" class=\"headerlink\" title=\"循环综合练习：\"></a>循环综合练习：</h2><p><strong>Java中的两种循环：</strong></p>\n<p>在 Java 语言中，用于循环的语句有两个，一个是 for 循环，一个是 while 循环。而 for 循环其实还有两种实现方法，对于初学者来说，或许仅知道一般的 for 循环，即：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Java\"><span class=\"hljs-keyword\">for</span>(初始化条件; 限制条件; 迭代语句) &#123;<br>    <span class=\"hljs-comment\">// 循环体</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>而不太了解高级的 for 循环，即：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Java\"><span class=\"hljs-keyword\">for</span>(变量类型 变量名 : 集合) &#123;<br>    <span class=\"hljs-comment\">// 循环体</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>在本文中，咱们就一起来了解了解这两种 for 循环的使用方法以及区别。<br><strong>demo示例：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Java\"><span class=\"hljs-keyword\">import</span> java.util.Arrays;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * <span class=\"hljs-doctag\">@author</span> 维C果糖</span><br><span class=\"hljs-comment\"> * <span class=\"hljs-doctag\">@create</span> 2017-03-31-上午9:30</span><br><span class=\"hljs-comment\"> */</span><br><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ForDemo</span> &#123;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> &#123;<br><br>        <span class=\"hljs-type\">int</span>[] arr = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">int</span>[]&#123;<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">11</span>, <span class=\"hljs-number\">20</span>&#125;;<br><br>        System.out.println(<span class=\"hljs-string\">&quot;第一种 for 循环方法：&quot;</span>);<br><br>        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">i</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span>; i &lt; arr.length; i++) &#123;<br>            System.out.print(arr[i] + <span class=\"hljs-string\">&quot; &quot;</span>);<br>        &#125;<br><br>        System.out.println();<br><br>        System.out.println(<span class=\"hljs-string\">&quot;高级的 for 循环方法：&quot;</span>);<br><br>        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i : arr)&#123;<br>            System.out.print(i + <span class=\"hljs-string\">&quot; &quot;</span>);<br><br>        &#125;<br><br>        System.out.println();<br><br>        System.out.println(<span class=\"hljs-string\">&quot;用 Arrays 的 toString() 方法打印数组：&quot;</span>);<br><br>        System.out.println(Arrays.toString(arr));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><strong>运行结果：</strong></p>\n<p><img src=\"https://img-blog.csdn.net/20170331095210507?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzUyNDY2MjA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"for\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Java\">ATM经典案例：<br><br><span class=\"hljs-keyword\">package</span> step4;<br><br><span class=\"hljs-keyword\">import</span> java.util.Scanner;<br><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ForPractice4</span> &#123;<br><br>  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> &#123;<br><br>​    <span class=\"hljs-comment\">/*****start*****/</span><br><br>​    <span class=\"hljs-type\">Scanner</span> <span class=\"hljs-variable\">input</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Scanner</span>(System.in);     <br><br>   <br><br>​    System.out.println(<span class=\"hljs-string\">&quot;欢迎使用中国人民银行ATM取款机&quot;</span>);     <span class=\"hljs-comment\">//在循环体外，只输出一次  </span><br><br>​    <br><br>​    <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">capital</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">1000</span>;   <span class=\"hljs-comment\">//总资金  </span><br><br>​    <br><br>​    <span class=\"hljs-keyword\">while</span>(<span class=\"hljs-literal\">true</span>) &#123;                    <span class=\"hljs-comment\">//循环体设为true，无限循环</span><br><br>​      System.out.println(<span class=\"hljs-string\">&quot;输入取款金额：&quot;</span>);     <span class=\"hljs-comment\">//循环外层控制“输入金额”</span><br><br>​      <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">a</span> <span class=\"hljs-operator\">=</span> input.nextInt();                  <span class=\"hljs-comment\">//准备接收输入数据</span><br><br>​    <br><br>​      <span class=\"hljs-keyword\">if</span>(a &gt; capital) &#123;                        <span class=\"hljs-comment\">//执行判断语句，如果输出金额大于总金额，则返回返回外层循环</span><br><br>​        System.out.println(<span class=\"hljs-string\">&quot;目前余额：&quot;</span>+capital+<span class=\"hljs-string\">&quot;无法满足您的取款需求！&quot;</span>);   <br><br>​        <span class=\"hljs-keyword\">continue</span>;                          <span class=\"hljs-comment\">//返回外层循环</span><br><br>​        <br><br>​      &#125;<span class=\"hljs-keyword\">else</span> &#123;                           <span class=\"hljs-comment\">//如果“输入金额”小于capital，则，分支判断开始</span><br><br>​          capital = capital - a;<br><br>​          <br><br>​          System.out.println(<span class=\"hljs-string\">&quot;剩余金额：&quot;</span>+capital+<span class=\"hljs-string\">&quot;，是否继续（&#x27;1&#x27;：结束，&#x27;2&#x27;：继续）：&quot;</span>);<br><br>​            <span class=\"hljs-comment\">//资金等于总资金 - 取款额度</span><br><br>​          <br><br>​          <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">change</span> <span class=\"hljs-operator\">=</span> input.nextInt();      <span class=\"hljs-comment\">//控制输入“1”，“2”，判断是否结束程序</span><br><br>​          <span class=\"hljs-keyword\">if</span> (change == <span class=\"hljs-number\">1</span>) &#123;<br><br>​            System.out.println(<span class=\"hljs-string\">&quot;取款结束！&quot;</span>);    <span class=\"hljs-comment\">//如果为1，程序终止</span><br><br>​            <span class=\"hljs-keyword\">break</span>;<br><br>​            <br><br>​          &#125;<span class=\"hljs-keyword\">else</span> &#123;                         <span class=\"hljs-comment\">//如果为其他，则返回外层循环</span><br><br>​            <span class=\"hljs-keyword\">continue</span>;<br><br>​          &#125;<br><br>​      &#125;<br><br>​    <br><br>​    &#125;<br><br>​    <span class=\"hljs-comment\">/*****end*****/</span><br><br>  &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"第1关：将给定的整数进行由小至大排序\"><a href=\"#第1关：将给定的整数进行由小至大排序\" class=\"headerlink\" title=\"第1关：将给定的整数进行由小至大排序\"></a>第1关：将给定的整数进行由小至大排序</h2><figure class=\"highlight abnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs abnf\"> int a<span class=\"hljs-comment\">;</span><br><br>​    if(x&gt;y)&#123;<br><br>​      a<span class=\"hljs-operator\">=</span>y<span class=\"hljs-comment\">;</span><br><br>​      y<span class=\"hljs-operator\">=</span>x<span class=\"hljs-comment\">;</span><br><br>​      x<span class=\"hljs-operator\">=</span>a<span class=\"hljs-comment\">;</span><br><br>​    &#125;<br><br>​    <br><br>​    if(x&gt;z)&#123;<br><br>​      a<span class=\"hljs-operator\">=</span>x<span class=\"hljs-comment\">;</span><br><br>​      x<span class=\"hljs-operator\">=</span>z<span class=\"hljs-comment\">;</span><br><br>​      z<span class=\"hljs-operator\">=</span>a<span class=\"hljs-comment\">;</span><br><br>​    &#125;<br><br>​    if(y&gt;z)&#123;<br><br>​      a<span class=\"hljs-operator\">=</span>z<span class=\"hljs-comment\">;</span><br><br>​      z<span class=\"hljs-operator\">=</span>y<span class=\"hljs-comment\">;</span><br><br>​      y<span class=\"hljs-operator\">=</span>a<span class=\"hljs-comment\">;</span><br><br>​    &#125;<br></code></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"关于质数：（难度级别：⭐⭐⭐）\"><a href=\"#关于质数：（难度级别：⭐⭐⭐）\" class=\"headerlink\" title=\"关于质数：（难度级别：⭐⭐⭐）\"></a>关于质数：（难度级别：⭐⭐⭐）</h2><p>级别1：解题代码2022-07-02 23:30已解锁</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">package</span> step2;<br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">FindZhiShu</span> &#123;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> &#123;<br>        <span class=\"hljs-comment\">/**********begin**********/</span><br><span class=\"hljs-comment\">//由于偶数中只有2是质数，此处直接将2的值进行输出，如下代码中查找质数时，只需考虑奇数即可</span><br>        System.out.print(<span class=\"hljs-number\">2</span>+<span class=\"hljs-string\">&quot; &quot;</span>);<br>        <span class=\"hljs-comment\">//定义标签</span><br>        OUT:<br>        <span class=\"hljs-comment\">//1不是质数，2是质数但是已经打印输出，因此循环中i的值从3开始即可，i+=2是因为在循环中我们不再考虑偶数</span><br>        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">i</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">3</span>; i &lt;= <span class=\"hljs-number\">1000</span>; i+=<span class=\"hljs-number\">2</span>) &#123;<br>        <span class=\"hljs-comment\">//请补充程序判断i是否是质数并打印i，如果是质数按照 System.out.print(i+&quot; &quot;); 格式进行打印 </span><br>            <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">j</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">2</span>; j &lt; i; j++) &#123;<br>                <span class=\"hljs-keyword\">if</span>(i % j == <span class=\"hljs-number\">0</span>) &#123;<br>        <span class=\"hljs-comment\">//如果i对j求余数等于0说明i不是质数</span><br>                    <span class=\"hljs-keyword\">continue</span> OUT;<br>               &#125;  <br>           &#125;            <br>            <span class=\"hljs-comment\">//说明i是质数 </span><br>           System.out.print(i+<span class=\"hljs-string\">&quot; &quot;</span>); <br>       &#125; <br>        <span class=\"hljs-comment\">/**********end**********/</span> <br>    &#125;  <br></code></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">package</span> step2;<br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">FindZhiShu</span> &#123;<br>\t<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> &#123;<br>\t\t   <span class=\"hljs-comment\">/*</span><br><span class=\"hljs-comment\">\t\t     打印输出质数的时候务必按照如下格式：System.out.print(质数+&quot; &quot;)；</span><br><span class=\"hljs-comment\">\t\t     使用print进行打印同时被打印输出的质数后加上一个空格，</span><br><span class=\"hljs-comment\">\t\t     以便于与平台提供的结果格式保持一致！</span><br><span class=\"hljs-comment\">            */</span>   <br>\t\t   <span class=\"hljs-comment\">/**********begin**********/</span><br>            a:<span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">i</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">2</span>;i &lt; <span class=\"hljs-number\">1000</span>;i++)&#123;\t\t<span class=\"hljs-comment\">//此循环遍历次数较多，若对代码效率有要求，则可进一步改进代码：如下：</span><br>                <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">j</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">2</span>;j&lt;i;j++)<br>                <span class=\"hljs-keyword\">if</span>(i%j==<span class=\"hljs-number\">0</span>)&#123;<br>                    <span class=\"hljs-keyword\">continue</span> a;<br>                &#125;<br>                System.out.print(i+<span class=\"hljs-string\">&quot; &quot;</span>);<br>            &#125;<br>           <span class=\"hljs-comment\">/**********end**********/</span>\t<br>\t&#125;<br>&#125;<br>\t\t**********************改进之后的代码*********************<br><span class=\"hljs-keyword\">package</span> step2;<br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">FindZhiShu</span> &#123;<br>\t<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> &#123;<br>\t\t   <span class=\"hljs-comment\">/*</span><br><span class=\"hljs-comment\">\t\t     打印输出质数的时候务必按照如下格式：System.out.print(质数+&quot; &quot;)；</span><br><span class=\"hljs-comment\">\t\t     使用print进行打印同时被打印输出的质数后加上一个空格，</span><br><span class=\"hljs-comment\">\t\t     以便于与平台提供的结果格式保持一致！</span><br><span class=\"hljs-comment\">            */</span>   <br>\t\t   <span class=\"hljs-comment\">/**********begin**********/</span><br><br>\tSystem.out.print(<span class=\"hljs-string\">&quot;2 &quot;</span>);\t<span class=\"hljs-comment\">//因为2是特殊的质数，又因下面循环会自动跳过偶数，因此先将2打印出来。</span><br>\t        a:<span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">i</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">3</span>;i &lt; <span class=\"hljs-number\">1000</span>;i+=<span class=\"hljs-number\">2</span>)&#123;<br>\t            <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">j</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">2</span>;j&lt;i;j++)<br>\t            <span class=\"hljs-keyword\">if</span>(i%j==<span class=\"hljs-number\">0</span>)&#123;<br>\t                <span class=\"hljs-keyword\">continue</span> a;\t\t<span class=\"hljs-comment\">//此方法运用了给循环做标记，以此可以对continue和break进行明确的命令指示。</span><br>\t            &#125;<br>\t            System.out.print(i+<span class=\"hljs-string\">&quot; &quot;</span>);<br>\t        &#125;<br>\t       <span class=\"hljs-comment\">/**********end**********/</span>\t<br>\t&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>\n\n\n\n\n\n<h2 id=\"拓展知识：（break与continue）\"><a href=\"#拓展知识：（break与continue）\" class=\"headerlink\" title=\"拓展知识：（break与continue）\"></a>拓展知识：（break与continue）</h2><h5 id=\"break关键字\"><a href=\"#break关键字\" class=\"headerlink\" title=\"break关键字\"></a>break关键字</h5><p>先来看一段代码的运行效果，如下：</p>\n<p>   <img src=\"https://data.educoder.net/api/attachments/189112\" alt=\"img\">  </p>\n<p>可以发现只要你一直输入<code>1</code>程序就会不断的提示你输入选项，可是当你输入<code>2</code>的时候程序就会终止，你能根据这个运行结果想到要实现这个效果，需要编写什么代码吗？<br>可能你已经猜到了，需要使用到<code>break</code>关键字，<code>break</code>翻译过来是“打断”的意思，放在<code>Java</code>程序中的作用就是：<strong>结束整个循环过程</strong><br>好了，现在来一起看看刚刚那段效果的源代码吧。</p>\n<p>   <img src=\"https://data.educoder.net/api/attachments/189205\" alt=\"img\">  </p>\n<p>现在你应该基本了解<code>break</code>的用法了，不过我还有个小秘密要告诉你：</p>\n<p>   <img src=\"https://data.educoder.net/api/attachments/189207\" alt=\"img\">  </p>\n<p>如果我们在循环中使用<code>switch</code>语句，那么在<code>switch</code>语句中<code>break</code>就不能结束当前循环了，而只能结束<code>switch</code>语句。</p>\n<h5 id=\"continue关键字\"><a href=\"#continue关键字\" class=\"headerlink\" title=\"continue关键字\"></a>continue关键字</h5><p><code>continue</code>关键字的用途是：<strong>结束一次循环事件，开始下一个循环事件</strong>，也就是忽略该语句之后的语句，执行循环体的下一次循环。<br>例如：  </p>\n<figure class=\"highlight pgsql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs pgsql\"><span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>;  <span class=\"hljs-keyword\">while</span>(i &lt; <span class=\"hljs-number\">4</span>)&#123;  <span class=\"hljs-keyword\">if</span>(i == <span class=\"hljs-number\">2</span>)&#123;  i++;  <span class=\"hljs-keyword\">continue</span>;  &#125;  <span class=\"hljs-keyword\">System</span>.<span class=\"hljs-keyword\">out</span>.println(i);  i++;  &#125;<br></code></pre></td></tr></table></figure>\n\n<p>输出结果：<br><code>0</code><br><code>1</code><br><code>3</code></p>\n<h5 id=\"static关键字\"><a href=\"#static关键字\" class=\"headerlink\" title=\"static关键字\"></a>static关键字</h5><p>​        关于静态代码块你只需要记住一句话：在<strong>类被加载的时候</strong>运行且<strong>只运行一次</strong>。</p>\n<p>​        静态方法不能使用类的非静态变量；</p>\n<p>​        静态方法可以直接调用静态方法，但是调用普通方法只能通过对象的实例才能调用。</p>\n<h2 id=\"数组的两种初始化方法：\"><a href=\"#数组的两种初始化方法：\" class=\"headerlink\" title=\"数组的两种初始化方法：\"></a>数组的两种初始化方法：</h2><h4 id=\"1-静态初始化\"><a href=\"#1-静态初始化\" class=\"headerlink\" title=\"1.静态初始化\"></a>1.静态初始化</h4><p><strong>在程序运行前就能确定数组的大小和数组中的初始数据</strong>我们称之为静态初始化。<br>例如：  </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Java\"><span class=\"hljs-type\">float</span>[] stuScores = &#123;<span class=\"hljs-number\">80.0f</span>,<span class=\"hljs-number\">70.0f</span>,<span class=\"hljs-number\">90.0f</span>,<span class=\"hljs-number\">66.5f</span>&#125;;  <span class=\"hljs-type\">int</span>[] nums = &#123;<span class=\"hljs-number\">80</span>,<span class=\"hljs-number\">70</span>, <span class=\"hljs-number\">90</span>,<span class=\"hljs-number\">66</span>&#125;;  <span class=\"hljs-type\">char</span>[] chs = &#123;‘a’,’b’, ‘c’,’d’&#125;;  <br></code></pre></td></tr></table></figure>\n\n<h4 id=\"2-动态初始化\"><a href=\"#2-动态初始化\" class=\"headerlink\" title=\"2.动态初始化\"></a>2.动态初始化</h4><p><strong>数组的大小或数组中数据在程序运行时才能决定</strong>，且用到<code>new</code>这个关键字来确定数组的大小或初始数据我们称之为动态初始化。<br>定义数组：<code>变量类型[] 数组名 = new  数据类型 [ 数组长度 ];</code>  </p>\n<p><img src=\"https://data.educoder.net/api/attachments/189931\" alt=\"img\"></p>\n<p>定义数组与初始化分离：  </p>\n<p><img src=\"https://data.educoder.net/api/attachments/189927\" alt=\"img\"></p>\n<p>赋值：<br>初始化之后就可以向数组中放数据了，数组中元素都是通过下标来访问的，例如向 <code>stuScores</code>数组中存放学生成绩：  </p>\n<p><img src=\"https://data.educoder.net/api/attachments/189928\" alt=\"img\"></p>\n<h4 id=\"动态创建数组并循环赋值：\"><a href=\"#动态创建数组并循环赋值：\" class=\"headerlink\" title=\"动态创建数组并循环赋值：\"></a>动态创建数组并循环赋值：</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Java\"><span class=\"hljs-type\">int</span>[] arr = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">int</span>[sc.nextInt()];<br><br><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">i</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span> ; i&lt; arr.length ; i++)&#123;<br><br>   arr[i] = sc.nextInt();<br><br>&#125;<br></code></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"数组基础\"><a href=\"#数组基础\" class=\"headerlink\" title=\"数组基础\"></a>数组基础</h2><h4 id=\"如何获取数组的长度：\"><a href=\"#如何获取数组的长度：\" class=\"headerlink\" title=\"如何获取数组的长度：\"></a>如何获取数组的长度：</h4><p>数组的<code>length</code>属性用于记录数组中有多少个元素或存储单元，即记录数组的长度是多少。  </p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs csharp\"><span class=\"hljs-built_in\">int</span>[] nums = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">int</span>[<span class=\"hljs-number\">10</span>];<span class=\"hljs-comment\">//声明一个int型数组并动态初始化其大小为10</span><br>System.<span class=\"hljs-keyword\">out</span>.println(nums.length);<span class=\"hljs-comment\">//显示当前数组的大小  </span><br></code></pre></td></tr></table></figure>\n\n<p>输出：<code>10</code></p>\n<h4 id=\"一维数组的遍历\"><a href=\"#一维数组的遍历\" class=\"headerlink\" title=\"一维数组的遍历:\"></a>一维数组的遍历:</h4><p>通俗的理解，遍历数组就是：<strong>把数组中的元素都看一遍</strong>。</p>\n<p>示例如下：  </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Java\"><span class=\"hljs-type\">int</span>[] arr = &#123;<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">5</span>,<span class=\"hljs-number\">7</span>,<span class=\"hljs-number\">9</span>&#125;;  <br><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">i</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span> ; i&lt;arr.length; i++)&#123;<br>\tSystem.out.print(arr[i] + <span class=\"hljs-string\">&quot;,&quot;</span>);  <br>&#125;  <br><span class=\"hljs-comment\">//输出：`1,3,5,7,9`</span><br></code></pre></td></tr></table></figure>\n\n<h4 id=\"二维数组的遍历：\"><a href=\"#二维数组的遍历：\" class=\"headerlink\" title=\"二维数组的遍历：\"></a>二维数组的遍历：</h4><figure class=\"highlight glsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs glsl\"><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i =<span class=\"hljs-number\">0</span>;i&lt;scores.<span class=\"hljs-built_in\">length</span>;i++)&#123;<br>            <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> j=<span class=\"hljs-number\">0</span>;j&lt;scores[i].<span class=\"hljs-built_in\">length</span>;j++)\t\t<span class=\"hljs-comment\">//此处要加上遍历的行数，，即j&lt;scores[i].length</span><br>            System.<span class=\"hljs-keyword\">out</span>.println(scores[i][j]);<br>            System.<span class=\"hljs-keyword\">out</span>.println();<br>        &#125;<br></code></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"如何获取数组的最大值：\"><a href=\"#如何获取数组的最大值：\" class=\"headerlink\" title=\"如何获取数组的最大值：\"></a>如何获取数组的最大值：</h4><p>要求出数组的最大值，是不是很像是打擂台呢？  </p>\n<p><img src=\"https://data.educoder.net/api/attachments/193188\" alt=\"img\"></p>\n<p>对于一群人我们不知道谁最厉害，所以我们准备一个擂台，并挑选第一个人为擂主（max），擂台下的人不断的（循环）来挑战擂主。</p>\n<h4 id=\"数据类型强制转换：\"><a href=\"#数据类型强制转换：\" class=\"headerlink\" title=\"数据类型强制转换：\"></a>数据类型强制转换：</h4><p>测试输入：<code>5</code>，<code>1</code>，<code>151</code>，<code>12</code>，<code>22</code>，<code>100</code>；   预期输出：<br><code>平均值：57.2</code><br><code>最大值：151</code></p>\n<p>提示：  </p>\n<figure class=\"highlight pgsql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs pgsql\"><span class=\"hljs-type\">int</span> a = <span class=\"hljs-number\">3</span>;  <span class=\"hljs-type\">int</span> b = <span class=\"hljs-number\">2</span>;  <span class=\"hljs-keyword\">System</span>.<span class=\"hljs-keyword\">out</span>.println(a/b);  <span class=\"hljs-keyword\">System</span>.<span class=\"hljs-keyword\">out</span>.println((<span class=\"hljs-type\">double</span>)a/b);  <br></code></pre></td></tr></table></figure>\n\n<p>输出：<br><code>1</code><br><code>1.5</code></p>\n<p>例题如下：</p>\n<h4 id=\"编程要求\"><a href=\"#编程要求\" class=\"headerlink\" title=\"编程要求\"></a>编程要求</h4><p>根据提示，在右侧编辑器<code>Begin-End</code>处补充代码，计算并输出数组的平均值和最大值。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">package</span> step3;<br><br><span class=\"hljs-keyword\">import</span> java.util.Scanner;<br><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">HelloWorld</span> &#123;<br>\t<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> &#123;<br>\t\t<span class=\"hljs-type\">Scanner</span> <span class=\"hljs-variable\">sc</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Scanner</span>(System.in);<br>\t\t<br>\t\t<span class=\"hljs-type\">int</span>[] scores = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">int</span>[sc.nextInt()];<br>\t\t<br>\t\t<span class=\"hljs-comment\">//循环给数组赋值</span><br>\t\t<span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">i</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span> ; i&lt; scores.length;i++)&#123;<br>\t\t\tscores[i] = sc.nextInt();<br>\t\t&#125;<br>\t\t<span class=\"hljs-comment\">/********** Begin **********/</span><br>\t\t<span class=\"hljs-comment\">//在这里计算数组scores的平均值和最大值</span><br>\t\t<span class=\"hljs-type\">int</span> sum=<span class=\"hljs-number\">0</span>,max=<span class=\"hljs-number\">0</span>;<br>        <span class=\"hljs-type\">double</span> av=<span class=\"hljs-number\">0</span>;<span class=\"hljs-comment\">//此处是因为提前声明了一个double变量，否则则需要强制类型转换。</span><br>        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;scores.length;i++)&#123;<br>            sum+=scores[i];<br>        &#125;<br>        av=sum/scores.length;<br>        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;scores.length;i++)&#123;<br>            <span class=\"hljs-keyword\">if</span>(max&lt;scores[i])&#123;<br>                max=scores[i];<br>            &#125;<br>        &#125;<br>\t\tSystem.out.println(<span class=\"hljs-string\">&quot;平均值：&quot;</span> +av ); <br>        <span class=\"hljs-comment\">//若不声明多变量，则用这句强制转换类型。</span><br>        <span class=\"hljs-comment\">//System.out.println(&quot;平均值：&quot; +(double)sum/scores.length );</span><br>\t\tSystem.out.println(<span class=\"hljs-string\">&quot;最大值：&quot;</span> +max );<br>\t\t<span class=\"hljs-comment\">/********** End **********/</span><br>\t&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"获取二维数组的行列长度：\"><a href=\"#获取二维数组的行列长度：\" class=\"headerlink\" title=\"获取二维数组的行列长度：\"></a>获取二维数组的行列长度：</h4><p>二维数组定义：<code>int array[][] = new int[3][3];</code><br>获取行数： <code>int rowLength = array.length;</code><br>获取列数： <code>int colLength = array[0].length;</code></p>\n<h4 id=\"二维数组的遍历\"><a href=\"#二维数组的遍历\" class=\"headerlink\" title=\"二维数组的遍历\"></a>二维数组的遍历</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Test</span>&#123;<br>\t<span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">i</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span>; i &lt; array.length; i++)&#123;<br>\t\t<span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">j</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span>; j &lt; array[i].length; j++)&#123;\t\t<span class=\"hljs-comment\">//此处要加上遍历的行数，，即j&lt;scores[i].length</span><br>\t\t\tSystem.out.println(array[i][j);<br>\t\t&#125;<br>\t&#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"知识拓展\"><a href=\"#知识拓展\" class=\"headerlink\" title=\"知识拓展\"></a><em>知识拓展</em></h4><p><strong>for-each</strong></p>\n<p>for-each 循环通常用于遍历数组和集合，它的使用规则比普通的 for 循环还要简单，不需要初始变量，不需要条件，不需要下标来自增或者自减。来看一下语法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">for</span>(元素类型 元素 : 数组或集合)&#123;  <br><span class=\"hljs-comment\">// 要执行的代码</span><br>&#125;  <br></code></pre></td></tr></table></figure>\n\n<p>来看一下示例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ForEachExample</span> &#123;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> &#123;<br>        String[] strs = &#123;<span class=\"hljs-string\">&quot;沉默王二&quot;</span>, <span class=\"hljs-string\">&quot;一枚有趣的程序员&quot;</span>&#125;;<br><br>        <span class=\"hljs-keyword\">for</span> (String str : strs) &#123;<br>            System.out.println(str);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>输出：</p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs text\">沉默王二<br>一枚有趣的程序员<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"两数交换\"><a href=\"#两数交换\" class=\"headerlink\" title=\"两数交换:\"></a>两数交换:</h4><p>两个变量数值的交换有三种换发：</p>\n<p>（1）借助中间量交换 （开发常用）</p>\n<p>理解：三个杯子，两杯装水，其中一个空杯子用作容器。</p>\n<p>int x = 10;<br>int y = 20;<br>int z = x;<br>x = y;<br>y = z;<br>　（2）位移运算交换 （面试常用）</p>\n<p>理解：涉及到了异或运算符的规则：一个数对另一个数位异或两次，该数不变</p>\n<p>int x = 10;<br>int y = 20;<br>x = x ^ y;<br>y = x ^ y;<br>x = x ^ y;<br>　（3）数值相加减交换</p>\n<p>理解：先求得两数的和再进行减运算</p>\n<p>int x = 10;<br>int y = 20;<br>x = x + y;<br>y = x - y;<br>x = x - y;</p>\n<h2 id=\"排序\"><a href=\"#排序\" class=\"headerlink\" title=\"排序\"></a>排序</h2><h4 id=\"选择排序：\"><a href=\"#选择排序：\" class=\"headerlink\" title=\"选择排序：\"></a>选择排序：</h4><h5 id=\"实现过程\"><a href=\"#实现过程\" class=\"headerlink\" title=\"实现过程\"></a>实现过程</h5><p>为了实现选择排序，我们需要<strong>求出最大值</strong>，并且和相比较的数据<strong>交换位置</strong>：接下来我们对数组<code>int[] arr = &#123;6,5,8,0,2,9&#125;</code>来进行<strong>第一趟循环</strong>，将最大值移动到数组的第一位。</p>\n<p><img src=\"https://data.educoder.net/api/attachments/191743\" alt=\"img\"></p>\n<p>代码实现：  </p>\n<figure class=\"highlight apache\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs apache\"><span class=\"hljs-attribute\">int</span>[] arr = &#123;<span class=\"hljs-number\">6</span>,<span class=\"hljs-number\">5</span>,<span class=\"hljs-number\">8</span>,<span class=\"hljs-number\">0</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">9</span>&#125;;for (int i = <span class=\"hljs-number\">0</span>; i &lt; arr.length-<span class=\"hljs-number\">1</span>; i++) &#123;      if(arr[<span class=\"hljs-number\">0</span>] &lt; arr[i+<span class=\"hljs-number\">1</span>])&#123;          int temp = arr[<span class=\"hljs-number\">0</span>];          arr[<span class=\"hljs-number\">0</span>] = arr[i+<span class=\"hljs-number\">1</span>];          arr[i+<span class=\"hljs-number\">1</span>] = temp;      &#125;  &#125;  <br></code></pre></td></tr></table></figure>\n\n<p>一次循环操作就可以找出数组中的最大值，并将其移动到数组的首位，所以对于一个长度为<code>6</code>的数组，我们只需要进行<code>5</code>（length-1）次上述操作即可将数组降序排序了。</p>\n<p>接下来我们进行<strong>第二趟循环</strong>，求第二大的值，并将其移动到数组的第二个位置。因为我们已经求出了最大值，所以这一次循环，最大值不用参与比较。  </p>\n<p><img src=\"https://data.educoder.net/api/attachments/191767\" alt=\"img\"></p>\n<p>代码实现：  </p>\n<p><img src=\"https://data.educoder.net/api/attachments/191770\" alt=\"img\"></p>\n<p>结果：<code>[9, 8, 5, 0, 2, 6]</code></p>\n<p>可以发现经过两轮循环我们找出了数组中最大的两个值，并且移动他们到了数组的前两位。</p>\n<p>现在按照上述步骤就可以实现数组的排序了，不过如果我们照搬上述代码，就会有很多冗余的代码，所以需要你来改进，怎么改进是需要你思考的。</p>\n<p><strong>告诉你一个秘密</strong>：使用<code>Arrays.toString(数组)</code>可以直接输出数组中的值哦！<br>如下：  </p>\n<p><img src=\"https://data.educoder.net/api/attachments/191773\" alt=\"img\"></p>\n<p>输出结果：<code>[6, 5, 8, 0, 2, 9]</code></p>\n<p><strong>思考题</strong>：</p>\n<p>本关所讲述的选择排序是一个简化版本，如果你想要学习优化版可以根据下列图片，编写出相应代码，然后在评论区贴出来哦。  </p>\n<p><img src=\"https://data.educoder.net/api/attachments/192416\" alt=\" \"></p>\n<p>上图就是一个使用选择排序将一个数组中数据从小到大排序的过程，请思考如何用代码实现上述过程。</p>\n<p>原理：每一次从待排序的数据元素中选出最小的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完。</p>\n<hr>\n<p>本关难度较大，但这是学习数组绕不过去的一关，多思考，多尝试，你能成功的，加油！ </p>\n"},{"title":"一篇文章搞懂 JVM","index_img":"https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311151627635.png","banner_img":"https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202309111618297.png","abbrlink":8425,"date":"2023-01-07T00:58:32.000Z","_content":"\n# `JVM`\n\n> 图文详解 50 道Java虚拟机高频面试题，这次面试，一定吊打面试官，整理：csguider，戳[转载链接](https://mp.weixin.qq.com/s/bHhqhl8mH3OAPt3EkaVc8Q)，作者：三分恶，戳[原文链接](https://mp.weixin.qq.com/s/XYsEJyIo46jXhHE1sOR_0Q)\n\n## 一、引言\n\n1. 是什么\n\n> JVM--Java虚拟机，是实现Java编程语言平台无关性特性的基石。\n\n2. 有什么用\n\nJava源程序-（`javac编译` `编译型`）\n\n->.class文件-(`JVM` `解释型`)\n\n->OS机器码\n\n图解：\n\n![](https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/jvm-1.png)\n\n> 这就是说Java 语言“编译与解释并存”的原因\n\n此处的`JVM`：不同OS拥有不同的JVM，正因为有了中间层这个字节码文件，才可以实现跨平台操作\n\n## 二、JVM内存管理\n\n### 内存区域划分：\n\n按照虚拟机内存规范划分：\n\n![image-20230717091757266](E:/Master/TyporaImages/JVM/image-20230717091757266.png)\n\nJVM分为线程共享与隔离区，如上图所示。\n\n下面来介绍一下以上区域的具体功能：\n\n在此之前先说一下线程与进程，这里引用一个博客的图片：\n\n![](https://img-blog.csdnimg.cn/58369465841a4cdea8083b6951dff710.png#pic_center)\n\n\n\n1. 程序计数器\n\n​\t也被称为PC寄存器，是一块较小的内存空间。它可以看作是当前线程所在执行的行号治时期。\n\n2. Java虚拟机栈\n\n   \n\n\n\n","source":"_posts/JVM.md","raw":"---\ntitle: 一篇文章搞懂 JVM\nindex_img: https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311151627635.png\nbanner_img: https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202309111618297.png\ncategories:\n  - JVM\ntags:\n  - Java基础\nabbrlink: 8425\ndate: 2023-01-07 08:58:32\n---\n\n# `JVM`\n\n> 图文详解 50 道Java虚拟机高频面试题，这次面试，一定吊打面试官，整理：csguider，戳[转载链接](https://mp.weixin.qq.com/s/bHhqhl8mH3OAPt3EkaVc8Q)，作者：三分恶，戳[原文链接](https://mp.weixin.qq.com/s/XYsEJyIo46jXhHE1sOR_0Q)\n\n## 一、引言\n\n1. 是什么\n\n> JVM--Java虚拟机，是实现Java编程语言平台无关性特性的基石。\n\n2. 有什么用\n\nJava源程序-（`javac编译` `编译型`）\n\n->.class文件-(`JVM` `解释型`)\n\n->OS机器码\n\n图解：\n\n![](https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/jvm-1.png)\n\n> 这就是说Java 语言“编译与解释并存”的原因\n\n此处的`JVM`：不同OS拥有不同的JVM，正因为有了中间层这个字节码文件，才可以实现跨平台操作\n\n## 二、JVM内存管理\n\n### 内存区域划分：\n\n按照虚拟机内存规范划分：\n\n![image-20230717091757266](E:/Master/TyporaImages/JVM/image-20230717091757266.png)\n\nJVM分为线程共享与隔离区，如上图所示。\n\n下面来介绍一下以上区域的具体功能：\n\n在此之前先说一下线程与进程，这里引用一个博客的图片：\n\n![](https://img-blog.csdnimg.cn/58369465841a4cdea8083b6951dff710.png#pic_center)\n\n\n\n1. 程序计数器\n\n​\t也被称为PC寄存器，是一块较小的内存空间。它可以看作是当前线程所在执行的行号治时期。\n\n2. Java虚拟机栈\n\n   \n\n\n\n","slug":"JVM","published":1,"updated":"2023-11-15T09:21:15.716Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clpkiczii000bfkfocwkw63wp","content":"<h1 id=\"JVM\"><a href=\"#JVM\" class=\"headerlink\" title=\"JVM\"></a><code>JVM</code></h1><blockquote>\n<p>图文详解 50 道Java虚拟机高频面试题，这次面试，一定吊打面试官，整理：csguider，戳<a href=\"https://mp.weixin.qq.com/s/bHhqhl8mH3OAPt3EkaVc8Q\">转载链接</a>，作者：三分恶，戳<a href=\"https://mp.weixin.qq.com/s/XYsEJyIo46jXhHE1sOR_0Q\">原文链接</a></p>\n</blockquote>\n<h2 id=\"一、引言\"><a href=\"#一、引言\" class=\"headerlink\" title=\"一、引言\"></a>一、引言</h2><ol>\n<li>是什么</li>\n</ol>\n<blockquote>\n<p>JVM–Java虚拟机，是实现Java编程语言平台无关性特性的基石。</p>\n</blockquote>\n<ol start=\"2\">\n<li>有什么用</li>\n</ol>\n<p>Java源程序-（<code>javac编译</code> <code>编译型</code>）</p>\n<p>-&gt;.class文件-(<code>JVM</code> <code>解释型</code>)</p>\n<p>-&gt;OS机器码</p>\n<p>图解：</p>\n<p><img src=\"https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/jvm-1.png\"></p>\n<blockquote>\n<p>这就是说Java 语言“编译与解释并存”的原因</p>\n</blockquote>\n<p>此处的<code>JVM</code>：不同OS拥有不同的JVM，正因为有了中间层这个字节码文件，才可以实现跨平台操作</p>\n<h2 id=\"二、JVM内存管理\"><a href=\"#二、JVM内存管理\" class=\"headerlink\" title=\"二、JVM内存管理\"></a>二、JVM内存管理</h2><h3 id=\"内存区域划分：\"><a href=\"#内存区域划分：\" class=\"headerlink\" title=\"内存区域划分：\"></a>内存区域划分：</h3><p>按照虚拟机内存规范划分：</p>\n<p><img src=\"E:/Master/TyporaImages/JVM/image-20230717091757266.png\" alt=\"image-20230717091757266\"></p>\n<p>JVM分为线程共享与隔离区，如上图所示。</p>\n<p>下面来介绍一下以上区域的具体功能：</p>\n<p>在此之前先说一下线程与进程，这里引用一个博客的图片：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/58369465841a4cdea8083b6951dff710.png#pic_center\"></p>\n<ol>\n<li>程序计数器</li>\n</ol>\n<p>​    也被称为PC寄存器，是一块较小的内存空间。它可以看作是当前线程所在执行的行号治时期。</p>\n<ol start=\"2\">\n<li>Java虚拟机栈</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"JVM\"><a href=\"#JVM\" class=\"headerlink\" title=\"JVM\"></a><code>JVM</code></h1><blockquote>\n<p>图文详解 50 道Java虚拟机高频面试题，这次面试，一定吊打面试官，整理：csguider，戳<a href=\"https://mp.weixin.qq.com/s/bHhqhl8mH3OAPt3EkaVc8Q\">转载链接</a>，作者：三分恶，戳<a href=\"https://mp.weixin.qq.com/s/XYsEJyIo46jXhHE1sOR_0Q\">原文链接</a></p>\n</blockquote>\n<h2 id=\"一、引言\"><a href=\"#一、引言\" class=\"headerlink\" title=\"一、引言\"></a>一、引言</h2><ol>\n<li>是什么</li>\n</ol>\n<blockquote>\n<p>JVM–Java虚拟机，是实现Java编程语言平台无关性特性的基石。</p>\n</blockquote>\n<ol start=\"2\">\n<li>有什么用</li>\n</ol>\n<p>Java源程序-（<code>javac编译</code> <code>编译型</code>）</p>\n<p>-&gt;.class文件-(<code>JVM</code> <code>解释型</code>)</p>\n<p>-&gt;OS机器码</p>\n<p>图解：</p>\n<p><img src=\"https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/jvm-1.png\"></p>\n<blockquote>\n<p>这就是说Java 语言“编译与解释并存”的原因</p>\n</blockquote>\n<p>此处的<code>JVM</code>：不同OS拥有不同的JVM，正因为有了中间层这个字节码文件，才可以实现跨平台操作</p>\n<h2 id=\"二、JVM内存管理\"><a href=\"#二、JVM内存管理\" class=\"headerlink\" title=\"二、JVM内存管理\"></a>二、JVM内存管理</h2><h3 id=\"内存区域划分：\"><a href=\"#内存区域划分：\" class=\"headerlink\" title=\"内存区域划分：\"></a>内存区域划分：</h3><p>按照虚拟机内存规范划分：</p>\n<p><img src=\"E:/Master/TyporaImages/JVM/image-20230717091757266.png\" alt=\"image-20230717091757266\"></p>\n<p>JVM分为线程共享与隔离区，如上图所示。</p>\n<p>下面来介绍一下以上区域的具体功能：</p>\n<p>在此之前先说一下线程与进程，这里引用一个博客的图片：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/58369465841a4cdea8083b6951dff710.png#pic_center\"></p>\n<ol>\n<li>程序计数器</li>\n</ol>\n<p>​    也被称为PC寄存器，是一块较小的内存空间。它可以看作是当前线程所在执行的行号治时期。</p>\n<ol start=\"2\">\n<li>Java虚拟机栈</li>\n</ol>\n"},{"title":"001-JZoffer","index_img":"https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311151627628.png","abbrlink":14851,"date":"2023-06-01T01:56:58.000Z","_content":"\n> `JZ6 从尾到头打印链表`\n> \n> 简单 通过率：29.17% 时间限制：1秒 空间限制：64M\n>\n> 知识点[链表](https://www.nowcoder.com/exam/oj/ta?page=1&tpId=13&type=13?tag=580)\n>\n> ## 描述\n>\n> 输入一个链表的头节点，按链表从尾到头的顺序返回每个节点的值（用数组返回）。\n>\n> 如输入{1,2,3}的链表如下图:\n>\n> ![img](https://uploadfiles.nowcoder.com/images/20210717/557336_1626506480516/103D87B58E565E87DEFA9DD0B822C55F)\n>\n> 返回一个数组为[3,2,1]\n>\n> 0 <= 链表长度 <= 10000\n>\n> ## 示例1\n>\n> 输入：\n>\n> ```\n>{1,2,3}\n> ```\n> \n> 返回值：\n>\n> ```\n>[3,2,1]\n> ```\n> \n> ## 示例2\n>\n> 输入：\n>\n> ```\n>{67,0,24,58}\n> ```\n> \n> 返回值：\n>\n> ```\n>[58,24,0,67]\n> ```\n\n`技巧：`\n\n​\t出入栈或者递归\n\n​\t递归方法 + ArrayList的头结点添加元素实现链表逆序\n\n`思路：`\n\n​\t涉及到递归的思想：递归是一个过程或函数在其定义或说明中有直接或间接调用自身的一种方法，它通常把一个大型复杂问题层层转化为一个与原问题相似的小问题来求解。因此，所谓递归就是将一个复杂的问题细化为一个个子问题，这就是递归！\n\n​\t下面说说这个题目：\n\n​\t我们都知道链表无法进行逆序访问，那肯定无法直接遍历链表得到从头到尾的逆序结果。但是我们都知道递归是**到达底层**之后才会**往上层回溯**，因此我们可以考虑递归遍历链表：\n\n​\tstep1:从表头开始往后递归进入每一个节点。\n\n​\tstep2:每次返回添加一个值到新的数组中，直到遇到尾节点（head.next == null）\n\n​\t官方题解思路：\n\n![image-20230721101906413](https://cdn.jsdelivr.net/gh/wl2o2o/blogCdn/img/202307211019432.png)\n\n`code：`\n\n```java\nimport java.util.*;\n/**\n*    public class ListNode {\n*        int val;\n*        ListNode next = null;\n*\n*        ListNode(int val) {\n*            this.val = val;\n*        }\n*    }\n*\n*/\nimport java.util.ArrayList;\n\npublic class Solution {\n    public ArrayList<Integer> printListFromTailToHead(ListNode listNode) {\n        ArrayList<Integer> res = new ArrayList<>();\n        Stack<Integer> s = new Stack<>();\n        while(listNode != null){\n            s.push(listNode.val);\n            listNode = listNode.next;\n        }\n        while(!s.isEmpty()){\n            res.add(s.pop());\n        }\n        return res;\n    }\n}\n```\n\n\n\n```java\nimport java.util.ArrayList;\npublic class Solution {\n    //递归函数\n    public void recursion(ListNode head, ArrayList<Integer> res){ \n        if(head != null){\n            //先往链表深处遍历\n            recursion(head.next, res); \n            //再填充到数组就是逆序\n            res.add(head.val); \n        }\n    }\n    public ArrayList<Integer> printListFromTailToHead(ListNode listNode) {\n        ArrayList<Integer> res = new ArrayList<Integer>();\n        //递归函数解决\n        recursion(listNode, res);\n        return res;\n    }\n}\n```\n\n`结束语：`\n\n​\t本题考查的就是链表的逆向输出，要想逆向输出，\n\n1. 可以遍历链表然后存储到数组中，再利用数组的reverse()方法，直接反序；\n2. 官方题解中的链表递归，其实这个考察的就是递归的思想，递归是**到达底层**之后才会**往上层回溯**（先递进，再回归！可以这么理解）\n3. 既然涉及到链表的反序输出，那么为什么不利用栈呢？先入后出==>逆向输出。\n\n​\t\n\n好久没写算法题，太生疏了！！！每日一题，没有退路，继续加油！","source":"_posts/JZ06PrintLinkedList.md","raw":"---\ntitle: 001-JZoffer\nindex_img: https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311151627628.png\ncategories:\n  - 算法\ntags:\n  - 链表\n  - 递归\n  - ArrayList\nabbrlink: 14851\ndate: 2023-06-01 09:56:58\n---\n\n> `JZ6 从尾到头打印链表`\n> \n> 简单 通过率：29.17% 时间限制：1秒 空间限制：64M\n>\n> 知识点[链表](https://www.nowcoder.com/exam/oj/ta?page=1&tpId=13&type=13?tag=580)\n>\n> ## 描述\n>\n> 输入一个链表的头节点，按链表从尾到头的顺序返回每个节点的值（用数组返回）。\n>\n> 如输入{1,2,3}的链表如下图:\n>\n> ![img](https://uploadfiles.nowcoder.com/images/20210717/557336_1626506480516/103D87B58E565E87DEFA9DD0B822C55F)\n>\n> 返回一个数组为[3,2,1]\n>\n> 0 <= 链表长度 <= 10000\n>\n> ## 示例1\n>\n> 输入：\n>\n> ```\n>{1,2,3}\n> ```\n> \n> 返回值：\n>\n> ```\n>[3,2,1]\n> ```\n> \n> ## 示例2\n>\n> 输入：\n>\n> ```\n>{67,0,24,58}\n> ```\n> \n> 返回值：\n>\n> ```\n>[58,24,0,67]\n> ```\n\n`技巧：`\n\n​\t出入栈或者递归\n\n​\t递归方法 + ArrayList的头结点添加元素实现链表逆序\n\n`思路：`\n\n​\t涉及到递归的思想：递归是一个过程或函数在其定义或说明中有直接或间接调用自身的一种方法，它通常把一个大型复杂问题层层转化为一个与原问题相似的小问题来求解。因此，所谓递归就是将一个复杂的问题细化为一个个子问题，这就是递归！\n\n​\t下面说说这个题目：\n\n​\t我们都知道链表无法进行逆序访问，那肯定无法直接遍历链表得到从头到尾的逆序结果。但是我们都知道递归是**到达底层**之后才会**往上层回溯**，因此我们可以考虑递归遍历链表：\n\n​\tstep1:从表头开始往后递归进入每一个节点。\n\n​\tstep2:每次返回添加一个值到新的数组中，直到遇到尾节点（head.next == null）\n\n​\t官方题解思路：\n\n![image-20230721101906413](https://cdn.jsdelivr.net/gh/wl2o2o/blogCdn/img/202307211019432.png)\n\n`code：`\n\n```java\nimport java.util.*;\n/**\n*    public class ListNode {\n*        int val;\n*        ListNode next = null;\n*\n*        ListNode(int val) {\n*            this.val = val;\n*        }\n*    }\n*\n*/\nimport java.util.ArrayList;\n\npublic class Solution {\n    public ArrayList<Integer> printListFromTailToHead(ListNode listNode) {\n        ArrayList<Integer> res = new ArrayList<>();\n        Stack<Integer> s = new Stack<>();\n        while(listNode != null){\n            s.push(listNode.val);\n            listNode = listNode.next;\n        }\n        while(!s.isEmpty()){\n            res.add(s.pop());\n        }\n        return res;\n    }\n}\n```\n\n\n\n```java\nimport java.util.ArrayList;\npublic class Solution {\n    //递归函数\n    public void recursion(ListNode head, ArrayList<Integer> res){ \n        if(head != null){\n            //先往链表深处遍历\n            recursion(head.next, res); \n            //再填充到数组就是逆序\n            res.add(head.val); \n        }\n    }\n    public ArrayList<Integer> printListFromTailToHead(ListNode listNode) {\n        ArrayList<Integer> res = new ArrayList<Integer>();\n        //递归函数解决\n        recursion(listNode, res);\n        return res;\n    }\n}\n```\n\n`结束语：`\n\n​\t本题考查的就是链表的逆向输出，要想逆向输出，\n\n1. 可以遍历链表然后存储到数组中，再利用数组的reverse()方法，直接反序；\n2. 官方题解中的链表递归，其实这个考察的就是递归的思想，递归是**到达底层**之后才会**往上层回溯**（先递进，再回归！可以这么理解）\n3. 既然涉及到链表的反序输出，那么为什么不利用栈呢？先入后出==>逆向输出。\n\n​\t\n\n好久没写算法题，太生疏了！！！每日一题，没有退路，继续加油！","slug":"JZ06PrintLinkedList","published":1,"updated":"2023-11-15T08:29:46.758Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clpkiczik000ffkfo5wgfa3n1","content":"<blockquote>\n<p><code>JZ6 从尾到头打印链表</code></p>\n<p>简单 通过率：29.17% 时间限制：1秒 空间限制：64M</p>\n<p>知识点<a href=\"https://www.nowcoder.com/exam/oj/ta?page=1&tpId=13&type=13?tag=580\">链表</a></p>\n<h2 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a>描述</h2><p>输入一个链表的头节点，按链表从尾到头的顺序返回每个节点的值（用数组返回）。</p>\n<p>如输入{1,2,3}的链表如下图:</p>\n<p><img src=\"https://uploadfiles.nowcoder.com/images/20210717/557336_1626506480516/103D87B58E565E87DEFA9DD0B822C55F\" alt=\"img\"></p>\n<p>返回一个数组为[3,2,1]</p>\n<p>0 &lt;= 链表长度 &lt;= 10000</p>\n<h2 id=\"示例1\"><a href=\"#示例1\" class=\"headerlink\" title=\"示例1\"></a>示例1</h2><p>输入：</p>\n<figure class=\"highlight dust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs dust\"><span class=\"language-xml\">&gt;</span><span class=\"hljs-template-variable\">&#123;1,2,3&#125;</span><br></code></pre></td></tr></table></figure>\n\n<p>返回值：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\">&gt;<span class=\"hljs-selector-attr\">[3,2,1]</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"示例2\"><a href=\"#示例2\" class=\"headerlink\" title=\"示例2\"></a>示例2</h2><p>输入：</p>\n<figure class=\"highlight dns\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs dns\">&gt;&#123;<span class=\"hljs-number\">67,0,24,58</span>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>返回值：</p>\n<figure class=\"highlight accesslog\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs accesslog\">&gt;<span class=\"hljs-string\">[58,24,0,67]</span><br></code></pre></td></tr></table></figure>\n</blockquote>\n<p><code>技巧：</code></p>\n<p>​    出入栈或者递归</p>\n<p>​    递归方法 + ArrayList的头结点添加元素实现链表逆序</p>\n<p><code>思路：</code></p>\n<p>​    涉及到递归的思想：递归是一个过程或函数在其定义或说明中有直接或间接调用自身的一种方法，它通常把一个大型复杂问题层层转化为一个与原问题相似的小问题来求解。因此，所谓递归就是将一个复杂的问题细化为一个个子问题，这就是递归！</p>\n<p>​    下面说说这个题目：</p>\n<p>​    我们都知道链表无法进行逆序访问，那肯定无法直接遍历链表得到从头到尾的逆序结果。但是我们都知道递归是<strong>到达底层</strong>之后才会<strong>往上层回溯</strong>，因此我们可以考虑递归遍历链表：</p>\n<p>​    step1:从表头开始往后递归进入每一个节点。</p>\n<p>​    step2:每次返回添加一个值到新的数组中，直到遇到尾节点（head.next == null）</p>\n<p>​    官方题解思路：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/wl2o2o/blogCdn/img/202307211019432.png\" alt=\"image-20230721101906413\"></p>\n<p><code>code：</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">import</span> java.util.*;<br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">*    public class ListNode &#123;</span><br><span class=\"hljs-comment\">*        int val;</span><br><span class=\"hljs-comment\">*        ListNode next = null;</span><br><span class=\"hljs-comment\">*</span><br><span class=\"hljs-comment\">*        ListNode(int val) &#123;</span><br><span class=\"hljs-comment\">*            this.val = val;</span><br><span class=\"hljs-comment\">*        &#125;</span><br><span class=\"hljs-comment\">*    &#125;</span><br><span class=\"hljs-comment\">*</span><br><span class=\"hljs-comment\">*/</span><br><span class=\"hljs-keyword\">import</span> java.util.ArrayList;<br><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span> &#123;<br>    <span class=\"hljs-keyword\">public</span> ArrayList&lt;Integer&gt; <span class=\"hljs-title function_\">printListFromTailToHead</span><span class=\"hljs-params\">(ListNode listNode)</span> &#123;<br>        ArrayList&lt;Integer&gt; res = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ArrayList</span>&lt;&gt;();<br>        Stack&lt;Integer&gt; s = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Stack</span>&lt;&gt;();<br>        <span class=\"hljs-keyword\">while</span>(listNode != <span class=\"hljs-literal\">null</span>)&#123;<br>            s.push(listNode.val);<br>            listNode = listNode.next;<br>        &#125;<br>        <span class=\"hljs-keyword\">while</span>(!s.isEmpty())&#123;<br>            res.add(s.pop());<br>        &#125;<br>        <span class=\"hljs-keyword\">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">import</span> java.util.ArrayList;<br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span> &#123;<br>    <span class=\"hljs-comment\">//递归函数</span><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">recursion</span><span class=\"hljs-params\">(ListNode head, ArrayList&lt;Integer&gt; res)</span>&#123; <br>        <span class=\"hljs-keyword\">if</span>(head != <span class=\"hljs-literal\">null</span>)&#123;<br>            <span class=\"hljs-comment\">//先往链表深处遍历</span><br>            recursion(head.next, res); <br>            <span class=\"hljs-comment\">//再填充到数组就是逆序</span><br>            res.add(head.val); <br>        &#125;<br>    &#125;<br>    <span class=\"hljs-keyword\">public</span> ArrayList&lt;Integer&gt; <span class=\"hljs-title function_\">printListFromTailToHead</span><span class=\"hljs-params\">(ListNode listNode)</span> &#123;<br>        ArrayList&lt;Integer&gt; res = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ArrayList</span>&lt;Integer&gt;();<br>        <span class=\"hljs-comment\">//递归函数解决</span><br>        recursion(listNode, res);<br>        <span class=\"hljs-keyword\">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><code>结束语：</code></p>\n<p>​    本题考查的就是链表的逆向输出，要想逆向输出，</p>\n<ol>\n<li>可以遍历链表然后存储到数组中，再利用数组的reverse()方法，直接反序；</li>\n<li>官方题解中的链表递归，其实这个考察的就是递归的思想，递归是<strong>到达底层</strong>之后才会<strong>往上层回溯</strong>（先递进，再回归！可以这么理解）</li>\n<li>既然涉及到链表的反序输出，那么为什么不利用栈呢？先入后出==&gt;逆向输出。</li>\n</ol>\n<p>​    </p>\n<p>好久没写算法题，太生疏了！！！每日一题，没有退路，继续加油！</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p><code>JZ6 从尾到头打印链表</code></p>\n<p>简单 通过率：29.17% 时间限制：1秒 空间限制：64M</p>\n<p>知识点<a href=\"https://www.nowcoder.com/exam/oj/ta?page=1&tpId=13&type=13?tag=580\">链表</a></p>\n<h2 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a>描述</h2><p>输入一个链表的头节点，按链表从尾到头的顺序返回每个节点的值（用数组返回）。</p>\n<p>如输入{1,2,3}的链表如下图:</p>\n<p><img src=\"https://uploadfiles.nowcoder.com/images/20210717/557336_1626506480516/103D87B58E565E87DEFA9DD0B822C55F\" alt=\"img\"></p>\n<p>返回一个数组为[3,2,1]</p>\n<p>0 &lt;= 链表长度 &lt;= 10000</p>\n<h2 id=\"示例1\"><a href=\"#示例1\" class=\"headerlink\" title=\"示例1\"></a>示例1</h2><p>输入：</p>\n<figure class=\"highlight dust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs dust\"><span class=\"language-xml\">&gt;</span><span class=\"hljs-template-variable\">&#123;1,2,3&#125;</span><br></code></pre></td></tr></table></figure>\n\n<p>返回值：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\">&gt;<span class=\"hljs-selector-attr\">[3,2,1]</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"示例2\"><a href=\"#示例2\" class=\"headerlink\" title=\"示例2\"></a>示例2</h2><p>输入：</p>\n<figure class=\"highlight dns\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs dns\">&gt;&#123;<span class=\"hljs-number\">67,0,24,58</span>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>返回值：</p>\n<figure class=\"highlight accesslog\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs accesslog\">&gt;<span class=\"hljs-string\">[58,24,0,67]</span><br></code></pre></td></tr></table></figure>\n</blockquote>\n<p><code>技巧：</code></p>\n<p>​    出入栈或者递归</p>\n<p>​    递归方法 + ArrayList的头结点添加元素实现链表逆序</p>\n<p><code>思路：</code></p>\n<p>​    涉及到递归的思想：递归是一个过程或函数在其定义或说明中有直接或间接调用自身的一种方法，它通常把一个大型复杂问题层层转化为一个与原问题相似的小问题来求解。因此，所谓递归就是将一个复杂的问题细化为一个个子问题，这就是递归！</p>\n<p>​    下面说说这个题目：</p>\n<p>​    我们都知道链表无法进行逆序访问，那肯定无法直接遍历链表得到从头到尾的逆序结果。但是我们都知道递归是<strong>到达底层</strong>之后才会<strong>往上层回溯</strong>，因此我们可以考虑递归遍历链表：</p>\n<p>​    step1:从表头开始往后递归进入每一个节点。</p>\n<p>​    step2:每次返回添加一个值到新的数组中，直到遇到尾节点（head.next == null）</p>\n<p>​    官方题解思路：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/wl2o2o/blogCdn/img/202307211019432.png\" alt=\"image-20230721101906413\"></p>\n<p><code>code：</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">import</span> java.util.*;<br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">*    public class ListNode &#123;</span><br><span class=\"hljs-comment\">*        int val;</span><br><span class=\"hljs-comment\">*        ListNode next = null;</span><br><span class=\"hljs-comment\">*</span><br><span class=\"hljs-comment\">*        ListNode(int val) &#123;</span><br><span class=\"hljs-comment\">*            this.val = val;</span><br><span class=\"hljs-comment\">*        &#125;</span><br><span class=\"hljs-comment\">*    &#125;</span><br><span class=\"hljs-comment\">*</span><br><span class=\"hljs-comment\">*/</span><br><span class=\"hljs-keyword\">import</span> java.util.ArrayList;<br><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span> &#123;<br>    <span class=\"hljs-keyword\">public</span> ArrayList&lt;Integer&gt; <span class=\"hljs-title function_\">printListFromTailToHead</span><span class=\"hljs-params\">(ListNode listNode)</span> &#123;<br>        ArrayList&lt;Integer&gt; res = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ArrayList</span>&lt;&gt;();<br>        Stack&lt;Integer&gt; s = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Stack</span>&lt;&gt;();<br>        <span class=\"hljs-keyword\">while</span>(listNode != <span class=\"hljs-literal\">null</span>)&#123;<br>            s.push(listNode.val);<br>            listNode = listNode.next;<br>        &#125;<br>        <span class=\"hljs-keyword\">while</span>(!s.isEmpty())&#123;<br>            res.add(s.pop());<br>        &#125;<br>        <span class=\"hljs-keyword\">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">import</span> java.util.ArrayList;<br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span> &#123;<br>    <span class=\"hljs-comment\">//递归函数</span><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">recursion</span><span class=\"hljs-params\">(ListNode head, ArrayList&lt;Integer&gt; res)</span>&#123; <br>        <span class=\"hljs-keyword\">if</span>(head != <span class=\"hljs-literal\">null</span>)&#123;<br>            <span class=\"hljs-comment\">//先往链表深处遍历</span><br>            recursion(head.next, res); <br>            <span class=\"hljs-comment\">//再填充到数组就是逆序</span><br>            res.add(head.val); <br>        &#125;<br>    &#125;<br>    <span class=\"hljs-keyword\">public</span> ArrayList&lt;Integer&gt; <span class=\"hljs-title function_\">printListFromTailToHead</span><span class=\"hljs-params\">(ListNode listNode)</span> &#123;<br>        ArrayList&lt;Integer&gt; res = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ArrayList</span>&lt;Integer&gt;();<br>        <span class=\"hljs-comment\">//递归函数解决</span><br>        recursion(listNode, res);<br>        <span class=\"hljs-keyword\">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><code>结束语：</code></p>\n<p>​    本题考查的就是链表的逆向输出，要想逆向输出，</p>\n<ol>\n<li>可以遍历链表然后存储到数组中，再利用数组的reverse()方法，直接反序；</li>\n<li>官方题解中的链表递归，其实这个考察的就是递归的思想，递归是<strong>到达底层</strong>之后才会<strong>往上层回溯</strong>（先递进，再回归！可以这么理解）</li>\n<li>既然涉及到链表的反序输出，那么为什么不利用栈呢？先入后出==&gt;逆向输出。</li>\n</ol>\n<p>​    </p>\n<p>好久没写算法题，太生疏了！！！每日一题，没有退路，继续加油！</p>\n"},{"title":"002-JZoffer","index_img":"https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311151627628.png","abbrlink":51735,"date":"2023-06-01T01:56:58.000Z","_content":"\n#  JZ24 反转链表\n\n> 简单 通过率：38.87% 时间限制：1秒 空间限制：256M\n>\n> 知识点[链表](https://www.nowcoder.com/exam/oj/ta?page=1&tpId=13&type=13?tag=580)\n>\n> ## 描述\n>\n> 给定一个单链表的头结点pHead(该头节点是有值的，比如在下图，它的val是1)，长度为n，反转该链表后，返回新链表的表头。\n>\n> 数据范围： 0≤n≤1000\n>\n> 要求：空间复杂度 O(1) ，时间复杂度 O(n) 。\n>\n> 如当输入链表{1,2,3}时，\n>\n> 经反转后，原链表变为{3,2,1}，所以对应的输出为{3,2,1}。\n>\n> 以上转换过程如下图所示：\n>\n> ![img](https://uploadfiles.nowcoder.com/images/20211014/423483716_1634206291971/4A47A0DB6E60853DEDFCFDF08A5CA249)\n>\n> ## 示例1\n>\n> 输入：\n>\n> ```\n> {1,2,3}\n> ```\n>\n> 返回值：\n>\n> ```\n> {3,2,1}\n> ```\n>\n> ## 示例2\n>\n> 输入：\n>\n> ```\n> {}\n> ```\n>\n> 返回值：\n>\n> ```\n> {}\n> ```\n>\n> 说明：\n>\n> ```\n> 空链表则输出空                 \n> ```\n\n## 我的题解\n\n>  技巧： \n>\n>  \t出入栈\n>  \t\t\t\n>  \t要明白ListNode创建的是结点，所以需要另外创建一个curr指针，来指向结点，进而完成对链表的操作。\n>\n>  思路： \n>\n>  ```\n>  思路一：\n>  \t顺序压栈，然后指定新的头（newHead），然后while循环弹栈；\n>  \n>  思路二：\n>  \t迭代的思想（代码见官方题解方法一），反转指针指向，curr.next = pre;\n>  ```\n>\n>  思路一：\n>\n>  ```java\n>  import java.util.*;\n>  \n>  /*\n>   * public class ListNode {\n>   *   int val;\n>   *   ListNode next = null;\n>   *   public ListNode(int val) {\n>   *     this.val = val;\n>   *   }\n>   * }\n>   */\n>  \n>  \n>  public class Solution {\n>      /**\n>       * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可\n>       *\n>       *\n>       * @param head ListNode类\n>       * @return ListNode类\n>       */\n>      public ListNode ReverseList (ListNode head) {\n>          // write code here\n>          Stack<ListNode> s = new Stack<>();\n>          // 入栈\n>          while (head != null) {\n>              s.push(head);\n>              head = head.next;\n>          }\n>          if(s.isEmpty()) return null;\n>  \n>          // 出栈\n>          ListNode newHead = s.pop(); // 反转后的链表头节点\n>          ListNode curr = newHead;\n>          // 出栈并连接节点\n>          while (!s.isEmpty()) {\n>              curr.next = s.pop();\n>              curr = curr.next;\n>          }\n>          curr.next = null; // 将最后一个节点的next指针置空\n>  \n>          return newHead; // 返回反转后的链表头节点\n>      }\n>  }\n>  ```\n>\n>  \n\n## 官方题解思路\n\n### 方法一：迭代（推荐使用）\n\n**思路：**\n\n将链表反转，就是将每个表元的指针从向后变成向前，那我们可以遍历原始链表，将遇到的节点一一指针逆向即可。指针怎么逆向？不过就是断掉当前节点向后的指针，改为向前罢了。\n\n```\ncur.next = pre\n```\n\n**具体做法：**\n\n- step 1：优先处理空链表，空链表不需要反转。\n- step 2：我们可以设置两个指针，一个当前节点的指针，一个上一个节点的指针（初始为空）。\n- step 3：遍历整个链表，每到一个节点，断开当前节点与后面节点的指针，并用临时变量记录后一个节点，然后当前节点指向上一个节点，即可以将指针逆向。\n- step 4：再轮换当前指针与上一个指针，让它们进入下一个节点及下一个节点的前序节点。\n\n**图示：** ![alt](https://uploadfiles.nowcoder.com/images/20211001/397721558_1633084777359/E53A90674EDC6B8D31549D8DF4E7B38E)\n\n**Java实现代码：**\n\n[复制代码](https://www.nowcoder.com/practice/75e878df47f24fdc9dc3e400ec6058ca?tpId=13&tqId=23286&ru=/exam/oj/ta&qru=/ta/coding-interviews/question-ranking&sourceUrl=%2Fexam%2Foj%2Fta%3Fpage%3D1%26tpId%3D13%26type%3D13#)\n\n```java\npublic class  Solution {\n\tpublic   ListNode ReverseList(ListNode head) { \n    //处理空链表        \n    if (head ==   null)   return   null  ;    \n        \n    ListNode cur = head;        \n    ListNode pre =   null  ;    \n    \n    while  (cur !=   null  ){          \n    \t//断开链表，要记录后续一个          \n    \tListNode temp = cur.next;  \n        \n    \t//当前的next指向前一个          \n    \tcur.next = pre;     \n        \n    \t//前一个更新为当前          \n    \tpre = cur;       \n        \n    \t//当前更新为刚刚记录的后一个          \n    \tcur = temp;        \n    }        \n    return   pre;      \n    }   \n}\n```\n\n##### 方法二：递归（扩展思路）\n\n**思路：**\n\n从上述方法一，我们可以看到每当我们反转链表的一个节点以后，要遍历进入下一个节点进入反转，相当于对后续的子链表进行反转，这可以看成是一个子问题，因此我们也可以使用递归，其三段式模版为：\n\n- **终止条件：** 当到达链表尾，要么当前指针是空，要么下一个指针是空，就返回。\n- **返回值：** 每一级返回反转后的子问题的头节点。\n- **本级任务：** 先进入后一个节点作为子问题。等到子问题都反转完成，再将本级节点与后一个的指针反转。\n\n**具体做法：**\n\n- step 1：对于每个节点我们递归向下遍历到最后的尾节点。\n- step 2：然后往上依次逆转两个节点。\n- step 3：将逆转后的本层节点，即反转后这后半段子链表的尾，指向null，返回最底层上来的头部节点。\n\n**Java实现代码：**\n\n```Java\npublic   class   Solution {\n\tpublic   ListNode ReverseList(ListNode head) { \n    \t//递归结束条件        \n    \tif  (head ==   null   || head.next ==   null  ) \n        \treturn   head;        \n        \t\n        //反转下一个        \n        ListNode newHead = ReverseList(head.next);        \n        \n        //逆转本级节点        \n        head.next.next = head;        \n        \n        //尾部设置空节点        \n        head.next =   null  ;        \n        \n        return   newHead；\n            \n    }  \n}\n```\n\n\n\n总结：对于重复的子问题，可以使用递归的方法。\n","source":"_posts/JZ24ReverseLinkedList.md","raw":"---\ntitle: 002-JZoffer\nindex_img: https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311151627628.png\ncategories:\n  - 算法\ntags:\n  - 链表反转\n  - 迭代\n  - 递归\nabbrlink: 51735\ndate: 2023-06-01 09:56:58\n---\n\n#  JZ24 反转链表\n\n> 简单 通过率：38.87% 时间限制：1秒 空间限制：256M\n>\n> 知识点[链表](https://www.nowcoder.com/exam/oj/ta?page=1&tpId=13&type=13?tag=580)\n>\n> ## 描述\n>\n> 给定一个单链表的头结点pHead(该头节点是有值的，比如在下图，它的val是1)，长度为n，反转该链表后，返回新链表的表头。\n>\n> 数据范围： 0≤n≤1000\n>\n> 要求：空间复杂度 O(1) ，时间复杂度 O(n) 。\n>\n> 如当输入链表{1,2,3}时，\n>\n> 经反转后，原链表变为{3,2,1}，所以对应的输出为{3,2,1}。\n>\n> 以上转换过程如下图所示：\n>\n> ![img](https://uploadfiles.nowcoder.com/images/20211014/423483716_1634206291971/4A47A0DB6E60853DEDFCFDF08A5CA249)\n>\n> ## 示例1\n>\n> 输入：\n>\n> ```\n> {1,2,3}\n> ```\n>\n> 返回值：\n>\n> ```\n> {3,2,1}\n> ```\n>\n> ## 示例2\n>\n> 输入：\n>\n> ```\n> {}\n> ```\n>\n> 返回值：\n>\n> ```\n> {}\n> ```\n>\n> 说明：\n>\n> ```\n> 空链表则输出空                 \n> ```\n\n## 我的题解\n\n>  技巧： \n>\n>  \t出入栈\n>  \t\t\t\n>  \t要明白ListNode创建的是结点，所以需要另外创建一个curr指针，来指向结点，进而完成对链表的操作。\n>\n>  思路： \n>\n>  ```\n>  思路一：\n>  \t顺序压栈，然后指定新的头（newHead），然后while循环弹栈；\n>  \n>  思路二：\n>  \t迭代的思想（代码见官方题解方法一），反转指针指向，curr.next = pre;\n>  ```\n>\n>  思路一：\n>\n>  ```java\n>  import java.util.*;\n>  \n>  /*\n>   * public class ListNode {\n>   *   int val;\n>   *   ListNode next = null;\n>   *   public ListNode(int val) {\n>   *     this.val = val;\n>   *   }\n>   * }\n>   */\n>  \n>  \n>  public class Solution {\n>      /**\n>       * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可\n>       *\n>       *\n>       * @param head ListNode类\n>       * @return ListNode类\n>       */\n>      public ListNode ReverseList (ListNode head) {\n>          // write code here\n>          Stack<ListNode> s = new Stack<>();\n>          // 入栈\n>          while (head != null) {\n>              s.push(head);\n>              head = head.next;\n>          }\n>          if(s.isEmpty()) return null;\n>  \n>          // 出栈\n>          ListNode newHead = s.pop(); // 反转后的链表头节点\n>          ListNode curr = newHead;\n>          // 出栈并连接节点\n>          while (!s.isEmpty()) {\n>              curr.next = s.pop();\n>              curr = curr.next;\n>          }\n>          curr.next = null; // 将最后一个节点的next指针置空\n>  \n>          return newHead; // 返回反转后的链表头节点\n>      }\n>  }\n>  ```\n>\n>  \n\n## 官方题解思路\n\n### 方法一：迭代（推荐使用）\n\n**思路：**\n\n将链表反转，就是将每个表元的指针从向后变成向前，那我们可以遍历原始链表，将遇到的节点一一指针逆向即可。指针怎么逆向？不过就是断掉当前节点向后的指针，改为向前罢了。\n\n```\ncur.next = pre\n```\n\n**具体做法：**\n\n- step 1：优先处理空链表，空链表不需要反转。\n- step 2：我们可以设置两个指针，一个当前节点的指针，一个上一个节点的指针（初始为空）。\n- step 3：遍历整个链表，每到一个节点，断开当前节点与后面节点的指针，并用临时变量记录后一个节点，然后当前节点指向上一个节点，即可以将指针逆向。\n- step 4：再轮换当前指针与上一个指针，让它们进入下一个节点及下一个节点的前序节点。\n\n**图示：** ![alt](https://uploadfiles.nowcoder.com/images/20211001/397721558_1633084777359/E53A90674EDC6B8D31549D8DF4E7B38E)\n\n**Java实现代码：**\n\n[复制代码](https://www.nowcoder.com/practice/75e878df47f24fdc9dc3e400ec6058ca?tpId=13&tqId=23286&ru=/exam/oj/ta&qru=/ta/coding-interviews/question-ranking&sourceUrl=%2Fexam%2Foj%2Fta%3Fpage%3D1%26tpId%3D13%26type%3D13#)\n\n```java\npublic class  Solution {\n\tpublic   ListNode ReverseList(ListNode head) { \n    //处理空链表        \n    if (head ==   null)   return   null  ;    \n        \n    ListNode cur = head;        \n    ListNode pre =   null  ;    \n    \n    while  (cur !=   null  ){          \n    \t//断开链表，要记录后续一个          \n    \tListNode temp = cur.next;  \n        \n    \t//当前的next指向前一个          \n    \tcur.next = pre;     \n        \n    \t//前一个更新为当前          \n    \tpre = cur;       \n        \n    \t//当前更新为刚刚记录的后一个          \n    \tcur = temp;        \n    }        \n    return   pre;      \n    }   \n}\n```\n\n##### 方法二：递归（扩展思路）\n\n**思路：**\n\n从上述方法一，我们可以看到每当我们反转链表的一个节点以后，要遍历进入下一个节点进入反转，相当于对后续的子链表进行反转，这可以看成是一个子问题，因此我们也可以使用递归，其三段式模版为：\n\n- **终止条件：** 当到达链表尾，要么当前指针是空，要么下一个指针是空，就返回。\n- **返回值：** 每一级返回反转后的子问题的头节点。\n- **本级任务：** 先进入后一个节点作为子问题。等到子问题都反转完成，再将本级节点与后一个的指针反转。\n\n**具体做法：**\n\n- step 1：对于每个节点我们递归向下遍历到最后的尾节点。\n- step 2：然后往上依次逆转两个节点。\n- step 3：将逆转后的本层节点，即反转后这后半段子链表的尾，指向null，返回最底层上来的头部节点。\n\n**Java实现代码：**\n\n```Java\npublic   class   Solution {\n\tpublic   ListNode ReverseList(ListNode head) { \n    \t//递归结束条件        \n    \tif  (head ==   null   || head.next ==   null  ) \n        \treturn   head;        \n        \t\n        //反转下一个        \n        ListNode newHead = ReverseList(head.next);        \n        \n        //逆转本级节点        \n        head.next.next = head;        \n        \n        //尾部设置空节点        \n        head.next =   null  ;        \n        \n        return   newHead；\n            \n    }  \n}\n```\n\n\n\n总结：对于重复的子问题，可以使用递归的方法。\n","slug":"JZ24ReverseLinkedList","published":1,"updated":"2023-11-15T08:29:34.980Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clpkiczil000hfkfoer3x5oxs","content":"<h1 id=\"JZ24-反转链表\"><a href=\"#JZ24-反转链表\" class=\"headerlink\" title=\"JZ24 反转链表\"></a>JZ24 反转链表</h1><blockquote>\n<p>简单 通过率：38.87% 时间限制：1秒 空间限制：256M</p>\n<p>知识点<a href=\"https://www.nowcoder.com/exam/oj/ta?page=1&tpId=13&type=13?tag=580\">链表</a></p>\n<h2 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a>描述</h2><p>给定一个单链表的头结点pHead(该头节点是有值的，比如在下图，它的val是1)，长度为n，反转该链表后，返回新链表的表头。</p>\n<p>数据范围： 0≤n≤1000</p>\n<p>要求：空间复杂度 O(1) ，时间复杂度 O(n) 。</p>\n<p>如当输入链表{1,2,3}时，</p>\n<p>经反转后，原链表变为{3,2,1}，所以对应的输出为{3,2,1}。</p>\n<p>以上转换过程如下图所示：</p>\n<p><img src=\"https://uploadfiles.nowcoder.com/images/20211014/423483716_1634206291971/4A47A0DB6E60853DEDFCFDF08A5CA249\" alt=\"img\"></p>\n<h2 id=\"示例1\"><a href=\"#示例1\" class=\"headerlink\" title=\"示例1\"></a>示例1</h2><p>输入：</p>\n<figure class=\"highlight dust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs dust\"><span class=\"hljs-template-variable\">&#123;1,2,3&#125;</span><br></code></pre></td></tr></table></figure>\n\n<p>返回值：</p>\n<figure class=\"highlight dust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs dust\"><span class=\"hljs-template-variable\">&#123;3,2,1&#125;</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"示例2\"><a href=\"#示例2\" class=\"headerlink\" title=\"示例2\"></a>示例2</h2><p>输入：</p>\n<figure class=\"highlight dust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs dust\"><span class=\"hljs-template-variable\">&#123;&#125;</span><br></code></pre></td></tr></table></figure>\n\n<p>返回值：</p>\n<figure class=\"highlight dust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs dust\"><span class=\"hljs-template-variable\">&#123;&#125;</span><br></code></pre></td></tr></table></figure>\n\n<p>说明：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs\">空链表则输出空                 <br></code></pre></td></tr></table></figure>\n</blockquote>\n<h2 id=\"我的题解\"><a href=\"#我的题解\" class=\"headerlink\" title=\"我的题解\"></a>我的题解</h2><blockquote>\n<p> 技巧： </p>\n<pre><code class=\"hljs\"> 出入栈\n         \n 要明白ListNode创建的是结点，所以需要另外创建一个curr指针，来指向结点，进而完成对链表的操作。\n</code></pre>\n<p> 思路： </p>\n <figure class=\"highlight haxe\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs haxe\">思路一：<br>\t顺序压栈，然后指定新的头（<span class=\"hljs-keyword\">new</span><span class=\"hljs-type\">Head</span>），然后<span class=\"hljs-keyword\">while</span>循环弹栈；<br><br>思路二：<br>\t迭代的思想（代码见官方题解方法一），反转指针指向，curr.next = pre;<br></code></pre></td></tr></table></figure>\n\n<p> 思路一：</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">import</span> java.util.*;<br><br><span class=\"hljs-comment\">/*</span><br><span class=\"hljs-comment\"> * public class ListNode &#123;</span><br><span class=\"hljs-comment\"> *   int val;</span><br><span class=\"hljs-comment\"> *   ListNode next = null;</span><br><span class=\"hljs-comment\"> *   public ListNode(int val) &#123;</span><br><span class=\"hljs-comment\"> *     this.val = val;</span><br><span class=\"hljs-comment\"> *   &#125;</span><br><span class=\"hljs-comment\"> * &#125;</span><br><span class=\"hljs-comment\"> */</span><br><br><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span> &#123;<br>    <span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class=\"hljs-comment\">     *</span><br><span class=\"hljs-comment\">     *</span><br><span class=\"hljs-comment\">     * <span class=\"hljs-doctag\">@param</span> head ListNode类</span><br><span class=\"hljs-comment\">     * <span class=\"hljs-doctag\">@return</span> ListNode类</span><br><span class=\"hljs-comment\">     */</span><br>    <span class=\"hljs-keyword\">public</span> ListNode <span class=\"hljs-title function_\">ReverseList</span> <span class=\"hljs-params\">(ListNode head)</span> &#123;<br>        <span class=\"hljs-comment\">// write code here</span><br>        Stack&lt;ListNode&gt; s = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Stack</span>&lt;&gt;();<br>        <span class=\"hljs-comment\">// 入栈</span><br>        <span class=\"hljs-keyword\">while</span> (head != <span class=\"hljs-literal\">null</span>) &#123;<br>            s.push(head);<br>            head = head.next;<br>        &#125;<br>        <span class=\"hljs-keyword\">if</span>(s.isEmpty()) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">null</span>;<br><br>        <span class=\"hljs-comment\">// 出栈</span><br>        <span class=\"hljs-type\">ListNode</span> <span class=\"hljs-variable\">newHead</span> <span class=\"hljs-operator\">=</span> s.pop(); <span class=\"hljs-comment\">// 反转后的链表头节点</span><br>        <span class=\"hljs-type\">ListNode</span> <span class=\"hljs-variable\">curr</span> <span class=\"hljs-operator\">=</span> newHead;<br>        <span class=\"hljs-comment\">// 出栈并连接节点</span><br>        <span class=\"hljs-keyword\">while</span> (!s.isEmpty()) &#123;<br>            curr.next = s.pop();<br>            curr = curr.next;<br>        &#125;<br>        curr.next = <span class=\"hljs-literal\">null</span>; <span class=\"hljs-comment\">// 将最后一个节点的next指针置空</span><br><br>        <span class=\"hljs-keyword\">return</span> newHead; <span class=\"hljs-comment\">// 返回反转后的链表头节点</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n</blockquote>\n<h2 id=\"官方题解思路\"><a href=\"#官方题解思路\" class=\"headerlink\" title=\"官方题解思路\"></a>官方题解思路</h2><h3 id=\"方法一：迭代（推荐使用）\"><a href=\"#方法一：迭代（推荐使用）\" class=\"headerlink\" title=\"方法一：迭代（推荐使用）\"></a>方法一：迭代（推荐使用）</h3><p><strong>思路：</strong></p>\n<p>将链表反转，就是将每个表元的指针从向后变成向前，那我们可以遍历原始链表，将遇到的节点一一指针逆向即可。指针怎么逆向？不过就是断掉当前节点向后的指针，改为向前罢了。</p>\n<figure class=\"highlight ini\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ini\"><span class=\"hljs-attr\">cur.next</span> = pre<br></code></pre></td></tr></table></figure>\n\n<p><strong>具体做法：</strong></p>\n<ul>\n<li>step 1：优先处理空链表，空链表不需要反转。</li>\n<li>step 2：我们可以设置两个指针，一个当前节点的指针，一个上一个节点的指针（初始为空）。</li>\n<li>step 3：遍历整个链表，每到一个节点，断开当前节点与后面节点的指针，并用临时变量记录后一个节点，然后当前节点指向上一个节点，即可以将指针逆向。</li>\n<li>step 4：再轮换当前指针与上一个指针，让它们进入下一个节点及下一个节点的前序节点。</li>\n</ul>\n<p><strong>图示：</strong> <img src=\"https://uploadfiles.nowcoder.com/images/20211001/397721558_1633084777359/E53A90674EDC6B8D31549D8DF4E7B38E\" alt=\"alt\"></p>\n<p><strong>Java实现代码：</strong></p>\n<p><a href=\"https://www.nowcoder.com/practice/75e878df47f24fdc9dc3e400ec6058ca?tpId=13&tqId=23286&ru=/exam/oj/ta&qru=/ta/coding-interviews/question-ranking&sourceUrl=/exam/oj/ta?page=1&tpId=13&type=13#\">复制代码</a></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span>  <span class=\"hljs-title class_\">Solution</span> &#123;<br>\t<span class=\"hljs-keyword\">public</span>   ListNode <span class=\"hljs-title function_\">ReverseList</span><span class=\"hljs-params\">(ListNode head)</span> &#123; <br>    <span class=\"hljs-comment\">//处理空链表        </span><br>    <span class=\"hljs-keyword\">if</span> (head ==   <span class=\"hljs-literal\">null</span>)   <span class=\"hljs-keyword\">return</span>   <span class=\"hljs-literal\">null</span>  ;    <br>        <br>    <span class=\"hljs-type\">ListNode</span> <span class=\"hljs-variable\">cur</span> <span class=\"hljs-operator\">=</span> head;        <br>    <span class=\"hljs-type\">ListNode</span> <span class=\"hljs-variable\">pre</span> <span class=\"hljs-operator\">=</span>   <span class=\"hljs-literal\">null</span>  ;    <br>    <br>    <span class=\"hljs-keyword\">while</span>  (cur !=   <span class=\"hljs-literal\">null</span>  )&#123;          <br>    \t<span class=\"hljs-comment\">//断开链表，要记录后续一个          </span><br>    \t<span class=\"hljs-type\">ListNode</span> <span class=\"hljs-variable\">temp</span> <span class=\"hljs-operator\">=</span> cur.next;  <br>        <br>    \t<span class=\"hljs-comment\">//当前的next指向前一个          </span><br>    \tcur.next = pre;     <br>        <br>    \t<span class=\"hljs-comment\">//前一个更新为当前          </span><br>    \tpre = cur;       <br>        <br>    \t<span class=\"hljs-comment\">//当前更新为刚刚记录的后一个          </span><br>    \tcur = temp;        <br>    &#125;        <br>    <span class=\"hljs-keyword\">return</span>   pre;      <br>    &#125;   <br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h5 id=\"方法二：递归（扩展思路）\"><a href=\"#方法二：递归（扩展思路）\" class=\"headerlink\" title=\"方法二：递归（扩展思路）\"></a>方法二：递归（扩展思路）</h5><p><strong>思路：</strong></p>\n<p>从上述方法一，我们可以看到每当我们反转链表的一个节点以后，要遍历进入下一个节点进入反转，相当于对后续的子链表进行反转，这可以看成是一个子问题，因此我们也可以使用递归，其三段式模版为：</p>\n<ul>\n<li><strong>终止条件：</strong> 当到达链表尾，要么当前指针是空，要么下一个指针是空，就返回。</li>\n<li><strong>返回值：</strong> 每一级返回反转后的子问题的头节点。</li>\n<li><strong>本级任务：</strong> 先进入后一个节点作为子问题。等到子问题都反转完成，再将本级节点与后一个的指针反转。</li>\n</ul>\n<p><strong>具体做法：</strong></p>\n<ul>\n<li>step 1：对于每个节点我们递归向下遍历到最后的尾节点。</li>\n<li>step 2：然后往上依次逆转两个节点。</li>\n<li>step 3：将逆转后的本层节点，即反转后这后半段子链表的尾，指向null，返回最底层上来的头部节点。</li>\n</ul>\n<p><strong>Java实现代码：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Java\"><span class=\"hljs-keyword\">public</span>   <span class=\"hljs-keyword\">class</span>   <span class=\"hljs-title class_\">Solution</span> &#123;<br>\t<span class=\"hljs-keyword\">public</span>   ListNode <span class=\"hljs-title function_\">ReverseList</span><span class=\"hljs-params\">(ListNode head)</span> &#123; <br>    \t<span class=\"hljs-comment\">//递归结束条件        </span><br>    \t<span class=\"hljs-keyword\">if</span>  (head ==   <span class=\"hljs-literal\">null</span>   || head.next ==   <span class=\"hljs-literal\">null</span>  ) <br>        \t<span class=\"hljs-keyword\">return</span>   head;        <br>        \t<br>        <span class=\"hljs-comment\">//反转下一个        </span><br>        <span class=\"hljs-type\">ListNode</span> <span class=\"hljs-variable\">newHead</span> <span class=\"hljs-operator\">=</span> ReverseList(head.next);        <br>        <br>        <span class=\"hljs-comment\">//逆转本级节点        </span><br>        head.next.next = head;        <br>        <br>        <span class=\"hljs-comment\">//尾部设置空节点        </span><br>        head.next =   <span class=\"hljs-literal\">null</span>  ;        <br>        <br>        <span class=\"hljs-keyword\">return</span>   newHead；<br>            <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure>\n\n\n\n<p>总结：对于重复的子问题，可以使用递归的方法。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"JZ24-反转链表\"><a href=\"#JZ24-反转链表\" class=\"headerlink\" title=\"JZ24 反转链表\"></a>JZ24 反转链表</h1><blockquote>\n<p>简单 通过率：38.87% 时间限制：1秒 空间限制：256M</p>\n<p>知识点<a href=\"https://www.nowcoder.com/exam/oj/ta?page=1&tpId=13&type=13?tag=580\">链表</a></p>\n<h2 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a>描述</h2><p>给定一个单链表的头结点pHead(该头节点是有值的，比如在下图，它的val是1)，长度为n，反转该链表后，返回新链表的表头。</p>\n<p>数据范围： 0≤n≤1000</p>\n<p>要求：空间复杂度 O(1) ，时间复杂度 O(n) 。</p>\n<p>如当输入链表{1,2,3}时，</p>\n<p>经反转后，原链表变为{3,2,1}，所以对应的输出为{3,2,1}。</p>\n<p>以上转换过程如下图所示：</p>\n<p><img src=\"https://uploadfiles.nowcoder.com/images/20211014/423483716_1634206291971/4A47A0DB6E60853DEDFCFDF08A5CA249\" alt=\"img\"></p>\n<h2 id=\"示例1\"><a href=\"#示例1\" class=\"headerlink\" title=\"示例1\"></a>示例1</h2><p>输入：</p>\n<figure class=\"highlight dust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs dust\"><span class=\"hljs-template-variable\">&#123;1,2,3&#125;</span><br></code></pre></td></tr></table></figure>\n\n<p>返回值：</p>\n<figure class=\"highlight dust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs dust\"><span class=\"hljs-template-variable\">&#123;3,2,1&#125;</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"示例2\"><a href=\"#示例2\" class=\"headerlink\" title=\"示例2\"></a>示例2</h2><p>输入：</p>\n<figure class=\"highlight dust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs dust\"><span class=\"hljs-template-variable\">&#123;&#125;</span><br></code></pre></td></tr></table></figure>\n\n<p>返回值：</p>\n<figure class=\"highlight dust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs dust\"><span class=\"hljs-template-variable\">&#123;&#125;</span><br></code></pre></td></tr></table></figure>\n\n<p>说明：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs\">空链表则输出空                 <br></code></pre></td></tr></table></figure>\n</blockquote>\n<h2 id=\"我的题解\"><a href=\"#我的题解\" class=\"headerlink\" title=\"我的题解\"></a>我的题解</h2><blockquote>\n<p> 技巧： </p>\n<pre><code> 出入栈\n         \n 要明白ListNode创建的是结点，所以需要另外创建一个curr指针，来指向结点，进而完成对链表的操作。\n</code></pre>\n<p> 思路： </p>\n <figure class=\"highlight haxe\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs haxe\">思路一：<br>\t顺序压栈，然后指定新的头（<span class=\"hljs-keyword\">new</span><span class=\"hljs-type\">Head</span>），然后<span class=\"hljs-keyword\">while</span>循环弹栈；<br><br>思路二：<br>\t迭代的思想（代码见官方题解方法一），反转指针指向，curr.next = pre;<br></code></pre></td></tr></table></figure>\n\n<p> 思路一：</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">import</span> java.util.*;<br><br><span class=\"hljs-comment\">/*</span><br><span class=\"hljs-comment\"> * public class ListNode &#123;</span><br><span class=\"hljs-comment\"> *   int val;</span><br><span class=\"hljs-comment\"> *   ListNode next = null;</span><br><span class=\"hljs-comment\"> *   public ListNode(int val) &#123;</span><br><span class=\"hljs-comment\"> *     this.val = val;</span><br><span class=\"hljs-comment\"> *   &#125;</span><br><span class=\"hljs-comment\"> * &#125;</span><br><span class=\"hljs-comment\"> */</span><br><br><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span> &#123;<br>    <span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class=\"hljs-comment\">     *</span><br><span class=\"hljs-comment\">     *</span><br><span class=\"hljs-comment\">     * <span class=\"hljs-doctag\">@param</span> head ListNode类</span><br><span class=\"hljs-comment\">     * <span class=\"hljs-doctag\">@return</span> ListNode类</span><br><span class=\"hljs-comment\">     */</span><br>    <span class=\"hljs-keyword\">public</span> ListNode <span class=\"hljs-title function_\">ReverseList</span> <span class=\"hljs-params\">(ListNode head)</span> &#123;<br>        <span class=\"hljs-comment\">// write code here</span><br>        Stack&lt;ListNode&gt; s = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Stack</span>&lt;&gt;();<br>        <span class=\"hljs-comment\">// 入栈</span><br>        <span class=\"hljs-keyword\">while</span> (head != <span class=\"hljs-literal\">null</span>) &#123;<br>            s.push(head);<br>            head = head.next;<br>        &#125;<br>        <span class=\"hljs-keyword\">if</span>(s.isEmpty()) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">null</span>;<br><br>        <span class=\"hljs-comment\">// 出栈</span><br>        <span class=\"hljs-type\">ListNode</span> <span class=\"hljs-variable\">newHead</span> <span class=\"hljs-operator\">=</span> s.pop(); <span class=\"hljs-comment\">// 反转后的链表头节点</span><br>        <span class=\"hljs-type\">ListNode</span> <span class=\"hljs-variable\">curr</span> <span class=\"hljs-operator\">=</span> newHead;<br>        <span class=\"hljs-comment\">// 出栈并连接节点</span><br>        <span class=\"hljs-keyword\">while</span> (!s.isEmpty()) &#123;<br>            curr.next = s.pop();<br>            curr = curr.next;<br>        &#125;<br>        curr.next = <span class=\"hljs-literal\">null</span>; <span class=\"hljs-comment\">// 将最后一个节点的next指针置空</span><br><br>        <span class=\"hljs-keyword\">return</span> newHead; <span class=\"hljs-comment\">// 返回反转后的链表头节点</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n</blockquote>\n<h2 id=\"官方题解思路\"><a href=\"#官方题解思路\" class=\"headerlink\" title=\"官方题解思路\"></a>官方题解思路</h2><h3 id=\"方法一：迭代（推荐使用）\"><a href=\"#方法一：迭代（推荐使用）\" class=\"headerlink\" title=\"方法一：迭代（推荐使用）\"></a>方法一：迭代（推荐使用）</h3><p><strong>思路：</strong></p>\n<p>将链表反转，就是将每个表元的指针从向后变成向前，那我们可以遍历原始链表，将遇到的节点一一指针逆向即可。指针怎么逆向？不过就是断掉当前节点向后的指针，改为向前罢了。</p>\n<figure class=\"highlight ini\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ini\"><span class=\"hljs-attr\">cur.next</span> = pre<br></code></pre></td></tr></table></figure>\n\n<p><strong>具体做法：</strong></p>\n<ul>\n<li>step 1：优先处理空链表，空链表不需要反转。</li>\n<li>step 2：我们可以设置两个指针，一个当前节点的指针，一个上一个节点的指针（初始为空）。</li>\n<li>step 3：遍历整个链表，每到一个节点，断开当前节点与后面节点的指针，并用临时变量记录后一个节点，然后当前节点指向上一个节点，即可以将指针逆向。</li>\n<li>step 4：再轮换当前指针与上一个指针，让它们进入下一个节点及下一个节点的前序节点。</li>\n</ul>\n<p><strong>图示：</strong> <img src=\"https://uploadfiles.nowcoder.com/images/20211001/397721558_1633084777359/E53A90674EDC6B8D31549D8DF4E7B38E\" alt=\"alt\"></p>\n<p><strong>Java实现代码：</strong></p>\n<p><a href=\"https://www.nowcoder.com/practice/75e878df47f24fdc9dc3e400ec6058ca?tpId=13&tqId=23286&ru=/exam/oj/ta&qru=/ta/coding-interviews/question-ranking&sourceUrl=/exam/oj/ta?page=1&tpId=13&type=13#\">复制代码</a></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span>  <span class=\"hljs-title class_\">Solution</span> &#123;<br>\t<span class=\"hljs-keyword\">public</span>   ListNode <span class=\"hljs-title function_\">ReverseList</span><span class=\"hljs-params\">(ListNode head)</span> &#123; <br>    <span class=\"hljs-comment\">//处理空链表        </span><br>    <span class=\"hljs-keyword\">if</span> (head ==   <span class=\"hljs-literal\">null</span>)   <span class=\"hljs-keyword\">return</span>   <span class=\"hljs-literal\">null</span>  ;    <br>        <br>    <span class=\"hljs-type\">ListNode</span> <span class=\"hljs-variable\">cur</span> <span class=\"hljs-operator\">=</span> head;        <br>    <span class=\"hljs-type\">ListNode</span> <span class=\"hljs-variable\">pre</span> <span class=\"hljs-operator\">=</span>   <span class=\"hljs-literal\">null</span>  ;    <br>    <br>    <span class=\"hljs-keyword\">while</span>  (cur !=   <span class=\"hljs-literal\">null</span>  )&#123;          <br>    \t<span class=\"hljs-comment\">//断开链表，要记录后续一个          </span><br>    \t<span class=\"hljs-type\">ListNode</span> <span class=\"hljs-variable\">temp</span> <span class=\"hljs-operator\">=</span> cur.next;  <br>        <br>    \t<span class=\"hljs-comment\">//当前的next指向前一个          </span><br>    \tcur.next = pre;     <br>        <br>    \t<span class=\"hljs-comment\">//前一个更新为当前          </span><br>    \tpre = cur;       <br>        <br>    \t<span class=\"hljs-comment\">//当前更新为刚刚记录的后一个          </span><br>    \tcur = temp;        <br>    &#125;        <br>    <span class=\"hljs-keyword\">return</span>   pre;      <br>    &#125;   <br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h5 id=\"方法二：递归（扩展思路）\"><a href=\"#方法二：递归（扩展思路）\" class=\"headerlink\" title=\"方法二：递归（扩展思路）\"></a>方法二：递归（扩展思路）</h5><p><strong>思路：</strong></p>\n<p>从上述方法一，我们可以看到每当我们反转链表的一个节点以后，要遍历进入下一个节点进入反转，相当于对后续的子链表进行反转，这可以看成是一个子问题，因此我们也可以使用递归，其三段式模版为：</p>\n<ul>\n<li><strong>终止条件：</strong> 当到达链表尾，要么当前指针是空，要么下一个指针是空，就返回。</li>\n<li><strong>返回值：</strong> 每一级返回反转后的子问题的头节点。</li>\n<li><strong>本级任务：</strong> 先进入后一个节点作为子问题。等到子问题都反转完成，再将本级节点与后一个的指针反转。</li>\n</ul>\n<p><strong>具体做法：</strong></p>\n<ul>\n<li>step 1：对于每个节点我们递归向下遍历到最后的尾节点。</li>\n<li>step 2：然后往上依次逆转两个节点。</li>\n<li>step 3：将逆转后的本层节点，即反转后这后半段子链表的尾，指向null，返回最底层上来的头部节点。</li>\n</ul>\n<p><strong>Java实现代码：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Java\"><span class=\"hljs-keyword\">public</span>   <span class=\"hljs-keyword\">class</span>   <span class=\"hljs-title class_\">Solution</span> &#123;<br>\t<span class=\"hljs-keyword\">public</span>   ListNode <span class=\"hljs-title function_\">ReverseList</span><span class=\"hljs-params\">(ListNode head)</span> &#123; <br>    \t<span class=\"hljs-comment\">//递归结束条件        </span><br>    \t<span class=\"hljs-keyword\">if</span>  (head ==   <span class=\"hljs-literal\">null</span>   || head.next ==   <span class=\"hljs-literal\">null</span>  ) <br>        \t<span class=\"hljs-keyword\">return</span>   head;        <br>        \t<br>        <span class=\"hljs-comment\">//反转下一个        </span><br>        <span class=\"hljs-type\">ListNode</span> <span class=\"hljs-variable\">newHead</span> <span class=\"hljs-operator\">=</span> ReverseList(head.next);        <br>        <br>        <span class=\"hljs-comment\">//逆转本级节点        </span><br>        head.next.next = head;        <br>        <br>        <span class=\"hljs-comment\">//尾部设置空节点        </span><br>        head.next =   <span class=\"hljs-literal\">null</span>  ;        <br>        <br>        <span class=\"hljs-keyword\">return</span>   newHead；<br>            <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure>\n\n\n\n<p>总结：对于重复的子问题，可以使用递归的方法。</p>\n"},{"title":"LCR 002. 二进制求和","index_img":"https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311151627628.png","abbrlink":5634,"date":"2023-09-10T00:29:42.000Z","_content":"\n# 每日一题，陷入深思审题十分钟\n## 发现关键点：\n提示：\n\n每个字符串仅由字符 '0' 或 '1' 组成。\n1 <= a.length, b.length <= 10^4----->注意这里\n字符串如果不是 \"0\" ，就都不含前导零。\n\n决定先让小弟冲锋，我直接一个 API 的`Interger.parseInt(String, radius)`\n```Java\nclass Solution {\n        public String addBinary(String a, String b) {\n            return Integer.toBinaryString(Integer.parseInt(a,2) + Integer.parseInt(b,2));\n        }\n}\n---\n因为 Integer 的长度问题,导致输入样例没有全部 AC ,这就是看提示信息的重要性!\n\n```\n报错如图所示:\n![image.png](https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311150916196.png)\n\n\n## 小弟败北,大哥上!\n\n接下来,我们还是用现成的 API ,纯纯一枚懒货\n\n去吧! `BigInteger`!\n\n直接上代码:\n```Java\nclass Solution {\n        public String addBinary(String a, String b) {\n            return new BigInteger(a,2).add(new BigInteger(b,2)).toString(2);\n        }\n}\n```\n\n直接提交, 🆗,全部 AC 🧑‍💻\n![image.png](https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311150916519.png)\n","source":"_posts/LCR-002-二进制求和.md","raw":"---\ntitle: LCR 002. 二进制求和\nindex_img: https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311151627628.png\ncategories:\n  - 算法\ntags:\n  - BigInteger\n  - java.math\n  - 进制转换\nabbrlink: 5634\ndate: 2023-09-10 08:29:42\n---\n\n# 每日一题，陷入深思审题十分钟\n## 发现关键点：\n提示：\n\n每个字符串仅由字符 '0' 或 '1' 组成。\n1 <= a.length, b.length <= 10^4----->注意这里\n字符串如果不是 \"0\" ，就都不含前导零。\n\n决定先让小弟冲锋，我直接一个 API 的`Interger.parseInt(String, radius)`\n```Java\nclass Solution {\n        public String addBinary(String a, String b) {\n            return Integer.toBinaryString(Integer.parseInt(a,2) + Integer.parseInt(b,2));\n        }\n}\n---\n因为 Integer 的长度问题,导致输入样例没有全部 AC ,这就是看提示信息的重要性!\n\n```\n报错如图所示:\n![image.png](https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311150916196.png)\n\n\n## 小弟败北,大哥上!\n\n接下来,我们还是用现成的 API ,纯纯一枚懒货\n\n去吧! `BigInteger`!\n\n直接上代码:\n```Java\nclass Solution {\n        public String addBinary(String a, String b) {\n            return new BigInteger(a,2).add(new BigInteger(b,2)).toString(2);\n        }\n}\n```\n\n直接提交, 🆗,全部 AC 🧑‍💻\n![image.png](https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311150916519.png)\n","slug":"LCR-002-二进制求和","published":1,"updated":"2023-11-15T08:29:17.996Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clpkiczim000mfkfofp3nae2n","content":"<h1 id=\"每日一题，陷入深思审题十分钟\"><a href=\"#每日一题，陷入深思审题十分钟\" class=\"headerlink\" title=\"每日一题，陷入深思审题十分钟\"></a>每日一题，陷入深思审题十分钟</h1><h2 id=\"发现关键点：\"><a href=\"#发现关键点：\" class=\"headerlink\" title=\"发现关键点：\"></a>发现关键点：</h2><p>提示：</p>\n<p>每个字符串仅由字符 ‘0’ 或 ‘1’ 组成。<br>1 &lt;= a.length, b.length &lt;= 10^4—–&gt;注意这里<br>字符串如果不是 “0” ，就都不含前导零。</p>\n<p>决定先让小弟冲锋，我直接一个 API 的<code>Interger.parseInt(String, radius)</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Java\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span> &#123;<br>        <span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title function_\">addBinary</span><span class=\"hljs-params\">(String a, String b)</span> &#123;<br>            <span class=\"hljs-keyword\">return</span> Integer.toBinaryString(Integer.parseInt(a,<span class=\"hljs-number\">2</span>) + Integer.parseInt(b,<span class=\"hljs-number\">2</span>));<br>        &#125;<br>&#125;<br>---<br>因为 Integer 的长度问题,导致输入样例没有全部 AC ,这就是看提示信息的重要性!<br><br></code></pre></td></tr></table></figure>\n<p>报错如图所示:<br><img src=\"https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311150916196.png\" alt=\"image.png\"></p>\n<h2 id=\"小弟败北-大哥上\"><a href=\"#小弟败北-大哥上\" class=\"headerlink\" title=\"小弟败北,大哥上!\"></a>小弟败北,大哥上!</h2><p>接下来,我们还是用现成的 API ,纯纯一枚懒货</p>\n<p>去吧! <code>BigInteger</code>!</p>\n<p>直接上代码:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Java\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span> &#123;<br>        <span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title function_\">addBinary</span><span class=\"hljs-params\">(String a, String b)</span> &#123;<br>            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">BigInteger</span>(a,<span class=\"hljs-number\">2</span>).add(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">BigInteger</span>(b,<span class=\"hljs-number\">2</span>)).toString(<span class=\"hljs-number\">2</span>);<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>直接提交, 🆗,全部 AC 🧑‍💻<br><img src=\"https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311150916519.png\" alt=\"image.png\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"每日一题，陷入深思审题十分钟\"><a href=\"#每日一题，陷入深思审题十分钟\" class=\"headerlink\" title=\"每日一题，陷入深思审题十分钟\"></a>每日一题，陷入深思审题十分钟</h1><h2 id=\"发现关键点：\"><a href=\"#发现关键点：\" class=\"headerlink\" title=\"发现关键点：\"></a>发现关键点：</h2><p>提示：</p>\n<p>每个字符串仅由字符 ‘0’ 或 ‘1’ 组成。<br>1 &lt;= a.length, b.length &lt;= 10^4—–&gt;注意这里<br>字符串如果不是 “0” ，就都不含前导零。</p>\n<p>决定先让小弟冲锋，我直接一个 API 的<code>Interger.parseInt(String, radius)</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Java\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span> &#123;<br>        <span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title function_\">addBinary</span><span class=\"hljs-params\">(String a, String b)</span> &#123;<br>            <span class=\"hljs-keyword\">return</span> Integer.toBinaryString(Integer.parseInt(a,<span class=\"hljs-number\">2</span>) + Integer.parseInt(b,<span class=\"hljs-number\">2</span>));<br>        &#125;<br>&#125;<br>---<br>因为 Integer 的长度问题,导致输入样例没有全部 AC ,这就是看提示信息的重要性!<br><br></code></pre></td></tr></table></figure>\n<p>报错如图所示:<br><img src=\"https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311150916196.png\" alt=\"image.png\"></p>\n<h2 id=\"小弟败北-大哥上\"><a href=\"#小弟败北-大哥上\" class=\"headerlink\" title=\"小弟败北,大哥上!\"></a>小弟败北,大哥上!</h2><p>接下来,我们还是用现成的 API ,纯纯一枚懒货</p>\n<p>去吧! <code>BigInteger</code>!</p>\n<p>直接上代码:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Java\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span> &#123;<br>        <span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title function_\">addBinary</span><span class=\"hljs-params\">(String a, String b)</span> &#123;<br>            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">BigInteger</span>(a,<span class=\"hljs-number\">2</span>).add(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">BigInteger</span>(b,<span class=\"hljs-number\">2</span>)).toString(<span class=\"hljs-number\">2</span>);<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>直接提交, 🆗,全部 AC 🧑‍💻<br><img src=\"https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311150916519.png\" alt=\"image.png\"></p>\n"},{"title":"Java Essay","index_img":"https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311151627635.png","sticky":100,"abbrlink":11449,"date":"2022-09-07T00:58:32.000Z","_content":"\n* *写在前面：*\n  * 【免责声明：】本笔记来源自互联，是笔者结合自己的理解进行整理归纳发表在hexo博客只便于个人学习使用，若涉及到侵权，请联系我，谢谢！\n  * 个人博客地址：https://wl2o2o.github.io/\n* 写作背景:\n  * 笔者是一名大三在校生，目前正在努力学习Java方向，笔记书写于22年暑假期间，虽然起步有点晚，但是每天都在坚持，只要努力，光一定会shine向我的！\n\n# Essay笔记来源\n\n[Java全栈知识体系](https://www.pdai.tech/md/java/basic/java-basic-x-generic.html)——泛型\n\n[哔哩哔哩老杜Java](https://www.bilibili.com/video/BV1mE411x7Wt)——哔哩哔哩\n\n[Java程序员进阶之路](https://tobebetterjavaer.com/home.html)——沉默王二\n\n# 老杜Java零基础\n\n**P58**\n具体的命名规范：\n1、顾名思义；\n2、驼峰原则：一高一低：例如：PowerNodeNotes；\n3、类名、接口名首字母大写 ；\n\t变量名方法名首字母小写；\n\t\t常量名全部大写，单词之间用_下划线连接：USER_AGE;\n\n**P60**\n关键字：\nint、long、float...public static void boolean private protect 蓝色字体、小写显示\n\n**P63**\n提取帮助文档：也就是写在/**\t\t\t这里面的注释信息。\n\t\t\t\t*\n\t\t\t\t*@author\n\t\t\t\t*@version\n\t\t\t\t*/\njavadoc -d+文件夹名（文件夹绝对路径）+（需要提取的信息）+Java源文件\n例如：javadoc -d javaapi -author -version VarTest02.java\n\n**P70**\n1，变量的分类：\npublic class Test{\n\tint i;//全局变量\n\tpublic static void main(String[] args){\n\t\tint j;局部变量\n  }\n}\n\n2，变量的作用域：即有效范围（出了大括号就处于非作用域）！\n\n**P72**\n标识符可以标志什么：\n类名、方法名、常量、变量、接口名\n\n\n记录所有编程出现的错误，记录错误~！\n\n**P113**\n\n```java\npublic class Homework1{\n\tpublic static void main(String[] args){\n\t\tint i=10;\n\t\ti=i++;\n\t\tSystem.out.println(i);\t//运行结果为10！\n  }\n}\n//Java和C++源代码运行结果不一样，C++结果为11、Java为10.\n```\n\n原因：编译器原理不一样，其中Java的代码可以理解为一下三行：\n（在Java语言中i++，这种表达式在执行的时候，会提前将i变量找一个存储空间临时存储，不同于C++）\nint temp=i;\ni++;\ni=temp;\n因此！！！可以理解为：分号之后++再加一 \n\n**P116**\n接收键盘输入：\n\n在Java中则怎么接收键盘信息呢？\n第一种形式：\n\n```java\n//创建一个键盘扫描器对象(s为对象名，上下对应)\njava.util.Scanner s =new java.util.Scanner(System.in);\t\njava.util.Scanner s =new java.util.Scanner(System.in);\t\nint i=s.nextInt(); \nSystem.out.println();\t\n\nString str =s.next();\nSystem.out.println();\n//接收用户的输入，从键盘上接受一个int类型的数据、\n//i变量有值了，并且i变量中保存的这个值是用户输入的数字。\n//i变量就是接收键盘数据的\nint i=s.nextInt();\nSystem.out.println(\"您输入的数字是：\"+i);\n\nint j=s.nextInt();\nSystem.out.println(\"您输入的数字是：\"+j);\n//字符串类型\nString str = s.next();\n其他数据类型类似\n其中println:print为打印、ln为换行。\n```\n\n另外一种形式：\n\n```java\nimport java.util.Scanner;\t//idea可以自动引入\n//创建键盘扫描器对象\nScanner s = new Scanner(System.in);\nint num1 = s.nextInt();\nSystem.out.println(num1+\"+\"+num2+\"=\");\n```\n\n头歌实践教学平台项目案例练习：\n\n```java\n//什么是类、怎么创建类：\npackage step1;\n\npublic class Test {\n\tpublic static void main(String[] args) {\n\t\t/********** Begin **********/\n\t\t//创建Dog对象\n\t\t//设置Dog对象的属性\n        Dog wuhuarou = new Dog();\n\t\twuhuarou.name=\"五花肉\";\n        wuhuarou.color=\"棕色\";\n        wuhuarou.variety=\"阿拉斯加\";\n\t\t//输出小狗的属性\n\t\tSystem.out.println(\"名字：\" + wuhuarou.name + \"，毛色：\" + wuhuarou.color+ \"，品种：\" +wuhuarou.variety );\n\t\t//调用方法\n        wuhuarou.eat();\n        wuhuarou.run();\n\t\t/********** End **********/\n\t}\n}\n//在这里定义Dog类\n/********** Begin **********/\nclass Dog{\n    String name,color,variety;\n    void eat(){\n        System.out.println(\"啃骨头\");\n    }\n    void run(){\n        System.out.print(\"叼着骨头跑\");\n    }\n}\n/********** End **********/\n```\n\n关于质数：\n\n```java\npackage step2;\npublic class FindZhiShu {\n\tpublic static void main(String[] args) {\n\t\t   /*\n\t\t     打印输出质数的时候务必按照如下格式：System.out.print(质数+\" \")；\n\t\t     使用print进行打印同时被打印输出的质数后加上一个空格，\n\t\t     以便于与平台提供的结果格式保持一致！\n            */   \n\t\t   /**********begin**********/\n            a:for(int i = 2;i < 1000;i++){\t\t//此循环遍历次数较多，若对代码效率有要求，则可进一步改进代码：如下：\n                for(int j = 2;j<i;j++)\n                if(i%j==0){\n                    continue a;\n                }\n                System.out.print(i+\" \");\n            }\n           /**********end**********/\t\n\t}\n}\n\t\t**********************改进之后的代码*********************\npackage step2;\npublic class FindZhiShu {\n\tpublic static void main(String[] args) {\n\t\t   /*\n\t\t     打印输出质数的时候务必按照如下格式：System.out.print(质数+\" \")；\n\t\t     使用print进行打印同时被打印输出的质数后加上一个空格，\n\t\t     以便于与平台提供的结果格式保持一致！\n            */   \n\t\t   /**********begin**********/\n\n\tSystem.out.print(\"2 \");\t//因为2是特殊的质数，又因下面循环会自动跳过偶数，因此先将2打印出来。\n\t        a:for(int i = 3;i < 1000;i+=2){\n\t            for(int j = 2;j<i;j++)\n\t            if(i%j==0){\n\t                continue a;\t\t//此方法运用了给循环做标记，以此可以对continue和break进行明确的命令指示。\n\t            }\n\t            System.out.print(i+\" \");\n\t        }\n\t       /**********end**********/\t\n\t}\n\n}\n```\n\n\n\n## 《方法》\n\n### 定义：\n\n是可以完成某一个特定的功能，并且可被重复利用。\n\n在面向对象的语言中，函数称为方法，类似于C语言总的函数。方法写在类体中，可以写在main函数前后，不分顺序，因为main函数为执行入口。\n\n### 方法结构定义：\n\n【修饰符列表】 返回值类型 方法名 （形式参数列表）{\n\n​\t\t方法体;\n\n}\n\n注意：\n\n【】符号叫中括号、以上中括号里的内容表是不是必须的，是可以选择的，方法体由Java语句构成；\n\n \n\n关于修饰符列表：\n\n也不是必须的，目前可写成public static（称为静态方法）\n\n\n\nbreak与return的区别：\n\nbreak：用来终止一个switch语句和距离最近的循环\n\nreturn：用来终止一个方法。 \n\n### 方法优化：\n\n例题：编写一个方法，输出大于某个正整数n的最小的质数（思考：这个方法应该取什么名字，这个方法的形参是什么，返回值类型是什么？）\n\n```Java\n public class Homework2{\n    public static void main(String[] args){\n        //假设目前系统给定一个正整数n，n为5\n        int n = 7;\n        //输出大于5的最小质数\n        while(true){\n            n++;\n\t\t\t//需要一个判断是否为质数的方法。。\n            if(isZhiShu(n)){\t\t\t\t\n                System.out.print(\"最小质数是\"+n);\n                break;\n            }\n        }\n    }\n\n\t//该方法返回一个Boolean字符，用于main方法中的if判断语句。\n\tpublic static boolean isZhiShu(int num){\n\t\t//判断num是否为质数\n\t\t//可以利用循环取余的方法来判断是否可以整除除1和本身的数字\n\t\tfor(int i = 2; i < num;i++ ){\n\t\t\tif(num%i==0){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\t//return语句容易写在for循环里面，写在里面判断不完全\n\t\t//return之所以写在外面是因为要让循环执行完毕，执行完毕才可以正确判断\n\t\treturn true;\n\t}\n}\n```\n\n编程思路以及改进版：\n\n```java\n \nimport java.util.Scanner;\npublic class Homework2{\n    public static void main(String[] args){\n        \n        //以下代码省略，新增打印质数的方法\n\t\t/*\n\t\t//假设目前系统给定一个正整数n，n为5\n        int n = 7;\n\t\t//输出大于5的最小质数\n        while(true){\n            n++;\n\t\t\t//需要一个判断是否为质数的方法。。\n            if(isZhiShu(n)){\t\t\t\t\n                System.out.print(\"最小质数是\"+n);\n                break;\n            }\n        }\n\t\t*/\n\t\t\n\t\t//引入用户输入的数据\n\t\tScanner s = new Scanner(System.in);\n\t\tint num = s.nextInt();\n\t\t//直接调用打印质数的方法\n\t\tprintZhiShu(num);\n\n\n    }\n\t//代码不够精简，还可以在main（）中调用打印输出质数的方法\n\tpublic static void printZhiShu(int num){\n\t\t\n\t\t//while循环仍可精简，但是精简之后不易理解，代码如下：\n\t\t/*\t\t\n\t\twhile(isZhiShu(num)){\n\t\t}\n\t\tSystem.out.print(\"最小质数是\"+num);\n\t\t*/\n\n\t\t/*while(true){\n    \t\t//需要一个判断是否为质数的方法。。\n            if(isZhiShu(++num)){\t\t\t\t\n                System.out.print(\"最小质数是\"+num);\n                break;\n            }\n\t\t}\t\n\t\t*/\n\t\twhile(!isZhiShu(++num)){\n\t\t}\n\t\tSystem.out.print(\"最小质数是\"+num);\n        \n\t}\n\n\t//该方法返回一个Boolean字符，用于main方法中的if判断语句。\n\tpublic static boolean isZhiShu(int num){\n\t\t//判断num是否为质数\n\t\t//可以利用循环取余的方法来判断是否可以整除除1和本身的数字\n\t\tfor(int i = 2; i < num;i++ ){\n\t\t\tif(num%i==0){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\t//return语句容易写在for循环里面，写在里面判断不完全\n\t\t//return之所以写在外面是因为要让循环执行完毕，执行完毕才可以正确判断\n\t\treturn true;\n\t}\n\n}\n\n//以上代码为编程思路，以下为精简代码：\n/*\nimport java.util.Scanner;\npublic class Homework2{\n    public static void main(String[] args){\n\t\tScanner s = new Scanner(System.in);\n\t\tint num = s.nextInt();\n\n\t\tprintZhiShu(num);\n    }\n\n\tpublic static void printZhiShu(int num){\n\t\twhile(!isZhiShu(++num)){\n\t\t}\n\t\tSystem.out.print(\"最小质数是\"+num);\n\t}\n\n\tpublic static boolean isZhiShu(int num){\n\t\tfor(int i = 2; i < num;i++ ){\n\t\t\tif(num%i==0){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n}\n*/\n \n\n```\n\n### 方法重载\n\n同一个类中：方法名相同，形参个数或者类型不同。\n\n优点：代码整齐美观，记忆方法名较少。\n\n含义：就是可以定义多个相同名字的方法（例如：public static int sum(int a,int b)和public static int sum(long a,long b)）\n\n原理：Java编译器会自动识别方法名，若方法名相同，则进行参数类型匹配，所以名方法重载。\n\n怎么判断：方法名相同、形参类型不同、形参个数不同、形参顺序不同\n\n\n\n\n\n### 方法递归\n\n含义：方法调用自己的方法！\n\n典例：从前有座山，山里有个和尚说：{从前有座山，山里有个和尚说}：{从前有座山，山里有个和尚说}——递归。。。\n\n\n\n老杜这样说：\n\n方法递归？\n\n​\t1、什么是方法递归？\n\n​\t\t\t方法自己调用自己，这就是方法递归。\n\n​\t2、当递归时程序没有结束条件，一定会发生：\n\n​\t\t\t栈内存溢出错误：StackOverflowError\n\n​\t\t\t所以：递归必须要有结束条件。（这是一个非常重要的知识点。）\n\n​\t\t\tJVM发生错误之后一定会推出JVM。\n\n​\t3、递归假设是有结束条件的，就一定不会发生栈内存溢出吗？\n\n​\t\t\t假设这个结束条件时对的，是合法的，递归有时候也会出现栈内存溢出的错误。\n\n​\t\t\t因为有时候，可能递归的太深，栈内存不够（因为一直在压栈）\n\n​\t4、不建议在实际的开发中使用递归，，能用for循环while循环代替的尽量使用循环来做，因为循环的效率较高，耗费内存少。递归耗费的内存较多，另外递归若使用不当，则会导致JVM的死掉。\n\n​\t\t（极少数的情况下是必须要用递归的。）\n\n​\t\t所以：递归还是要认真学习的！\n\n\n\n老杜讲经验：\n\n​\t如果遇到了栈内存溢出，怎么调bug?\n\n​\t第一步：\n\n​\t\t先检查递归的结束条件对不对。如果不对，则进一步修改，直到正确。\n\n​\t第二步：\n\n​\t\t如果假设条件没问题，这个时候需要手动调整JVM的栈内存初始大小（通过命令行适当调大。）\n\n​\t第三步：\n\n​\t\t如果还会栈内存溢出，则继续调大。（Java -X  这个命令可以查看调整堆栈大小的参数。具体格式如下图所示：）\n\n\n\n\n\n老杜栈内存溢出图：\n\n![image-20220715183512822](http://images.rl0206.love/image-20220715183512822.png)\n\n\n\n如何指 定栈内存大小：\n\n![image-20220715184629869](http://images.rl0206.love/image-20220715184629869.png)\n\n\n\n### 递归实例\n\n题目：计算1~ 10的和。\n\n不用递归思路：写一个for循环方法，直接调用。\n\n用递归思路：（方法调用打法）\n\n![image-20220716094554506](http://images.rl0206.love/image-20220716094554506.png)\n\n\n\n\n\n\n\n\n\n## 《代码的包装与封装》\n\n封装及使用方法：\n\n![image-20220715170415137](http://images.rl0206.love/image-20220715170415137.png)\n\n\n\n\n\n\n\n## 《认识面向对象》\n\n面向对象与面向过程：\n\n​\t面向过程的优缺点：\n\n​\t\t缺点：（高度耦合）\n\n​\t\t\t面向过程的程序的每一个功能之间都是因果关系，因为A所以B，AB联合成一个子模块，然后模块与模块之间形成因果关系。因此任何一个功能之间出现问题，就会导致另一出现问题。 这就是高度耦合！（耦合度就是粘连程度）\n\n​\t\t\t耦合度高导致扩展力差（主板集成显卡）\n\n​\t\t\t耦合度低导致扩展力强（独立下显卡，螺栓与螺母等）\n\n​\t\t优点：（快速开发）\n\n​\t\t\t对于小型项目，可以直接通过因果关系来写代码。不需要前期对象的提取、模型的建立，可以直接干活，从而实现功能。\n\n\n\n什么是面向对象的开发模式？\n\n​\t万物皆为对象，人眼看到的是各个对象之间的联系，更符合人类的思维方式。因此，面向对象在成为主流。\n\n如何判断面向过程和面向对象？\n\n​\t可以通过耦合度等判断。\n\n\n\n三个过程：\n\n​\tOOA-->OOD-->OOP\n\n​\t分析\t  设计\t 编程\n\n\n\n三大特征：\n\n封装、继承、多态。（任何一个面向对象的编程语言都包括这三个特征。）\n\n\n\n## 类与对象\n\n### 浅析类与对象：\n\n​\t类是一个集合，包含对象的特征，是特征的总结。\n\n​\t而对象是真实存在的，万物皆可对象。\n\n在Java语言中，要想得到对象，必须先定义类，，，对象是通过类创建的。\n\n​\t例如：先定义人类，才可以定义魏磊。哈哈哈哈。\n\n重要概念：\n\n​\t《实例化》\n\n​\t\t\t含义：通过类创建对象的过程叫做实例化。\n\n​\t《实例》\n\n​\t\t\t含义：对象又被称为实例。\n\n\n\n（此处补充类与对象的图）\n\n\n\n​\t《抽象》\n\n​\t\t\t含义：魏磊到人类的过程程为抽象。\n\n​\t类--【实例化】-->对象（实例）\n\n​\t对象--【抽象】-->类\n\n\n\n```Java\npublic class 明星类{\n    /*\n    类 = 属性 + 方法\n\n\t属性来源于状态； （名词）\t数据是以数据形式存在的，所以只能存放在变量中。\t\t即属性即变量。\n\n\t方法来源于动作； （动词）\n\t*/\n    //属性\n    int 身高;\n    int 体重;\n    \n    //方法\n    打篮球（）{\n        \n    }\n    学习（）{\n        \n    }\n    \n    \n\n\n}\n```\n\n\n\n### 对象的创建：\n\n​\t\"没对象，new一个\"\n\n​\t\t创建对象语法：XueSheng  s1 = new XueSheng();\n\n​\t\t\t\t\t\t\t\t\t\t\tXueSheng  s1 = new XueSheng()；此时此刻就相当于 ：int i = 1；\n\n \t\t\t\t\t\t\t\t\t\t\tXueSheng:数据类型\n\n​\t\t\t\t\t\t\t\t\t\t\ts1:变量名\n\n​\t\t\t\t\t\t\t\t\t\t\tnew:运算符\n\n​\t\t\t\t\t\t\t\t\t\t\tXueSheng:类名\n\n\n\n## Java变量\n\n\n\n变量的分类：\n\n1局部变量\n\n2成员变量\n\n3静态变量\n\n4常量        （要求大写）\n\n\n\n————————————笔记分隔线———————————\n\n# Java进阶之路笔记\n\n## 常用的48个关键字\n\n[沉默王二](https://tobebetterjavaer.com/about-the-author/)2021年10月22日Java核心Java大约 4 分钟\n\n------\n\n“二哥，就我之前学过的这些 Java 代码中，有 public、static、void、main 等等，它们应该都是关键字吧？”三妹的脸上泛着甜甜的笑容，我想她在学习 Java 方面已经变得越来越自信了。\n\n“是的，三妹。Java 中的关键字可不少呢！你一下子可能记不了那么多，不过，先保留个印象吧，对以后的学习会很有帮助。”\n\nPS：按照首字母的自然顺序排列。\n\n1. **abstract：** 用于声明抽象类，以及抽象方法。\n2. **boolean：** 用于将变量声明为布尔值类型，只有 true 和 false 两个值。\n3. **break：** 用于中断循环或 switch 语句。\n4. **byte：** 用于声明一个可以容纳 8 个比特的变量。\n5. **case：** 用于在 switch 语句中标记条件的值。\n6. **catch：** 用于捕获 try 语句中的异常。\n7. **char：** 用于声明一个可以容纳无符号 16 位比特的 [Unicode 字符open in new window](https://mp.weixin.qq.com/s/pNQjlXOivIgO3pbYc0GnpA)的变量。\n8. **class：** 用于声明一个类。\n9. **continue：** 用于继续下一个循环，可以在指定条件下跳过其余代码。\n10. **default：** 用于指定 switch 语句中除去 case 条件之外的默认代码块。\n11. **do：** 通常和 while 关键字配合使用，do 后紧跟循环体。\n12. **double：** 用于声明一个可以容纳 64 位浮点数的变量。\n13. **else：** 用于指示 if 语句中的备用分支。\n14. **enum：** 用于定义一组固定的常量（枚举）。\n15. **extends：** 用于指示一个类是从另一个类或接口继承的。\n16. **final：** 用于指示该变量是不可更改的。\n17. **finally：** 和 `try-catch` 配合使用，表示无论是否处理异常，总是执行 finally 块中的代码。\n18. **float：** 用于声明一个可以容纳 32 位浮点数的变量。\n19. **for：** 用于声明一个 for 循环，如果循环次数是固定的，建议使用 for 循环。\n20. **if：** 用于指定条件，如果条件为真，则执行对应代码。\n21. **implements：** 用于实现接口。\n22. **import：** 用于导入对应的类或者接口。\n23. **instanceof：** 用于判断对象是否属于某个类型（class）。\n24. **int：** 用于声明一个可以容纳 32 位带符号的整数变量。\n25. **interface：** 用于声明接口。\n26. **long：** 用于声明一个可以容纳 64 位整数的变量。\n27. **native：** 用于指定一个方法是通过调用本机接口（非 Java）实现的。\n28. **new：** 用于创建一个新的对象。\n29. **null：** 如果一个变量是空的（什么引用也没有指向），就可以将它赋值为 null，和空指针异常息息相关。\n30. **package：** 用于声明类所在的包。\n31. **private：** 一个访问权限修饰符，表示方法或变量只对当前类可见。\n32. **protected：** 一个访问权限修饰符，表示方法或变量对同一包内的类和所有子类可见。\n33. **public：** 一个访问权限修饰符，除了可以声明方法和变量（所有类可见），还可以声明类。`main()` 方法必须声明为 public。\n34. **return：** 用于在代码执行完成后返回（一个值）。\n35. **short：** 用于声明一个可以容纳 16 位整数的变量。\n36. **static：** 表示该变量或方法是静态变量或静态方法。\n37. **strictfp：** 并不常见，通常用于修饰一个方法，确保方法体内的浮点数运算在每个平台上执行的结果相同。\n38. **super：** 可用于调用父类的方法或者字段。\n39. **switch：** 通常用于三个（以上）的条件判断。\n40. **synchronized：** 用于指定多线程代码中的同步方法、变量或者代码块。\n41. **this：** 可用于在方法或构造函数中引用当前对象。\n42. **throw：** 主动抛出异常。\n43. **throws：** 用于声明异常。\n44. **transient：** 修饰的字段不会被序列化。\n45. **try：** 于包裹要捕获异常的代码块。\n46. **void：** 用于指定方法没有返回值。\n47. **volatile：** 保证不同线程对它修饰的变量进行操作时的可见性，即一个线程修改了某个变量的值，新值对其他线程来说是立即可见的。\n48. **while：** 如果循环次数不固定，建议使用 while 循环。\n\n## **关键字顺序排序**：\n\nbyte<short(char)<int<long<float<doublepackage step2;\n\n## **用户自定义方法**\n\n## （tips：如果是静态方法，那么调用时就不用new关键字来创建对象来调用了）\n\n当预先定义方法无法满足我们的要求时，就需要自定义一些方法，比如说，我们来定义这样一个方法，用来检查数字是偶数还是奇数。\n\n\n\n```java\npublic static void findEvenOdd(int num) {\n    if (num % 2 == 0) {\n        System.out.println(num + \" 是偶数\");\n    } else {\n        System.out.println(num + \" 是奇数\");\n    }\n}\n```\n\n方法名叫做 `findEvenOdd`，访问权限修饰符是 public，并且是静态的（static），返回类型是 void，参数有一个整型（int）的 num。方法体中有一个 if else 语句，如果 num 可以被 2 整除，那么就打印这个数字是偶数，否则就打印这个数字是奇数。\n\n方法被定义好后，如何被调用呢？\n\n\n\n```java\n/**\n * @author 微信搜「沉默王二」，回复关键字 PDF\n */\npublic class EvenOddDemo {\n    public static void main(String[] args) {\n        findEvenOdd(10);\n        findEvenOdd(11);\n    }\n\n    public static void findEvenOdd(int num) {\n        if (num % 2 == 0) {\n            System.out.println(num + \" 是偶数\");\n        } else {\n            System.out.println(num + \" 是奇数\");\n        }\n    }\n}\n```\n\n`main()` 方法是程序的入口，并且是静态的，那么就可以直接调用同样是静态方法的 `findEvenOdd()`。\n\n当一个方法被 static 关键字修饰时，它就是一个静态方法。换句话说，静态方法是属于类的，不属于类实例的（不需要通过 new 关键字创建对象来调用，直接通过类名就可以调用）。\n\n\n\n\n\n## 访问权限控制\n\n### **1.修饰类**\n\n- 默认访问权限（包访问权限）：用来修饰类的话，表示该类只对同一个包中的其他类可见。\n- public：用来修饰类的话，表示该类对其他所有的类都可见。\n\n### **2.修饰类的方法和变量**\n\n- 默认访问权限（包访问权限）：如果一个类的方法或变量被包访问权限修饰，也就意味着只能在同一个包中的其他类中显示地调用该类的方法或者变量，在不同包中的类中不能显式地调用该类的方法或变量。\n- private：如果一个类的方法或者变量被 private 修饰，那么这个类的方法或者变量只能在该类本身中被访问，在类外以及其他类中都不能显式的进行访问。\n- protected：如果一个类的方法或者变量被 protected 修饰，对于同一个包的类，这个类的方法或变量是可以被访问的。对于不同包的类，只有继承于该类的类才可以访问到该类的方法或者变量。\n- public：被 public 修饰的方法或者变量，在任何地方都是可见的。\n\n## 代码初始化块\n\n三个规则：\n\n- 类实例化的时候执行代码初始化块；\n- 实际上，代码初始化块是放在构造方法中执行的，只不过比较靠前；\n- 代码初始化块里的执行顺序是从前到后的。\n\n## 补充：什么叫构造方法？有参？无参？\n\n```Java\npublic class StudentDemo {\n    public static void main(String[] args) {\n       \n        // 类名称 对象名 = new 类名称();\n        Student stu1 = new Student();           //无参构造方法执行\n        Student stu2 = new Student(\"张三\",23);   //全参构造方法执行\n        //赋值\n        stu1.setName(\"李四\");\n        stu1.setAge(23);\n       \n        //对象名.成员变量名；\n        System.out.println(\"姓名：\"+stu1.getName()+\"，年龄：\"+ stu1.getAge());\n        System.out.println(\"姓名：\"+stu2.getName()+\"，年龄：\"+ stu2.getAge());\n    }\n\n}\n\n```\n\n\n\n## 方法的继承\n\n关键字：extend，super（用于继承父类）\n\n“在默认情况下，子类的构造方法在执行的时候会主动去调用父类的构造方法。也就是说，其实是构造方法先执行的，再执行的代码初始化块。”\n\n**知识拓展：**\n\n什么是@Overwide?\n\n```java\n@Override是伪代码,表示重写(当然不写也可以)，不过写上有如下好处:\n1、可以当注释用,方便阅读；\n2、编译器可以给你验证@Override下面的方法名是否是你父类中所有的，如果没有则报错。例如，你如果没写@Override，而你下面的方法名又写错了，这时你的编译器是可以编译通过的，因为编译器以为这个方法是你的子类中自己增加的方法。\n \n举例：在重写父类的onCreate时，在方法前面加上@Override 系统可以帮你检查方法的正确性。\n@Override\npublic void onCreate(Bundle savedInstanceState)\n\n{…….}\n这种写法是正确的，如果你写成：\n\n@Override\npublic void oncreate(Bundle savedInstanceState)\n{…….}\n编译器会报如下错误：The method oncreate(Bundle) of type HelloWorld must override or implement a supertype method，以确保你正确重写onCreate方法（因为oncreate应该为onCreate）。而如果你不加@Override，则编译器将不会检测出错误，而是会认为你为子类定义了一个新方法：oncreate\n```\n\n\n\n## 抽象类\n\n### 敲黑板知识点：\n\n**写在前面：**\n\n什么是抽象？抽象的含义？\n\n​\t\t抽象是不确定的、不具体的概念或事物。在Java中的抽象类，是指需要在子类中通过方法扩展来实现新的方法。\n\n**关键字：**abstract\n\n**语句格式：**\n\n```Java\nabstract class AbstractPlayer {\n}\n```\n\n**命名规则：**\n\n关于抽象类的命名，《阿里的 Java 开发手册》上有强调，“抽象类命名要使用 Abstract 或 Base 开头”，这条规约还是值得遵守的。\n\n**Tips：**\n\n抽象类是不能实例化的，尝试通过 `new` 关键字实例化的话，编译器会报错，提示“类是抽象的，不能实例化”。\n\n虽然抽象类不能实例化，但可以有子类。子类通过 `extends` 关键字来继承抽象类。就像下面这样。\n\nDemo code:\n\n```Java\npublic class BasketballPlayer extends AbstractPlayer {\n}\n\n```\n\n抽象的方法不能定义在普通类中。否则会在类和方法处出现两个报错。\n\n错误提示。第一处在类级别上，提示“这个类必须通过 `abstract` 关键字定义”，见下图。\n\n![img](http://cdn.tobebetterjavaer.com/tobebetterjavaer/images/object-class/abstract-02.png)\n\n第二处在尝试定义 abstract 的方法上，提示“抽象方法所在的类不是抽象的”，见下图。\n\n![img](http://cdn.tobebetterjavaer.com/tobebetterjavaer/images/object-class/abstract-03.png)\n\n\n\n**But,抽象类中既可以定义抽象方法、也可以普通方法。**\n\n### 抽象方法的应用场景\n\n**第一种场景**。\n\n当我们希望一些通用的功能被多个子类复用的时候，就可以使用抽象类。比如说，`AbstractPlayer` 抽象类中有一个普通的方法 `sleep()`，表明所有运动员都需要休息，那么这个方法就可以被子类复用。\n\nDemo:\n\n```java\nabstract class AbstractPlayer {\n    public void sleep() {\n        System.out.println(\"运动员也要休息而不是挑战极限\");\n    }\n}\n```\n\n子类 `BasketballPlayer` 继承了 `AbstractPlayer` 类：\n\n```java\nclass BasketballPlayer extends AbstractPlayer {\n}\n```\n\n也就拥有了 `sleep()` 方法。`BasketballPlayer `的对象可以直接调用父类的 `sleep() `方法：\n\n```java\nBasketballPlayer basketballPlayer = new BasketballPlayer();\nbasketballPlayer.sleep();\n```\n\n如此，就实现了代码的复用。\n\n**第二种场景**。\n\n当我们需要在抽象类中定义好 `API`，然后在子类中扩展实现的时候就可以使用抽象类。比如说，`AbstractPlayer` 抽象类中定义了一个抽象方法 `play()`，表明所有运动员都可以从事某项运动，但需要对应子类去扩展实现，表明篮球运动员打篮球，足球运动员踢足球。\n\n**知识拓展：**\n\n什么是API？\n\nAPI（Application Programming Interface,应用程序编程接口）是一些预先定义的函数，目的是提供应用程序与开发人员基于某软件或硬件得以访问一组例程的能力，而又无需访问源码，或理解内部工作机制的细节。\"\n\n**抽象类实例：**\n\n读取大小写helloworld：\n\n[https://tobebetterjavaer.com/oo/abstract.html]()\n\n## 接口\n\n关键字：\n\ninterface\n\n语法格式：\n\npublic interface jiekou1\n\nclass A extends B implements jiekou1,jiekou2,jiekou3\n\n小结论：\n\n- 接口中允许定义变量\n- 接口中允许定义抽象方法\n- 接口中允许定义静态方法（Java 8 之后）\n- 接口中允许定义默认方法（Java 8 之后）\n\n除此之外，我们还应该知道：\n\n1）接口不允许直接实例化，否则编译器会报错。\n\n![img](http://cdn.tobebetterjavaer.com/tobebetterjavaer/images/object-class/interface-04.png)\n\n需要定义一个类去实现接口，见下例。\n\n\n\n```java\npublic class Computer implements Electronic {\n\n    public static void main(String[] args) {\n        new Computer();\n    }\n\n    @Override\n    public int getElectricityUse() {\n        return 0;\n    }\n}\n```\n\n然后再实例化。\n\n\n\n```Java\nElectronic e = new Computer();\n```\n\n知识点拓展：\n\nJAVA中extends 与implements有啥区别？\n\n1. 在类的声明中，通过关键字extends来创建一个类的子类。一个类通过关键字implements声明自己使用一个或者多个接口。\n   extends 是继承某个类, 继承之后可以使用父类的方法, 也可以重写父类的方法; implements 是实现多个接口, 接口的方法一般为空的, 必须重写才能使用\n2. extends是继承父类，只要那个类不是声明为final或者那个类定义为abstract的就能继承，JAVA中不支持多重继承，但是可以用接口 来实现，这样就要用到implements，继承只能继承一个类，但implements可以实现多个接口，用逗号分开就行了\n   比如\n   class A extends B implements C,D,E\n\n[(56条消息) Java之implements_小白study的博客-CSDN博客_implements](https://blog.csdn.net/android_lover2014/article/details/52176814)\n\n\n\n\n\n作业：多态与重载\n\n​\t\t\t构造与重载\n\n​\t\t\t抽象类与接口？\n\n\n\n\n\n## 内部类\n\n**== = = = = = = [内部类](https://so.csdn.net/so/search?q=内部类&spm=1001.2101.3001.7020)（四种内部类详解）= = = = = = = ==**\n\n**一、基本介绍：一个类的内部又完整的嵌套了另一个类结构。被嵌套的类称为内部类(inner class),嵌套其他类的类称为外部类(outer class)。是我们类的第五大成员【思考:类的五大成员是哪些?[属性、方法、构造器、代码块、内部类]】，内部类最大的特点就是可以直接访问私有属性，并且可以体现类与类之间的包含关系，注意:内部类是学习的难点,同时也是重点,后面看底层源码时,有大量的内部类.**\n**如果定义类在局部位置(方法中/代码块) :(1) 局部内部类 (2) 匿名内部类\n定义在成员位置 (1) 成员内部类 (2)静态内部类**\n\n在 Java 中，可以将一个类定义在另外一个类里面或者一个方法里面，这样的类叫做内部类。\n\n**二、基本语法**\n**class Outer{ //外部类\nclass Inner{ //内部类\n}\n}\nclass Other{ //外部其他类\n}**\n\n三、分类\n\n一般来说，内部类分为成员内部类、局部内部类、匿名内部类和静态内部类。\n\n定义在外部类的局部位置上(如方法内):\n1)局部内部类(有类名)\n2)匿名内部类(没有类名，重点!!!)\n\n定义在外部类的成员位置上:\n1)成员内部类(没用static修饰)\n2)静态内部类（使用static修饰)\n\n\n\n**1.成员内部类：**\n\n成员内部类可以无限制访问外部类的所有成员属性。\n\n内部类可以随心所欲地访问外部类的成员，但外部类想要访问内部类的成员，就不那么容易了，必须先创建一个成员内部类的对象，再通过这个对象来访问：\n\n```Java\npublic class Wanger {\n    int age = 18;\n    private String name = \"沉默王二\";\n    static double money = 1;\n\n    public Wanger () {\n        new Wangxiaoer().print();\n    }\n\n    class Wangxiaoer {\n        int age = 81;\n\n        public void print() {\n            System.out.println(name);\n            System.out.println(money);\n        }\n    }\n}\n\n```\n\n这种创建内部类的方式在实际开发中并不常用，因为内部类和外部类紧紧地绑定在一起，使用起来非常不便。\n\n**2.局部内部类**\n\n**3.匿名内部类**\n\n**4.静态内部类**\n\n第一，静态内部类不能访问外部类的所有成员变量；\n\n第二，静态内部类可以访问外部类的所有静态变量，包括私有静态变量。\n\n第三，外部类不能声明为 static。”\n\n“三妹，你看，在 Singleton 类上加 static 后，编译器就提示错误了。”\n\n![img](http://cdn.tobebetterjavaer.com/tobebetterjavaer/images/keywords/19-08.png)\n\n### 总结\n\n为什么要使用内部类？\n\n在《Think in java》中有这样一句话：\n\n> 使用内部类最吸引人的原因是：每个内部类都能独立地继承一个（接口的）实现，所以无论外围类是否已经继承了某个（接口的）实现，对于内部类都没有影响。\n\n在我们程序设计中有时候会存在一些使用接口很难解决的问题，这个时候我们可以利用内部类提供的、可以继承多个具体的或者抽象的类的能力来解决这些程序设计问题。可以这样说，接口只是解决了部分问题，而内部类使得多重继承的解决方案变得更加完整。\n\n使用内部类还能够为我们带来如下特性（摘自《Think in java》）：\n\n- 1、内部类可以使用多个实例，每个实例都有自己的状态信息，并且与其他外围对象的信息相互独立。\n- 2、在单个外部类中，可以让多个内部类以不同的方式实现同一个接口，或者继承同一个类。\n- 3、创建内部类对象的时刻并不依赖于外部类对象的创建。\n- 4、内部类并没有令人迷惑的“is-a”关系，他就是一个独立的实体。\n- 5、内部类提供了更好的封装，除了该外围类，其他类都不能访问。\n\n## 关键字\n\n### 1.static\n\n**static的作用**\n\n“static 关键字的作用可以用一句话来描述：‘**方便在没有创建对象的情况下进行调用**，包括变量和方法’。也就是说，只要类被加载了，就可以通过类名进行访问。”我扶了扶沉重眼镜，继续说到，“static 可以用来修饰类的成员变量，以及成员方法。我们一个个来看。”\n\ndemo：\n\n```Java\npublic class Counter {\n    int count = 0;\n\n    Counter() {\n        count++;\n        System.out.println(count);\n    }\n\n    public static void main(String args[]) {\n        Counter c1 = new Counter();\n        Counter c2 = new Counter();\n        Counter c3 = new Counter();\n    }\n}\n/*\n我们创建一个成员变量 count，并且在构造函数中让它自增。因为成员变量会在创建对象的时候获取内存，因此每一个对象都会有一个 count 的副本， count 的值并不会随着对象的增多而递增。\n*/\n```\n\n```Java \npublic class StaticCounter {\n    static int count = 0;\n\n    StaticCounter() {\n        count++;\n        System.out.println(count);\n    }\n\n    public static void main(String args[]) {\n        StaticCounter c1 = new StaticCounter();\n        StaticCounter c2 = new StaticCounter();\n        StaticCounter c3 = new StaticCounter();\n    }\n}\n/*\n简单解释一下哈，由于静态变量只会获取一次内存空间，所以任何对象对它的修改都会得到保留，所以每创建一个对象，count 的值就会加 1，所以最终的结果是 3，明白了吧？三妹。这就是静态变量和成员变量之间的差别。\n*/\n```\n\nwarnning:\n\n“另外，需要注意的是，由于静态变量属于一个类，所以不要通过对象引用来访问，而应该直接通过类名来访问，否则编译器会发出警告。”\n\n![img](http://cdn.tobebetterjavaer.com/tobebetterjavaer/images/keywords/19-03.png)\n\n\n\nstatic的特点：\n\n- 静态方法属于这个类而不是这个类的对象；\n\n​\t\t（因为静态方法不用类的实例化，所以直接通过类来调用，不通过类的实例来调用，因此不应通过对象调用）\n\n- 调用静态方法的时候不需要创建这个类的对象；\n- 静态方法可以访问静态变量。\n\n\n\n那么问题来了，为什么main方法是静态的，这就涉及到Java的编译器JVM了，为了代码简洁与方便调用，main函数作为程序的入口，所以设为静态更为合适。\n\n二哥这么说：\n\n`“如果 main 方法不是静态的，就意味着 Java 虚拟机在执行的时候需要先创建一个对象才能调用 main 方法，而 main 方法作为程序的入口，创建一个额外的对象显得非常多余。”我不假思索的回答令三妹感到非常的钦佩。`\n\n“java.lang.Math 类的几乎所有方法都是静态的，可以直接通过类名来调用，不需要创建类的对象。”\n\n![img](http://cdn.tobebetterjavaer.com/tobebetterjavaer/images/keywords/19-06.png)\n\n综上所述（由上可得）：\n\n一些函数基本上都是静态的。\n\n### 静态代码块 \n\n“除了静态变量和静态方法，static 关键字还有一个重要的作用。”我心情愉悦地对三妹说，“用一个 static 关键字，外加一个大括号括起来的代码被称为静态代码块。”\n\n“就像下面这串代码。”\n\n\n\n```java\npublic class StaticBlock {\n    static {\n        System.out.println(\"静态代码块\");\n    }\n\n    public static void main(String[] args) {\n        System.out.println(\"main 方法\");\n    }\n}\n```\n\n“静态代码块通常用来初始化一些静态变量，它会优先于 `main()` 方法执行。”\n\n\n\n### 2.this\n\nthis除了可以指向当前方法或者构造函数的对象，还可以完成以下工作：\n\n- 调用当前类的方法；\n- `this()` 可以调用当前类的构造方法；\n- this 可以作为参数在方法中传递；\n- this 可以作为参数在构造方法中传递；\n- this 可以作为方法的返回值，返回当前类的对象。\n\n### 01、 指向当前对象\n\n**demo**：\n\n```Java\nWithoutThisStudent(String name, int age) {\n        name = name;\n        age = age;\n    }\n\n```\n\n伪代码运行结果：\n\n```Java\nnull\t0\n\nnull\t0\n```\n\n更改之后的demo:\n\n```java\nWithThisStudent(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n```\n\n运行正确√\n\n### 02、调用当前类的方法\n\n“我们可以在一个类中使用 this 关键字来调用另外一个方法，如果没有使用的话，编译器会自动帮我们加上。”我对自己深厚的编程功底充满自信，“在源代码中，`method2()` 在调用 `method1()` 的时候并没有使用 this 关键字，但通过反编译后的字节码可以看得到。”\n\n### 03、调用当前类的构造方法\n\n调用无参的constructor\n\n```java\npublic class InvokeConstrutor {\n    InvokeConstrutor() {\n        System.out.println(\"hello\");\n    }\n\n    InvokeConstrutor(int count) {\n        this();\n        System.out.println(count);\n    }\n\n    public static void main(String[] args) {\n        InvokeConstrutor invokeConstrutor = new InvokeConstrutor(10);\n    }\n}\n```\n\n\n\n“也可以在无参构造方法中使用 `this()` 并传递参数来调用有参构造方法。”话音没落，我就在键盘上敲了起来，“来看下面这段代码。”\n\n\n\n```java\npublic class InvokeParamConstrutor {\n    InvokeParamConstrutor() {\n        this(10);\n        System.out.println(\"hello\");\n    }\n\n    InvokeParamConstrutor(int count) {\n        System.out.println(count);\n    }\n\n    public static void main(String[] args) {\n        InvokeParamConstrutor invokeConstrutor = new InvokeParamConstrutor();\n    }\n}\n```\n\n\n\nwarning：\n\n“不过，需要注意的是，`this()` 必须放在构造方法的第一行，否则就报错了。”\n\n![img](http://cdn.tobebetterjavaer.com/tobebetterjavaer/images/keywords/20-01.png)\n\n### *04、作为参数在方法中传递（没看懂\n\n###  05、作为参数在构造方法中传递\n\n### 06、作为方法的返回值\n\n```java\npublic class ThisAsMethodResult {\n    ThisAsMethodResult getThisAsMethodResult() {\n        return this;\n    }\n    \n    void out() {\n        System.out.println(\"hello\");\n    }\n\n    public static void main(String[] args) {\n        new ThisAsMethodResult().getThisAsMethodResult().out();\n    }\n}\n```\n\n“`getThisAsMethodResult()` 方法返回了 this 关键字，指向的就是 `new ThisAsMethodResult()` 这个对象，所以可以紧接着调用 `out()` 方法——达到了链式调用的目的，这也是 this 关键字非常经典的一种用法。”\n\n### 3.super\n\n“super 关键字的用法主要有三种。”\n\n- 指向父类对象；\n- 调用父类的方法；\n- `super()` 可以调用父类的构造方法。\n\n### 4.final\n\n什么是序列化？\n\n序列化是什么意思呢？Java 的序列化是指，将对象转换成以字节序列的形式来表示，这些字节序中包含了对象的字段和方法。序列化后的对象可以被写到数据库、写到文件，也可用于网络传输。\n\n“被 final 修饰的变量无法重新赋值。换句话说，final 变量一旦初始化，就无法更改。”\n\n**final类：**\n\n“如果一个类使用了 final 关键字修饰，那么它就无法被继承.....”\n\n“等等，哥，我知道，String 类就是一个 final 类。”还没等我说完，三妹就抢着说到。\n\n“说得没毛病。”\n\n```java\npublic final class String\n    implements java.io.Serializable, Comparable<String>, CharSequence,\n               Constable, ConstantDesc {}\n```\n\n⚠️⚠️⚠️：String 是 immutable 类（不可变对象）\n\n“那三妹你知道为什么 String 类要设计成 final 吗？”\n\n“这个还真不知道。”三妹的表情透露出这种无奈。\n\n“原因大致有 3 个。”\n\n- 为了实现字符串常量池的需要\n- 为了线程安全的需要\n- 为了 HashCode 的不可变性的需要\n\n“想了解更详细的原因，可以一会看看我之前写的这篇文章。”\n\n[为什么 Java 字符串是不可变的？](https://mp.weixin.qq.com/s/CRQrm5zGpqWxYL_ztk-b2Q)\n\n### 5.instanceof\n\n语法格式：\n\n`(object) instanceof (type)`\n\n​    对象\t\t\t\t\t\t\t\t类型\n\n用意也非常简单，判断对象是否符合指定的类型，结果要么是 true，要么是 false。在反序列化的时候，instanceof 操作符还是蛮常用的，因为这时候我们不太确定对象属不属于指定的类型，如果不进行判断的话，就容易抛出 ClassCastException 异常。\n\nJava 是一门面向对象的编程语言，也就意味着除了基本数据类型，所有的类都会隐式继承 Object 类。所以下面的结果肯定也会输出 true。\n\n```java\nThread thread = new Thread();\nSystem.out.println(thread instanceof Object);\n```\n\n如何使用？\n\n```java\n// 先判断类型\nif (obj instanceof String) {\n    // 然后强制转换\n    String s = (String) obj;\n    // 然后才能使用\n}\n```\n\n先用 instanceof 进行类型判断，然后再把 obj 强制转换成我们期望的类型再进行使用。\n\nJDK 16 的时候，instanceof 模式匹配转了正，意味着使用 instanceof 的时候更便捷了。\n\n```java\nif (obj instanceof String s) {\n    // 如果类型匹配 直接使用 s\n}\n```\n\n## *不可变对象\n\n### 01、什么是不可变类？\n\n一个类的对象在通过构造方法创建后如果状态不会再被改变，那么它就是一个不可变（immutable）类。它的所有成员变量的赋值仅在构造方法中完成，不会提供任何 setter 方法供外部类去修改。\n\n自从有了**多线程**，生产力就被无限地放大了，所有的程序员都爱它，因为强大的硬件能力被充分地利用了。但与此同时，所有的程序员都对它心生忌惮，因为一不小心，多线程就会把**对象的状态变得混乱不堪**。\n\n引入关键字：synchronized(同步)\n\n为了保护状态的原子性、可见性、有序性，我们程序员可以说是竭尽所能。其中，synchronized（同步）关键字是最简单最入门的一种解决方案。\n\n假如说类是不可变的，那么对象的状态就也是不可变的。这样的话，每次修改对象的状态，就会产生一个新的对象供不同的线程使用，我们程序员就不必再担心并发问题了。\n\n### 02、常见的不可变类\n\nString类\n\n为什么要将String类设置为不可变类？\n\n原因如下：\n\n1）常量池的需要\n\n字符串常量池是 Java 堆内存中一个特殊的存储区域，当创建一个 String 对象时，假如此字符串在常量池中不存在，那么就创建一个；假如已经存，就不会再创建了，而是直接引用已经存在的对象。这样做能够减少 JVM 的内存开销，提高效率。\n\n2）hashCode 的需要\n\n因为字符串是不可变的，所以在它创建的时候，其 hashCode 就被缓存了，因此非常适合作为哈希值（比如说作为 HashMap 的键），多次调用只返回同一个值，来提高效率。\n\n3）线程安全\n\n就像之前说的那样，如果对象的状态是可变的，那么在多线程环境下，就很容易造成不可预期的结果。而 String 是不可变的，就可以在多个线程之间共享，不需要同步处理。\n\n因此，当我们调用 String 类的任何方法（比如说 `trim()`、`substring()`、`toLowerCase()`）时，总会返回一个新的对象，而不影响之前的值。\n\n\n\n```java\nString cmower = \"沉默王二，一枚有趣的\n```\n\n\n\n\n\n## *可变参数\n\n\n\n\n\n\n\n\n\n## 泛型\n\n### 什么是泛型\n\n> 泛型：就是指在类定义时不会设置类中的属性或方法参数的具体类型，而是在类使用时（创建对象）再进行类型的定义。会在编译期检查类型是否错误。\n\n![](https://img-blog.csdnimg.cn/101412155b854d98891f6c0facdfde7f.png)\n\n类声明后的<>中这个T被称为类型参数，用于指代任意类型，实际上这个T只是个代表，写什么都可以。表示此时的value1，value2都是在类定义时没有明确类型，只有在使用时才告知编译器类型。出于规范，类型参数用单个的大写字母来代替，常见如下：\n\n- T：代表任意类\n- E：表示Element的意思，或是异常\n- K：与V搭配使用\n- V：与K搭配使用\n\n\n\n以下内容来源于[Java全栈体系](https://www.pdai.tech/md/java/basic/java-basic-x-generic.html):\n\n**通过泛型可以将不同数据类型的add()方法复用为一个方法：**\n\n`eg:`泛型add()方法：\n\n```Java\nprivate static <T extends Number> double add(T a, T b) {\n    System.out.println(a + \"+\" + b + \"=\" + (a.doubleValue() + b.doubleValue()));\n    return a.doubleValue() + b.doubleValue();\n}\n```\n\n\n\n- 泛型中的类型在使用时指定，不需要强制类型转换（**类型安全**，编译器会**检查类型**）\n\n看下这个例子：\n\n```java\nList list = new ArrayList();\nlist.add(\"xxString\");\nlist.add(100d);\nlist.add(new Person());        \n```\n\n我们在使用上述list中，list中的元素都是Object类型（无法约束其中的类型），所以在取出集合元素时需要人为的强制类型转化到具体的目标类型，且很容易出现`java.lang.ClassCastException`异常。\n\n引入泛型，它将提供类型的约束，提供编译前的检查：\n\n```Java\nList<String> list = new ArrayList<String>();\n\n// list中只能放String, 不能放其它类型的元素\n```\n\n更多内容请见：\n\nhttps://www.pdai.tech/md/java/basic/java-basic-x-generic.html\n\n## 注解\n\n直接开始上实例：\n\n```Java\nclass A{\n    public void test() {\n        \n    }\n}\n\nclass B extends A{\n\n    /**\n        * 重载父类的test方法\n        */\n    @Override\n    public void test() {\n    }\n\n    /**\n        * 被弃用的方法\n        */\n    @Deprecated\n    public void oldMethod() {\n    }\n\n    /**\n        * 忽略告警\n        * \n        * @return\n        */\n    @SuppressWarnings(\"rawtypes\")\n    public List processList() {\n        List list = new ArrayList();\n        return list;\n    }\n}\n\n```\n\nJava 1.5开始自带的标准注解，包括`@Override`、`@Deprecated`和`@SuppressWarnings`：\n\n- `@Override`：表示当前的方法定义将覆盖父类中的方法\n- `@Deprecated`：表示代码被弃用，如果使用了被@Deprecated注解的代码则编译器将发出警告\n- `@SuppressWarnings`：表示关闭编译器警告信息\n\n## 枚举（enum）\n\n**定义：**\n\n“枚举（enum），是 Java 1.5 时引入的关键字，它表示一种特殊类型的类，继承自 java.lang.Enum。”\n\n“我们来新建一个枚举 PlayerType。”\n\neg:\n\n```java\npublic enum PlayerType {\n    TENNIS,\n    FOOTBALL,\n    BASKETBALL\n}\n```\n\n01 “既然枚举是一种特殊的类，那它其实是可以定义在一个类的内部的，这样它的作用域就可以限定于这个外部类中使用。”我说。\n\neg:\n\n```java \npublic class Player {\n    private PlayerType type;\n    public enum PlayerType {\n        TENNIS,\n        FOOTBALL,\n        BASKETBALL\n    }\n    \n    public boolean isBasketballPlayer() {\n      return getType() == PlayerType.BASKETBALL;\n    }\n\n    public PlayerType getType() {\n        return type;\n    }\n\n    public void setType(PlayerType type) {\n        this.type = type;\n    }\n}\n\n```\n\n02 由于枚举是 final 的，所以可以确保在 Java 虚拟机中仅有一个常量对象，基于这个原因，我们可以使用“==”运算符来比较两个枚举是否相等，参照 `isBasketballPlayer()` 方法。\n\n03 “枚举还可用于 switch 语句，和基本数据类型的用法一致。”我说。\n\n04 “如果枚举中需要包含更多信息的话，可以为其添加一些字段，比如下面示例中的 name，此时需要为枚举添加一个带参的构造方法，这样就可以在定义枚举时添加对应的名称了。”我继续说。\n\neg:\n\n```java \npublic enum PlayerType {\n    TENNIS(\"网球\"),\n    FOOTBALL(\"足球\"),\n    BASKETBALL(\"篮球\");\n\n    private String name;\n    \n    PlayerType(String name) {\n        this.name = name;\n    }\n\n}\n```\n\n05 “EnumSet 是一个专门针对枚举类型的 Set 接口（后面会讲）的实现类，它是处理枚举类型数据的一把利器，非常高效。”我说，“从名字上就可以看得出，EnumSet 不仅和 Set 有关系，和枚举也有关系。”\n\n06 “因为 EnumSet 是一个抽象类，所以创建 EnumSet 时不能使用 new 关键字。不过，EnumSet 提供了很多有用的静态工厂方法。”\n\n![img](http://cdn.tobebetterjavaer.com/tobebetterjavaer/images/enum/enum-02.png)\n\n07 “除了 EnumSet，还有 EnumMap，是一个专门针对枚举类型的 Map 接口的实现类，它可以将枚举常量作为键来使用。EnumMap 的效率比 HashMap 还要高，可以直接通过数组下标（枚举的 ordinal 值）访问到元素。”\n\n08 “和 EnumSet 不同，EnumMap 不是一个抽象类，所以创建 EnumMap 时可以使用 new 关键字。”\n\n\n\n```java\nEnumMap<PlayerType, String> enumMap = new EnumMap<>(PlayerType.class);\n```\n\n09 有了 EnumMap 对象后就可以使用 Map 的一些方法了，见下图。\n\n![img](http://cdn.tobebetterjavaer.com/tobebetterjavaer/images/enum/enum-04.png)\n\n和 HashMap（后面会讲）的使用方法大致相同，来看下面的例子。\n\n\n\n```java\nEnumMap<PlayerType, String> enumMap = new EnumMap<>(PlayerType.class);\nenumMap.put(PlayerType.BASKETBALL,\"篮球运动员\");\nenumMap.put(PlayerType.FOOTBALL,\"足球运动员\");\nenumMap.put(PlayerType.TENNIS,\"网球运动员\");\nSystem.out.println(enumMap);\n\nSystem.out.println(enumMap.get(PlayerType.BASKETBALL));\nSystem.out.println(enumMap.containsKey(PlayerType.BASKETBALL));\nSystem.out.println(enumMap.remove(PlayerType.BASKETBALL));\n```\n\n“来看一下输出结果。”\n\n\n\n```text\n{TENNIS=网球运动员, FOOTBALL=足球运动员, BASKETBALL=篮球运动员}\n篮球运动员\ntrue\n篮球运动员\n```\n\n“除了以上这些，《Effective Java》这本书里还提到了一点，如果要实现单例的话，最好使用枚举的方式。”我说。\n\n\n\n### 单例：。。。\n\n\n\n## 反射\n\n何为正射？何为反射？\n\n“一般情况下，我们在使用某个类之前已经确定它到底是个什么类了，拿到手就直接可以使用 `new` 关键字来调用构造方法进行初始化，之后使用这个类的对象来进行操作。”\n\n```Java\nWriter writer = new Writer();\nwriter.setName(\"沉默王二\");\n\n```\n\n像上面这个例子，就可以理解为“正射”。而反射就意味着一开始我们不知道要初始化的类到底是什么，也就没法直接使用 `new` 关键字创建对象了。\n\n我们只知道这个类的一些基本信息，就好像我们看电影的时候，为了抓住一个犯罪嫌疑人，警察就会问一些目击证人，根据这些证人提供的信息，找专家把犯罪嫌疑人的样貌给画出来——这个过程，就可以称之为**反射**。\n\n\n\n反射的缺点：\n\n- **破坏封装**：由于反射允许访问私有字段和私有方法，所以可能会破坏封装而导致安全问题。\n- **性能开销**：由于反射涉及到动态解析，因此无法执行 Java 虚拟机优化，再加上反射的写法的确要复杂得多，所以性能要比“正射”差很多，在一些性能敏感的程序中应该避免使用反射。\n\n好处：\n\n- **开发通用框架**：像 Spring，为了保持通用性，通过配置文件来加载不同的对象，调用不同的方法。\n- **动态代理**：在面向切面编程中，需要拦截特定的方法，就会选择动态代理的方式，而动态代理的底层技术就是反射。\n- **注解**：注解本身只是起到一个标记符的作用，它需要利用发射机制，根据标记符去执行特定的行为。\n\n\n\n详情参考：\n\n[浅析](https://www.cnblogs.com/chanshuyi/p/head_first_of_reflection.html)\n\n[深入理解](https://dunwu.github.io/javacore/basics/java-reflection.html#_1-%E5%8F%8D%E5%B0%84%E7%AE%80%E4%BB%8B)\n\n\n\n## 集合框架（容器）\n\n集合框架的结构图：\n\n<img src=\"http://cdn.tobebetterjavaer.com/tobebetterjavaer/images/collection/gailan-01.png\" alt=\"img\" style=\"zoom:200%;\" />\n\n单词：\n\nCollection——集合；\n\nMap——图、表（两个类间的映射关系）；\n\nList——列举、列表；\n\nArray——数组；\n\nArraylist——数组列表；\n\nLinkedlist——链表；\n\nStack——栈；\t\t\t  \t`执行效率较低`\n\nVector——矩阵、模型\t`线程安全`\n\nJava 集合框架可以分为两条大的支线：\n\n- Collection，主要由 List、Set、Queue 组成，List 代表有序、可重复的集合，典型代表就是封装了动态数组的 ArrayList 和封装了链表的 LinkedList；Set 代表无序、不可重复的集合，典型代表就是 HashSet 和 TreeSet；Queue 代表队列，典型代表就是双端队列 ArrayDeque，以及优先级队列 PriorityQue。\n- Map，代表键值对的集合，典型代表就是 HashMap。\n\n### 01、List\n\n> List 的特点是存取有序，可以存放重复的元素，可以用下标对元素进行操作\n\n### 02、Set\n\n说在前面：\n\nSet 集合不是关注的重点，因为底层都是由 Map 实现的，为什么要用 Map 实现呢？\n\n因为 Map 的键不允许重复、无序吗\n\n> Set 的特点是存取无序，不可以存放重复的元素，不可以用下标对元素进行操作，和 List 有很多不同\n\nSet是Java中的**集合类，提供了一种无顺序，不重复的集合**。常用的子类包括HashSet, TreeSet等。\n\n### 03、Queue\n\n> Queue，也就是队列，通常遵循先进先出（FIFO）的原则，新元素插入到队列的尾部，访问元素返回队列的头部。\n\n### 04、Map\n\n> Map 保存的是键值对，键要求保持唯一性，值可以重复。\n\n### 浅析ArrayList（动态数组）\n\narraylist是接口list的实现类，有很多方便调用的预定义方法，便于用户直接调用。\n\n\n\n```Java\nList接口常用方法：\n1、add(Object element)： 向列表的尾部添加指定的元素。\n    /*\n    \tList<String> alist = new ArrayList<>();\n    \talist.add(\"沉默王二\");\n\t*/\n2、size()： 返回列表中的元素个数。\n\n3、get(int index)： 返回列表中指定位置的元素，index从0开始。\n\n4、add(int index, Object element)： 在列表的指定位置插入指定元素。\n\n5、set(int i, Object element)： 将索引i位置元素替换为元素element并返回被替换的元素。\n\n6、clear()： 从列表中移除所有元素。\n\n7、isEmpty()： 判断列表是否包含元素，不包含元素则返回 true，否则返回false。\n\n8、contains(Object o)： 如果列表包含指定的元素，则返回 true。\n\n9、remove(int index)： 移除列表中指定位置的元素，并返回被删元素。\n\n10、remove(Object o)： 移除集合中第一次出现的指定元素，移除成功返回true，否则返回false。\n\n11、iterator()： 返回按适当顺序在列表的元素上进行迭代的迭代器。    \n```\n\n12、indexof()：正序查找一个元素。倒叙查找为lastIndexOf()\n    \n\nArrayList 可以称得上是集合框架方面最常用的类了，可以和 HashMap 一较高下。\n\nArrayList 在数组的基础上实现了自动扩容，并且提供了比数组更丰富的预定义方法（各种增删改查），非常灵活。\n\n创建一个ArrayList的语法格式：\n\n```Java\nArrayList<String> alist = new ArrayList<String>();//标准\n/*可以通过上面的语句来创建一个字符串类型的 ArrayList（通过尖括号来限定 ArrayList 中元素的类型，如果尝试添加其他类型的元素，将会产生编译错误），更简化的写法如下：*/\nList<String> alist = new ArrayList<>();\n```\n\n由于 ArrayList 实现了 List 接口，所以 alist 变量的类型可以是 List 类型；new 关键字声明后的尖括号中可以不再指定元素的类型，因为编译器可以通过前面尖括号中的类型进行智能推断。\n\n如果非常确定 ArrayList 中元素的个数，在创建的时候还可以指定初始大小。\n\n\n\n### 浅析linkedList（链表）\n\n链表这门内功大致分为三个层次：\n\n- 第一层叫做“单向链表”，我只有一个后指针，指向下一个数据；\n- 第二层叫做“双向链表”，我有两个指针，后指针指向下一个数据，前指针指向上一个数据。\n- 第三层叫做“二叉树”，把后指针去掉，换成左右指针。\n\n```Java\n创建一个LinkedList的语法格式：\nLinkedList<String> list = new LinkedList();\n```\n\n\n\n**1）招式一：增**\n\n可以调用 add 方法添加元素：\n\n\n\n```java\nlist.add(\"沉默王二\");\nlist.add(\"沉默王三\");\nlist.add(\"沉默王四\");\n```\n\nadd 方法内部其实调用的是 linkLast 方法：\n\n\n\n```java\npublic boolean add(E e) {\n    linkLast(e);\n    return true;\n}\n```\n\nlinkLast，顾名思义，就是在链表的尾部链接：\n\n- 添加第一个元素的时候，first 和 last 都为 null。\n- 然后新建一个节点 newNode，它的 prev 和 next 也为 null。\n- 然后把 last 和 first 都赋值为 newNode。\n\n此时还不能称之为链表，因为前后节点都是断裂的。\n\n![img](http://cdn.tobebetterjavaer.com/tobebetterjavaer/images/collection/linkedlist-02.png)\n\n- 添加第二个元素的时候，first 和 last 都指向的是第一个节点。\n- 然后新建一个节点 newNode，它的 prev 指向的是第一个节点，next 为 null。\n- 然后把第一个节点的 next 赋值为 newNode。\n\n此时的链表还不完整。\n\n![img](http://cdn.tobebetterjavaer.com/tobebetterjavaer/images/collection/linkedlist-03.png)\n\n- 添加第三个元素的时候，first 指向的是第一个节点，last 指向的是最后一个节点。\n- 然后新建一个节点 newNode，它的 prev 指向的是第二个节点，next 为 null。\n- 然后把第二个节点的 next 赋值为 newNode。\n\n此时的链表已经完整了。\n\n![img](http://cdn.tobebetterjavaer.com/tobebetterjavaer/images/collection/linkedlist-04.png)\n\n我这个增的招式，还可以演化成另外两个：\n\n- `addFirst()` 方法将元素添加到第一位；\n- `addLast()` 方法将元素添加到末尾。\n\naddFirst 内部其实调用的是 linkFirst：\n\n\n\n```java\npublic void addFirst(E e) {\n    linkFirst(e);\n}\n```\n\nlinkFirst 负责把新的节点设为 first，并将新的 first 的 next 更**2）招式二：删**\n\n我这个删的招式还挺多的：\n\n- `remove()`：删除第一个节点\n- `remove(int)`：删除指定位置的节点\n- `remove(Object)`：删除指定元素的节点\n- `removeFirst()`：删除第一个节点\n- `removeLast()`：删除最后一个节点\n\nremove 内部调用的是 removeFirst，所以这两个招式的功效一样。\n\n`remove(int)` 内部其实调用的是 unlink 方法。\n\n\n\n```java\npublic E remove(int index) {\n    checkElementIndex(index);\n    return unlink(node(index));\n}\n```\n\n新为之前的 first。\n\nunlink 方法其实很好理解，就是更新当前节点的 next 和 prev，然后把当前节点上的元素设为 null。\n\n**3）招式三：改**\n\n可以调用 `set()` 方法来更新元素：\n\n\n\n```java\nlist.set(0, \"沉默王五\");\n```\n\n来看一下 `set()` 方法：\n\n\n\n```java\npublic E set(int index, E element) {\n    checkElementIndex(index);\n    Node<E> x = node(index);\n    E oldVal = x.item;\n    x.item = element;\n    return oldVal;\n}\n```\n\n首先对指定的下标进行检查，看是否越界；然后根据下标查找原有的节点：\n\n`size >> 1`：也就是右移一位，相当于除以 2。对于计算机来说，移位比除法运算效率更高，因为数据在计算机内部都是二进制存储的。\n\n换句话说，node 方法会对下标进行一个初步判断，如果靠近前半截，就从下标 0 开始遍历；如果靠近后半截，就从末尾开始遍历。\n\n找到指定下标的节点就简单了，直接把原有节点的元素替换成新的节点就 OK 了，prev 和 next 都不用改动。\n\n**4）招式四：查**\n\n我这个查的招式可以分为两种：\n\n- indexOf(Object)：查找某个元素所在的位置\n- get(int)：查找某个位置上的元素\n\nindexOf 的内部分为两种，一种是元素为 null 的时候，必须使用 == 来判断；一种是元素为非 null 的时候，要使用 equals 来判断。因为 equals 是不能用来判 null 的，会抛出 NPE 错误。\n\nget 方法的内核其实还是 node 方法，这个之前已经说明过了，这里略过。\n\n\n\n```java\npublic E get(int index) {\n    checkElementIndex(index);\n    return node(index).item;\n}\n```\n\n其实，查这个招式还可以演化为其他的一些，比如说：\n\n- `getFirst()` 方法用于获取第一个元素；\n- `getLast()` 方法用于获取最后一个元素；\n- `poll()` 和 `pollFirst()` 方法用于删除并返回第一个元素（两个方法尽管名字不同，但方法体是完全相同的）；\n- `pollLast()` 方法用于删除并返回最后一个元素；\n- `peekFirst()` 方法用于返回但不删除第一个元素。\n\n虽然ArrayList经常喊LinkedList一声师弟，但二者之间其实挺和谐的。但我知道，在外人眼里，同门师兄弟，总要一较高下的。\n\n比如说，我们俩在增删改查时候的时间复杂度。\n\n### ArrayList和LinkedList的区别\n\n增删改查时候的时间复杂度。\n\n由此，可以得出这样的结论：**遍历 LinkedList 的时候，千万不要使用 for 循环，要使用迭代器。**\n\n### Java中的Iterator和Iterable区别\n\nIterator：迭代器\n\nIterable：可迭代的\n\n什么是迭代器？\n\n```txt\n迭代器 （iterator）有时又称 光标 （cursor）是**程序设计的 软件设计模式** ，可在容器对象（container，例如 链表 或 数组 ）上遍访的接口，设计人员无需关心容器对象的内存分配的实现细节。\n\n**中文名:** 迭代器\n\n**外文名:** iterator\n```\n\n在 Java 中，我们对 List 进行遍历的时候，主要有这么三种方式。\n\n第一种：for 循环。\n\n```java\nfor (int i = 0; i < list.size(); i++) {\n    System.out.print(list.get(i) + \"，\");\n}\n```\n\n第二种：迭代器。\n\n```java\nIterator it = list.iterator();\nwhile (it.hasNext()) {\n    System.out.print(it.next() + \"，\");\n}\n```\n\n第三种：for-each。\n\n```java\nfor (String str : list) {\n    System.out.print(str + \"，\");\n}\n```\n\n### fail-fast\n\n官翻：\n\n```txet\nIn systems design, a fail-fast system is one which immediately reports at its interface any condition that is likely to indicate a failure. Fail-fast systems are usually designed to stop normal operation rather than attempt to continue a possibly flawed process. Such designs often check the system's state at several points in an operation, so any failures can be detected early. The responsibility of a fail-fast module is detecting errors, then letting the next-highest level of the system handle them.\n```\n\nfail-fast 是一种通用的系统设计思想，一旦检测到可能会发生错误，就立马抛出异常，程序将不再往下执行。——一种保护机制。\n\ndemo：\n\n```java\nList<String> list = new ArrayList<>();\nlist.add(\"沉默王二\");\nlist.add(\"沉默王三\");\nlist.add(\"一个文章真特么有趣的程序员\");\n\nfor (String str : list) {\n\tif (\"沉默王二\".equals(str)) {\n\t\tlist.remove(str);\n\t}\n}\n\nSystem.out.println(list);\n```\n\n这段代码看起来没有任何问题，但运行起来就报错了。\n\n![img](http://cdn.tobebetterjavaer.com/tobebetterjavaer/images/collection/fail-fast-01.png)\n\n**![img](http://cdn.tobebetterjavaer.com/tobebetterjavaer/images/collection/fail-fast-02.png)那该如何正确地删除元素呢**？\n\n**1）remove 后 break**\n\n\n\n```java\nList<String> list = new ArrayList<>();\nlist.add(\"沉默王二\");\nlist.add(\"沉默王三\");\nlist.add(\"一个文章真特么有趣的程序员\");\n\nfor (String str : list) {\n\tif (\"沉默王二\".equals(str)) {\n\t\tlist.remove(str);\n\t\tbreak;\n\t}\n}\n```\n\nbreak 后循环就不再遍历了，意味着 Iterator 的 next 方法不再执行了，也就意味着 `checkForComodification` 方法不再执行了，所以异常也就不会抛出了。\n\n但是呢，当 List 中有重复元素要删除的时候，break 就不合适了。\n\n**3）使用 Iterator**\n\n\n\n```java\nList<String> list = new ArrayList<>();\nlist.add(\"沉默王二\");\nlist.add(\"沉默王三\");\nlist.add(\"一个文章真特么有趣的程序员\");\n\nIterator<String> itr = list.iterator();\n\nwhile (itr.hasNext()) {\n\tString str = itr.next();\n\tif (\"沉默王二\".equals(str)) {\n\t\titr.remove();\n\t}\n}\n```\n\n为什么使用 Iterator 的 remove 方法就可以避开 fail-fast 保护机制呢？看一下 remove 的源码就明白了。** 循环**\n\n简单地总结一下，fail-fast 是一种保护机制，可以通过 for-each 循环删除集合的元素的方式验证这种保护机制。\n\n那也就是说，for-each 本质上是一种语法糖，遍历集合时很方面，但并不适合拿来操作集合中的元素（增删）。\n\n\n\n### HashMap\n\n什么是hashmap？\n\n说在前面：\n\n```txt\n说到HashMap，就先说一下Map\nmap是用于存储键值对（<key,value>）的集合类，也可以说是一组键值对的映射（数学概念）。\nMap的特点\n1.没有重复的 key（一方面，key用set保存，所以key必须是唯一，无序的；另一方面，map的取值基本上是通过key来获取value，如果有两个相同的key，计算机将不知道到底获取哪个对应值；这时候有可能会问，那为什么我编程时候可以用put（）方法传入两个key值相同的键值对？那是因为源码中，传入key值相同的键值对，将作为覆盖处理）\n\n2.每个 key 只能对应一个 value, 多个 key 可以对应一个 value（这就是映射的概念，最经典的例子就是射箭，一排射手，一排箭靶，一个射手只能射中一个箭靶，而每个箭靶可能被不同射手射中。这里每个射手只有一根箭，不存在三箭齐发还都中靶这种骚操作。将射手和射中的靶子连线，这根线加射手加靶子就是一个映射）\n\n3.key,value 都可以是任何引用类型（包括 null）的数据（只能是引用类型）\n\n4.Map 取代了古老的 Dictionary 抽象类（知道就行，可以忽略）\n————————————————\n版权声明：本文为CSDN博主「酒吧七」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。\n原文链接：https://blog.csdn.net/qq_36711757/article/details/80394272\n```\n\n\n\n#### 一、hash 方法的原理\n\n```\n把任意长度的输入（输入叫做预映射，知道就行），通过一种函数（hashCode() 方法），变换成固定长度的输出，该输出就是***\\*哈希值\\****（hashCode），这种函数就叫做***\\*哈希函数\\****，而计算哈希值的过程就叫做***\\*哈希\\****。哈希的主要应用是哈希表和分布式缓存。\n\n这里有个问题，哈希算法和哈希函数不是一个东西，哈希函数是哈希算法的一种实现，以后面试就说哈希函数就行。\n\n在将键值对存入数组之前，将key通过哈希算法计算出哈希值，把哈希值作为数组下标，把该下标对应的位置作为键值对的存储位置，通过该方法建立的数组就叫做***\\*哈希表\\****，而这个存储位置就叫做***\\*桶（bucket）\\****。数组是通过整数下标直接访问元素，哈希表是通过字符串key直接访问元素，也就说哈希表是一种特殊的数组（关联数组），哈希表广泛应用于实现数据的快速查找（在map的key[集合](https://so.csdn.net/so/search?q=集合&spm=1001.2101.3001.7020)中，一旦存储的key的数量特别多，那么在要查找某个key的时候就会变得很麻烦，数组中的key需要挨个比较，哈希的出现，使得这样的比较次数大大减少。）\n\n哈希表选用哈希函数计算哈希值时，可能不同的 key 会得到相同的结果，一个地址怎么存放多个数据呢？这就是***\\*哈希冲突（碰撞）\\****。解决哈希冲突有两种方法，拉链法（链接法）和开放定址法（这种没用过）。***\\*拉链法\\****：将键值对对象封装为一个node结点，新增了next指向，这样就可以将碰撞的结点链接成一条单链表，保存在该地址（数组位置）中。\n```\n\n再来看一下 hash 方法的源码（JDK 8 中的 HashMap）：\n\n```java\nstatic final int hash(Object key) {\n    int h;\n    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);\n}\n```\n\n`key.hashCode()` 是用来获取键位的哈希值的，理论上，哈希值是一个 int 类型，范围从-2147483648 到 2147483648。前后加起来大概 40 亿的映射空间，只要哈希值映射得比较均匀松散，一般是不会出现哈希碰撞的。\n\n取模运算有两处。\n\n> 取模运算（“Modulo Operation”）和取余运算（“Remainder Operation ”）两个概念有重叠的部分但又不完全一致。主要的区别在于对负整数进行除法运算时操作不同。**取模**主要是用于**计算机术语**中，**取余**则更多是**数学概念**。\n\n一处是往 HashMap 中 put 的时候（`putVal` 方法中）：\n\n```java\nfinal V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) {\n     HashMap.Node<K,V>[] tab; HashMap.Node<K,V> p; int n, i;\n     if ((tab = table) == null || (n = tab.length) == 0)\n         n = (tab = resize()).length;\n     if ((p = tab[i = (n - 1) & hash]) == null)\n         tab[i] = newNode(hash, key, value, null);\n}\n```\n\n一处是从 HashMap 中 get 的时候（`getNode` 方法中）：\n\n```java\nfinal Node<K,V> getNode(int hash, Object key) {\n     Node<K,V>[] tab; Node<K,V> first, e; int n; K k;\n     if ((tab = table) != null && (n = tab.length) > 0 &&\n            (first = tab[(n - 1) & hash]) != null) {}\n}\n```\n\n其中的 `(n - 1) & hash` 正是取模运算，就是把哈希值和（数组长度-1）做了一个“与”运算。\n\n可能大家在疑惑：**取模运算难道不该用 `%` 吗？为什么要用 `&` 呢**？\n\n这是因为 `&` 运算比 `%` 更加高效，并且当 b 为 2 的 n 次方时，存在下面这样一个公式。\n\n> a % b = a & (b-1)\n\n用 $2^n$ 替换下 b 就是：\n\n> a % 2^n = a & (2^n-1)\n\n综上所述，hash 方法是用来做哈希值优化的，把哈希值右移 16 位，也就正好是自己长度的一半，之后与原哈希值做异或运算，这样就混合了原哈希值中的高位和低位，增大了随机性。\n\n说白了，**hash 方法就是为了增加随机性，让数据元素更加均衡的分布，减少碰撞**。\n\n**[为什么 HashMap 的数组长度要取 2 的整次方?](https://mp.weixin.qq.com/s/aS2dg4Dj1Efwujmv-6YTBg)**\n\n#### 二、扩容机制\n\n大家都知道，数组一旦初始化后大小就无法改变了，所以就有了 [ArrayList]这种“动态数组”，可以自动扩容。\n\nHashMap 的底层用的也是数组。向 HashMap 里不停地添加元素，当数组无法装载更多元素时，就需要对数组进行扩容，以便装入更多的元素。\n\n当然了，数组是无法自动扩容的，所以如果要扩容的话，就需要新建一个大的数组，然后把小数组的元素复制过去。\n\nHashMap 的扩容是通过 resize 方法来实现的，JDK 8 中融入了红黑树，比较复杂，为了便于理解，就还使用 JDK 7 的源码，搞清楚了 JDK 7 的，我们后面再详细说明 JDK 8 和 JDK 7 之间的区别。\n\n\n\n#### 三、加载因子为什么是0.75\n\n哈希函数计算结果越分散均匀，哈希碰撞的概率就越小，map的存取效率（时间复杂度）就会越高。\n\n哈希表长度越长，空间成本越大，哈希函数计算结果越分散均匀。\n\n***\\*扩容机制\\****（实际上就是负载因子）和哈希函数越合理，空间成本越小，哈希函数计算结果越分散均匀。\n\n从HashMap的默认构造函数源码可知，构造函数就是对下面几个字段进行初始化。\n\n负载因子越大（长度一定），最大结点容量越大，resize次数越少，空间成本越小，map的存取效率就会越高。\n\n桶数组初始容量（长度）越大（加载因子一定），最大结点容量越大，resize次数越少，空间成本越大，map的存取效率就会越高。\n\n涉及到概率论的泊松分布与二项分布。\n\n***引入红黑树的概念：***\n\n这里存在一个问题，即使负载因子和哈希函数设计的再合理，也免不了会出现***\\*拉链过长\\****（桶内结点过多）的情况，一旦出现拉链过长，则会严重影响HashMap的性能。于是，在JDK1.8版本中，对数据结构做了进一步的优化，引入了红黑树。而当链表长度太长（默认超过8）时，链表就转换为红黑树，利用红黑树快速增删改查的特点提高HashMap的性能。\n\n#### 四、线程不安全\n\n\n\n有何体现：\n\n多线程下扩容会死循环、多线程下 put 会导致元素丢失、put 和 get 并发时会导致 get 到 null，也就是环链死循环、数据丢失、数据覆盖三个问题。其中环链在JDK1.8已经解决，但还是有数据覆盖的问题。\n\n究其根本：\n\n线程不安全主要是发生在扩容函数中，即根源是在**transfer函数**中：transfer函数代码如下：\n\n```Java\n/**\n  *\n  @version JDK1.7\n  */\nvoid transfer(Entry[] newTable, boolean rehash) {\n        int newCapacity = newTable.length;\n        for (Entry<K,V> e : table) {\n            while(null != e) {\n                Entry<K,V> next = e.next;\n                if (rehash) {\n                    e.hash = null == e.key ? 0 : hash(e.key);\n                }\n                int i = indexFor(e.hash, newCapacity);\n                e.next = newTable[i];\n                newTable[i] = e;\n                e = next;\n            }\n        }\n    }\n```\n\n`HashMap`的扩容操作，重新定位每个桶的下标，并采用头插法将元素迁移到新数组中。头插法会将链表的顺序翻转，这也是形成死循环的关键点。\n\n\n\nkey 用 Set 存放，所以想做到 **key 不允许重复**，key 对应的类（一般是String）需要重写 hashCode 和 equals 方法\n\n- HashMap不是同步，HashTable是同步的，但HashTable已经弃用，如果需要线程安全，可以用synchronizedMap，例如       Map m = Collections.synchronizedMap(new HashMap(...));\n\n\n\n","source":"_posts/Java-Essay.md","raw":"---\ntitle: Java Essay\nindex_img: https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311151627635.png\nsticky: 100\ncategories:\n  - Java notes\ntags:\n  - Java基础\nabbrlink: 11449\ndate: 2022-09-07 08:58:32\n---\n\n* *写在前面：*\n  * 【免责声明：】本笔记来源自互联，是笔者结合自己的理解进行整理归纳发表在hexo博客只便于个人学习使用，若涉及到侵权，请联系我，谢谢！\n  * 个人博客地址：https://wl2o2o.github.io/\n* 写作背景:\n  * 笔者是一名大三在校生，目前正在努力学习Java方向，笔记书写于22年暑假期间，虽然起步有点晚，但是每天都在坚持，只要努力，光一定会shine向我的！\n\n# Essay笔记来源\n\n[Java全栈知识体系](https://www.pdai.tech/md/java/basic/java-basic-x-generic.html)——泛型\n\n[哔哩哔哩老杜Java](https://www.bilibili.com/video/BV1mE411x7Wt)——哔哩哔哩\n\n[Java程序员进阶之路](https://tobebetterjavaer.com/home.html)——沉默王二\n\n# 老杜Java零基础\n\n**P58**\n具体的命名规范：\n1、顾名思义；\n2、驼峰原则：一高一低：例如：PowerNodeNotes；\n3、类名、接口名首字母大写 ；\n\t变量名方法名首字母小写；\n\t\t常量名全部大写，单词之间用_下划线连接：USER_AGE;\n\n**P60**\n关键字：\nint、long、float...public static void boolean private protect 蓝色字体、小写显示\n\n**P63**\n提取帮助文档：也就是写在/**\t\t\t这里面的注释信息。\n\t\t\t\t*\n\t\t\t\t*@author\n\t\t\t\t*@version\n\t\t\t\t*/\njavadoc -d+文件夹名（文件夹绝对路径）+（需要提取的信息）+Java源文件\n例如：javadoc -d javaapi -author -version VarTest02.java\n\n**P70**\n1，变量的分类：\npublic class Test{\n\tint i;//全局变量\n\tpublic static void main(String[] args){\n\t\tint j;局部变量\n  }\n}\n\n2，变量的作用域：即有效范围（出了大括号就处于非作用域）！\n\n**P72**\n标识符可以标志什么：\n类名、方法名、常量、变量、接口名\n\n\n记录所有编程出现的错误，记录错误~！\n\n**P113**\n\n```java\npublic class Homework1{\n\tpublic static void main(String[] args){\n\t\tint i=10;\n\t\ti=i++;\n\t\tSystem.out.println(i);\t//运行结果为10！\n  }\n}\n//Java和C++源代码运行结果不一样，C++结果为11、Java为10.\n```\n\n原因：编译器原理不一样，其中Java的代码可以理解为一下三行：\n（在Java语言中i++，这种表达式在执行的时候，会提前将i变量找一个存储空间临时存储，不同于C++）\nint temp=i;\ni++;\ni=temp;\n因此！！！可以理解为：分号之后++再加一 \n\n**P116**\n接收键盘输入：\n\n在Java中则怎么接收键盘信息呢？\n第一种形式：\n\n```java\n//创建一个键盘扫描器对象(s为对象名，上下对应)\njava.util.Scanner s =new java.util.Scanner(System.in);\t\njava.util.Scanner s =new java.util.Scanner(System.in);\t\nint i=s.nextInt(); \nSystem.out.println();\t\n\nString str =s.next();\nSystem.out.println();\n//接收用户的输入，从键盘上接受一个int类型的数据、\n//i变量有值了，并且i变量中保存的这个值是用户输入的数字。\n//i变量就是接收键盘数据的\nint i=s.nextInt();\nSystem.out.println(\"您输入的数字是：\"+i);\n\nint j=s.nextInt();\nSystem.out.println(\"您输入的数字是：\"+j);\n//字符串类型\nString str = s.next();\n其他数据类型类似\n其中println:print为打印、ln为换行。\n```\n\n另外一种形式：\n\n```java\nimport java.util.Scanner;\t//idea可以自动引入\n//创建键盘扫描器对象\nScanner s = new Scanner(System.in);\nint num1 = s.nextInt();\nSystem.out.println(num1+\"+\"+num2+\"=\");\n```\n\n头歌实践教学平台项目案例练习：\n\n```java\n//什么是类、怎么创建类：\npackage step1;\n\npublic class Test {\n\tpublic static void main(String[] args) {\n\t\t/********** Begin **********/\n\t\t//创建Dog对象\n\t\t//设置Dog对象的属性\n        Dog wuhuarou = new Dog();\n\t\twuhuarou.name=\"五花肉\";\n        wuhuarou.color=\"棕色\";\n        wuhuarou.variety=\"阿拉斯加\";\n\t\t//输出小狗的属性\n\t\tSystem.out.println(\"名字：\" + wuhuarou.name + \"，毛色：\" + wuhuarou.color+ \"，品种：\" +wuhuarou.variety );\n\t\t//调用方法\n        wuhuarou.eat();\n        wuhuarou.run();\n\t\t/********** End **********/\n\t}\n}\n//在这里定义Dog类\n/********** Begin **********/\nclass Dog{\n    String name,color,variety;\n    void eat(){\n        System.out.println(\"啃骨头\");\n    }\n    void run(){\n        System.out.print(\"叼着骨头跑\");\n    }\n}\n/********** End **********/\n```\n\n关于质数：\n\n```java\npackage step2;\npublic class FindZhiShu {\n\tpublic static void main(String[] args) {\n\t\t   /*\n\t\t     打印输出质数的时候务必按照如下格式：System.out.print(质数+\" \")；\n\t\t     使用print进行打印同时被打印输出的质数后加上一个空格，\n\t\t     以便于与平台提供的结果格式保持一致！\n            */   \n\t\t   /**********begin**********/\n            a:for(int i = 2;i < 1000;i++){\t\t//此循环遍历次数较多，若对代码效率有要求，则可进一步改进代码：如下：\n                for(int j = 2;j<i;j++)\n                if(i%j==0){\n                    continue a;\n                }\n                System.out.print(i+\" \");\n            }\n           /**********end**********/\t\n\t}\n}\n\t\t**********************改进之后的代码*********************\npackage step2;\npublic class FindZhiShu {\n\tpublic static void main(String[] args) {\n\t\t   /*\n\t\t     打印输出质数的时候务必按照如下格式：System.out.print(质数+\" \")；\n\t\t     使用print进行打印同时被打印输出的质数后加上一个空格，\n\t\t     以便于与平台提供的结果格式保持一致！\n            */   \n\t\t   /**********begin**********/\n\n\tSystem.out.print(\"2 \");\t//因为2是特殊的质数，又因下面循环会自动跳过偶数，因此先将2打印出来。\n\t        a:for(int i = 3;i < 1000;i+=2){\n\t            for(int j = 2;j<i;j++)\n\t            if(i%j==0){\n\t                continue a;\t\t//此方法运用了给循环做标记，以此可以对continue和break进行明确的命令指示。\n\t            }\n\t            System.out.print(i+\" \");\n\t        }\n\t       /**********end**********/\t\n\t}\n\n}\n```\n\n\n\n## 《方法》\n\n### 定义：\n\n是可以完成某一个特定的功能，并且可被重复利用。\n\n在面向对象的语言中，函数称为方法，类似于C语言总的函数。方法写在类体中，可以写在main函数前后，不分顺序，因为main函数为执行入口。\n\n### 方法结构定义：\n\n【修饰符列表】 返回值类型 方法名 （形式参数列表）{\n\n​\t\t方法体;\n\n}\n\n注意：\n\n【】符号叫中括号、以上中括号里的内容表是不是必须的，是可以选择的，方法体由Java语句构成；\n\n \n\n关于修饰符列表：\n\n也不是必须的，目前可写成public static（称为静态方法）\n\n\n\nbreak与return的区别：\n\nbreak：用来终止一个switch语句和距离最近的循环\n\nreturn：用来终止一个方法。 \n\n### 方法优化：\n\n例题：编写一个方法，输出大于某个正整数n的最小的质数（思考：这个方法应该取什么名字，这个方法的形参是什么，返回值类型是什么？）\n\n```Java\n public class Homework2{\n    public static void main(String[] args){\n        //假设目前系统给定一个正整数n，n为5\n        int n = 7;\n        //输出大于5的最小质数\n        while(true){\n            n++;\n\t\t\t//需要一个判断是否为质数的方法。。\n            if(isZhiShu(n)){\t\t\t\t\n                System.out.print(\"最小质数是\"+n);\n                break;\n            }\n        }\n    }\n\n\t//该方法返回一个Boolean字符，用于main方法中的if判断语句。\n\tpublic static boolean isZhiShu(int num){\n\t\t//判断num是否为质数\n\t\t//可以利用循环取余的方法来判断是否可以整除除1和本身的数字\n\t\tfor(int i = 2; i < num;i++ ){\n\t\t\tif(num%i==0){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\t//return语句容易写在for循环里面，写在里面判断不完全\n\t\t//return之所以写在外面是因为要让循环执行完毕，执行完毕才可以正确判断\n\t\treturn true;\n\t}\n}\n```\n\n编程思路以及改进版：\n\n```java\n \nimport java.util.Scanner;\npublic class Homework2{\n    public static void main(String[] args){\n        \n        //以下代码省略，新增打印质数的方法\n\t\t/*\n\t\t//假设目前系统给定一个正整数n，n为5\n        int n = 7;\n\t\t//输出大于5的最小质数\n        while(true){\n            n++;\n\t\t\t//需要一个判断是否为质数的方法。。\n            if(isZhiShu(n)){\t\t\t\t\n                System.out.print(\"最小质数是\"+n);\n                break;\n            }\n        }\n\t\t*/\n\t\t\n\t\t//引入用户输入的数据\n\t\tScanner s = new Scanner(System.in);\n\t\tint num = s.nextInt();\n\t\t//直接调用打印质数的方法\n\t\tprintZhiShu(num);\n\n\n    }\n\t//代码不够精简，还可以在main（）中调用打印输出质数的方法\n\tpublic static void printZhiShu(int num){\n\t\t\n\t\t//while循环仍可精简，但是精简之后不易理解，代码如下：\n\t\t/*\t\t\n\t\twhile(isZhiShu(num)){\n\t\t}\n\t\tSystem.out.print(\"最小质数是\"+num);\n\t\t*/\n\n\t\t/*while(true){\n    \t\t//需要一个判断是否为质数的方法。。\n            if(isZhiShu(++num)){\t\t\t\t\n                System.out.print(\"最小质数是\"+num);\n                break;\n            }\n\t\t}\t\n\t\t*/\n\t\twhile(!isZhiShu(++num)){\n\t\t}\n\t\tSystem.out.print(\"最小质数是\"+num);\n        \n\t}\n\n\t//该方法返回一个Boolean字符，用于main方法中的if判断语句。\n\tpublic static boolean isZhiShu(int num){\n\t\t//判断num是否为质数\n\t\t//可以利用循环取余的方法来判断是否可以整除除1和本身的数字\n\t\tfor(int i = 2; i < num;i++ ){\n\t\t\tif(num%i==0){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\t//return语句容易写在for循环里面，写在里面判断不完全\n\t\t//return之所以写在外面是因为要让循环执行完毕，执行完毕才可以正确判断\n\t\treturn true;\n\t}\n\n}\n\n//以上代码为编程思路，以下为精简代码：\n/*\nimport java.util.Scanner;\npublic class Homework2{\n    public static void main(String[] args){\n\t\tScanner s = new Scanner(System.in);\n\t\tint num = s.nextInt();\n\n\t\tprintZhiShu(num);\n    }\n\n\tpublic static void printZhiShu(int num){\n\t\twhile(!isZhiShu(++num)){\n\t\t}\n\t\tSystem.out.print(\"最小质数是\"+num);\n\t}\n\n\tpublic static boolean isZhiShu(int num){\n\t\tfor(int i = 2; i < num;i++ ){\n\t\t\tif(num%i==0){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n}\n*/\n \n\n```\n\n### 方法重载\n\n同一个类中：方法名相同，形参个数或者类型不同。\n\n优点：代码整齐美观，记忆方法名较少。\n\n含义：就是可以定义多个相同名字的方法（例如：public static int sum(int a,int b)和public static int sum(long a,long b)）\n\n原理：Java编译器会自动识别方法名，若方法名相同，则进行参数类型匹配，所以名方法重载。\n\n怎么判断：方法名相同、形参类型不同、形参个数不同、形参顺序不同\n\n\n\n\n\n### 方法递归\n\n含义：方法调用自己的方法！\n\n典例：从前有座山，山里有个和尚说：{从前有座山，山里有个和尚说}：{从前有座山，山里有个和尚说}——递归。。。\n\n\n\n老杜这样说：\n\n方法递归？\n\n​\t1、什么是方法递归？\n\n​\t\t\t方法自己调用自己，这就是方法递归。\n\n​\t2、当递归时程序没有结束条件，一定会发生：\n\n​\t\t\t栈内存溢出错误：StackOverflowError\n\n​\t\t\t所以：递归必须要有结束条件。（这是一个非常重要的知识点。）\n\n​\t\t\tJVM发生错误之后一定会推出JVM。\n\n​\t3、递归假设是有结束条件的，就一定不会发生栈内存溢出吗？\n\n​\t\t\t假设这个结束条件时对的，是合法的，递归有时候也会出现栈内存溢出的错误。\n\n​\t\t\t因为有时候，可能递归的太深，栈内存不够（因为一直在压栈）\n\n​\t4、不建议在实际的开发中使用递归，，能用for循环while循环代替的尽量使用循环来做，因为循环的效率较高，耗费内存少。递归耗费的内存较多，另外递归若使用不当，则会导致JVM的死掉。\n\n​\t\t（极少数的情况下是必须要用递归的。）\n\n​\t\t所以：递归还是要认真学习的！\n\n\n\n老杜讲经验：\n\n​\t如果遇到了栈内存溢出，怎么调bug?\n\n​\t第一步：\n\n​\t\t先检查递归的结束条件对不对。如果不对，则进一步修改，直到正确。\n\n​\t第二步：\n\n​\t\t如果假设条件没问题，这个时候需要手动调整JVM的栈内存初始大小（通过命令行适当调大。）\n\n​\t第三步：\n\n​\t\t如果还会栈内存溢出，则继续调大。（Java -X  这个命令可以查看调整堆栈大小的参数。具体格式如下图所示：）\n\n\n\n\n\n老杜栈内存溢出图：\n\n![image-20220715183512822](http://images.rl0206.love/image-20220715183512822.png)\n\n\n\n如何指 定栈内存大小：\n\n![image-20220715184629869](http://images.rl0206.love/image-20220715184629869.png)\n\n\n\n### 递归实例\n\n题目：计算1~ 10的和。\n\n不用递归思路：写一个for循环方法，直接调用。\n\n用递归思路：（方法调用打法）\n\n![image-20220716094554506](http://images.rl0206.love/image-20220716094554506.png)\n\n\n\n\n\n\n\n\n\n## 《代码的包装与封装》\n\n封装及使用方法：\n\n![image-20220715170415137](http://images.rl0206.love/image-20220715170415137.png)\n\n\n\n\n\n\n\n## 《认识面向对象》\n\n面向对象与面向过程：\n\n​\t面向过程的优缺点：\n\n​\t\t缺点：（高度耦合）\n\n​\t\t\t面向过程的程序的每一个功能之间都是因果关系，因为A所以B，AB联合成一个子模块，然后模块与模块之间形成因果关系。因此任何一个功能之间出现问题，就会导致另一出现问题。 这就是高度耦合！（耦合度就是粘连程度）\n\n​\t\t\t耦合度高导致扩展力差（主板集成显卡）\n\n​\t\t\t耦合度低导致扩展力强（独立下显卡，螺栓与螺母等）\n\n​\t\t优点：（快速开发）\n\n​\t\t\t对于小型项目，可以直接通过因果关系来写代码。不需要前期对象的提取、模型的建立，可以直接干活，从而实现功能。\n\n\n\n什么是面向对象的开发模式？\n\n​\t万物皆为对象，人眼看到的是各个对象之间的联系，更符合人类的思维方式。因此，面向对象在成为主流。\n\n如何判断面向过程和面向对象？\n\n​\t可以通过耦合度等判断。\n\n\n\n三个过程：\n\n​\tOOA-->OOD-->OOP\n\n​\t分析\t  设计\t 编程\n\n\n\n三大特征：\n\n封装、继承、多态。（任何一个面向对象的编程语言都包括这三个特征。）\n\n\n\n## 类与对象\n\n### 浅析类与对象：\n\n​\t类是一个集合，包含对象的特征，是特征的总结。\n\n​\t而对象是真实存在的，万物皆可对象。\n\n在Java语言中，要想得到对象，必须先定义类，，，对象是通过类创建的。\n\n​\t例如：先定义人类，才可以定义魏磊。哈哈哈哈。\n\n重要概念：\n\n​\t《实例化》\n\n​\t\t\t含义：通过类创建对象的过程叫做实例化。\n\n​\t《实例》\n\n​\t\t\t含义：对象又被称为实例。\n\n\n\n（此处补充类与对象的图）\n\n\n\n​\t《抽象》\n\n​\t\t\t含义：魏磊到人类的过程程为抽象。\n\n​\t类--【实例化】-->对象（实例）\n\n​\t对象--【抽象】-->类\n\n\n\n```Java\npublic class 明星类{\n    /*\n    类 = 属性 + 方法\n\n\t属性来源于状态； （名词）\t数据是以数据形式存在的，所以只能存放在变量中。\t\t即属性即变量。\n\n\t方法来源于动作； （动词）\n\t*/\n    //属性\n    int 身高;\n    int 体重;\n    \n    //方法\n    打篮球（）{\n        \n    }\n    学习（）{\n        \n    }\n    \n    \n\n\n}\n```\n\n\n\n### 对象的创建：\n\n​\t\"没对象，new一个\"\n\n​\t\t创建对象语法：XueSheng  s1 = new XueSheng();\n\n​\t\t\t\t\t\t\t\t\t\t\tXueSheng  s1 = new XueSheng()；此时此刻就相当于 ：int i = 1；\n\n \t\t\t\t\t\t\t\t\t\t\tXueSheng:数据类型\n\n​\t\t\t\t\t\t\t\t\t\t\ts1:变量名\n\n​\t\t\t\t\t\t\t\t\t\t\tnew:运算符\n\n​\t\t\t\t\t\t\t\t\t\t\tXueSheng:类名\n\n\n\n## Java变量\n\n\n\n变量的分类：\n\n1局部变量\n\n2成员变量\n\n3静态变量\n\n4常量        （要求大写）\n\n\n\n————————————笔记分隔线———————————\n\n# Java进阶之路笔记\n\n## 常用的48个关键字\n\n[沉默王二](https://tobebetterjavaer.com/about-the-author/)2021年10月22日Java核心Java大约 4 分钟\n\n------\n\n“二哥，就我之前学过的这些 Java 代码中，有 public、static、void、main 等等，它们应该都是关键字吧？”三妹的脸上泛着甜甜的笑容，我想她在学习 Java 方面已经变得越来越自信了。\n\n“是的，三妹。Java 中的关键字可不少呢！你一下子可能记不了那么多，不过，先保留个印象吧，对以后的学习会很有帮助。”\n\nPS：按照首字母的自然顺序排列。\n\n1. **abstract：** 用于声明抽象类，以及抽象方法。\n2. **boolean：** 用于将变量声明为布尔值类型，只有 true 和 false 两个值。\n3. **break：** 用于中断循环或 switch 语句。\n4. **byte：** 用于声明一个可以容纳 8 个比特的变量。\n5. **case：** 用于在 switch 语句中标记条件的值。\n6. **catch：** 用于捕获 try 语句中的异常。\n7. **char：** 用于声明一个可以容纳无符号 16 位比特的 [Unicode 字符open in new window](https://mp.weixin.qq.com/s/pNQjlXOivIgO3pbYc0GnpA)的变量。\n8. **class：** 用于声明一个类。\n9. **continue：** 用于继续下一个循环，可以在指定条件下跳过其余代码。\n10. **default：** 用于指定 switch 语句中除去 case 条件之外的默认代码块。\n11. **do：** 通常和 while 关键字配合使用，do 后紧跟循环体。\n12. **double：** 用于声明一个可以容纳 64 位浮点数的变量。\n13. **else：** 用于指示 if 语句中的备用分支。\n14. **enum：** 用于定义一组固定的常量（枚举）。\n15. **extends：** 用于指示一个类是从另一个类或接口继承的。\n16. **final：** 用于指示该变量是不可更改的。\n17. **finally：** 和 `try-catch` 配合使用，表示无论是否处理异常，总是执行 finally 块中的代码。\n18. **float：** 用于声明一个可以容纳 32 位浮点数的变量。\n19. **for：** 用于声明一个 for 循环，如果循环次数是固定的，建议使用 for 循环。\n20. **if：** 用于指定条件，如果条件为真，则执行对应代码。\n21. **implements：** 用于实现接口。\n22. **import：** 用于导入对应的类或者接口。\n23. **instanceof：** 用于判断对象是否属于某个类型（class）。\n24. **int：** 用于声明一个可以容纳 32 位带符号的整数变量。\n25. **interface：** 用于声明接口。\n26. **long：** 用于声明一个可以容纳 64 位整数的变量。\n27. **native：** 用于指定一个方法是通过调用本机接口（非 Java）实现的。\n28. **new：** 用于创建一个新的对象。\n29. **null：** 如果一个变量是空的（什么引用也没有指向），就可以将它赋值为 null，和空指针异常息息相关。\n30. **package：** 用于声明类所在的包。\n31. **private：** 一个访问权限修饰符，表示方法或变量只对当前类可见。\n32. **protected：** 一个访问权限修饰符，表示方法或变量对同一包内的类和所有子类可见。\n33. **public：** 一个访问权限修饰符，除了可以声明方法和变量（所有类可见），还可以声明类。`main()` 方法必须声明为 public。\n34. **return：** 用于在代码执行完成后返回（一个值）。\n35. **short：** 用于声明一个可以容纳 16 位整数的变量。\n36. **static：** 表示该变量或方法是静态变量或静态方法。\n37. **strictfp：** 并不常见，通常用于修饰一个方法，确保方法体内的浮点数运算在每个平台上执行的结果相同。\n38. **super：** 可用于调用父类的方法或者字段。\n39. **switch：** 通常用于三个（以上）的条件判断。\n40. **synchronized：** 用于指定多线程代码中的同步方法、变量或者代码块。\n41. **this：** 可用于在方法或构造函数中引用当前对象。\n42. **throw：** 主动抛出异常。\n43. **throws：** 用于声明异常。\n44. **transient：** 修饰的字段不会被序列化。\n45. **try：** 于包裹要捕获异常的代码块。\n46. **void：** 用于指定方法没有返回值。\n47. **volatile：** 保证不同线程对它修饰的变量进行操作时的可见性，即一个线程修改了某个变量的值，新值对其他线程来说是立即可见的。\n48. **while：** 如果循环次数不固定，建议使用 while 循环。\n\n## **关键字顺序排序**：\n\nbyte<short(char)<int<long<float<doublepackage step2;\n\n## **用户自定义方法**\n\n## （tips：如果是静态方法，那么调用时就不用new关键字来创建对象来调用了）\n\n当预先定义方法无法满足我们的要求时，就需要自定义一些方法，比如说，我们来定义这样一个方法，用来检查数字是偶数还是奇数。\n\n\n\n```java\npublic static void findEvenOdd(int num) {\n    if (num % 2 == 0) {\n        System.out.println(num + \" 是偶数\");\n    } else {\n        System.out.println(num + \" 是奇数\");\n    }\n}\n```\n\n方法名叫做 `findEvenOdd`，访问权限修饰符是 public，并且是静态的（static），返回类型是 void，参数有一个整型（int）的 num。方法体中有一个 if else 语句，如果 num 可以被 2 整除，那么就打印这个数字是偶数，否则就打印这个数字是奇数。\n\n方法被定义好后，如何被调用呢？\n\n\n\n```java\n/**\n * @author 微信搜「沉默王二」，回复关键字 PDF\n */\npublic class EvenOddDemo {\n    public static void main(String[] args) {\n        findEvenOdd(10);\n        findEvenOdd(11);\n    }\n\n    public static void findEvenOdd(int num) {\n        if (num % 2 == 0) {\n            System.out.println(num + \" 是偶数\");\n        } else {\n            System.out.println(num + \" 是奇数\");\n        }\n    }\n}\n```\n\n`main()` 方法是程序的入口，并且是静态的，那么就可以直接调用同样是静态方法的 `findEvenOdd()`。\n\n当一个方法被 static 关键字修饰时，它就是一个静态方法。换句话说，静态方法是属于类的，不属于类实例的（不需要通过 new 关键字创建对象来调用，直接通过类名就可以调用）。\n\n\n\n\n\n## 访问权限控制\n\n### **1.修饰类**\n\n- 默认访问权限（包访问权限）：用来修饰类的话，表示该类只对同一个包中的其他类可见。\n- public：用来修饰类的话，表示该类对其他所有的类都可见。\n\n### **2.修饰类的方法和变量**\n\n- 默认访问权限（包访问权限）：如果一个类的方法或变量被包访问权限修饰，也就意味着只能在同一个包中的其他类中显示地调用该类的方法或者变量，在不同包中的类中不能显式地调用该类的方法或变量。\n- private：如果一个类的方法或者变量被 private 修饰，那么这个类的方法或者变量只能在该类本身中被访问，在类外以及其他类中都不能显式的进行访问。\n- protected：如果一个类的方法或者变量被 protected 修饰，对于同一个包的类，这个类的方法或变量是可以被访问的。对于不同包的类，只有继承于该类的类才可以访问到该类的方法或者变量。\n- public：被 public 修饰的方法或者变量，在任何地方都是可见的。\n\n## 代码初始化块\n\n三个规则：\n\n- 类实例化的时候执行代码初始化块；\n- 实际上，代码初始化块是放在构造方法中执行的，只不过比较靠前；\n- 代码初始化块里的执行顺序是从前到后的。\n\n## 补充：什么叫构造方法？有参？无参？\n\n```Java\npublic class StudentDemo {\n    public static void main(String[] args) {\n       \n        // 类名称 对象名 = new 类名称();\n        Student stu1 = new Student();           //无参构造方法执行\n        Student stu2 = new Student(\"张三\",23);   //全参构造方法执行\n        //赋值\n        stu1.setName(\"李四\");\n        stu1.setAge(23);\n       \n        //对象名.成员变量名；\n        System.out.println(\"姓名：\"+stu1.getName()+\"，年龄：\"+ stu1.getAge());\n        System.out.println(\"姓名：\"+stu2.getName()+\"，年龄：\"+ stu2.getAge());\n    }\n\n}\n\n```\n\n\n\n## 方法的继承\n\n关键字：extend，super（用于继承父类）\n\n“在默认情况下，子类的构造方法在执行的时候会主动去调用父类的构造方法。也就是说，其实是构造方法先执行的，再执行的代码初始化块。”\n\n**知识拓展：**\n\n什么是@Overwide?\n\n```java\n@Override是伪代码,表示重写(当然不写也可以)，不过写上有如下好处:\n1、可以当注释用,方便阅读；\n2、编译器可以给你验证@Override下面的方法名是否是你父类中所有的，如果没有则报错。例如，你如果没写@Override，而你下面的方法名又写错了，这时你的编译器是可以编译通过的，因为编译器以为这个方法是你的子类中自己增加的方法。\n \n举例：在重写父类的onCreate时，在方法前面加上@Override 系统可以帮你检查方法的正确性。\n@Override\npublic void onCreate(Bundle savedInstanceState)\n\n{…….}\n这种写法是正确的，如果你写成：\n\n@Override\npublic void oncreate(Bundle savedInstanceState)\n{…….}\n编译器会报如下错误：The method oncreate(Bundle) of type HelloWorld must override or implement a supertype method，以确保你正确重写onCreate方法（因为oncreate应该为onCreate）。而如果你不加@Override，则编译器将不会检测出错误，而是会认为你为子类定义了一个新方法：oncreate\n```\n\n\n\n## 抽象类\n\n### 敲黑板知识点：\n\n**写在前面：**\n\n什么是抽象？抽象的含义？\n\n​\t\t抽象是不确定的、不具体的概念或事物。在Java中的抽象类，是指需要在子类中通过方法扩展来实现新的方法。\n\n**关键字：**abstract\n\n**语句格式：**\n\n```Java\nabstract class AbstractPlayer {\n}\n```\n\n**命名规则：**\n\n关于抽象类的命名，《阿里的 Java 开发手册》上有强调，“抽象类命名要使用 Abstract 或 Base 开头”，这条规约还是值得遵守的。\n\n**Tips：**\n\n抽象类是不能实例化的，尝试通过 `new` 关键字实例化的话，编译器会报错，提示“类是抽象的，不能实例化”。\n\n虽然抽象类不能实例化，但可以有子类。子类通过 `extends` 关键字来继承抽象类。就像下面这样。\n\nDemo code:\n\n```Java\npublic class BasketballPlayer extends AbstractPlayer {\n}\n\n```\n\n抽象的方法不能定义在普通类中。否则会在类和方法处出现两个报错。\n\n错误提示。第一处在类级别上，提示“这个类必须通过 `abstract` 关键字定义”，见下图。\n\n![img](http://cdn.tobebetterjavaer.com/tobebetterjavaer/images/object-class/abstract-02.png)\n\n第二处在尝试定义 abstract 的方法上，提示“抽象方法所在的类不是抽象的”，见下图。\n\n![img](http://cdn.tobebetterjavaer.com/tobebetterjavaer/images/object-class/abstract-03.png)\n\n\n\n**But,抽象类中既可以定义抽象方法、也可以普通方法。**\n\n### 抽象方法的应用场景\n\n**第一种场景**。\n\n当我们希望一些通用的功能被多个子类复用的时候，就可以使用抽象类。比如说，`AbstractPlayer` 抽象类中有一个普通的方法 `sleep()`，表明所有运动员都需要休息，那么这个方法就可以被子类复用。\n\nDemo:\n\n```java\nabstract class AbstractPlayer {\n    public void sleep() {\n        System.out.println(\"运动员也要休息而不是挑战极限\");\n    }\n}\n```\n\n子类 `BasketballPlayer` 继承了 `AbstractPlayer` 类：\n\n```java\nclass BasketballPlayer extends AbstractPlayer {\n}\n```\n\n也就拥有了 `sleep()` 方法。`BasketballPlayer `的对象可以直接调用父类的 `sleep() `方法：\n\n```java\nBasketballPlayer basketballPlayer = new BasketballPlayer();\nbasketballPlayer.sleep();\n```\n\n如此，就实现了代码的复用。\n\n**第二种场景**。\n\n当我们需要在抽象类中定义好 `API`，然后在子类中扩展实现的时候就可以使用抽象类。比如说，`AbstractPlayer` 抽象类中定义了一个抽象方法 `play()`，表明所有运动员都可以从事某项运动，但需要对应子类去扩展实现，表明篮球运动员打篮球，足球运动员踢足球。\n\n**知识拓展：**\n\n什么是API？\n\nAPI（Application Programming Interface,应用程序编程接口）是一些预先定义的函数，目的是提供应用程序与开发人员基于某软件或硬件得以访问一组例程的能力，而又无需访问源码，或理解内部工作机制的细节。\"\n\n**抽象类实例：**\n\n读取大小写helloworld：\n\n[https://tobebetterjavaer.com/oo/abstract.html]()\n\n## 接口\n\n关键字：\n\ninterface\n\n语法格式：\n\npublic interface jiekou1\n\nclass A extends B implements jiekou1,jiekou2,jiekou3\n\n小结论：\n\n- 接口中允许定义变量\n- 接口中允许定义抽象方法\n- 接口中允许定义静态方法（Java 8 之后）\n- 接口中允许定义默认方法（Java 8 之后）\n\n除此之外，我们还应该知道：\n\n1）接口不允许直接实例化，否则编译器会报错。\n\n![img](http://cdn.tobebetterjavaer.com/tobebetterjavaer/images/object-class/interface-04.png)\n\n需要定义一个类去实现接口，见下例。\n\n\n\n```java\npublic class Computer implements Electronic {\n\n    public static void main(String[] args) {\n        new Computer();\n    }\n\n    @Override\n    public int getElectricityUse() {\n        return 0;\n    }\n}\n```\n\n然后再实例化。\n\n\n\n```Java\nElectronic e = new Computer();\n```\n\n知识点拓展：\n\nJAVA中extends 与implements有啥区别？\n\n1. 在类的声明中，通过关键字extends来创建一个类的子类。一个类通过关键字implements声明自己使用一个或者多个接口。\n   extends 是继承某个类, 继承之后可以使用父类的方法, 也可以重写父类的方法; implements 是实现多个接口, 接口的方法一般为空的, 必须重写才能使用\n2. extends是继承父类，只要那个类不是声明为final或者那个类定义为abstract的就能继承，JAVA中不支持多重继承，但是可以用接口 来实现，这样就要用到implements，继承只能继承一个类，但implements可以实现多个接口，用逗号分开就行了\n   比如\n   class A extends B implements C,D,E\n\n[(56条消息) Java之implements_小白study的博客-CSDN博客_implements](https://blog.csdn.net/android_lover2014/article/details/52176814)\n\n\n\n\n\n作业：多态与重载\n\n​\t\t\t构造与重载\n\n​\t\t\t抽象类与接口？\n\n\n\n\n\n## 内部类\n\n**== = = = = = = [内部类](https://so.csdn.net/so/search?q=内部类&spm=1001.2101.3001.7020)（四种内部类详解）= = = = = = = ==**\n\n**一、基本介绍：一个类的内部又完整的嵌套了另一个类结构。被嵌套的类称为内部类(inner class),嵌套其他类的类称为外部类(outer class)。是我们类的第五大成员【思考:类的五大成员是哪些?[属性、方法、构造器、代码块、内部类]】，内部类最大的特点就是可以直接访问私有属性，并且可以体现类与类之间的包含关系，注意:内部类是学习的难点,同时也是重点,后面看底层源码时,有大量的内部类.**\n**如果定义类在局部位置(方法中/代码块) :(1) 局部内部类 (2) 匿名内部类\n定义在成员位置 (1) 成员内部类 (2)静态内部类**\n\n在 Java 中，可以将一个类定义在另外一个类里面或者一个方法里面，这样的类叫做内部类。\n\n**二、基本语法**\n**class Outer{ //外部类\nclass Inner{ //内部类\n}\n}\nclass Other{ //外部其他类\n}**\n\n三、分类\n\n一般来说，内部类分为成员内部类、局部内部类、匿名内部类和静态内部类。\n\n定义在外部类的局部位置上(如方法内):\n1)局部内部类(有类名)\n2)匿名内部类(没有类名，重点!!!)\n\n定义在外部类的成员位置上:\n1)成员内部类(没用static修饰)\n2)静态内部类（使用static修饰)\n\n\n\n**1.成员内部类：**\n\n成员内部类可以无限制访问外部类的所有成员属性。\n\n内部类可以随心所欲地访问外部类的成员，但外部类想要访问内部类的成员，就不那么容易了，必须先创建一个成员内部类的对象，再通过这个对象来访问：\n\n```Java\npublic class Wanger {\n    int age = 18;\n    private String name = \"沉默王二\";\n    static double money = 1;\n\n    public Wanger () {\n        new Wangxiaoer().print();\n    }\n\n    class Wangxiaoer {\n        int age = 81;\n\n        public void print() {\n            System.out.println(name);\n            System.out.println(money);\n        }\n    }\n}\n\n```\n\n这种创建内部类的方式在实际开发中并不常用，因为内部类和外部类紧紧地绑定在一起，使用起来非常不便。\n\n**2.局部内部类**\n\n**3.匿名内部类**\n\n**4.静态内部类**\n\n第一，静态内部类不能访问外部类的所有成员变量；\n\n第二，静态内部类可以访问外部类的所有静态变量，包括私有静态变量。\n\n第三，外部类不能声明为 static。”\n\n“三妹，你看，在 Singleton 类上加 static 后，编译器就提示错误了。”\n\n![img](http://cdn.tobebetterjavaer.com/tobebetterjavaer/images/keywords/19-08.png)\n\n### 总结\n\n为什么要使用内部类？\n\n在《Think in java》中有这样一句话：\n\n> 使用内部类最吸引人的原因是：每个内部类都能独立地继承一个（接口的）实现，所以无论外围类是否已经继承了某个（接口的）实现，对于内部类都没有影响。\n\n在我们程序设计中有时候会存在一些使用接口很难解决的问题，这个时候我们可以利用内部类提供的、可以继承多个具体的或者抽象的类的能力来解决这些程序设计问题。可以这样说，接口只是解决了部分问题，而内部类使得多重继承的解决方案变得更加完整。\n\n使用内部类还能够为我们带来如下特性（摘自《Think in java》）：\n\n- 1、内部类可以使用多个实例，每个实例都有自己的状态信息，并且与其他外围对象的信息相互独立。\n- 2、在单个外部类中，可以让多个内部类以不同的方式实现同一个接口，或者继承同一个类。\n- 3、创建内部类对象的时刻并不依赖于外部类对象的创建。\n- 4、内部类并没有令人迷惑的“is-a”关系，他就是一个独立的实体。\n- 5、内部类提供了更好的封装，除了该外围类，其他类都不能访问。\n\n## 关键字\n\n### 1.static\n\n**static的作用**\n\n“static 关键字的作用可以用一句话来描述：‘**方便在没有创建对象的情况下进行调用**，包括变量和方法’。也就是说，只要类被加载了，就可以通过类名进行访问。”我扶了扶沉重眼镜，继续说到，“static 可以用来修饰类的成员变量，以及成员方法。我们一个个来看。”\n\ndemo：\n\n```Java\npublic class Counter {\n    int count = 0;\n\n    Counter() {\n        count++;\n        System.out.println(count);\n    }\n\n    public static void main(String args[]) {\n        Counter c1 = new Counter();\n        Counter c2 = new Counter();\n        Counter c3 = new Counter();\n    }\n}\n/*\n我们创建一个成员变量 count，并且在构造函数中让它自增。因为成员变量会在创建对象的时候获取内存，因此每一个对象都会有一个 count 的副本， count 的值并不会随着对象的增多而递增。\n*/\n```\n\n```Java \npublic class StaticCounter {\n    static int count = 0;\n\n    StaticCounter() {\n        count++;\n        System.out.println(count);\n    }\n\n    public static void main(String args[]) {\n        StaticCounter c1 = new StaticCounter();\n        StaticCounter c2 = new StaticCounter();\n        StaticCounter c3 = new StaticCounter();\n    }\n}\n/*\n简单解释一下哈，由于静态变量只会获取一次内存空间，所以任何对象对它的修改都会得到保留，所以每创建一个对象，count 的值就会加 1，所以最终的结果是 3，明白了吧？三妹。这就是静态变量和成员变量之间的差别。\n*/\n```\n\nwarnning:\n\n“另外，需要注意的是，由于静态变量属于一个类，所以不要通过对象引用来访问，而应该直接通过类名来访问，否则编译器会发出警告。”\n\n![img](http://cdn.tobebetterjavaer.com/tobebetterjavaer/images/keywords/19-03.png)\n\n\n\nstatic的特点：\n\n- 静态方法属于这个类而不是这个类的对象；\n\n​\t\t（因为静态方法不用类的实例化，所以直接通过类来调用，不通过类的实例来调用，因此不应通过对象调用）\n\n- 调用静态方法的时候不需要创建这个类的对象；\n- 静态方法可以访问静态变量。\n\n\n\n那么问题来了，为什么main方法是静态的，这就涉及到Java的编译器JVM了，为了代码简洁与方便调用，main函数作为程序的入口，所以设为静态更为合适。\n\n二哥这么说：\n\n`“如果 main 方法不是静态的，就意味着 Java 虚拟机在执行的时候需要先创建一个对象才能调用 main 方法，而 main 方法作为程序的入口，创建一个额外的对象显得非常多余。”我不假思索的回答令三妹感到非常的钦佩。`\n\n“java.lang.Math 类的几乎所有方法都是静态的，可以直接通过类名来调用，不需要创建类的对象。”\n\n![img](http://cdn.tobebetterjavaer.com/tobebetterjavaer/images/keywords/19-06.png)\n\n综上所述（由上可得）：\n\n一些函数基本上都是静态的。\n\n### 静态代码块 \n\n“除了静态变量和静态方法，static 关键字还有一个重要的作用。”我心情愉悦地对三妹说，“用一个 static 关键字，外加一个大括号括起来的代码被称为静态代码块。”\n\n“就像下面这串代码。”\n\n\n\n```java\npublic class StaticBlock {\n    static {\n        System.out.println(\"静态代码块\");\n    }\n\n    public static void main(String[] args) {\n        System.out.println(\"main 方法\");\n    }\n}\n```\n\n“静态代码块通常用来初始化一些静态变量，它会优先于 `main()` 方法执行。”\n\n\n\n### 2.this\n\nthis除了可以指向当前方法或者构造函数的对象，还可以完成以下工作：\n\n- 调用当前类的方法；\n- `this()` 可以调用当前类的构造方法；\n- this 可以作为参数在方法中传递；\n- this 可以作为参数在构造方法中传递；\n- this 可以作为方法的返回值，返回当前类的对象。\n\n### 01、 指向当前对象\n\n**demo**：\n\n```Java\nWithoutThisStudent(String name, int age) {\n        name = name;\n        age = age;\n    }\n\n```\n\n伪代码运行结果：\n\n```Java\nnull\t0\n\nnull\t0\n```\n\n更改之后的demo:\n\n```java\nWithThisStudent(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n```\n\n运行正确√\n\n### 02、调用当前类的方法\n\n“我们可以在一个类中使用 this 关键字来调用另外一个方法，如果没有使用的话，编译器会自动帮我们加上。”我对自己深厚的编程功底充满自信，“在源代码中，`method2()` 在调用 `method1()` 的时候并没有使用 this 关键字，但通过反编译后的字节码可以看得到。”\n\n### 03、调用当前类的构造方法\n\n调用无参的constructor\n\n```java\npublic class InvokeConstrutor {\n    InvokeConstrutor() {\n        System.out.println(\"hello\");\n    }\n\n    InvokeConstrutor(int count) {\n        this();\n        System.out.println(count);\n    }\n\n    public static void main(String[] args) {\n        InvokeConstrutor invokeConstrutor = new InvokeConstrutor(10);\n    }\n}\n```\n\n\n\n“也可以在无参构造方法中使用 `this()` 并传递参数来调用有参构造方法。”话音没落，我就在键盘上敲了起来，“来看下面这段代码。”\n\n\n\n```java\npublic class InvokeParamConstrutor {\n    InvokeParamConstrutor() {\n        this(10);\n        System.out.println(\"hello\");\n    }\n\n    InvokeParamConstrutor(int count) {\n        System.out.println(count);\n    }\n\n    public static void main(String[] args) {\n        InvokeParamConstrutor invokeConstrutor = new InvokeParamConstrutor();\n    }\n}\n```\n\n\n\nwarning：\n\n“不过，需要注意的是，`this()` 必须放在构造方法的第一行，否则就报错了。”\n\n![img](http://cdn.tobebetterjavaer.com/tobebetterjavaer/images/keywords/20-01.png)\n\n### *04、作为参数在方法中传递（没看懂\n\n###  05、作为参数在构造方法中传递\n\n### 06、作为方法的返回值\n\n```java\npublic class ThisAsMethodResult {\n    ThisAsMethodResult getThisAsMethodResult() {\n        return this;\n    }\n    \n    void out() {\n        System.out.println(\"hello\");\n    }\n\n    public static void main(String[] args) {\n        new ThisAsMethodResult().getThisAsMethodResult().out();\n    }\n}\n```\n\n“`getThisAsMethodResult()` 方法返回了 this 关键字，指向的就是 `new ThisAsMethodResult()` 这个对象，所以可以紧接着调用 `out()` 方法——达到了链式调用的目的，这也是 this 关键字非常经典的一种用法。”\n\n### 3.super\n\n“super 关键字的用法主要有三种。”\n\n- 指向父类对象；\n- 调用父类的方法；\n- `super()` 可以调用父类的构造方法。\n\n### 4.final\n\n什么是序列化？\n\n序列化是什么意思呢？Java 的序列化是指，将对象转换成以字节序列的形式来表示，这些字节序中包含了对象的字段和方法。序列化后的对象可以被写到数据库、写到文件，也可用于网络传输。\n\n“被 final 修饰的变量无法重新赋值。换句话说，final 变量一旦初始化，就无法更改。”\n\n**final类：**\n\n“如果一个类使用了 final 关键字修饰，那么它就无法被继承.....”\n\n“等等，哥，我知道，String 类就是一个 final 类。”还没等我说完，三妹就抢着说到。\n\n“说得没毛病。”\n\n```java\npublic final class String\n    implements java.io.Serializable, Comparable<String>, CharSequence,\n               Constable, ConstantDesc {}\n```\n\n⚠️⚠️⚠️：String 是 immutable 类（不可变对象）\n\n“那三妹你知道为什么 String 类要设计成 final 吗？”\n\n“这个还真不知道。”三妹的表情透露出这种无奈。\n\n“原因大致有 3 个。”\n\n- 为了实现字符串常量池的需要\n- 为了线程安全的需要\n- 为了 HashCode 的不可变性的需要\n\n“想了解更详细的原因，可以一会看看我之前写的这篇文章。”\n\n[为什么 Java 字符串是不可变的？](https://mp.weixin.qq.com/s/CRQrm5zGpqWxYL_ztk-b2Q)\n\n### 5.instanceof\n\n语法格式：\n\n`(object) instanceof (type)`\n\n​    对象\t\t\t\t\t\t\t\t类型\n\n用意也非常简单，判断对象是否符合指定的类型，结果要么是 true，要么是 false。在反序列化的时候，instanceof 操作符还是蛮常用的，因为这时候我们不太确定对象属不属于指定的类型，如果不进行判断的话，就容易抛出 ClassCastException 异常。\n\nJava 是一门面向对象的编程语言，也就意味着除了基本数据类型，所有的类都会隐式继承 Object 类。所以下面的结果肯定也会输出 true。\n\n```java\nThread thread = new Thread();\nSystem.out.println(thread instanceof Object);\n```\n\n如何使用？\n\n```java\n// 先判断类型\nif (obj instanceof String) {\n    // 然后强制转换\n    String s = (String) obj;\n    // 然后才能使用\n}\n```\n\n先用 instanceof 进行类型判断，然后再把 obj 强制转换成我们期望的类型再进行使用。\n\nJDK 16 的时候，instanceof 模式匹配转了正，意味着使用 instanceof 的时候更便捷了。\n\n```java\nif (obj instanceof String s) {\n    // 如果类型匹配 直接使用 s\n}\n```\n\n## *不可变对象\n\n### 01、什么是不可变类？\n\n一个类的对象在通过构造方法创建后如果状态不会再被改变，那么它就是一个不可变（immutable）类。它的所有成员变量的赋值仅在构造方法中完成，不会提供任何 setter 方法供外部类去修改。\n\n自从有了**多线程**，生产力就被无限地放大了，所有的程序员都爱它，因为强大的硬件能力被充分地利用了。但与此同时，所有的程序员都对它心生忌惮，因为一不小心，多线程就会把**对象的状态变得混乱不堪**。\n\n引入关键字：synchronized(同步)\n\n为了保护状态的原子性、可见性、有序性，我们程序员可以说是竭尽所能。其中，synchronized（同步）关键字是最简单最入门的一种解决方案。\n\n假如说类是不可变的，那么对象的状态就也是不可变的。这样的话，每次修改对象的状态，就会产生一个新的对象供不同的线程使用，我们程序员就不必再担心并发问题了。\n\n### 02、常见的不可变类\n\nString类\n\n为什么要将String类设置为不可变类？\n\n原因如下：\n\n1）常量池的需要\n\n字符串常量池是 Java 堆内存中一个特殊的存储区域，当创建一个 String 对象时，假如此字符串在常量池中不存在，那么就创建一个；假如已经存，就不会再创建了，而是直接引用已经存在的对象。这样做能够减少 JVM 的内存开销，提高效率。\n\n2）hashCode 的需要\n\n因为字符串是不可变的，所以在它创建的时候，其 hashCode 就被缓存了，因此非常适合作为哈希值（比如说作为 HashMap 的键），多次调用只返回同一个值，来提高效率。\n\n3）线程安全\n\n就像之前说的那样，如果对象的状态是可变的，那么在多线程环境下，就很容易造成不可预期的结果。而 String 是不可变的，就可以在多个线程之间共享，不需要同步处理。\n\n因此，当我们调用 String 类的任何方法（比如说 `trim()`、`substring()`、`toLowerCase()`）时，总会返回一个新的对象，而不影响之前的值。\n\n\n\n```java\nString cmower = \"沉默王二，一枚有趣的\n```\n\n\n\n\n\n## *可变参数\n\n\n\n\n\n\n\n\n\n## 泛型\n\n### 什么是泛型\n\n> 泛型：就是指在类定义时不会设置类中的属性或方法参数的具体类型，而是在类使用时（创建对象）再进行类型的定义。会在编译期检查类型是否错误。\n\n![](https://img-blog.csdnimg.cn/101412155b854d98891f6c0facdfde7f.png)\n\n类声明后的<>中这个T被称为类型参数，用于指代任意类型，实际上这个T只是个代表，写什么都可以。表示此时的value1，value2都是在类定义时没有明确类型，只有在使用时才告知编译器类型。出于规范，类型参数用单个的大写字母来代替，常见如下：\n\n- T：代表任意类\n- E：表示Element的意思，或是异常\n- K：与V搭配使用\n- V：与K搭配使用\n\n\n\n以下内容来源于[Java全栈体系](https://www.pdai.tech/md/java/basic/java-basic-x-generic.html):\n\n**通过泛型可以将不同数据类型的add()方法复用为一个方法：**\n\n`eg:`泛型add()方法：\n\n```Java\nprivate static <T extends Number> double add(T a, T b) {\n    System.out.println(a + \"+\" + b + \"=\" + (a.doubleValue() + b.doubleValue()));\n    return a.doubleValue() + b.doubleValue();\n}\n```\n\n\n\n- 泛型中的类型在使用时指定，不需要强制类型转换（**类型安全**，编译器会**检查类型**）\n\n看下这个例子：\n\n```java\nList list = new ArrayList();\nlist.add(\"xxString\");\nlist.add(100d);\nlist.add(new Person());        \n```\n\n我们在使用上述list中，list中的元素都是Object类型（无法约束其中的类型），所以在取出集合元素时需要人为的强制类型转化到具体的目标类型，且很容易出现`java.lang.ClassCastException`异常。\n\n引入泛型，它将提供类型的约束，提供编译前的检查：\n\n```Java\nList<String> list = new ArrayList<String>();\n\n// list中只能放String, 不能放其它类型的元素\n```\n\n更多内容请见：\n\nhttps://www.pdai.tech/md/java/basic/java-basic-x-generic.html\n\n## 注解\n\n直接开始上实例：\n\n```Java\nclass A{\n    public void test() {\n        \n    }\n}\n\nclass B extends A{\n\n    /**\n        * 重载父类的test方法\n        */\n    @Override\n    public void test() {\n    }\n\n    /**\n        * 被弃用的方法\n        */\n    @Deprecated\n    public void oldMethod() {\n    }\n\n    /**\n        * 忽略告警\n        * \n        * @return\n        */\n    @SuppressWarnings(\"rawtypes\")\n    public List processList() {\n        List list = new ArrayList();\n        return list;\n    }\n}\n\n```\n\nJava 1.5开始自带的标准注解，包括`@Override`、`@Deprecated`和`@SuppressWarnings`：\n\n- `@Override`：表示当前的方法定义将覆盖父类中的方法\n- `@Deprecated`：表示代码被弃用，如果使用了被@Deprecated注解的代码则编译器将发出警告\n- `@SuppressWarnings`：表示关闭编译器警告信息\n\n## 枚举（enum）\n\n**定义：**\n\n“枚举（enum），是 Java 1.5 时引入的关键字，它表示一种特殊类型的类，继承自 java.lang.Enum。”\n\n“我们来新建一个枚举 PlayerType。”\n\neg:\n\n```java\npublic enum PlayerType {\n    TENNIS,\n    FOOTBALL,\n    BASKETBALL\n}\n```\n\n01 “既然枚举是一种特殊的类，那它其实是可以定义在一个类的内部的，这样它的作用域就可以限定于这个外部类中使用。”我说。\n\neg:\n\n```java \npublic class Player {\n    private PlayerType type;\n    public enum PlayerType {\n        TENNIS,\n        FOOTBALL,\n        BASKETBALL\n    }\n    \n    public boolean isBasketballPlayer() {\n      return getType() == PlayerType.BASKETBALL;\n    }\n\n    public PlayerType getType() {\n        return type;\n    }\n\n    public void setType(PlayerType type) {\n        this.type = type;\n    }\n}\n\n```\n\n02 由于枚举是 final 的，所以可以确保在 Java 虚拟机中仅有一个常量对象，基于这个原因，我们可以使用“==”运算符来比较两个枚举是否相等，参照 `isBasketballPlayer()` 方法。\n\n03 “枚举还可用于 switch 语句，和基本数据类型的用法一致。”我说。\n\n04 “如果枚举中需要包含更多信息的话，可以为其添加一些字段，比如下面示例中的 name，此时需要为枚举添加一个带参的构造方法，这样就可以在定义枚举时添加对应的名称了。”我继续说。\n\neg:\n\n```java \npublic enum PlayerType {\n    TENNIS(\"网球\"),\n    FOOTBALL(\"足球\"),\n    BASKETBALL(\"篮球\");\n\n    private String name;\n    \n    PlayerType(String name) {\n        this.name = name;\n    }\n\n}\n```\n\n05 “EnumSet 是一个专门针对枚举类型的 Set 接口（后面会讲）的实现类，它是处理枚举类型数据的一把利器，非常高效。”我说，“从名字上就可以看得出，EnumSet 不仅和 Set 有关系，和枚举也有关系。”\n\n06 “因为 EnumSet 是一个抽象类，所以创建 EnumSet 时不能使用 new 关键字。不过，EnumSet 提供了很多有用的静态工厂方法。”\n\n![img](http://cdn.tobebetterjavaer.com/tobebetterjavaer/images/enum/enum-02.png)\n\n07 “除了 EnumSet，还有 EnumMap，是一个专门针对枚举类型的 Map 接口的实现类，它可以将枚举常量作为键来使用。EnumMap 的效率比 HashMap 还要高，可以直接通过数组下标（枚举的 ordinal 值）访问到元素。”\n\n08 “和 EnumSet 不同，EnumMap 不是一个抽象类，所以创建 EnumMap 时可以使用 new 关键字。”\n\n\n\n```java\nEnumMap<PlayerType, String> enumMap = new EnumMap<>(PlayerType.class);\n```\n\n09 有了 EnumMap 对象后就可以使用 Map 的一些方法了，见下图。\n\n![img](http://cdn.tobebetterjavaer.com/tobebetterjavaer/images/enum/enum-04.png)\n\n和 HashMap（后面会讲）的使用方法大致相同，来看下面的例子。\n\n\n\n```java\nEnumMap<PlayerType, String> enumMap = new EnumMap<>(PlayerType.class);\nenumMap.put(PlayerType.BASKETBALL,\"篮球运动员\");\nenumMap.put(PlayerType.FOOTBALL,\"足球运动员\");\nenumMap.put(PlayerType.TENNIS,\"网球运动员\");\nSystem.out.println(enumMap);\n\nSystem.out.println(enumMap.get(PlayerType.BASKETBALL));\nSystem.out.println(enumMap.containsKey(PlayerType.BASKETBALL));\nSystem.out.println(enumMap.remove(PlayerType.BASKETBALL));\n```\n\n“来看一下输出结果。”\n\n\n\n```text\n{TENNIS=网球运动员, FOOTBALL=足球运动员, BASKETBALL=篮球运动员}\n篮球运动员\ntrue\n篮球运动员\n```\n\n“除了以上这些，《Effective Java》这本书里还提到了一点，如果要实现单例的话，最好使用枚举的方式。”我说。\n\n\n\n### 单例：。。。\n\n\n\n## 反射\n\n何为正射？何为反射？\n\n“一般情况下，我们在使用某个类之前已经确定它到底是个什么类了，拿到手就直接可以使用 `new` 关键字来调用构造方法进行初始化，之后使用这个类的对象来进行操作。”\n\n```Java\nWriter writer = new Writer();\nwriter.setName(\"沉默王二\");\n\n```\n\n像上面这个例子，就可以理解为“正射”。而反射就意味着一开始我们不知道要初始化的类到底是什么，也就没法直接使用 `new` 关键字创建对象了。\n\n我们只知道这个类的一些基本信息，就好像我们看电影的时候，为了抓住一个犯罪嫌疑人，警察就会问一些目击证人，根据这些证人提供的信息，找专家把犯罪嫌疑人的样貌给画出来——这个过程，就可以称之为**反射**。\n\n\n\n反射的缺点：\n\n- **破坏封装**：由于反射允许访问私有字段和私有方法，所以可能会破坏封装而导致安全问题。\n- **性能开销**：由于反射涉及到动态解析，因此无法执行 Java 虚拟机优化，再加上反射的写法的确要复杂得多，所以性能要比“正射”差很多，在一些性能敏感的程序中应该避免使用反射。\n\n好处：\n\n- **开发通用框架**：像 Spring，为了保持通用性，通过配置文件来加载不同的对象，调用不同的方法。\n- **动态代理**：在面向切面编程中，需要拦截特定的方法，就会选择动态代理的方式，而动态代理的底层技术就是反射。\n- **注解**：注解本身只是起到一个标记符的作用，它需要利用发射机制，根据标记符去执行特定的行为。\n\n\n\n详情参考：\n\n[浅析](https://www.cnblogs.com/chanshuyi/p/head_first_of_reflection.html)\n\n[深入理解](https://dunwu.github.io/javacore/basics/java-reflection.html#_1-%E5%8F%8D%E5%B0%84%E7%AE%80%E4%BB%8B)\n\n\n\n## 集合框架（容器）\n\n集合框架的结构图：\n\n<img src=\"http://cdn.tobebetterjavaer.com/tobebetterjavaer/images/collection/gailan-01.png\" alt=\"img\" style=\"zoom:200%;\" />\n\n单词：\n\nCollection——集合；\n\nMap——图、表（两个类间的映射关系）；\n\nList——列举、列表；\n\nArray——数组；\n\nArraylist——数组列表；\n\nLinkedlist——链表；\n\nStack——栈；\t\t\t  \t`执行效率较低`\n\nVector——矩阵、模型\t`线程安全`\n\nJava 集合框架可以分为两条大的支线：\n\n- Collection，主要由 List、Set、Queue 组成，List 代表有序、可重复的集合，典型代表就是封装了动态数组的 ArrayList 和封装了链表的 LinkedList；Set 代表无序、不可重复的集合，典型代表就是 HashSet 和 TreeSet；Queue 代表队列，典型代表就是双端队列 ArrayDeque，以及优先级队列 PriorityQue。\n- Map，代表键值对的集合，典型代表就是 HashMap。\n\n### 01、List\n\n> List 的特点是存取有序，可以存放重复的元素，可以用下标对元素进行操作\n\n### 02、Set\n\n说在前面：\n\nSet 集合不是关注的重点，因为底层都是由 Map 实现的，为什么要用 Map 实现呢？\n\n因为 Map 的键不允许重复、无序吗\n\n> Set 的特点是存取无序，不可以存放重复的元素，不可以用下标对元素进行操作，和 List 有很多不同\n\nSet是Java中的**集合类，提供了一种无顺序，不重复的集合**。常用的子类包括HashSet, TreeSet等。\n\n### 03、Queue\n\n> Queue，也就是队列，通常遵循先进先出（FIFO）的原则，新元素插入到队列的尾部，访问元素返回队列的头部。\n\n### 04、Map\n\n> Map 保存的是键值对，键要求保持唯一性，值可以重复。\n\n### 浅析ArrayList（动态数组）\n\narraylist是接口list的实现类，有很多方便调用的预定义方法，便于用户直接调用。\n\n\n\n```Java\nList接口常用方法：\n1、add(Object element)： 向列表的尾部添加指定的元素。\n    /*\n    \tList<String> alist = new ArrayList<>();\n    \talist.add(\"沉默王二\");\n\t*/\n2、size()： 返回列表中的元素个数。\n\n3、get(int index)： 返回列表中指定位置的元素，index从0开始。\n\n4、add(int index, Object element)： 在列表的指定位置插入指定元素。\n\n5、set(int i, Object element)： 将索引i位置元素替换为元素element并返回被替换的元素。\n\n6、clear()： 从列表中移除所有元素。\n\n7、isEmpty()： 判断列表是否包含元素，不包含元素则返回 true，否则返回false。\n\n8、contains(Object o)： 如果列表包含指定的元素，则返回 true。\n\n9、remove(int index)： 移除列表中指定位置的元素，并返回被删元素。\n\n10、remove(Object o)： 移除集合中第一次出现的指定元素，移除成功返回true，否则返回false。\n\n11、iterator()： 返回按适当顺序在列表的元素上进行迭代的迭代器。    \n```\n\n12、indexof()：正序查找一个元素。倒叙查找为lastIndexOf()\n    \n\nArrayList 可以称得上是集合框架方面最常用的类了，可以和 HashMap 一较高下。\n\nArrayList 在数组的基础上实现了自动扩容，并且提供了比数组更丰富的预定义方法（各种增删改查），非常灵活。\n\n创建一个ArrayList的语法格式：\n\n```Java\nArrayList<String> alist = new ArrayList<String>();//标准\n/*可以通过上面的语句来创建一个字符串类型的 ArrayList（通过尖括号来限定 ArrayList 中元素的类型，如果尝试添加其他类型的元素，将会产生编译错误），更简化的写法如下：*/\nList<String> alist = new ArrayList<>();\n```\n\n由于 ArrayList 实现了 List 接口，所以 alist 变量的类型可以是 List 类型；new 关键字声明后的尖括号中可以不再指定元素的类型，因为编译器可以通过前面尖括号中的类型进行智能推断。\n\n如果非常确定 ArrayList 中元素的个数，在创建的时候还可以指定初始大小。\n\n\n\n### 浅析linkedList（链表）\n\n链表这门内功大致分为三个层次：\n\n- 第一层叫做“单向链表”，我只有一个后指针，指向下一个数据；\n- 第二层叫做“双向链表”，我有两个指针，后指针指向下一个数据，前指针指向上一个数据。\n- 第三层叫做“二叉树”，把后指针去掉，换成左右指针。\n\n```Java\n创建一个LinkedList的语法格式：\nLinkedList<String> list = new LinkedList();\n```\n\n\n\n**1）招式一：增**\n\n可以调用 add 方法添加元素：\n\n\n\n```java\nlist.add(\"沉默王二\");\nlist.add(\"沉默王三\");\nlist.add(\"沉默王四\");\n```\n\nadd 方法内部其实调用的是 linkLast 方法：\n\n\n\n```java\npublic boolean add(E e) {\n    linkLast(e);\n    return true;\n}\n```\n\nlinkLast，顾名思义，就是在链表的尾部链接：\n\n- 添加第一个元素的时候，first 和 last 都为 null。\n- 然后新建一个节点 newNode，它的 prev 和 next 也为 null。\n- 然后把 last 和 first 都赋值为 newNode。\n\n此时还不能称之为链表，因为前后节点都是断裂的。\n\n![img](http://cdn.tobebetterjavaer.com/tobebetterjavaer/images/collection/linkedlist-02.png)\n\n- 添加第二个元素的时候，first 和 last 都指向的是第一个节点。\n- 然后新建一个节点 newNode，它的 prev 指向的是第一个节点，next 为 null。\n- 然后把第一个节点的 next 赋值为 newNode。\n\n此时的链表还不完整。\n\n![img](http://cdn.tobebetterjavaer.com/tobebetterjavaer/images/collection/linkedlist-03.png)\n\n- 添加第三个元素的时候，first 指向的是第一个节点，last 指向的是最后一个节点。\n- 然后新建一个节点 newNode，它的 prev 指向的是第二个节点，next 为 null。\n- 然后把第二个节点的 next 赋值为 newNode。\n\n此时的链表已经完整了。\n\n![img](http://cdn.tobebetterjavaer.com/tobebetterjavaer/images/collection/linkedlist-04.png)\n\n我这个增的招式，还可以演化成另外两个：\n\n- `addFirst()` 方法将元素添加到第一位；\n- `addLast()` 方法将元素添加到末尾。\n\naddFirst 内部其实调用的是 linkFirst：\n\n\n\n```java\npublic void addFirst(E e) {\n    linkFirst(e);\n}\n```\n\nlinkFirst 负责把新的节点设为 first，并将新的 first 的 next 更**2）招式二：删**\n\n我这个删的招式还挺多的：\n\n- `remove()`：删除第一个节点\n- `remove(int)`：删除指定位置的节点\n- `remove(Object)`：删除指定元素的节点\n- `removeFirst()`：删除第一个节点\n- `removeLast()`：删除最后一个节点\n\nremove 内部调用的是 removeFirst，所以这两个招式的功效一样。\n\n`remove(int)` 内部其实调用的是 unlink 方法。\n\n\n\n```java\npublic E remove(int index) {\n    checkElementIndex(index);\n    return unlink(node(index));\n}\n```\n\n新为之前的 first。\n\nunlink 方法其实很好理解，就是更新当前节点的 next 和 prev，然后把当前节点上的元素设为 null。\n\n**3）招式三：改**\n\n可以调用 `set()` 方法来更新元素：\n\n\n\n```java\nlist.set(0, \"沉默王五\");\n```\n\n来看一下 `set()` 方法：\n\n\n\n```java\npublic E set(int index, E element) {\n    checkElementIndex(index);\n    Node<E> x = node(index);\n    E oldVal = x.item;\n    x.item = element;\n    return oldVal;\n}\n```\n\n首先对指定的下标进行检查，看是否越界；然后根据下标查找原有的节点：\n\n`size >> 1`：也就是右移一位，相当于除以 2。对于计算机来说，移位比除法运算效率更高，因为数据在计算机内部都是二进制存储的。\n\n换句话说，node 方法会对下标进行一个初步判断，如果靠近前半截，就从下标 0 开始遍历；如果靠近后半截，就从末尾开始遍历。\n\n找到指定下标的节点就简单了，直接把原有节点的元素替换成新的节点就 OK 了，prev 和 next 都不用改动。\n\n**4）招式四：查**\n\n我这个查的招式可以分为两种：\n\n- indexOf(Object)：查找某个元素所在的位置\n- get(int)：查找某个位置上的元素\n\nindexOf 的内部分为两种，一种是元素为 null 的时候，必须使用 == 来判断；一种是元素为非 null 的时候，要使用 equals 来判断。因为 equals 是不能用来判 null 的，会抛出 NPE 错误。\n\nget 方法的内核其实还是 node 方法，这个之前已经说明过了，这里略过。\n\n\n\n```java\npublic E get(int index) {\n    checkElementIndex(index);\n    return node(index).item;\n}\n```\n\n其实，查这个招式还可以演化为其他的一些，比如说：\n\n- `getFirst()` 方法用于获取第一个元素；\n- `getLast()` 方法用于获取最后一个元素；\n- `poll()` 和 `pollFirst()` 方法用于删除并返回第一个元素（两个方法尽管名字不同，但方法体是完全相同的）；\n- `pollLast()` 方法用于删除并返回最后一个元素；\n- `peekFirst()` 方法用于返回但不删除第一个元素。\n\n虽然ArrayList经常喊LinkedList一声师弟，但二者之间其实挺和谐的。但我知道，在外人眼里，同门师兄弟，总要一较高下的。\n\n比如说，我们俩在增删改查时候的时间复杂度。\n\n### ArrayList和LinkedList的区别\n\n增删改查时候的时间复杂度。\n\n由此，可以得出这样的结论：**遍历 LinkedList 的时候，千万不要使用 for 循环，要使用迭代器。**\n\n### Java中的Iterator和Iterable区别\n\nIterator：迭代器\n\nIterable：可迭代的\n\n什么是迭代器？\n\n```txt\n迭代器 （iterator）有时又称 光标 （cursor）是**程序设计的 软件设计模式** ，可在容器对象（container，例如 链表 或 数组 ）上遍访的接口，设计人员无需关心容器对象的内存分配的实现细节。\n\n**中文名:** 迭代器\n\n**外文名:** iterator\n```\n\n在 Java 中，我们对 List 进行遍历的时候，主要有这么三种方式。\n\n第一种：for 循环。\n\n```java\nfor (int i = 0; i < list.size(); i++) {\n    System.out.print(list.get(i) + \"，\");\n}\n```\n\n第二种：迭代器。\n\n```java\nIterator it = list.iterator();\nwhile (it.hasNext()) {\n    System.out.print(it.next() + \"，\");\n}\n```\n\n第三种：for-each。\n\n```java\nfor (String str : list) {\n    System.out.print(str + \"，\");\n}\n```\n\n### fail-fast\n\n官翻：\n\n```txet\nIn systems design, a fail-fast system is one which immediately reports at its interface any condition that is likely to indicate a failure. Fail-fast systems are usually designed to stop normal operation rather than attempt to continue a possibly flawed process. Such designs often check the system's state at several points in an operation, so any failures can be detected early. The responsibility of a fail-fast module is detecting errors, then letting the next-highest level of the system handle them.\n```\n\nfail-fast 是一种通用的系统设计思想，一旦检测到可能会发生错误，就立马抛出异常，程序将不再往下执行。——一种保护机制。\n\ndemo：\n\n```java\nList<String> list = new ArrayList<>();\nlist.add(\"沉默王二\");\nlist.add(\"沉默王三\");\nlist.add(\"一个文章真特么有趣的程序员\");\n\nfor (String str : list) {\n\tif (\"沉默王二\".equals(str)) {\n\t\tlist.remove(str);\n\t}\n}\n\nSystem.out.println(list);\n```\n\n这段代码看起来没有任何问题，但运行起来就报错了。\n\n![img](http://cdn.tobebetterjavaer.com/tobebetterjavaer/images/collection/fail-fast-01.png)\n\n**![img](http://cdn.tobebetterjavaer.com/tobebetterjavaer/images/collection/fail-fast-02.png)那该如何正确地删除元素呢**？\n\n**1）remove 后 break**\n\n\n\n```java\nList<String> list = new ArrayList<>();\nlist.add(\"沉默王二\");\nlist.add(\"沉默王三\");\nlist.add(\"一个文章真特么有趣的程序员\");\n\nfor (String str : list) {\n\tif (\"沉默王二\".equals(str)) {\n\t\tlist.remove(str);\n\t\tbreak;\n\t}\n}\n```\n\nbreak 后循环就不再遍历了，意味着 Iterator 的 next 方法不再执行了，也就意味着 `checkForComodification` 方法不再执行了，所以异常也就不会抛出了。\n\n但是呢，当 List 中有重复元素要删除的时候，break 就不合适了。\n\n**3）使用 Iterator**\n\n\n\n```java\nList<String> list = new ArrayList<>();\nlist.add(\"沉默王二\");\nlist.add(\"沉默王三\");\nlist.add(\"一个文章真特么有趣的程序员\");\n\nIterator<String> itr = list.iterator();\n\nwhile (itr.hasNext()) {\n\tString str = itr.next();\n\tif (\"沉默王二\".equals(str)) {\n\t\titr.remove();\n\t}\n}\n```\n\n为什么使用 Iterator 的 remove 方法就可以避开 fail-fast 保护机制呢？看一下 remove 的源码就明白了。** 循环**\n\n简单地总结一下，fail-fast 是一种保护机制，可以通过 for-each 循环删除集合的元素的方式验证这种保护机制。\n\n那也就是说，for-each 本质上是一种语法糖，遍历集合时很方面，但并不适合拿来操作集合中的元素（增删）。\n\n\n\n### HashMap\n\n什么是hashmap？\n\n说在前面：\n\n```txt\n说到HashMap，就先说一下Map\nmap是用于存储键值对（<key,value>）的集合类，也可以说是一组键值对的映射（数学概念）。\nMap的特点\n1.没有重复的 key（一方面，key用set保存，所以key必须是唯一，无序的；另一方面，map的取值基本上是通过key来获取value，如果有两个相同的key，计算机将不知道到底获取哪个对应值；这时候有可能会问，那为什么我编程时候可以用put（）方法传入两个key值相同的键值对？那是因为源码中，传入key值相同的键值对，将作为覆盖处理）\n\n2.每个 key 只能对应一个 value, 多个 key 可以对应一个 value（这就是映射的概念，最经典的例子就是射箭，一排射手，一排箭靶，一个射手只能射中一个箭靶，而每个箭靶可能被不同射手射中。这里每个射手只有一根箭，不存在三箭齐发还都中靶这种骚操作。将射手和射中的靶子连线，这根线加射手加靶子就是一个映射）\n\n3.key,value 都可以是任何引用类型（包括 null）的数据（只能是引用类型）\n\n4.Map 取代了古老的 Dictionary 抽象类（知道就行，可以忽略）\n————————————————\n版权声明：本文为CSDN博主「酒吧七」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。\n原文链接：https://blog.csdn.net/qq_36711757/article/details/80394272\n```\n\n\n\n#### 一、hash 方法的原理\n\n```\n把任意长度的输入（输入叫做预映射，知道就行），通过一种函数（hashCode() 方法），变换成固定长度的输出，该输出就是***\\*哈希值\\****（hashCode），这种函数就叫做***\\*哈希函数\\****，而计算哈希值的过程就叫做***\\*哈希\\****。哈希的主要应用是哈希表和分布式缓存。\n\n这里有个问题，哈希算法和哈希函数不是一个东西，哈希函数是哈希算法的一种实现，以后面试就说哈希函数就行。\n\n在将键值对存入数组之前，将key通过哈希算法计算出哈希值，把哈希值作为数组下标，把该下标对应的位置作为键值对的存储位置，通过该方法建立的数组就叫做***\\*哈希表\\****，而这个存储位置就叫做***\\*桶（bucket）\\****。数组是通过整数下标直接访问元素，哈希表是通过字符串key直接访问元素，也就说哈希表是一种特殊的数组（关联数组），哈希表广泛应用于实现数据的快速查找（在map的key[集合](https://so.csdn.net/so/search?q=集合&spm=1001.2101.3001.7020)中，一旦存储的key的数量特别多，那么在要查找某个key的时候就会变得很麻烦，数组中的key需要挨个比较，哈希的出现，使得这样的比较次数大大减少。）\n\n哈希表选用哈希函数计算哈希值时，可能不同的 key 会得到相同的结果，一个地址怎么存放多个数据呢？这就是***\\*哈希冲突（碰撞）\\****。解决哈希冲突有两种方法，拉链法（链接法）和开放定址法（这种没用过）。***\\*拉链法\\****：将键值对对象封装为一个node结点，新增了next指向，这样就可以将碰撞的结点链接成一条单链表，保存在该地址（数组位置）中。\n```\n\n再来看一下 hash 方法的源码（JDK 8 中的 HashMap）：\n\n```java\nstatic final int hash(Object key) {\n    int h;\n    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);\n}\n```\n\n`key.hashCode()` 是用来获取键位的哈希值的，理论上，哈希值是一个 int 类型，范围从-2147483648 到 2147483648。前后加起来大概 40 亿的映射空间，只要哈希值映射得比较均匀松散，一般是不会出现哈希碰撞的。\n\n取模运算有两处。\n\n> 取模运算（“Modulo Operation”）和取余运算（“Remainder Operation ”）两个概念有重叠的部分但又不完全一致。主要的区别在于对负整数进行除法运算时操作不同。**取模**主要是用于**计算机术语**中，**取余**则更多是**数学概念**。\n\n一处是往 HashMap 中 put 的时候（`putVal` 方法中）：\n\n```java\nfinal V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) {\n     HashMap.Node<K,V>[] tab; HashMap.Node<K,V> p; int n, i;\n     if ((tab = table) == null || (n = tab.length) == 0)\n         n = (tab = resize()).length;\n     if ((p = tab[i = (n - 1) & hash]) == null)\n         tab[i] = newNode(hash, key, value, null);\n}\n```\n\n一处是从 HashMap 中 get 的时候（`getNode` 方法中）：\n\n```java\nfinal Node<K,V> getNode(int hash, Object key) {\n     Node<K,V>[] tab; Node<K,V> first, e; int n; K k;\n     if ((tab = table) != null && (n = tab.length) > 0 &&\n            (first = tab[(n - 1) & hash]) != null) {}\n}\n```\n\n其中的 `(n - 1) & hash` 正是取模运算，就是把哈希值和（数组长度-1）做了一个“与”运算。\n\n可能大家在疑惑：**取模运算难道不该用 `%` 吗？为什么要用 `&` 呢**？\n\n这是因为 `&` 运算比 `%` 更加高效，并且当 b 为 2 的 n 次方时，存在下面这样一个公式。\n\n> a % b = a & (b-1)\n\n用 $2^n$ 替换下 b 就是：\n\n> a % 2^n = a & (2^n-1)\n\n综上所述，hash 方法是用来做哈希值优化的，把哈希值右移 16 位，也就正好是自己长度的一半，之后与原哈希值做异或运算，这样就混合了原哈希值中的高位和低位，增大了随机性。\n\n说白了，**hash 方法就是为了增加随机性，让数据元素更加均衡的分布，减少碰撞**。\n\n**[为什么 HashMap 的数组长度要取 2 的整次方?](https://mp.weixin.qq.com/s/aS2dg4Dj1Efwujmv-6YTBg)**\n\n#### 二、扩容机制\n\n大家都知道，数组一旦初始化后大小就无法改变了，所以就有了 [ArrayList]这种“动态数组”，可以自动扩容。\n\nHashMap 的底层用的也是数组。向 HashMap 里不停地添加元素，当数组无法装载更多元素时，就需要对数组进行扩容，以便装入更多的元素。\n\n当然了，数组是无法自动扩容的，所以如果要扩容的话，就需要新建一个大的数组，然后把小数组的元素复制过去。\n\nHashMap 的扩容是通过 resize 方法来实现的，JDK 8 中融入了红黑树，比较复杂，为了便于理解，就还使用 JDK 7 的源码，搞清楚了 JDK 7 的，我们后面再详细说明 JDK 8 和 JDK 7 之间的区别。\n\n\n\n#### 三、加载因子为什么是0.75\n\n哈希函数计算结果越分散均匀，哈希碰撞的概率就越小，map的存取效率（时间复杂度）就会越高。\n\n哈希表长度越长，空间成本越大，哈希函数计算结果越分散均匀。\n\n***\\*扩容机制\\****（实际上就是负载因子）和哈希函数越合理，空间成本越小，哈希函数计算结果越分散均匀。\n\n从HashMap的默认构造函数源码可知，构造函数就是对下面几个字段进行初始化。\n\n负载因子越大（长度一定），最大结点容量越大，resize次数越少，空间成本越小，map的存取效率就会越高。\n\n桶数组初始容量（长度）越大（加载因子一定），最大结点容量越大，resize次数越少，空间成本越大，map的存取效率就会越高。\n\n涉及到概率论的泊松分布与二项分布。\n\n***引入红黑树的概念：***\n\n这里存在一个问题，即使负载因子和哈希函数设计的再合理，也免不了会出现***\\*拉链过长\\****（桶内结点过多）的情况，一旦出现拉链过长，则会严重影响HashMap的性能。于是，在JDK1.8版本中，对数据结构做了进一步的优化，引入了红黑树。而当链表长度太长（默认超过8）时，链表就转换为红黑树，利用红黑树快速增删改查的特点提高HashMap的性能。\n\n#### 四、线程不安全\n\n\n\n有何体现：\n\n多线程下扩容会死循环、多线程下 put 会导致元素丢失、put 和 get 并发时会导致 get 到 null，也就是环链死循环、数据丢失、数据覆盖三个问题。其中环链在JDK1.8已经解决，但还是有数据覆盖的问题。\n\n究其根本：\n\n线程不安全主要是发生在扩容函数中，即根源是在**transfer函数**中：transfer函数代码如下：\n\n```Java\n/**\n  *\n  @version JDK1.7\n  */\nvoid transfer(Entry[] newTable, boolean rehash) {\n        int newCapacity = newTable.length;\n        for (Entry<K,V> e : table) {\n            while(null != e) {\n                Entry<K,V> next = e.next;\n                if (rehash) {\n                    e.hash = null == e.key ? 0 : hash(e.key);\n                }\n                int i = indexFor(e.hash, newCapacity);\n                e.next = newTable[i];\n                newTable[i] = e;\n                e = next;\n            }\n        }\n    }\n```\n\n`HashMap`的扩容操作，重新定位每个桶的下标，并采用头插法将元素迁移到新数组中。头插法会将链表的顺序翻转，这也是形成死循环的关键点。\n\n\n\nkey 用 Set 存放，所以想做到 **key 不允许重复**，key 对应的类（一般是String）需要重写 hashCode 和 equals 方法\n\n- HashMap不是同步，HashTable是同步的，但HashTable已经弃用，如果需要线程安全，可以用synchronizedMap，例如       Map m = Collections.synchronizedMap(new HashMap(...));\n\n\n\n","slug":"Java-Essay","published":1,"updated":"2023-11-19T16:59:00.512Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clpkiczio000nfkfofr7yhbc9","content":"<ul>\n<li><em>写在前面：</em><ul>\n<li>【免责声明：】本笔记来源自互联，是笔者结合自己的理解进行整理归纳发表在hexo博客只便于个人学习使用，若涉及到侵权，请联系我，谢谢！</li>\n<li>个人博客地址：<a href=\"https://wl2o2o.github.io/\">https://wl2o2o.github.io/</a></li>\n</ul>\n</li>\n<li>写作背景:<ul>\n<li>笔者是一名大三在校生，目前正在努力学习Java方向，笔记书写于22年暑假期间，虽然起步有点晚，但是每天都在坚持，只要努力，光一定会shine向我的！</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"Essay笔记来源\"><a href=\"#Essay笔记来源\" class=\"headerlink\" title=\"Essay笔记来源\"></a>Essay笔记来源</h1><p><a href=\"https://www.pdai.tech/md/java/basic/java-basic-x-generic.html\">Java全栈知识体系</a>——泛型</p>\n<p><a href=\"https://www.bilibili.com/video/BV1mE411x7Wt\">哔哩哔哩老杜Java</a>——哔哩哔哩</p>\n<p><a href=\"https://tobebetterjavaer.com/home.html\">Java程序员进阶之路</a>——沉默王二</p>\n<h1 id=\"老杜Java零基础\"><a href=\"#老杜Java零基础\" class=\"headerlink\" title=\"老杜Java零基础\"></a>老杜Java零基础</h1><p><strong>P58</strong><br>具体的命名规范：<br>1、顾名思义；<br>2、驼峰原则：一高一低：例如：PowerNodeNotes；<br>3、类名、接口名首字母大写 ；<br>    变量名方法名首字母小写；<br>        常量名全部大写，单词之间用_下划线连接：USER_AGE;</p>\n<p><strong>P60</strong><br>关键字：<br>int、long、float…public static void boolean private protect 蓝色字体、小写显示</p>\n<p><strong>P63</strong><br>提取帮助文档：也就是写在/**            这里面的注释信息。<br>                *<br>                *@author<br>                *@version<br>                */<br>javadoc -d+文件夹名（文件夹绝对路径）+（需要提取的信息）+Java源文件<br>例如：javadoc -d javaapi -author -version VarTest02.java</p>\n<p><strong>P70</strong><br>1，变量的分类：<br>public class Test{<br>    int i;//全局变量<br>    public static void main(String[] args){<br>        int j;局部变量<br>  }<br>}</p>\n<p>2，变量的作用域：即有效范围（出了大括号就处于非作用域）！</p>\n<p><strong>P72</strong><br>标识符可以标志什么：<br>类名、方法名、常量、变量、接口名</p>\n<p>记录所有编程出现的错误，记录错误~！</p>\n<p><strong>P113</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Homework1</span>&#123;<br>\t<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span>&#123;<br>\t\t<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">10</span>;<br>\t\ti=i++;<br>\t\tSystem.out.println(i);\t<span class=\"hljs-comment\">//运行结果为10！</span><br>  &#125;<br>&#125;<br><span class=\"hljs-comment\">//Java和C++源代码运行结果不一样，C++结果为11、Java为10.</span><br></code></pre></td></tr></table></figure>\n\n<p>原因：编译器原理不一样，其中Java的代码可以理解为一下三行：<br>（在Java语言中i++，这种表达式在执行的时候，会提前将i变量找一个存储空间临时存储，不同于C++）<br>int temp=i;<br>i++;<br>i=temp;<br>因此！！！可以理解为：分号之后++再加一 </p>\n<p><strong>P116</strong><br>接收键盘输入：</p>\n<p>在Java中则怎么接收键盘信息呢？<br>第一种形式：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">//创建一个键盘扫描器对象(s为对象名，上下对应)</span><br>java.util.<span class=\"hljs-type\">Scanner</span> <span class=\"hljs-variable\">s</span> <span class=\"hljs-operator\">=</span><span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">java</span>.util.Scanner(System.in);\t<br>java.util.<span class=\"hljs-type\">Scanner</span> <span class=\"hljs-variable\">s</span> <span class=\"hljs-operator\">=</span><span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">java</span>.util.Scanner(System.in);\t<br><span class=\"hljs-type\">int</span> i=s.nextInt(); <br>System.out.println();\t<br><br><span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">str</span> <span class=\"hljs-operator\">=</span>s.next();<br>System.out.println();<br><span class=\"hljs-comment\">//接收用户的输入，从键盘上接受一个int类型的数据、</span><br><span class=\"hljs-comment\">//i变量有值了，并且i变量中保存的这个值是用户输入的数字。</span><br><span class=\"hljs-comment\">//i变量就是接收键盘数据的</span><br><span class=\"hljs-type\">int</span> i=s.nextInt();<br>System.out.println(<span class=\"hljs-string\">&quot;您输入的数字是：&quot;</span>+i);<br><br><span class=\"hljs-type\">int</span> j=s.nextInt();<br>System.out.println(<span class=\"hljs-string\">&quot;您输入的数字是：&quot;</span>+j);<br><span class=\"hljs-comment\">//字符串类型</span><br><span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">str</span> <span class=\"hljs-operator\">=</span> s.next();<br>其他数据类型类似<br>其中println:print为打印、ln为换行。<br></code></pre></td></tr></table></figure>\n\n<p>另外一种形式：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">import</span> java.util.Scanner;\t<span class=\"hljs-comment\">//idea可以自动引入</span><br><span class=\"hljs-comment\">//创建键盘扫描器对象</span><br><span class=\"hljs-type\">Scanner</span> <span class=\"hljs-variable\">s</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Scanner</span>(System.in);<br><span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">num1</span> <span class=\"hljs-operator\">=</span> s.nextInt();<br>System.out.println(num1+<span class=\"hljs-string\">&quot;+&quot;</span>+num2+<span class=\"hljs-string\">&quot;=&quot;</span>);<br></code></pre></td></tr></table></figure>\n\n<p>头歌实践教学平台项目案例练习：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">//什么是类、怎么创建类：</span><br><span class=\"hljs-keyword\">package</span> step1;<br><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Test</span> &#123;<br>\t<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> &#123;<br>\t\t<span class=\"hljs-comment\">/********** Begin **********/</span><br>\t\t<span class=\"hljs-comment\">//创建Dog对象</span><br>\t\t<span class=\"hljs-comment\">//设置Dog对象的属性</span><br>        <span class=\"hljs-type\">Dog</span> <span class=\"hljs-variable\">wuhuarou</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Dog</span>();<br>\t\twuhuarou.name=<span class=\"hljs-string\">&quot;五花肉&quot;</span>;<br>        wuhuarou.color=<span class=\"hljs-string\">&quot;棕色&quot;</span>;<br>        wuhuarou.variety=<span class=\"hljs-string\">&quot;阿拉斯加&quot;</span>;<br>\t\t<span class=\"hljs-comment\">//输出小狗的属性</span><br>\t\tSystem.out.println(<span class=\"hljs-string\">&quot;名字：&quot;</span> + wuhuarou.name + <span class=\"hljs-string\">&quot;，毛色：&quot;</span> + wuhuarou.color+ <span class=\"hljs-string\">&quot;，品种：&quot;</span> +wuhuarou.variety );<br>\t\t<span class=\"hljs-comment\">//调用方法</span><br>        wuhuarou.eat();<br>        wuhuarou.run();<br>\t\t<span class=\"hljs-comment\">/********** End **********/</span><br>\t&#125;<br>&#125;<br><span class=\"hljs-comment\">//在这里定义Dog类</span><br><span class=\"hljs-comment\">/********** Begin **********/</span><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Dog</span>&#123;<br>    String name,color,variety;<br>    <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">eat</span><span class=\"hljs-params\">()</span>&#123;<br>        System.out.println(<span class=\"hljs-string\">&quot;啃骨头&quot;</span>);<br>    &#125;<br>    <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">run</span><span class=\"hljs-params\">()</span>&#123;<br>        System.out.print(<span class=\"hljs-string\">&quot;叼着骨头跑&quot;</span>);<br>    &#125;<br>&#125;<br><span class=\"hljs-comment\">/********** End **********/</span><br></code></pre></td></tr></table></figure>\n\n<p>关于质数：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">package</span> step2;<br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">FindZhiShu</span> &#123;<br>\t<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> &#123;<br>\t\t   <span class=\"hljs-comment\">/*</span><br><span class=\"hljs-comment\">\t\t     打印输出质数的时候务必按照如下格式：System.out.print(质数+&quot; &quot;)；</span><br><span class=\"hljs-comment\">\t\t     使用print进行打印同时被打印输出的质数后加上一个空格，</span><br><span class=\"hljs-comment\">\t\t     以便于与平台提供的结果格式保持一致！</span><br><span class=\"hljs-comment\">            */</span>   <br>\t\t   <span class=\"hljs-comment\">/**********begin**********/</span><br>            a:<span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">i</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">2</span>;i &lt; <span class=\"hljs-number\">1000</span>;i++)&#123;\t\t<span class=\"hljs-comment\">//此循环遍历次数较多，若对代码效率有要求，则可进一步改进代码：如下：</span><br>                <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">j</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">2</span>;j&lt;i;j++)<br>                <span class=\"hljs-keyword\">if</span>(i%j==<span class=\"hljs-number\">0</span>)&#123;<br>                    <span class=\"hljs-keyword\">continue</span> a;<br>                &#125;<br>                System.out.print(i+<span class=\"hljs-string\">&quot; &quot;</span>);<br>            &#125;<br>           <span class=\"hljs-comment\">/**********end**********/</span>\t<br>\t&#125;<br>&#125;<br>\t\t**********************改进之后的代码*********************<br><span class=\"hljs-keyword\">package</span> step2;<br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">FindZhiShu</span> &#123;<br>\t<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> &#123;<br>\t\t   <span class=\"hljs-comment\">/*</span><br><span class=\"hljs-comment\">\t\t     打印输出质数的时候务必按照如下格式：System.out.print(质数+&quot; &quot;)；</span><br><span class=\"hljs-comment\">\t\t     使用print进行打印同时被打印输出的质数后加上一个空格，</span><br><span class=\"hljs-comment\">\t\t     以便于与平台提供的结果格式保持一致！</span><br><span class=\"hljs-comment\">            */</span>   <br>\t\t   <span class=\"hljs-comment\">/**********begin**********/</span><br><br>\tSystem.out.print(<span class=\"hljs-string\">&quot;2 &quot;</span>);\t<span class=\"hljs-comment\">//因为2是特殊的质数，又因下面循环会自动跳过偶数，因此先将2打印出来。</span><br>\t        a:<span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">i</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">3</span>;i &lt; <span class=\"hljs-number\">1000</span>;i+=<span class=\"hljs-number\">2</span>)&#123;<br>\t            <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">j</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">2</span>;j&lt;i;j++)<br>\t            <span class=\"hljs-keyword\">if</span>(i%j==<span class=\"hljs-number\">0</span>)&#123;<br>\t                <span class=\"hljs-keyword\">continue</span> a;\t\t<span class=\"hljs-comment\">//此方法运用了给循环做标记，以此可以对continue和break进行明确的命令指示。</span><br>\t            &#125;<br>\t            System.out.print(i+<span class=\"hljs-string\">&quot; &quot;</span>);<br>\t        &#125;<br>\t       <span class=\"hljs-comment\">/**********end**********/</span>\t<br>\t&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"《方法》\"><a href=\"#《方法》\" class=\"headerlink\" title=\"《方法》\"></a>《方法》</h2><h3 id=\"定义：\"><a href=\"#定义：\" class=\"headerlink\" title=\"定义：\"></a>定义：</h3><p>是可以完成某一个特定的功能，并且可被重复利用。</p>\n<p>在面向对象的语言中，函数称为方法，类似于C语言总的函数。方法写在类体中，可以写在main函数前后，不分顺序，因为main函数为执行入口。</p>\n<h3 id=\"方法结构定义：\"><a href=\"#方法结构定义：\" class=\"headerlink\" title=\"方法结构定义：\"></a>方法结构定义：</h3><p>【修饰符列表】 返回值类型 方法名 （形式参数列表）{</p>\n<p>​        方法体;</p>\n<p>}</p>\n<p>注意：</p>\n<p>【】符号叫中括号、以上中括号里的内容表是不是必须的，是可以选择的，方法体由Java语句构成；</p>\n<p>关于修饰符列表：</p>\n<p>也不是必须的，目前可写成public static（称为静态方法）</p>\n<p>break与return的区别：</p>\n<p>break：用来终止一个switch语句和距离最近的循环</p>\n<p>return：用来终止一个方法。 </p>\n<h3 id=\"方法优化：\"><a href=\"#方法优化：\" class=\"headerlink\" title=\"方法优化：\"></a>方法优化：</h3><p>例题：编写一个方法，输出大于某个正整数n的最小的质数（思考：这个方法应该取什么名字，这个方法的形参是什么，返回值类型是什么？）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Java\"> <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Homework2</span>&#123;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span>&#123;<br>        <span class=\"hljs-comment\">//假设目前系统给定一个正整数n，n为5</span><br>        <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">n</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">7</span>;<br>        <span class=\"hljs-comment\">//输出大于5的最小质数</span><br>        <span class=\"hljs-keyword\">while</span>(<span class=\"hljs-literal\">true</span>)&#123;<br>            n++;<br>\t\t\t<span class=\"hljs-comment\">//需要一个判断是否为质数的方法。。</span><br>            <span class=\"hljs-keyword\">if</span>(isZhiShu(n))&#123;\t\t\t\t<br>                System.out.print(<span class=\"hljs-string\">&quot;最小质数是&quot;</span>+n);<br>                <span class=\"hljs-keyword\">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>\t<span class=\"hljs-comment\">//该方法返回一个Boolean字符，用于main方法中的if判断语句。</span><br>\t<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">boolean</span> <span class=\"hljs-title function_\">isZhiShu</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> num)</span>&#123;<br>\t\t<span class=\"hljs-comment\">//判断num是否为质数</span><br>\t\t<span class=\"hljs-comment\">//可以利用循环取余的方法来判断是否可以整除除1和本身的数字</span><br>\t\t<span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">i</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">2</span>; i &lt; num;i++ )&#123;<br>\t\t\t<span class=\"hljs-keyword\">if</span>(num%i==<span class=\"hljs-number\">0</span>)&#123;<br>\t\t\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;<br>\t\t\t&#125;<br>\t\t&#125;<br>\t\t<span class=\"hljs-comment\">//return语句容易写在for循环里面，写在里面判断不完全</span><br>\t\t<span class=\"hljs-comment\">//return之所以写在外面是因为要让循环执行完毕，执行完毕才可以正确判断</span><br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;<br>\t&#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>编程思路以及改进版：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"> <br><span class=\"hljs-keyword\">import</span> java.util.Scanner;<br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Homework2</span>&#123;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span>&#123;<br>        <br>        <span class=\"hljs-comment\">//以下代码省略，新增打印质数的方法</span><br>\t\t<span class=\"hljs-comment\">/*</span><br><span class=\"hljs-comment\">\t\t//假设目前系统给定一个正整数n，n为5</span><br><span class=\"hljs-comment\">        int n = 7;</span><br><span class=\"hljs-comment\">\t\t//输出大于5的最小质数</span><br><span class=\"hljs-comment\">        while(true)&#123;</span><br><span class=\"hljs-comment\">            n++;</span><br><span class=\"hljs-comment\">\t\t\t//需要一个判断是否为质数的方法。。</span><br><span class=\"hljs-comment\">            if(isZhiShu(n))&#123;\t\t\t\t</span><br><span class=\"hljs-comment\">                System.out.print(&quot;最小质数是&quot;+n);</span><br><span class=\"hljs-comment\">                break;</span><br><span class=\"hljs-comment\">            &#125;</span><br><span class=\"hljs-comment\">        &#125;</span><br><span class=\"hljs-comment\">\t\t*/</span><br>\t\t<br>\t\t<span class=\"hljs-comment\">//引入用户输入的数据</span><br>\t\t<span class=\"hljs-type\">Scanner</span> <span class=\"hljs-variable\">s</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Scanner</span>(System.in);<br>\t\t<span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">num</span> <span class=\"hljs-operator\">=</span> s.nextInt();<br>\t\t<span class=\"hljs-comment\">//直接调用打印质数的方法</span><br>\t\tprintZhiShu(num);<br><br><br>    &#125;<br>\t<span class=\"hljs-comment\">//代码不够精简，还可以在main（）中调用打印输出质数的方法</span><br>\t<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">printZhiShu</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> num)</span>&#123;<br>\t\t<br>\t\t<span class=\"hljs-comment\">//while循环仍可精简，但是精简之后不易理解，代码如下：</span><br>\t\t<span class=\"hljs-comment\">/*\t\t</span><br><span class=\"hljs-comment\">\t\twhile(isZhiShu(num))&#123;</span><br><span class=\"hljs-comment\">\t\t&#125;</span><br><span class=\"hljs-comment\">\t\tSystem.out.print(&quot;最小质数是&quot;+num);</span><br><span class=\"hljs-comment\">\t\t*/</span><br><br>\t\t<span class=\"hljs-comment\">/*while(true)&#123;</span><br><span class=\"hljs-comment\">    \t\t//需要一个判断是否为质数的方法。。</span><br><span class=\"hljs-comment\">            if(isZhiShu(++num))&#123;\t\t\t\t</span><br><span class=\"hljs-comment\">                System.out.print(&quot;最小质数是&quot;+num);</span><br><span class=\"hljs-comment\">                break;</span><br><span class=\"hljs-comment\">            &#125;</span><br><span class=\"hljs-comment\">\t\t&#125;\t</span><br><span class=\"hljs-comment\">\t\t*/</span><br>\t\t<span class=\"hljs-keyword\">while</span>(!isZhiShu(++num))&#123;<br>\t\t&#125;<br>\t\tSystem.out.print(<span class=\"hljs-string\">&quot;最小质数是&quot;</span>+num);<br>        <br>\t&#125;<br><br>\t<span class=\"hljs-comment\">//该方法返回一个Boolean字符，用于main方法中的if判断语句。</span><br>\t<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">boolean</span> <span class=\"hljs-title function_\">isZhiShu</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> num)</span>&#123;<br>\t\t<span class=\"hljs-comment\">//判断num是否为质数</span><br>\t\t<span class=\"hljs-comment\">//可以利用循环取余的方法来判断是否可以整除除1和本身的数字</span><br>\t\t<span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">i</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">2</span>; i &lt; num;i++ )&#123;<br>\t\t\t<span class=\"hljs-keyword\">if</span>(num%i==<span class=\"hljs-number\">0</span>)&#123;<br>\t\t\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;<br>\t\t\t&#125;<br>\t\t&#125;<br>\t\t<span class=\"hljs-comment\">//return语句容易写在for循环里面，写在里面判断不完全</span><br>\t\t<span class=\"hljs-comment\">//return之所以写在外面是因为要让循环执行完毕，执行完毕才可以正确判断</span><br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;<br>\t&#125;<br><br>&#125;<br><br><span class=\"hljs-comment\">//以上代码为编程思路，以下为精简代码：</span><br><span class=\"hljs-comment\">/*</span><br><span class=\"hljs-comment\">import java.util.Scanner;</span><br><span class=\"hljs-comment\">public class Homework2&#123;</span><br><span class=\"hljs-comment\">    public static void main(String[] args)&#123;</span><br><span class=\"hljs-comment\">\t\tScanner s = new Scanner(System.in);</span><br><span class=\"hljs-comment\">\t\tint num = s.nextInt();</span><br><span class=\"hljs-comment\"></span><br><span class=\"hljs-comment\">\t\tprintZhiShu(num);</span><br><span class=\"hljs-comment\">    &#125;</span><br><span class=\"hljs-comment\"></span><br><span class=\"hljs-comment\">\tpublic static void printZhiShu(int num)&#123;</span><br><span class=\"hljs-comment\">\t\twhile(!isZhiShu(++num))&#123;</span><br><span class=\"hljs-comment\">\t\t&#125;</span><br><span class=\"hljs-comment\">\t\tSystem.out.print(&quot;最小质数是&quot;+num);</span><br><span class=\"hljs-comment\">\t&#125;</span><br><span class=\"hljs-comment\"></span><br><span class=\"hljs-comment\">\tpublic static boolean isZhiShu(int num)&#123;</span><br><span class=\"hljs-comment\">\t\tfor(int i = 2; i &lt; num;i++ )&#123;</span><br><span class=\"hljs-comment\">\t\t\tif(num%i==0)&#123;</span><br><span class=\"hljs-comment\">\t\t\t\treturn false;</span><br><span class=\"hljs-comment\">\t\t\t&#125;</span><br><span class=\"hljs-comment\">\t\t&#125;</span><br><span class=\"hljs-comment\">\t\treturn true;</span><br><span class=\"hljs-comment\">\t&#125;</span><br><span class=\"hljs-comment\"></span><br><span class=\"hljs-comment\">&#125;</span><br><span class=\"hljs-comment\">*/</span><br> <br><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"方法重载\"><a href=\"#方法重载\" class=\"headerlink\" title=\"方法重载\"></a>方法重载</h3><p>同一个类中：方法名相同，形参个数或者类型不同。</p>\n<p>优点：代码整齐美观，记忆方法名较少。</p>\n<p>含义：就是可以定义多个相同名字的方法（例如：public static int sum(int a,int b)和public static int sum(long a,long b)）</p>\n<p>原理：Java编译器会自动识别方法名，若方法名相同，则进行参数类型匹配，所以名方法重载。</p>\n<p>怎么判断：方法名相同、形参类型不同、形参个数不同、形参顺序不同</p>\n<h3 id=\"方法递归\"><a href=\"#方法递归\" class=\"headerlink\" title=\"方法递归\"></a>方法递归</h3><p>含义：方法调用自己的方法！</p>\n<p>典例：从前有座山，山里有个和尚说：{从前有座山，山里有个和尚说}：{从前有座山，山里有个和尚说}——递归。。。</p>\n<p>老杜这样说：</p>\n<p>方法递归？</p>\n<p>​    1、什么是方法递归？</p>\n<p>​            方法自己调用自己，这就是方法递归。</p>\n<p>​    2、当递归时程序没有结束条件，一定会发生：</p>\n<p>​            栈内存溢出错误：StackOverflowError</p>\n<p>​            所以：递归必须要有结束条件。（这是一个非常重要的知识点。）</p>\n<p>​            JVM发生错误之后一定会推出JVM。</p>\n<p>​    3、递归假设是有结束条件的，就一定不会发生栈内存溢出吗？</p>\n<p>​            假设这个结束条件时对的，是合法的，递归有时候也会出现栈内存溢出的错误。</p>\n<p>​            因为有时候，可能递归的太深，栈内存不够（因为一直在压栈）</p>\n<p>​    4、不建议在实际的开发中使用递归，，能用for循环while循环代替的尽量使用循环来做，因为循环的效率较高，耗费内存少。递归耗费的内存较多，另外递归若使用不当，则会导致JVM的死掉。</p>\n<p>​        （极少数的情况下是必须要用递归的。）</p>\n<p>​        所以：递归还是要认真学习的！</p>\n<p>老杜讲经验：</p>\n<p>​    如果遇到了栈内存溢出，怎么调bug?</p>\n<p>​    第一步：</p>\n<p>​        先检查递归的结束条件对不对。如果不对，则进一步修改，直到正确。</p>\n<p>​    第二步：</p>\n<p>​        如果假设条件没问题，这个时候需要手动调整JVM的栈内存初始大小（通过命令行适当调大。）</p>\n<p>​    第三步：</p>\n<p>​        如果还会栈内存溢出，则继续调大。（Java -X  这个命令可以查看调整堆栈大小的参数。具体格式如下图所示：）</p>\n<p>老杜栈内存溢出图：</p>\n<p><img src=\"http://images.rl0206.love/image-20220715183512822.png\" alt=\"image-20220715183512822\"></p>\n<p>如何指 定栈内存大小：</p>\n<p><img src=\"http://images.rl0206.love/image-20220715184629869.png\" alt=\"image-20220715184629869\"></p>\n<h3 id=\"递归实例\"><a href=\"#递归实例\" class=\"headerlink\" title=\"递归实例\"></a>递归实例</h3><p>题目：计算1~ 10的和。</p>\n<p>不用递归思路：写一个for循环方法，直接调用。</p>\n<p>用递归思路：（方法调用打法）</p>\n<p><img src=\"http://images.rl0206.love/image-20220716094554506.png\" alt=\"image-20220716094554506\"></p>\n<h2 id=\"《代码的包装与封装》\"><a href=\"#《代码的包装与封装》\" class=\"headerlink\" title=\"《代码的包装与封装》\"></a>《代码的包装与封装》</h2><p>封装及使用方法：</p>\n<p><img src=\"http://images.rl0206.love/image-20220715170415137.png\" alt=\"image-20220715170415137\"></p>\n<h2 id=\"《认识面向对象》\"><a href=\"#《认识面向对象》\" class=\"headerlink\" title=\"《认识面向对象》\"></a>《认识面向对象》</h2><p>面向对象与面向过程：</p>\n<p>​    面向过程的优缺点：</p>\n<p>​        缺点：（高度耦合）</p>\n<p>​            面向过程的程序的每一个功能之间都是因果关系，因为A所以B，AB联合成一个子模块，然后模块与模块之间形成因果关系。因此任何一个功能之间出现问题，就会导致另一出现问题。 这就是高度耦合！（耦合度就是粘连程度）</p>\n<p>​            耦合度高导致扩展力差（主板集成显卡）</p>\n<p>​            耦合度低导致扩展力强（独立下显卡，螺栓与螺母等）</p>\n<p>​        优点：（快速开发）</p>\n<p>​            对于小型项目，可以直接通过因果关系来写代码。不需要前期对象的提取、模型的建立，可以直接干活，从而实现功能。</p>\n<p>什么是面向对象的开发模式？</p>\n<p>​    万物皆为对象，人眼看到的是各个对象之间的联系，更符合人类的思维方式。因此，面向对象在成为主流。</p>\n<p>如何判断面向过程和面向对象？</p>\n<p>​    可以通过耦合度等判断。</p>\n<p>三个过程：</p>\n<p>​    OOA–&gt;OOD–&gt;OOP</p>\n<p>​    分析      设计     编程</p>\n<p>三大特征：</p>\n<p>封装、继承、多态。（任何一个面向对象的编程语言都包括这三个特征。）</p>\n<h2 id=\"类与对象\"><a href=\"#类与对象\" class=\"headerlink\" title=\"类与对象\"></a>类与对象</h2><h3 id=\"浅析类与对象：\"><a href=\"#浅析类与对象：\" class=\"headerlink\" title=\"浅析类与对象：\"></a>浅析类与对象：</h3><p>​    类是一个集合，包含对象的特征，是特征的总结。</p>\n<p>​    而对象是真实存在的，万物皆可对象。</p>\n<p>在Java语言中，要想得到对象，必须先定义类，，，对象是通过类创建的。</p>\n<p>​    例如：先定义人类，才可以定义魏磊。哈哈哈哈。</p>\n<p>重要概念：</p>\n<p>​    《实例化》</p>\n<p>​            含义：通过类创建对象的过程叫做实例化。</p>\n<p>​    《实例》</p>\n<p>​            含义：对象又被称为实例。</p>\n<p>（此处补充类与对象的图）</p>\n<p>​    《抽象》</p>\n<p>​            含义：魏磊到人类的过程程为抽象。</p>\n<p>​    类–【实例化】–&gt;对象（实例）</p>\n<p>​    对象–【抽象】–&gt;类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Java\"><span class=\"hljs-keyword\">public</span> class 明星类&#123;<br>    <span class=\"hljs-comment\">/*</span><br><span class=\"hljs-comment\">    类 = 属性 + 方法</span><br><span class=\"hljs-comment\"></span><br><span class=\"hljs-comment\">\t属性来源于状态； （名词）\t数据是以数据形式存在的，所以只能存放在变量中。\t\t即属性即变量。</span><br><span class=\"hljs-comment\"></span><br><span class=\"hljs-comment\">\t方法来源于动作； （动词）</span><br><span class=\"hljs-comment\">\t*/</span><br>    <span class=\"hljs-comment\">//属性</span><br>    <span class=\"hljs-type\">int</span> 身高;<br>    <span class=\"hljs-type\">int</span> 体重;<br>    <br>    <span class=\"hljs-comment\">//方法</span><br>    打篮球（）&#123;<br>        <br>    &#125;<br>    学习（）&#123;<br>        <br>    &#125;<br>    <br>    <br><br><br>&#125;<br></code></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"对象的创建：\"><a href=\"#对象的创建：\" class=\"headerlink\" title=\"对象的创建：\"></a>对象的创建：</h3><p>​    “没对象，new一个”</p>\n<p>​        创建对象语法：XueSheng  s1 = new XueSheng();</p>\n<p>​                                            XueSheng  s1 = new XueSheng()；此时此刻就相当于 ：int i = 1；</p>\n<pre><code class=\"hljs\">                                         XueSheng:数据类型\n</code></pre>\n<p>​                                            s1:变量名</p>\n<p>​                                            new:运算符</p>\n<p>​                                            XueSheng:类名</p>\n<h2 id=\"Java变量\"><a href=\"#Java变量\" class=\"headerlink\" title=\"Java变量\"></a>Java变量</h2><p>变量的分类：</p>\n<p>1局部变量</p>\n<p>2成员变量</p>\n<p>3静态变量</p>\n<p>4常量        （要求大写）</p>\n<p>————————————笔记分隔线———————————</p>\n<h1 id=\"Java进阶之路笔记\"><a href=\"#Java进阶之路笔记\" class=\"headerlink\" title=\"Java进阶之路笔记\"></a>Java进阶之路笔记</h1><h2 id=\"常用的48个关键字\"><a href=\"#常用的48个关键字\" class=\"headerlink\" title=\"常用的48个关键字\"></a>常用的48个关键字</h2><p><a href=\"https://tobebetterjavaer.com/about-the-author/\">沉默王二</a>2021年10月22日Java核心Java大约 4 分钟</p>\n<hr>\n<p>“二哥，就我之前学过的这些 Java 代码中，有 public、static、void、main 等等，它们应该都是关键字吧？”三妹的脸上泛着甜甜的笑容，我想她在学习 Java 方面已经变得越来越自信了。</p>\n<p>“是的，三妹。Java 中的关键字可不少呢！你一下子可能记不了那么多，不过，先保留个印象吧，对以后的学习会很有帮助。”</p>\n<p>PS：按照首字母的自然顺序排列。</p>\n<ol>\n<li><strong>abstract：</strong> 用于声明抽象类，以及抽象方法。</li>\n<li><strong>boolean：</strong> 用于将变量声明为布尔值类型，只有 true 和 false 两个值。</li>\n<li><strong>break：</strong> 用于中断循环或 switch 语句。</li>\n<li><strong>byte：</strong> 用于声明一个可以容纳 8 个比特的变量。</li>\n<li><strong>case：</strong> 用于在 switch 语句中标记条件的值。</li>\n<li><strong>catch：</strong> 用于捕获 try 语句中的异常。</li>\n<li><strong>char：</strong> 用于声明一个可以容纳无符号 16 位比特的 <a href=\"https://mp.weixin.qq.com/s/pNQjlXOivIgO3pbYc0GnpA\">Unicode 字符open in new window</a>的变量。</li>\n<li><strong>class：</strong> 用于声明一个类。</li>\n<li><strong>continue：</strong> 用于继续下一个循环，可以在指定条件下跳过其余代码。</li>\n<li><strong>default：</strong> 用于指定 switch 语句中除去 case 条件之外的默认代码块。</li>\n<li><strong>do：</strong> 通常和 while 关键字配合使用，do 后紧跟循环体。</li>\n<li><strong>double：</strong> 用于声明一个可以容纳 64 位浮点数的变量。</li>\n<li><strong>else：</strong> 用于指示 if 语句中的备用分支。</li>\n<li><strong>enum：</strong> 用于定义一组固定的常量（枚举）。</li>\n<li><strong>extends：</strong> 用于指示一个类是从另一个类或接口继承的。</li>\n<li><strong>final：</strong> 用于指示该变量是不可更改的。</li>\n<li><strong>finally：</strong> 和 <code>try-catch</code> 配合使用，表示无论是否处理异常，总是执行 finally 块中的代码。</li>\n<li><strong>float：</strong> 用于声明一个可以容纳 32 位浮点数的变量。</li>\n<li><strong>for：</strong> 用于声明一个 for 循环，如果循环次数是固定的，建议使用 for 循环。</li>\n<li><strong>if：</strong> 用于指定条件，如果条件为真，则执行对应代码。</li>\n<li><strong>implements：</strong> 用于实现接口。</li>\n<li><strong>import：</strong> 用于导入对应的类或者接口。</li>\n<li><strong>instanceof：</strong> 用于判断对象是否属于某个类型（class）。</li>\n<li><strong>int：</strong> 用于声明一个可以容纳 32 位带符号的整数变量。</li>\n<li><strong>interface：</strong> 用于声明接口。</li>\n<li><strong>long：</strong> 用于声明一个可以容纳 64 位整数的变量。</li>\n<li><strong>native：</strong> 用于指定一个方法是通过调用本机接口（非 Java）实现的。</li>\n<li><strong>new：</strong> 用于创建一个新的对象。</li>\n<li><strong>null：</strong> 如果一个变量是空的（什么引用也没有指向），就可以将它赋值为 null，和空指针异常息息相关。</li>\n<li><strong>package：</strong> 用于声明类所在的包。</li>\n<li><strong>private：</strong> 一个访问权限修饰符，表示方法或变量只对当前类可见。</li>\n<li><strong>protected：</strong> 一个访问权限修饰符，表示方法或变量对同一包内的类和所有子类可见。</li>\n<li><strong>public：</strong> 一个访问权限修饰符，除了可以声明方法和变量（所有类可见），还可以声明类。<code>main()</code> 方法必须声明为 public。</li>\n<li><strong>return：</strong> 用于在代码执行完成后返回（一个值）。</li>\n<li><strong>short：</strong> 用于声明一个可以容纳 16 位整数的变量。</li>\n<li><strong>static：</strong> 表示该变量或方法是静态变量或静态方法。</li>\n<li><strong>strictfp：</strong> 并不常见，通常用于修饰一个方法，确保方法体内的浮点数运算在每个平台上执行的结果相同。</li>\n<li><strong>super：</strong> 可用于调用父类的方法或者字段。</li>\n<li><strong>switch：</strong> 通常用于三个（以上）的条件判断。</li>\n<li><strong>synchronized：</strong> 用于指定多线程代码中的同步方法、变量或者代码块。</li>\n<li><strong>this：</strong> 可用于在方法或构造函数中引用当前对象。</li>\n<li><strong>throw：</strong> 主动抛出异常。</li>\n<li><strong>throws：</strong> 用于声明异常。</li>\n<li><strong>transient：</strong> 修饰的字段不会被序列化。</li>\n<li><strong>try：</strong> 于包裹要捕获异常的代码块。</li>\n<li><strong>void：</strong> 用于指定方法没有返回值。</li>\n<li><strong>volatile：</strong> 保证不同线程对它修饰的变量进行操作时的可见性，即一个线程修改了某个变量的值，新值对其他线程来说是立即可见的。</li>\n<li><strong>while：</strong> 如果循环次数不固定，建议使用 while 循环。</li>\n</ol>\n<h2 id=\"关键字顺序排序：\"><a href=\"#关键字顺序排序：\" class=\"headerlink\" title=\"关键字顺序排序：\"></a><strong>关键字顺序排序</strong>：</h2><p>byte&lt;short(char)&lt;int&lt;long&lt;float&lt;doublepackage step2;</p>\n<h2 id=\"用户自定义方法\"><a href=\"#用户自定义方法\" class=\"headerlink\" title=\"用户自定义方法\"></a><strong>用户自定义方法</strong></h2><h2 id=\"（tips：如果是静态方法，那么调用时就不用new关键字来创建对象来调用了）\"><a href=\"#（tips：如果是静态方法，那么调用时就不用new关键字来创建对象来调用了）\" class=\"headerlink\" title=\"（tips：如果是静态方法，那么调用时就不用new关键字来创建对象来调用了）\"></a>（tips：如果是静态方法，那么调用时就不用new关键字来创建对象来调用了）</h2><p>当预先定义方法无法满足我们的要求时，就需要自定义一些方法，比如说，我们来定义这样一个方法，用来检查数字是偶数还是奇数。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">findEvenOdd</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> num)</span> &#123;<br>    <span class=\"hljs-keyword\">if</span> (num % <span class=\"hljs-number\">2</span> == <span class=\"hljs-number\">0</span>) &#123;<br>        System.out.println(num + <span class=\"hljs-string\">&quot; 是偶数&quot;</span>);<br>    &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>        System.out.println(num + <span class=\"hljs-string\">&quot; 是奇数&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>方法名叫做 <code>findEvenOdd</code>，访问权限修饰符是 public，并且是静态的（static），返回类型是 void，参数有一个整型（int）的 num。方法体中有一个 if else 语句，如果 num 可以被 2 整除，那么就打印这个数字是偶数，否则就打印这个数字是奇数。</p>\n<p>方法被定义好后，如何被调用呢？</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * <span class=\"hljs-doctag\">@author</span> 微信搜「沉默王二」，回复关键字 PDF</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">EvenOddDemo</span> &#123;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> &#123;<br>        findEvenOdd(<span class=\"hljs-number\">10</span>);<br>        findEvenOdd(<span class=\"hljs-number\">11</span>);<br>    &#125;<br><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">findEvenOdd</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> num)</span> &#123;<br>        <span class=\"hljs-keyword\">if</span> (num % <span class=\"hljs-number\">2</span> == <span class=\"hljs-number\">0</span>) &#123;<br>            System.out.println(num + <span class=\"hljs-string\">&quot; 是偶数&quot;</span>);<br>        &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>            System.out.println(num + <span class=\"hljs-string\">&quot; 是奇数&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><code>main()</code> 方法是程序的入口，并且是静态的，那么就可以直接调用同样是静态方法的 <code>findEvenOdd()</code>。</p>\n<p>当一个方法被 static 关键字修饰时，它就是一个静态方法。换句话说，静态方法是属于类的，不属于类实例的（不需要通过 new 关键字创建对象来调用，直接通过类名就可以调用）。</p>\n<h2 id=\"访问权限控制\"><a href=\"#访问权限控制\" class=\"headerlink\" title=\"访问权限控制\"></a>访问权限控制</h2><h3 id=\"1-修饰类\"><a href=\"#1-修饰类\" class=\"headerlink\" title=\"1.修饰类\"></a><strong>1.修饰类</strong></h3><ul>\n<li>默认访问权限（包访问权限）：用来修饰类的话，表示该类只对同一个包中的其他类可见。</li>\n<li>public：用来修饰类的话，表示该类对其他所有的类都可见。</li>\n</ul>\n<h3 id=\"2-修饰类的方法和变量\"><a href=\"#2-修饰类的方法和变量\" class=\"headerlink\" title=\"2.修饰类的方法和变量\"></a><strong>2.修饰类的方法和变量</strong></h3><ul>\n<li>默认访问权限（包访问权限）：如果一个类的方法或变量被包访问权限修饰，也就意味着只能在同一个包中的其他类中显示地调用该类的方法或者变量，在不同包中的类中不能显式地调用该类的方法或变量。</li>\n<li>private：如果一个类的方法或者变量被 private 修饰，那么这个类的方法或者变量只能在该类本身中被访问，在类外以及其他类中都不能显式的进行访问。</li>\n<li>protected：如果一个类的方法或者变量被 protected 修饰，对于同一个包的类，这个类的方法或变量是可以被访问的。对于不同包的类，只有继承于该类的类才可以访问到该类的方法或者变量。</li>\n<li>public：被 public 修饰的方法或者变量，在任何地方都是可见的。</li>\n</ul>\n<h2 id=\"代码初始化块\"><a href=\"#代码初始化块\" class=\"headerlink\" title=\"代码初始化块\"></a>代码初始化块</h2><p>三个规则：</p>\n<ul>\n<li>类实例化的时候执行代码初始化块；</li>\n<li>实际上，代码初始化块是放在构造方法中执行的，只不过比较靠前；</li>\n<li>代码初始化块里的执行顺序是从前到后的。</li>\n</ul>\n<h2 id=\"补充：什么叫构造方法？有参？无参？\"><a href=\"#补充：什么叫构造方法？有参？无参？\" class=\"headerlink\" title=\"补充：什么叫构造方法？有参？无参？\"></a>补充：什么叫构造方法？有参？无参？</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">StudentDemo</span> &#123;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> &#123;<br>       <br>        <span class=\"hljs-comment\">// 类名称 对象名 = new 类名称();</span><br>        <span class=\"hljs-type\">Student</span> <span class=\"hljs-variable\">stu1</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Student</span>();           <span class=\"hljs-comment\">//无参构造方法执行</span><br>        <span class=\"hljs-type\">Student</span> <span class=\"hljs-variable\">stu2</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Student</span>(<span class=\"hljs-string\">&quot;张三&quot;</span>,<span class=\"hljs-number\">23</span>);   <span class=\"hljs-comment\">//全参构造方法执行</span><br>        <span class=\"hljs-comment\">//赋值</span><br>        stu1.setName(<span class=\"hljs-string\">&quot;李四&quot;</span>);<br>        stu1.setAge(<span class=\"hljs-number\">23</span>);<br>       <br>        <span class=\"hljs-comment\">//对象名.成员变量名；</span><br>        System.out.println(<span class=\"hljs-string\">&quot;姓名：&quot;</span>+stu1.getName()+<span class=\"hljs-string\">&quot;，年龄：&quot;</span>+ stu1.getAge());<br>        System.out.println(<span class=\"hljs-string\">&quot;姓名：&quot;</span>+stu2.getName()+<span class=\"hljs-string\">&quot;，年龄：&quot;</span>+ stu2.getAge());<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"方法的继承\"><a href=\"#方法的继承\" class=\"headerlink\" title=\"方法的继承\"></a>方法的继承</h2><p>关键字：extend，super（用于继承父类）</p>\n<p>“在默认情况下，子类的构造方法在执行的时候会主动去调用父类的构造方法。也就是说，其实是构造方法先执行的，再执行的代码初始化块。”</p>\n<p><strong>知识拓展：</strong></p>\n<p>什么是@Overwide?</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-meta\">@Override</span>是伪代码,表示重写(当然不写也可以)，不过写上有如下好处:<br><span class=\"hljs-number\">1</span>、可以当注释用,方便阅读；<br><span class=\"hljs-number\">2</span>、编译器可以给你验证<span class=\"hljs-meta\">@Override</span>下面的方法名是否是你父类中所有的，如果没有则报错。例如，你如果没写<span class=\"hljs-meta\">@Override</span>，而你下面的方法名又写错了，这时你的编译器是可以编译通过的，因为编译器以为这个方法是你的子类中自己增加的方法。<br> <br>举例：在重写父类的onCreate时，在方法前面加上<span class=\"hljs-meta\">@Override</span> 系统可以帮你检查方法的正确性。<br><span class=\"hljs-meta\">@Override</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">onCreate</span><span class=\"hljs-params\">(Bundle savedInstanceState)</span><br><br>&#123;…….&#125;<br>这种写法是正确的，如果你写成：<br><br><span class=\"hljs-meta\">@Override</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">oncreate</span><span class=\"hljs-params\">(Bundle savedInstanceState)</span><br>&#123;…….&#125;<br>编译器会报如下错误：The method <span class=\"hljs-title function_\">oncreate</span><span class=\"hljs-params\">(Bundle)</span> of type HelloWorld must override or implement a supertype method，以确保你正确重写onCreate方法（因为oncreate应该为onCreate）。而如果你不加<span class=\"hljs-meta\">@Override</span>，则编译器将不会检测出错误，而是会认为你为子类定义了一个新方法：oncreate<br></code></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"抽象类\"><a href=\"#抽象类\" class=\"headerlink\" title=\"抽象类\"></a>抽象类</h2><h3 id=\"敲黑板知识点：\"><a href=\"#敲黑板知识点：\" class=\"headerlink\" title=\"敲黑板知识点：\"></a>敲黑板知识点：</h3><p><strong>写在前面：</strong></p>\n<p>什么是抽象？抽象的含义？</p>\n<p>​        抽象是不确定的、不具体的概念或事物。在Java中的抽象类，是指需要在子类中通过方法扩展来实现新的方法。</p>\n<p><strong>关键字：</strong>abstract</p>\n<p><strong>语句格式：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Java\"><span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">AbstractPlayer</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><strong>命名规则：</strong></p>\n<p>关于抽象类的命名，《阿里的 Java 开发手册》上有强调，“抽象类命名要使用 Abstract 或 Base 开头”，这条规约还是值得遵守的。</p>\n<p><strong>Tips：</strong></p>\n<p>抽象类是不能实例化的，尝试通过 <code>new</code> 关键字实例化的话，编译器会报错，提示“类是抽象的，不能实例化”。</p>\n<p>虽然抽象类不能实例化，但可以有子类。子类通过 <code>extends</code> 关键字来继承抽象类。就像下面这样。</p>\n<p>Demo code:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">BasketballPlayer</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">AbstractPlayer</span> &#123;<br>&#125;<br><br></code></pre></td></tr></table></figure>\n\n<p>抽象的方法不能定义在普通类中。否则会在类和方法处出现两个报错。</p>\n<p>错误提示。第一处在类级别上，提示“这个类必须通过 <code>abstract</code> 关键字定义”，见下图。</p>\n<p><img src=\"http://cdn.tobebetterjavaer.com/tobebetterjavaer/images/object-class/abstract-02.png\" alt=\"img\"></p>\n<p>第二处在尝试定义 abstract 的方法上，提示“抽象方法所在的类不是抽象的”，见下图。</p>\n<p><img src=\"http://cdn.tobebetterjavaer.com/tobebetterjavaer/images/object-class/abstract-03.png\" alt=\"img\"></p>\n<p><strong>But,抽象类中既可以定义抽象方法、也可以普通方法。</strong></p>\n<h3 id=\"抽象方法的应用场景\"><a href=\"#抽象方法的应用场景\" class=\"headerlink\" title=\"抽象方法的应用场景\"></a>抽象方法的应用场景</h3><p><strong>第一种场景</strong>。</p>\n<p>当我们希望一些通用的功能被多个子类复用的时候，就可以使用抽象类。比如说，<code>AbstractPlayer</code> 抽象类中有一个普通的方法 <code>sleep()</code>，表明所有运动员都需要休息，那么这个方法就可以被子类复用。</p>\n<p>Demo:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">AbstractPlayer</span> &#123;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">sleep</span><span class=\"hljs-params\">()</span> &#123;<br>        System.out.println(<span class=\"hljs-string\">&quot;运动员也要休息而不是挑战极限&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>子类 <code>BasketballPlayer</code> 继承了 <code>AbstractPlayer</code> 类：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">BasketballPlayer</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">AbstractPlayer</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>也就拥有了 <code>sleep()</code> 方法。<code>BasketballPlayer </code>的对象可以直接调用父类的 <code>sleep() </code>方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-type\">BasketballPlayer</span> <span class=\"hljs-variable\">basketballPlayer</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">BasketballPlayer</span>();<br>basketballPlayer.sleep();<br></code></pre></td></tr></table></figure>\n\n<p>如此，就实现了代码的复用。</p>\n<p><strong>第二种场景</strong>。</p>\n<p>当我们需要在抽象类中定义好 <code>API</code>，然后在子类中扩展实现的时候就可以使用抽象类。比如说，<code>AbstractPlayer</code> 抽象类中定义了一个抽象方法 <code>play()</code>，表明所有运动员都可以从事某项运动，但需要对应子类去扩展实现，表明篮球运动员打篮球，足球运动员踢足球。</p>\n<p><strong>知识拓展：</strong></p>\n<p>什么是API？</p>\n<p>API（Application Programming Interface,应用程序编程接口）是一些预先定义的函数，目的是提供应用程序与开发人员基于某软件或硬件得以访问一组例程的能力，而又无需访问源码，或理解内部工作机制的细节。”</p>\n<p><strong>抽象类实例：</strong></p>\n<p>读取大小写helloworld：</p>\n<p><a href=\"\">https://tobebetterjavaer.com/oo/abstract.html</a></p>\n<h2 id=\"接口\"><a href=\"#接口\" class=\"headerlink\" title=\"接口\"></a>接口</h2><p>关键字：</p>\n<p>interface</p>\n<p>语法格式：</p>\n<p>public interface jiekou1</p>\n<p>class A extends B implements jiekou1,jiekou2,jiekou3</p>\n<p>小结论：</p>\n<ul>\n<li>接口中允许定义变量</li>\n<li>接口中允许定义抽象方法</li>\n<li>接口中允许定义静态方法（Java 8 之后）</li>\n<li>接口中允许定义默认方法（Java 8 之后）</li>\n</ul>\n<p>除此之外，我们还应该知道：</p>\n<p>1）接口不允许直接实例化，否则编译器会报错。</p>\n<p><img src=\"http://cdn.tobebetterjavaer.com/tobebetterjavaer/images/object-class/interface-04.png\" alt=\"img\"></p>\n<p>需要定义一个类去实现接口，见下例。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Computer</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title class_\">Electronic</span> &#123;<br><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> &#123;<br>        <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Computer</span>();<br>    &#125;<br><br>    <span class=\"hljs-meta\">@Override</span><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">getElectricityUse</span><span class=\"hljs-params\">()</span> &#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>然后再实例化。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Java\"><span class=\"hljs-type\">Electronic</span> <span class=\"hljs-variable\">e</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Computer</span>();<br></code></pre></td></tr></table></figure>\n\n<p>知识点拓展：</p>\n<p>JAVA中extends 与implements有啥区别？</p>\n<ol>\n<li>在类的声明中，通过关键字extends来创建一个类的子类。一个类通过关键字implements声明自己使用一个或者多个接口。<br>extends 是继承某个类, 继承之后可以使用父类的方法, 也可以重写父类的方法; implements 是实现多个接口, 接口的方法一般为空的, 必须重写才能使用</li>\n<li>extends是继承父类，只要那个类不是声明为final或者那个类定义为abstract的就能继承，JAVA中不支持多重继承，但是可以用接口 来实现，这样就要用到implements，继承只能继承一个类，但implements可以实现多个接口，用逗号分开就行了<br>比如<br>class A extends B implements C,D,E</li>\n</ol>\n<p><a href=\"https://blog.csdn.net/android_lover2014/article/details/52176814\">(56条消息) Java之implements_小白study的博客-CSDN博客_implements</a></p>\n<p>作业：多态与重载</p>\n<p>​            构造与重载</p>\n<p>​            抽象类与接口？</p>\n<h2 id=\"内部类\"><a href=\"#内部类\" class=\"headerlink\" title=\"内部类\"></a>内部类</h2><p><strong>== = = = = = = <a href=\"https://so.csdn.net/so/search?q=%E5%86%85%E9%83%A8%E7%B1%BB&spm=1001.2101.3001.7020\">内部类</a>（四种内部类详解）= = = = = = = ==</strong></p>\n<p><strong>一、基本介绍：一个类的内部又完整的嵌套了另一个类结构。被嵌套的类称为内部类(inner class),嵌套其他类的类称为外部类(outer class)。是我们类的第五大成员【思考:类的五大成员是哪些?[属性、方法、构造器、代码块、内部类]】，内部类最大的特点就是可以直接访问私有属性，并且可以体现类与类之间的包含关系，注意:内部类是学习的难点,同时也是重点,后面看底层源码时,有大量的内部类.</strong><br><strong>如果定义类在局部位置(方法中/代码块) :(1) 局部内部类 (2) 匿名内部类<br>定义在成员位置 (1) 成员内部类 (2)静态内部类</strong></p>\n<p>在 Java 中，可以将一个类定义在另外一个类里面或者一个方法里面，这样的类叫做内部类。</p>\n<p><strong>二、基本语法</strong><br><strong>class Outer{ //外部类<br>class Inner{ //内部类<br>}<br>}<br>class Other{ //外部其他类<br>}</strong></p>\n<p>三、分类</p>\n<p>一般来说，内部类分为成员内部类、局部内部类、匿名内部类和静态内部类。</p>\n<p>定义在外部类的局部位置上(如方法内):<br>1)局部内部类(有类名)<br>2)匿名内部类(没有类名，重点!!!)</p>\n<p>定义在外部类的成员位置上:<br>1)成员内部类(没用static修饰)<br>2)静态内部类（使用static修饰)</p>\n<p><strong>1.成员内部类：</strong></p>\n<p>成员内部类可以无限制访问外部类的所有成员属性。</p>\n<p>内部类可以随心所欲地访问外部类的成员，但外部类想要访问内部类的成员，就不那么容易了，必须先创建一个成员内部类的对象，再通过这个对象来访问：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Wanger</span> &#123;<br>    <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">age</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">18</span>;<br>    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">name</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;沉默王二&quot;</span>;<br>    <span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">double</span> <span class=\"hljs-variable\">money</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">1</span>;<br><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-title function_\">Wanger</span> <span class=\"hljs-params\">()</span> &#123;<br>        <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Wangxiaoer</span>().print();<br>    &#125;<br><br>    <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Wangxiaoer</span> &#123;<br>        <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">age</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">81</span>;<br><br>        <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">print</span><span class=\"hljs-params\">()</span> &#123;<br>            System.out.println(name);<br>            System.out.println(money);<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>\n\n<p>这种创建内部类的方式在实际开发中并不常用，因为内部类和外部类紧紧地绑定在一起，使用起来非常不便。</p>\n<p><strong>2.局部内部类</strong></p>\n<p><strong>3.匿名内部类</strong></p>\n<p><strong>4.静态内部类</strong></p>\n<p>第一，静态内部类不能访问外部类的所有成员变量；</p>\n<p>第二，静态内部类可以访问外部类的所有静态变量，包括私有静态变量。</p>\n<p>第三，外部类不能声明为 static。”</p>\n<p>“三妹，你看，在 Singleton 类上加 static 后，编译器就提示错误了。”</p>\n<p><img src=\"http://cdn.tobebetterjavaer.com/tobebetterjavaer/images/keywords/19-08.png\" alt=\"img\"></p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>为什么要使用内部类？</p>\n<p>在《Think in java》中有这样一句话：</p>\n<blockquote>\n<p>使用内部类最吸引人的原因是：每个内部类都能独立地继承一个（接口的）实现，所以无论外围类是否已经继承了某个（接口的）实现，对于内部类都没有影响。</p>\n</blockquote>\n<p>在我们程序设计中有时候会存在一些使用接口很难解决的问题，这个时候我们可以利用内部类提供的、可以继承多个具体的或者抽象的类的能力来解决这些程序设计问题。可以这样说，接口只是解决了部分问题，而内部类使得多重继承的解决方案变得更加完整。</p>\n<p>使用内部类还能够为我们带来如下特性（摘自《Think in java》）：</p>\n<ul>\n<li>1、内部类可以使用多个实例，每个实例都有自己的状态信息，并且与其他外围对象的信息相互独立。</li>\n<li>2、在单个外部类中，可以让多个内部类以不同的方式实现同一个接口，或者继承同一个类。</li>\n<li>3、创建内部类对象的时刻并不依赖于外部类对象的创建。</li>\n<li>4、内部类并没有令人迷惑的“is-a”关系，他就是一个独立的实体。</li>\n<li>5、内部类提供了更好的封装，除了该外围类，其他类都不能访问。</li>\n</ul>\n<h2 id=\"关键字\"><a href=\"#关键字\" class=\"headerlink\" title=\"关键字\"></a>关键字</h2><h3 id=\"1-static\"><a href=\"#1-static\" class=\"headerlink\" title=\"1.static\"></a>1.static</h3><p><strong>static的作用</strong></p>\n<p>“static 关键字的作用可以用一句话来描述：‘<strong>方便在没有创建对象的情况下进行调用</strong>，包括变量和方法’。也就是说，只要类被加载了，就可以通过类名进行访问。”我扶了扶沉重眼镜，继续说到，“static 可以用来修饰类的成员变量，以及成员方法。我们一个个来看。”</p>\n<p>demo：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Counter</span> &#123;<br>    <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">count</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span>;<br><br>    Counter() &#123;<br>        count++;<br>        System.out.println(count);<br>    &#125;<br><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String args[])</span> &#123;<br>        <span class=\"hljs-type\">Counter</span> <span class=\"hljs-variable\">c1</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Counter</span>();<br>        <span class=\"hljs-type\">Counter</span> <span class=\"hljs-variable\">c2</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Counter</span>();<br>        <span class=\"hljs-type\">Counter</span> <span class=\"hljs-variable\">c3</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Counter</span>();<br>    &#125;<br>&#125;<br><span class=\"hljs-comment\">/*</span><br><span class=\"hljs-comment\">我们创建一个成员变量 count，并且在构造函数中让它自增。因为成员变量会在创建对象的时候获取内存，因此每一个对象都会有一个 count 的副本， count 的值并不会随着对象的增多而递增。</span><br><span class=\"hljs-comment\">*/</span><br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">StaticCounter</span> &#123;<br>    <span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">count</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span>;<br><br>    StaticCounter() &#123;<br>        count++;<br>        System.out.println(count);<br>    &#125;<br><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String args[])</span> &#123;<br>        <span class=\"hljs-type\">StaticCounter</span> <span class=\"hljs-variable\">c1</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">StaticCounter</span>();<br>        <span class=\"hljs-type\">StaticCounter</span> <span class=\"hljs-variable\">c2</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">StaticCounter</span>();<br>        <span class=\"hljs-type\">StaticCounter</span> <span class=\"hljs-variable\">c3</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">StaticCounter</span>();<br>    &#125;<br>&#125;<br><span class=\"hljs-comment\">/*</span><br><span class=\"hljs-comment\">简单解释一下哈，由于静态变量只会获取一次内存空间，所以任何对象对它的修改都会得到保留，所以每创建一个对象，count 的值就会加 1，所以最终的结果是 3，明白了吧？三妹。这就是静态变量和成员变量之间的差别。</span><br><span class=\"hljs-comment\">*/</span><br></code></pre></td></tr></table></figure>\n\n<p>warnning:</p>\n<p>“另外，需要注意的是，由于静态变量属于一个类，所以不要通过对象引用来访问，而应该直接通过类名来访问，否则编译器会发出警告。”</p>\n<p><img src=\"http://cdn.tobebetterjavaer.com/tobebetterjavaer/images/keywords/19-03.png\" alt=\"img\"></p>\n<p>static的特点：</p>\n<ul>\n<li>静态方法属于这个类而不是这个类的对象；</li>\n</ul>\n<p>​        （因为静态方法不用类的实例化，所以直接通过类来调用，不通过类的实例来调用，因此不应通过对象调用）</p>\n<ul>\n<li>调用静态方法的时候不需要创建这个类的对象；</li>\n<li>静态方法可以访问静态变量。</li>\n</ul>\n<p>那么问题来了，为什么main方法是静态的，这就涉及到Java的编译器JVM了，为了代码简洁与方便调用，main函数作为程序的入口，所以设为静态更为合适。</p>\n<p>二哥这么说：</p>\n<p><code>“如果 main 方法不是静态的，就意味着 Java 虚拟机在执行的时候需要先创建一个对象才能调用 main 方法，而 main 方法作为程序的入口，创建一个额外的对象显得非常多余。”我不假思索的回答令三妹感到非常的钦佩。</code></p>\n<p>“java.lang.Math 类的几乎所有方法都是静态的，可以直接通过类名来调用，不需要创建类的对象。”</p>\n<p><img src=\"http://cdn.tobebetterjavaer.com/tobebetterjavaer/images/keywords/19-06.png\" alt=\"img\"></p>\n<p>综上所述（由上可得）：</p>\n<p>一些函数基本上都是静态的。</p>\n<h3 id=\"静态代码块\"><a href=\"#静态代码块\" class=\"headerlink\" title=\"静态代码块\"></a>静态代码块</h3><p>“除了静态变量和静态方法，static 关键字还有一个重要的作用。”我心情愉悦地对三妹说，“用一个 static 关键字，外加一个大括号括起来的代码被称为静态代码块。”</p>\n<p>“就像下面这串代码。”</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">StaticBlock</span> &#123;<br>    <span class=\"hljs-keyword\">static</span> &#123;<br>        System.out.println(<span class=\"hljs-string\">&quot;静态代码块&quot;</span>);<br>    &#125;<br><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> &#123;<br>        System.out.println(<span class=\"hljs-string\">&quot;main 方法&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>“静态代码块通常用来初始化一些静态变量，它会优先于 <code>main()</code> 方法执行。”</p>\n<h3 id=\"2-this\"><a href=\"#2-this\" class=\"headerlink\" title=\"2.this\"></a>2.this</h3><p>this除了可以指向当前方法或者构造函数的对象，还可以完成以下工作：</p>\n<ul>\n<li>调用当前类的方法；</li>\n<li><code>this()</code> 可以调用当前类的构造方法；</li>\n<li>this 可以作为参数在方法中传递；</li>\n<li>this 可以作为参数在构造方法中传递；</li>\n<li>this 可以作为方法的返回值，返回当前类的对象。</li>\n</ul>\n<h3 id=\"01、-指向当前对象\"><a href=\"#01、-指向当前对象\" class=\"headerlink\" title=\"01、 指向当前对象\"></a>01、 指向当前对象</h3><p><strong>demo</strong>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Java\">WithoutThisStudent(String name, <span class=\"hljs-type\">int</span> age) &#123;<br>        name = name;<br>        age = age;<br>    &#125;<br><br></code></pre></td></tr></table></figure>\n\n<p>伪代码运行结果：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Java\"><span class=\"hljs-literal\">null</span>\t<span class=\"hljs-number\">0</span><br><br><span class=\"hljs-literal\">null</span>\t<span class=\"hljs-number\">0</span><br></code></pre></td></tr></table></figure>\n\n<p>更改之后的demo:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">WithThisStudent(String name, <span class=\"hljs-type\">int</span> age) &#123;<br>        <span class=\"hljs-built_in\">this</span>.name = name;<br>        <span class=\"hljs-built_in\">this</span>.age = age;<br>    &#125;<br></code></pre></td></tr></table></figure>\n\n<p>运行正确√</p>\n<h3 id=\"02、调用当前类的方法\"><a href=\"#02、调用当前类的方法\" class=\"headerlink\" title=\"02、调用当前类的方法\"></a>02、调用当前类的方法</h3><p>“我们可以在一个类中使用 this 关键字来调用另外一个方法，如果没有使用的话，编译器会自动帮我们加上。”我对自己深厚的编程功底充满自信，“在源代码中，<code>method2()</code> 在调用 <code>method1()</code> 的时候并没有使用 this 关键字，但通过反编译后的字节码可以看得到。”</p>\n<h3 id=\"03、调用当前类的构造方法\"><a href=\"#03、调用当前类的构造方法\" class=\"headerlink\" title=\"03、调用当前类的构造方法\"></a>03、调用当前类的构造方法</h3><p>调用无参的constructor</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">InvokeConstrutor</span> &#123;<br>    InvokeConstrutor() &#123;<br>        System.out.println(<span class=\"hljs-string\">&quot;hello&quot;</span>);<br>    &#125;<br><br>    InvokeConstrutor(<span class=\"hljs-type\">int</span> count) &#123;<br>        <span class=\"hljs-built_in\">this</span>();<br>        System.out.println(count);<br>    &#125;<br><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> &#123;<br>        <span class=\"hljs-type\">InvokeConstrutor</span> <span class=\"hljs-variable\">invokeConstrutor</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">InvokeConstrutor</span>(<span class=\"hljs-number\">10</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n\n\n<p>“也可以在无参构造方法中使用 <code>this()</code> 并传递参数来调用有参构造方法。”话音没落，我就在键盘上敲了起来，“来看下面这段代码。”</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">InvokeParamConstrutor</span> &#123;<br>    InvokeParamConstrutor() &#123;<br>        <span class=\"hljs-built_in\">this</span>(<span class=\"hljs-number\">10</span>);<br>        System.out.println(<span class=\"hljs-string\">&quot;hello&quot;</span>);<br>    &#125;<br><br>    InvokeParamConstrutor(<span class=\"hljs-type\">int</span> count) &#123;<br>        System.out.println(count);<br>    &#125;<br><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> &#123;<br>        <span class=\"hljs-type\">InvokeParamConstrutor</span> <span class=\"hljs-variable\">invokeConstrutor</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">InvokeParamConstrutor</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n\n\n<p>warning：</p>\n<p>“不过，需要注意的是，<code>this()</code> 必须放在构造方法的第一行，否则就报错了。”</p>\n<p><img src=\"http://cdn.tobebetterjavaer.com/tobebetterjavaer/images/keywords/20-01.png\" alt=\"img\"></p>\n<h3 id=\"04、作为参数在方法中传递（没看懂\"><a href=\"#04、作为参数在方法中传递（没看懂\" class=\"headerlink\" title=\"*04、作为参数在方法中传递（没看懂\"></a>*04、作为参数在方法中传递（没看懂</h3><h3 id=\"05、作为参数在构造方法中传递\"><a href=\"#05、作为参数在构造方法中传递\" class=\"headerlink\" title=\"05、作为参数在构造方法中传递\"></a>05、作为参数在构造方法中传递</h3><h3 id=\"06、作为方法的返回值\"><a href=\"#06、作为方法的返回值\" class=\"headerlink\" title=\"06、作为方法的返回值\"></a>06、作为方法的返回值</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ThisAsMethodResult</span> &#123;<br>    ThisAsMethodResult <span class=\"hljs-title function_\">getThisAsMethodResult</span><span class=\"hljs-params\">()</span> &#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">this</span>;<br>    &#125;<br>    <br>    <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">out</span><span class=\"hljs-params\">()</span> &#123;<br>        System.out.println(<span class=\"hljs-string\">&quot;hello&quot;</span>);<br>    &#125;<br><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> &#123;<br>        <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ThisAsMethodResult</span>().getThisAsMethodResult().out();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>“<code>getThisAsMethodResult()</code> 方法返回了 this 关键字，指向的就是 <code>new ThisAsMethodResult()</code> 这个对象，所以可以紧接着调用 <code>out()</code> 方法——达到了链式调用的目的，这也是 this 关键字非常经典的一种用法。”</p>\n<h3 id=\"3-super\"><a href=\"#3-super\" class=\"headerlink\" title=\"3.super\"></a>3.super</h3><p>“super 关键字的用法主要有三种。”</p>\n<ul>\n<li>指向父类对象；</li>\n<li>调用父类的方法；</li>\n<li><code>super()</code> 可以调用父类的构造方法。</li>\n</ul>\n<h3 id=\"4-final\"><a href=\"#4-final\" class=\"headerlink\" title=\"4.final\"></a>4.final</h3><p>什么是序列化？</p>\n<p>序列化是什么意思呢？Java 的序列化是指，将对象转换成以字节序列的形式来表示，这些字节序中包含了对象的字段和方法。序列化后的对象可以被写到数据库、写到文件，也可用于网络传输。</p>\n<p>“被 final 修饰的变量无法重新赋值。换句话说，final 变量一旦初始化，就无法更改。”</p>\n<p><strong>final类：</strong></p>\n<p>“如果一个类使用了 final 关键字修饰，那么它就无法被继承…..”</p>\n<p>“等等，哥，我知道，String 类就是一个 final 类。”还没等我说完，三妹就抢着说到。</p>\n<p>“说得没毛病。”</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">String</span><br>    <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title class_\">java</span>.io.Serializable, Comparable&lt;String&gt;, CharSequence,<br>               Constable, ConstantDesc &#123;&#125;<br></code></pre></td></tr></table></figure>\n\n<p>⚠️⚠️⚠️：String 是 immutable 类（不可变对象）</p>\n<p>“那三妹你知道为什么 String 类要设计成 final 吗？”</p>\n<p>“这个还真不知道。”三妹的表情透露出这种无奈。</p>\n<p>“原因大致有 3 个。”</p>\n<ul>\n<li>为了实现字符串常量池的需要</li>\n<li>为了线程安全的需要</li>\n<li>为了 HashCode 的不可变性的需要</li>\n</ul>\n<p>“想了解更详细的原因，可以一会看看我之前写的这篇文章。”</p>\n<p><a href=\"https://mp.weixin.qq.com/s/CRQrm5zGpqWxYL_ztk-b2Q\">为什么 Java 字符串是不可变的？</a></p>\n<h3 id=\"5-instanceof\"><a href=\"#5-instanceof\" class=\"headerlink\" title=\"5.instanceof\"></a>5.instanceof</h3><p>语法格式：</p>\n<p><code>(object) instanceof (type)</code></p>\n<p>​    对象                                类型</p>\n<p>用意也非常简单，判断对象是否符合指定的类型，结果要么是 true，要么是 false。在反序列化的时候，instanceof 操作符还是蛮常用的，因为这时候我们不太确定对象属不属于指定的类型，如果不进行判断的话，就容易抛出 ClassCastException 异常。</p>\n<p>Java 是一门面向对象的编程语言，也就意味着除了基本数据类型，所有的类都会隐式继承 Object 类。所以下面的结果肯定也会输出 true。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-type\">Thread</span> <span class=\"hljs-variable\">thread</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Thread</span>();<br>System.out.println(thread <span class=\"hljs-keyword\">instanceof</span> Object);<br></code></pre></td></tr></table></figure>\n\n<p>如何使用？</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">// 先判断类型</span><br><span class=\"hljs-keyword\">if</span> (obj <span class=\"hljs-keyword\">instanceof</span> String) &#123;<br>    <span class=\"hljs-comment\">// 然后强制转换</span><br>    <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">s</span> <span class=\"hljs-operator\">=</span> (String) obj;<br>    <span class=\"hljs-comment\">// 然后才能使用</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>先用 instanceof 进行类型判断，然后再把 obj 强制转换成我们期望的类型再进行使用。</p>\n<p>JDK 16 的时候，instanceof 模式匹配转了正，意味着使用 instanceof 的时候更便捷了。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">if</span> (obj <span class=\"hljs-keyword\">instanceof</span> String s) &#123;<br>    <span class=\"hljs-comment\">// 如果类型匹配 直接使用 s</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"不可变对象\"><a href=\"#不可变对象\" class=\"headerlink\" title=\"*不可变对象\"></a>*不可变对象</h2><h3 id=\"01、什么是不可变类？\"><a href=\"#01、什么是不可变类？\" class=\"headerlink\" title=\"01、什么是不可变类？\"></a>01、什么是不可变类？</h3><p>一个类的对象在通过构造方法创建后如果状态不会再被改变，那么它就是一个不可变（immutable）类。它的所有成员变量的赋值仅在构造方法中完成，不会提供任何 setter 方法供外部类去修改。</p>\n<p>自从有了<strong>多线程</strong>，生产力就被无限地放大了，所有的程序员都爱它，因为强大的硬件能力被充分地利用了。但与此同时，所有的程序员都对它心生忌惮，因为一不小心，多线程就会把<strong>对象的状态变得混乱不堪</strong>。</p>\n<p>引入关键字：synchronized(同步)</p>\n<p>为了保护状态的原子性、可见性、有序性，我们程序员可以说是竭尽所能。其中，synchronized（同步）关键字是最简单最入门的一种解决方案。</p>\n<p>假如说类是不可变的，那么对象的状态就也是不可变的。这样的话，每次修改对象的状态，就会产生一个新的对象供不同的线程使用，我们程序员就不必再担心并发问题了。</p>\n<h3 id=\"02、常见的不可变类\"><a href=\"#02、常见的不可变类\" class=\"headerlink\" title=\"02、常见的不可变类\"></a>02、常见的不可变类</h3><p>String类</p>\n<p>为什么要将String类设置为不可变类？</p>\n<p>原因如下：</p>\n<p>1）常量池的需要</p>\n<p>字符串常量池是 Java 堆内存中一个特殊的存储区域，当创建一个 String 对象时，假如此字符串在常量池中不存在，那么就创建一个；假如已经存，就不会再创建了，而是直接引用已经存在的对象。这样做能够减少 JVM 的内存开销，提高效率。</p>\n<p>2）hashCode 的需要</p>\n<p>因为字符串是不可变的，所以在它创建的时候，其 hashCode 就被缓存了，因此非常适合作为哈希值（比如说作为 HashMap 的键），多次调用只返回同一个值，来提高效率。</p>\n<p>3）线程安全</p>\n<p>就像之前说的那样，如果对象的状态是可变的，那么在多线程环境下，就很容易造成不可预期的结果。而 String 是不可变的，就可以在多个线程之间共享，不需要同步处理。</p>\n<p>因此，当我们调用 String 类的任何方法（比如说 <code>trim()</code>、<code>substring()</code>、<code>toLowerCase()</code>）时，总会返回一个新的对象，而不影响之前的值。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">cmower</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;沉默王二，一枚有趣的</span><br></code></pre></td></tr></table></figure>\n\n\n\n\n\n<h2 id=\"可变参数\"><a href=\"#可变参数\" class=\"headerlink\" title=\"*可变参数\"></a>*可变参数</h2><h2 id=\"泛型\"><a href=\"#泛型\" class=\"headerlink\" title=\"泛型\"></a>泛型</h2><h3 id=\"什么是泛型\"><a href=\"#什么是泛型\" class=\"headerlink\" title=\"什么是泛型\"></a>什么是泛型</h3><blockquote>\n<p>泛型：就是指在类定义时不会设置类中的属性或方法参数的具体类型，而是在类使用时（创建对象）再进行类型的定义。会在编译期检查类型是否错误。</p>\n</blockquote>\n<p><img src=\"https://img-blog.csdnimg.cn/101412155b854d98891f6c0facdfde7f.png\"></p>\n<p>类声明后的&lt;&gt;中这个T被称为类型参数，用于指代任意类型，实际上这个T只是个代表，写什么都可以。表示此时的value1，value2都是在类定义时没有明确类型，只有在使用时才告知编译器类型。出于规范，类型参数用单个的大写字母来代替，常见如下：</p>\n<ul>\n<li>T：代表任意类</li>\n<li>E：表示Element的意思，或是异常</li>\n<li>K：与V搭配使用</li>\n<li>V：与K搭配使用</li>\n</ul>\n<p>以下内容来源于<a href=\"https://www.pdai.tech/md/java/basic/java-basic-x-generic.html\">Java全栈体系</a>:</p>\n<p><strong>通过泛型可以将不同数据类型的add()方法复用为一个方法：</strong></p>\n<p><code>eg:</code>泛型add()方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Java\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> &lt;T <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">Number</span>&gt; <span class=\"hljs-type\">double</span> <span class=\"hljs-title function_\">add</span><span class=\"hljs-params\">(T a, T b)</span> &#123;<br>    System.out.println(a + <span class=\"hljs-string\">&quot;+&quot;</span> + b + <span class=\"hljs-string\">&quot;=&quot;</span> + (a.doubleValue() + b.doubleValue()));<br>    <span class=\"hljs-keyword\">return</span> a.doubleValue() + b.doubleValue();<br>&#125;<br></code></pre></td></tr></table></figure>\n\n\n\n<ul>\n<li>泛型中的类型在使用时指定，不需要强制类型转换（<strong>类型安全</strong>，编译器会<strong>检查类型</strong>）</li>\n</ul>\n<p>看下这个例子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-type\">List</span> <span class=\"hljs-variable\">list</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ArrayList</span>();<br>list.add(<span class=\"hljs-string\">&quot;xxString&quot;</span>);<br>list.add(<span class=\"hljs-number\">100d</span>);<br>list.add(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Person</span>());        <br></code></pre></td></tr></table></figure>\n\n<p>我们在使用上述list中，list中的元素都是Object类型（无法约束其中的类型），所以在取出集合元素时需要人为的强制类型转化到具体的目标类型，且很容易出现<code>java.lang.ClassCastException</code>异常。</p>\n<p>引入泛型，它将提供类型的约束，提供编译前的检查：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Java\">List&lt;String&gt; list = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ArrayList</span>&lt;String&gt;();<br><br><span class=\"hljs-comment\">// list中只能放String, 不能放其它类型的元素</span><br></code></pre></td></tr></table></figure>\n\n<p>更多内容请见：</p>\n<p><a href=\"https://www.pdai.tech/md/java/basic/java-basic-x-generic.html\">https://www.pdai.tech/md/java/basic/java-basic-x-generic.html</a></p>\n<h2 id=\"注解\"><a href=\"#注解\" class=\"headerlink\" title=\"注解\"></a>注解</h2><p>直接开始上实例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Java\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">A</span>&#123;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">test</span><span class=\"hljs-params\">()</span> &#123;<br>        <br>    &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">B</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">A</span>&#123;<br><br>    <span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">        * 重载父类的test方法</span><br><span class=\"hljs-comment\">        */</span><br>    <span class=\"hljs-meta\">@Override</span><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">test</span><span class=\"hljs-params\">()</span> &#123;<br>    &#125;<br><br>    <span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">        * 被弃用的方法</span><br><span class=\"hljs-comment\">        */</span><br>    <span class=\"hljs-meta\">@Deprecated</span><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">oldMethod</span><span class=\"hljs-params\">()</span> &#123;<br>    &#125;<br><br>    <span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">        * 忽略告警</span><br><span class=\"hljs-comment\">        * </span><br><span class=\"hljs-comment\">        * <span class=\"hljs-doctag\">@return</span></span><br><span class=\"hljs-comment\">        */</span><br>    <span class=\"hljs-meta\">@SuppressWarnings(&quot;rawtypes&quot;)</span><br>    <span class=\"hljs-keyword\">public</span> List <span class=\"hljs-title function_\">processList</span><span class=\"hljs-params\">()</span> &#123;<br>        <span class=\"hljs-type\">List</span> <span class=\"hljs-variable\">list</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ArrayList</span>();<br>        <span class=\"hljs-keyword\">return</span> list;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>\n\n<p>Java 1.5开始自带的标准注解，包括<code>@Override</code>、<code>@Deprecated</code>和<code>@SuppressWarnings</code>：</p>\n<ul>\n<li><code>@Override</code>：表示当前的方法定义将覆盖父类中的方法</li>\n<li><code>@Deprecated</code>：表示代码被弃用，如果使用了被@Deprecated注解的代码则编译器将发出警告</li>\n<li><code>@SuppressWarnings</code>：表示关闭编译器警告信息</li>\n</ul>\n<h2 id=\"枚举（enum）\"><a href=\"#枚举（enum）\" class=\"headerlink\" title=\"枚举（enum）\"></a>枚举（enum）</h2><p><strong>定义：</strong></p>\n<p>“枚举（enum），是 Java 1.5 时引入的关键字，它表示一种特殊类型的类，继承自 java.lang.Enum。”</p>\n<p>“我们来新建一个枚举 PlayerType。”</p>\n<p>eg:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">enum</span> <span class=\"hljs-title class_\">PlayerType</span> &#123;<br>    TENNIS,<br>    FOOTBALL,<br>    BASKETBALL<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>01 “既然枚举是一种特殊的类，那它其实是可以定义在一个类的内部的，这样它的作用域就可以限定于这个外部类中使用。”我说。</p>\n<p>eg:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Player</span> &#123;<br>    <span class=\"hljs-keyword\">private</span> PlayerType type;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">enum</span> <span class=\"hljs-title class_\">PlayerType</span> &#123;<br>        TENNIS,<br>        FOOTBALL,<br>        BASKETBALL<br>    &#125;<br>    <br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-type\">boolean</span> <span class=\"hljs-title function_\">isBasketballPlayer</span><span class=\"hljs-params\">()</span> &#123;<br>      <span class=\"hljs-keyword\">return</span> getType() == PlayerType.BASKETBALL;<br>    &#125;<br><br>    <span class=\"hljs-keyword\">public</span> PlayerType <span class=\"hljs-title function_\">getType</span><span class=\"hljs-params\">()</span> &#123;<br>        <span class=\"hljs-keyword\">return</span> type;<br>    &#125;<br><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">setType</span><span class=\"hljs-params\">(PlayerType type)</span> &#123;<br>        <span class=\"hljs-built_in\">this</span>.type = type;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>\n\n<p>02 由于枚举是 final 的，所以可以确保在 Java 虚拟机中仅有一个常量对象，基于这个原因，我们可以使用“==”运算符来比较两个枚举是否相等，参照 <code>isBasketballPlayer()</code> 方法。</p>\n<p>03 “枚举还可用于 switch 语句，和基本数据类型的用法一致。”我说。</p>\n<p>04 “如果枚举中需要包含更多信息的话，可以为其添加一些字段，比如下面示例中的 name，此时需要为枚举添加一个带参的构造方法，这样就可以在定义枚举时添加对应的名称了。”我继续说。</p>\n<p>eg:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">enum</span> <span class=\"hljs-title class_\">PlayerType</span> &#123;<br>    TENNIS(<span class=\"hljs-string\">&quot;网球&quot;</span>),<br>    FOOTBALL(<span class=\"hljs-string\">&quot;足球&quot;</span>),<br>    BASKETBALL(<span class=\"hljs-string\">&quot;篮球&quot;</span>);<br><br>    <span class=\"hljs-keyword\">private</span> String name;<br>    <br>    PlayerType(String name) &#123;<br>        <span class=\"hljs-built_in\">this</span>.name = name;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>05 “EnumSet 是一个专门针对枚举类型的 Set 接口（后面会讲）的实现类，它是处理枚举类型数据的一把利器，非常高效。”我说，“从名字上就可以看得出，EnumSet 不仅和 Set 有关系，和枚举也有关系。”</p>\n<p>06 “因为 EnumSet 是一个抽象类，所以创建 EnumSet 时不能使用 new 关键字。不过，EnumSet 提供了很多有用的静态工厂方法。”</p>\n<p><img src=\"http://cdn.tobebetterjavaer.com/tobebetterjavaer/images/enum/enum-02.png\" alt=\"img\"></p>\n<p>07 “除了 EnumSet，还有 EnumMap，是一个专门针对枚举类型的 Map 接口的实现类，它可以将枚举常量作为键来使用。EnumMap 的效率比 HashMap 还要高，可以直接通过数组下标（枚举的 ordinal 值）访问到元素。”</p>\n<p>08 “和 EnumSet 不同，EnumMap 不是一个抽象类，所以创建 EnumMap 时可以使用 new 关键字。”</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">EnumMap&lt;PlayerType, String&gt; enumMap = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">EnumMap</span>&lt;&gt;(PlayerType.class);<br></code></pre></td></tr></table></figure>\n\n<p>09 有了 EnumMap 对象后就可以使用 Map 的一些方法了，见下图。</p>\n<p><img src=\"http://cdn.tobebetterjavaer.com/tobebetterjavaer/images/enum/enum-04.png\" alt=\"img\"></p>\n<p>和 HashMap（后面会讲）的使用方法大致相同，来看下面的例子。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">EnumMap&lt;PlayerType, String&gt; enumMap = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">EnumMap</span>&lt;&gt;(PlayerType.class);<br>enumMap.put(PlayerType.BASKETBALL,<span class=\"hljs-string\">&quot;篮球运动员&quot;</span>);<br>enumMap.put(PlayerType.FOOTBALL,<span class=\"hljs-string\">&quot;足球运动员&quot;</span>);<br>enumMap.put(PlayerType.TENNIS,<span class=\"hljs-string\">&quot;网球运动员&quot;</span>);<br>System.out.println(enumMap);<br><br>System.out.println(enumMap.get(PlayerType.BASKETBALL));<br>System.out.println(enumMap.containsKey(PlayerType.BASKETBALL));<br>System.out.println(enumMap.remove(PlayerType.BASKETBALL));<br></code></pre></td></tr></table></figure>\n\n<p>“来看一下输出结果。”</p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs text\">&#123;TENNIS=网球运动员, FOOTBALL=足球运动员, BASKETBALL=篮球运动员&#125;<br>篮球运动员<br>true<br>篮球运动员<br></code></pre></td></tr></table></figure>\n\n<p>“除了以上这些，《Effective Java》这本书里还提到了一点，如果要实现单例的话，最好使用枚举的方式。”我说。</p>\n<h3 id=\"单例：。。。\"><a href=\"#单例：。。。\" class=\"headerlink\" title=\"单例：。。。\"></a>单例：。。。</h3><h2 id=\"反射\"><a href=\"#反射\" class=\"headerlink\" title=\"反射\"></a>反射</h2><p>何为正射？何为反射？</p>\n<p>“一般情况下，我们在使用某个类之前已经确定它到底是个什么类了，拿到手就直接可以使用 <code>new</code> 关键字来调用构造方法进行初始化，之后使用这个类的对象来进行操作。”</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Java\"><span class=\"hljs-type\">Writer</span> <span class=\"hljs-variable\">writer</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Writer</span>();<br>writer.setName(<span class=\"hljs-string\">&quot;沉默王二&quot;</span>);<br><br></code></pre></td></tr></table></figure>\n\n<p>像上面这个例子，就可以理解为“正射”。而反射就意味着一开始我们不知道要初始化的类到底是什么，也就没法直接使用 <code>new</code> 关键字创建对象了。</p>\n<p>我们只知道这个类的一些基本信息，就好像我们看电影的时候，为了抓住一个犯罪嫌疑人，警察就会问一些目击证人，根据这些证人提供的信息，找专家把犯罪嫌疑人的样貌给画出来——这个过程，就可以称之为<strong>反射</strong>。</p>\n<p>反射的缺点：</p>\n<ul>\n<li><strong>破坏封装</strong>：由于反射允许访问私有字段和私有方法，所以可能会破坏封装而导致安全问题。</li>\n<li><strong>性能开销</strong>：由于反射涉及到动态解析，因此无法执行 Java 虚拟机优化，再加上反射的写法的确要复杂得多，所以性能要比“正射”差很多，在一些性能敏感的程序中应该避免使用反射。</li>\n</ul>\n<p>好处：</p>\n<ul>\n<li><strong>开发通用框架</strong>：像 Spring，为了保持通用性，通过配置文件来加载不同的对象，调用不同的方法。</li>\n<li><strong>动态代理</strong>：在面向切面编程中，需要拦截特定的方法，就会选择动态代理的方式，而动态代理的底层技术就是反射。</li>\n<li><strong>注解</strong>：注解本身只是起到一个标记符的作用，它需要利用发射机制，根据标记符去执行特定的行为。</li>\n</ul>\n<p>详情参考：</p>\n<p><a href=\"https://www.cnblogs.com/chanshuyi/p/head_first_of_reflection.html\">浅析</a></p>\n<p><a href=\"https://dunwu.github.io/javacore/basics/java-reflection.html#_1-%E5%8F%8D%E5%B0%84%E7%AE%80%E4%BB%8B\">深入理解</a></p>\n<h2 id=\"集合框架（容器）\"><a href=\"#集合框架（容器）\" class=\"headerlink\" title=\"集合框架（容器）\"></a>集合框架（容器）</h2><p>集合框架的结构图：</p>\n<img src=\"http://cdn.tobebetterjavaer.com/tobebetterjavaer/images/collection/gailan-01.png\" alt=\"img\" style=\"zoom:200%;\" />\n\n<p>单词：</p>\n<p>Collection——集合；</p>\n<p>Map——图、表（两个类间的映射关系）；</p>\n<p>List——列举、列表；</p>\n<p>Array——数组；</p>\n<p>Arraylist——数组列表；</p>\n<p>Linkedlist——链表；</p>\n<p>Stack——栈；                  <code>执行效率较低</code></p>\n<p>Vector——矩阵、模型    <code>线程安全</code></p>\n<p>Java 集合框架可以分为两条大的支线：</p>\n<ul>\n<li>Collection，主要由 List、Set、Queue 组成，List 代表有序、可重复的集合，典型代表就是封装了动态数组的 ArrayList 和封装了链表的 LinkedList；Set 代表无序、不可重复的集合，典型代表就是 HashSet 和 TreeSet；Queue 代表队列，典型代表就是双端队列 ArrayDeque，以及优先级队列 PriorityQue。</li>\n<li>Map，代表键值对的集合，典型代表就是 HashMap。</li>\n</ul>\n<h3 id=\"01、List\"><a href=\"#01、List\" class=\"headerlink\" title=\"01、List\"></a>01、List</h3><blockquote>\n<p>List 的特点是存取有序，可以存放重复的元素，可以用下标对元素进行操作</p>\n</blockquote>\n<h3 id=\"02、Set\"><a href=\"#02、Set\" class=\"headerlink\" title=\"02、Set\"></a>02、Set</h3><p>说在前面：</p>\n<p>Set 集合不是关注的重点，因为底层都是由 Map 实现的，为什么要用 Map 实现呢？</p>\n<p>因为 Map 的键不允许重复、无序吗</p>\n<blockquote>\n<p>Set 的特点是存取无序，不可以存放重复的元素，不可以用下标对元素进行操作，和 List 有很多不同</p>\n</blockquote>\n<p>Set是Java中的<strong>集合类，提供了一种无顺序，不重复的集合</strong>。常用的子类包括HashSet, TreeSet等。</p>\n<h3 id=\"03、Queue\"><a href=\"#03、Queue\" class=\"headerlink\" title=\"03、Queue\"></a>03、Queue</h3><blockquote>\n<p>Queue，也就是队列，通常遵循先进先出（FIFO）的原则，新元素插入到队列的尾部，访问元素返回队列的头部。</p>\n</blockquote>\n<h3 id=\"04、Map\"><a href=\"#04、Map\" class=\"headerlink\" title=\"04、Map\"></a>04、Map</h3><blockquote>\n<p>Map 保存的是键值对，键要求保持唯一性，值可以重复。</p>\n</blockquote>\n<h3 id=\"浅析ArrayList（动态数组）\"><a href=\"#浅析ArrayList（动态数组）\" class=\"headerlink\" title=\"浅析ArrayList（动态数组）\"></a>浅析ArrayList（动态数组）</h3><p>arraylist是接口list的实现类，有很多方便调用的预定义方法，便于用户直接调用。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Java\">List接口常用方法：<br><span class=\"hljs-number\">1</span>、add(Object element)： 向列表的尾部添加指定的元素。<br>    <span class=\"hljs-comment\">/*</span><br><span class=\"hljs-comment\">    \tList&lt;String&gt; alist = new ArrayList&lt;&gt;();</span><br><span class=\"hljs-comment\">    \talist.add(&quot;沉默王二&quot;);</span><br><span class=\"hljs-comment\">\t*/</span><br><span class=\"hljs-number\">2</span>、size()： 返回列表中的元素个数。<br><br><span class=\"hljs-number\">3</span>、get(<span class=\"hljs-type\">int</span> index)： 返回列表中指定位置的元素，index从<span class=\"hljs-number\">0</span>开始。<br><br><span class=\"hljs-number\">4</span>、add(<span class=\"hljs-type\">int</span> index, Object element)： 在列表的指定位置插入指定元素。<br><br><span class=\"hljs-number\">5</span>、set(<span class=\"hljs-type\">int</span> i, Object element)： 将索引i位置元素替换为元素element并返回被替换的元素。<br><br><span class=\"hljs-number\">6</span>、clear()： 从列表中移除所有元素。<br><br><span class=\"hljs-number\">7</span>、isEmpty()： 判断列表是否包含元素，不包含元素则返回 <span class=\"hljs-literal\">true</span>，否则返回<span class=\"hljs-literal\">false</span>。<br><br><span class=\"hljs-number\">8</span>、contains(Object o)： 如果列表包含指定的元素，则返回 <span class=\"hljs-literal\">true</span>。<br><br><span class=\"hljs-number\">9</span>、remove(<span class=\"hljs-type\">int</span> index)： 移除列表中指定位置的元素，并返回被删元素。<br><br><span class=\"hljs-number\">10</span>、remove(Object o)： 移除集合中第一次出现的指定元素，移除成功返回<span class=\"hljs-literal\">true</span>，否则返回<span class=\"hljs-literal\">false</span>。<br><br><span class=\"hljs-number\">11</span>、iterator()： 返回按适当顺序在列表的元素上进行迭代的迭代器。    <br></code></pre></td></tr></table></figure>\n\n<p>12、indexof()：正序查找一个元素。倒叙查找为lastIndexOf()</p>\n<p>ArrayList 可以称得上是集合框架方面最常用的类了，可以和 HashMap 一较高下。</p>\n<p>ArrayList 在数组的基础上实现了自动扩容，并且提供了比数组更丰富的预定义方法（各种增删改查），非常灵活。</p>\n<p>创建一个ArrayList的语法格式：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Java\">ArrayList&lt;String&gt; alist = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ArrayList</span>&lt;String&gt;();<span class=\"hljs-comment\">//标准</span><br><span class=\"hljs-comment\">/*可以通过上面的语句来创建一个字符串类型的 ArrayList（通过尖括号来限定 ArrayList 中元素的类型，如果尝试添加其他类型的元素，将会产生编译错误），更简化的写法如下：*/</span><br>List&lt;String&gt; alist = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ArrayList</span>&lt;&gt;();<br></code></pre></td></tr></table></figure>\n\n<p>由于 ArrayList 实现了 List 接口，所以 alist 变量的类型可以是 List 类型；new 关键字声明后的尖括号中可以不再指定元素的类型，因为编译器可以通过前面尖括号中的类型进行智能推断。</p>\n<p>如果非常确定 ArrayList 中元素的个数，在创建的时候还可以指定初始大小。</p>\n<h3 id=\"浅析linkedList（链表）\"><a href=\"#浅析linkedList（链表）\" class=\"headerlink\" title=\"浅析linkedList（链表）\"></a>浅析linkedList（链表）</h3><p>链表这门内功大致分为三个层次：</p>\n<ul>\n<li>第一层叫做“单向链表”，我只有一个后指针，指向下一个数据；</li>\n<li>第二层叫做“双向链表”，我有两个指针，后指针指向下一个数据，前指针指向上一个数据。</li>\n<li>第三层叫做“二叉树”，把后指针去掉，换成左右指针。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Java\">创建一个LinkedList的语法格式：<br>LinkedList&lt;String&gt; list = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">LinkedList</span>();<br></code></pre></td></tr></table></figure>\n\n\n\n<p><strong>1）招式一：增</strong></p>\n<p>可以调用 add 方法添加元素：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">list.add(<span class=\"hljs-string\">&quot;沉默王二&quot;</span>);<br>list.add(<span class=\"hljs-string\">&quot;沉默王三&quot;</span>);<br>list.add(<span class=\"hljs-string\">&quot;沉默王四&quot;</span>);<br></code></pre></td></tr></table></figure>\n\n<p>add 方法内部其实调用的是 linkLast 方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-type\">boolean</span> <span class=\"hljs-title function_\">add</span><span class=\"hljs-params\">(E e)</span> &#123;<br>    linkLast(e);<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>linkLast，顾名思义，就是在链表的尾部链接：</p>\n<ul>\n<li>添加第一个元素的时候，first 和 last 都为 null。</li>\n<li>然后新建一个节点 newNode，它的 prev 和 next 也为 null。</li>\n<li>然后把 last 和 first 都赋值为 newNode。</li>\n</ul>\n<p>此时还不能称之为链表，因为前后节点都是断裂的。</p>\n<p><img src=\"http://cdn.tobebetterjavaer.com/tobebetterjavaer/images/collection/linkedlist-02.png\" alt=\"img\"></p>\n<ul>\n<li>添加第二个元素的时候，first 和 last 都指向的是第一个节点。</li>\n<li>然后新建一个节点 newNode，它的 prev 指向的是第一个节点，next 为 null。</li>\n<li>然后把第一个节点的 next 赋值为 newNode。</li>\n</ul>\n<p>此时的链表还不完整。</p>\n<p><img src=\"http://cdn.tobebetterjavaer.com/tobebetterjavaer/images/collection/linkedlist-03.png\" alt=\"img\"></p>\n<ul>\n<li>添加第三个元素的时候，first 指向的是第一个节点，last 指向的是最后一个节点。</li>\n<li>然后新建一个节点 newNode，它的 prev 指向的是第二个节点，next 为 null。</li>\n<li>然后把第二个节点的 next 赋值为 newNode。</li>\n</ul>\n<p>此时的链表已经完整了。</p>\n<p><img src=\"http://cdn.tobebetterjavaer.com/tobebetterjavaer/images/collection/linkedlist-04.png\" alt=\"img\"></p>\n<p>我这个增的招式，还可以演化成另外两个：</p>\n<ul>\n<li><code>addFirst()</code> 方法将元素添加到第一位；</li>\n<li><code>addLast()</code> 方法将元素添加到末尾。</li>\n</ul>\n<p>addFirst 内部其实调用的是 linkFirst：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">addFirst</span><span class=\"hljs-params\">(E e)</span> &#123;<br>    linkFirst(e);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>linkFirst 负责把新的节点设为 first，并将新的 first 的 next 更<strong>2）招式二：删</strong></p>\n<p>我这个删的招式还挺多的：</p>\n<ul>\n<li><code>remove()</code>：删除第一个节点</li>\n<li><code>remove(int)</code>：删除指定位置的节点</li>\n<li><code>remove(Object)</code>：删除指定元素的节点</li>\n<li><code>removeFirst()</code>：删除第一个节点</li>\n<li><code>removeLast()</code>：删除最后一个节点</li>\n</ul>\n<p>remove 内部调用的是 removeFirst，所以这两个招式的功效一样。</p>\n<p><code>remove(int)</code> 内部其实调用的是 unlink 方法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> E <span class=\"hljs-title function_\">remove</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> index)</span> &#123;<br>    checkElementIndex(index);<br>    <span class=\"hljs-keyword\">return</span> unlink(node(index));<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>新为之前的 first。</p>\n<p>unlink 方法其实很好理解，就是更新当前节点的 next 和 prev，然后把当前节点上的元素设为 null。</p>\n<p><strong>3）招式三：改</strong></p>\n<p>可以调用 <code>set()</code> 方法来更新元素：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">list.set(<span class=\"hljs-number\">0</span>, <span class=\"hljs-string\">&quot;沉默王五&quot;</span>);<br></code></pre></td></tr></table></figure>\n\n<p>来看一下 <code>set()</code> 方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> E <span class=\"hljs-title function_\">set</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> index, E element)</span> &#123;<br>    checkElementIndex(index);<br>    Node&lt;E&gt; x = node(index);<br>    <span class=\"hljs-type\">E</span> <span class=\"hljs-variable\">oldVal</span> <span class=\"hljs-operator\">=</span> x.item;<br>    x.item = element;<br>    <span class=\"hljs-keyword\">return</span> oldVal;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>首先对指定的下标进行检查，看是否越界；然后根据下标查找原有的节点：</p>\n<p><code>size &gt;&gt; 1</code>：也就是右移一位，相当于除以 2。对于计算机来说，移位比除法运算效率更高，因为数据在计算机内部都是二进制存储的。</p>\n<p>换句话说，node 方法会对下标进行一个初步判断，如果靠近前半截，就从下标 0 开始遍历；如果靠近后半截，就从末尾开始遍历。</p>\n<p>找到指定下标的节点就简单了，直接把原有节点的元素替换成新的节点就 OK 了，prev 和 next 都不用改动。</p>\n<p><strong>4）招式四：查</strong></p>\n<p>我这个查的招式可以分为两种：</p>\n<ul>\n<li>indexOf(Object)：查找某个元素所在的位置</li>\n<li>get(int)：查找某个位置上的元素</li>\n</ul>\n<p>indexOf 的内部分为两种，一种是元素为 null 的时候，必须使用 == 来判断；一种是元素为非 null 的时候，要使用 equals 来判断。因为 equals 是不能用来判 null 的，会抛出 NPE 错误。</p>\n<p>get 方法的内核其实还是 node 方法，这个之前已经说明过了，这里略过。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> E <span class=\"hljs-title function_\">get</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> index)</span> &#123;<br>    checkElementIndex(index);<br>    <span class=\"hljs-keyword\">return</span> node(index).item;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>其实，查这个招式还可以演化为其他的一些，比如说：</p>\n<ul>\n<li><code>getFirst()</code> 方法用于获取第一个元素；</li>\n<li><code>getLast()</code> 方法用于获取最后一个元素；</li>\n<li><code>poll()</code> 和 <code>pollFirst()</code> 方法用于删除并返回第一个元素（两个方法尽管名字不同，但方法体是完全相同的）；</li>\n<li><code>pollLast()</code> 方法用于删除并返回最后一个元素；</li>\n<li><code>peekFirst()</code> 方法用于返回但不删除第一个元素。</li>\n</ul>\n<p>虽然ArrayList经常喊LinkedList一声师弟，但二者之间其实挺和谐的。但我知道，在外人眼里，同门师兄弟，总要一较高下的。</p>\n<p>比如说，我们俩在增删改查时候的时间复杂度。</p>\n<h3 id=\"ArrayList和LinkedList的区别\"><a href=\"#ArrayList和LinkedList的区别\" class=\"headerlink\" title=\"ArrayList和LinkedList的区别\"></a>ArrayList和LinkedList的区别</h3><p>增删改查时候的时间复杂度。</p>\n<p>由此，可以得出这样的结论：<strong>遍历 LinkedList 的时候，千万不要使用 for 循环，要使用迭代器。</strong></p>\n<h3 id=\"Java中的Iterator和Iterable区别\"><a href=\"#Java中的Iterator和Iterable区别\" class=\"headerlink\" title=\"Java中的Iterator和Iterable区别\"></a>Java中的Iterator和Iterable区别</h3><p>Iterator：迭代器</p>\n<p>Iterable：可迭代的</p>\n<p>什么是迭代器？</p>\n<figure class=\"highlight txt\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs txt\">迭代器 （iterator）有时又称 光标 （cursor）是**程序设计的 软件设计模式** ，可在容器对象（container，例如 链表 或 数组 ）上遍访的接口，设计人员无需关心容器对象的内存分配的实现细节。<br><br>**中文名:** 迭代器<br><br>**外文名:** iterator<br></code></pre></td></tr></table></figure>\n\n<p>在 Java 中，我们对 List 进行遍历的时候，主要有这么三种方式。</p>\n<p>第一种：for 循环。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">i</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span>; i &lt; list.size(); i++) &#123;<br>    System.out.print(list.get(i) + <span class=\"hljs-string\">&quot;，&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>第二种：迭代器。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-type\">Iterator</span> <span class=\"hljs-variable\">it</span> <span class=\"hljs-operator\">=</span> list.iterator();<br><span class=\"hljs-keyword\">while</span> (it.hasNext()) &#123;<br>    System.out.print(it.next() + <span class=\"hljs-string\">&quot;，&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>第三种：for-each。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">for</span> (String str : list) &#123;<br>    System.out.print(str + <span class=\"hljs-string\">&quot;，&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"fail-fast\"><a href=\"#fail-fast\" class=\"headerlink\" title=\"fail-fast\"></a>fail-fast</h3><p>官翻：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs txet\">In systems design, a fail-fast system is one which immediately reports at its interface any condition that is likely to indicate a failure. Fail-fast systems are usually designed to stop normal operation rather than attempt to continue a possibly flawed process. Such designs often check the system&#x27;s state at several points in an operation, so any failures can be detected early. The responsibility of a fail-fast module is detecting errors, then letting the next-highest level of the system handle them.<br></code></pre></td></tr></table></figure>\n\n<p>fail-fast 是一种通用的系统设计思想，一旦检测到可能会发生错误，就立马抛出异常，程序将不再往下执行。——一种保护机制。</p>\n<p>demo：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">List&lt;String&gt; list = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ArrayList</span>&lt;&gt;();<br>list.add(<span class=\"hljs-string\">&quot;沉默王二&quot;</span>);<br>list.add(<span class=\"hljs-string\">&quot;沉默王三&quot;</span>);<br>list.add(<span class=\"hljs-string\">&quot;一个文章真特么有趣的程序员&quot;</span>);<br><br><span class=\"hljs-keyword\">for</span> (String str : list) &#123;<br>\t<span class=\"hljs-keyword\">if</span> (<span class=\"hljs-string\">&quot;沉默王二&quot;</span>.equals(str)) &#123;<br>\t\tlist.remove(str);<br>\t&#125;<br>&#125;<br><br>System.out.println(list);<br></code></pre></td></tr></table></figure>\n\n<p>这段代码看起来没有任何问题，但运行起来就报错了。</p>\n<p><img src=\"http://cdn.tobebetterjavaer.com/tobebetterjavaer/images/collection/fail-fast-01.png\" alt=\"img\"></p>\n<p><strong><img src=\"http://cdn.tobebetterjavaer.com/tobebetterjavaer/images/collection/fail-fast-02.png\" alt=\"img\">那该如何正确地删除元素呢</strong>？</p>\n<p><strong>1）remove 后 break</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">List&lt;String&gt; list = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ArrayList</span>&lt;&gt;();<br>list.add(<span class=\"hljs-string\">&quot;沉默王二&quot;</span>);<br>list.add(<span class=\"hljs-string\">&quot;沉默王三&quot;</span>);<br>list.add(<span class=\"hljs-string\">&quot;一个文章真特么有趣的程序员&quot;</span>);<br><br><span class=\"hljs-keyword\">for</span> (String str : list) &#123;<br>\t<span class=\"hljs-keyword\">if</span> (<span class=\"hljs-string\">&quot;沉默王二&quot;</span>.equals(str)) &#123;<br>\t\tlist.remove(str);<br>\t\t<span class=\"hljs-keyword\">break</span>;<br>\t&#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>break 后循环就不再遍历了，意味着 Iterator 的 next 方法不再执行了，也就意味着 <code>checkForComodification</code> 方法不再执行了，所以异常也就不会抛出了。</p>\n<p>但是呢，当 List 中有重复元素要删除的时候，break 就不合适了。</p>\n<p><strong>3）使用 Iterator</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">List&lt;String&gt; list = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ArrayList</span>&lt;&gt;();<br>list.add(<span class=\"hljs-string\">&quot;沉默王二&quot;</span>);<br>list.add(<span class=\"hljs-string\">&quot;沉默王三&quot;</span>);<br>list.add(<span class=\"hljs-string\">&quot;一个文章真特么有趣的程序员&quot;</span>);<br><br>Iterator&lt;String&gt; itr = list.iterator();<br><br><span class=\"hljs-keyword\">while</span> (itr.hasNext()) &#123;<br>\t<span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">str</span> <span class=\"hljs-operator\">=</span> itr.next();<br>\t<span class=\"hljs-keyword\">if</span> (<span class=\"hljs-string\">&quot;沉默王二&quot;</span>.equals(str)) &#123;<br>\t\titr.remove();<br>\t&#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>为什么使用 Iterator 的 remove 方法就可以避开 fail-fast 保护机制呢？看一下 remove 的源码就明白了。** 循环**</p>\n<p>简单地总结一下，fail-fast 是一种保护机制，可以通过 for-each 循环删除集合的元素的方式验证这种保护机制。</p>\n<p>那也就是说，for-each 本质上是一种语法糖，遍历集合时很方面，但并不适合拿来操作集合中的元素（增删）。</p>\n<h3 id=\"HashMap\"><a href=\"#HashMap\" class=\"headerlink\" title=\"HashMap\"></a>HashMap</h3><p>什么是hashmap？</p>\n<p>说在前面：</p>\n<figure class=\"highlight txt\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs txt\">说到HashMap，就先说一下Map<br>map是用于存储键值对（&lt;key,value&gt;）的集合类，也可以说是一组键值对的映射（数学概念）。<br>Map的特点<br>1.没有重复的 key（一方面，key用set保存，所以key必须是唯一，无序的；另一方面，map的取值基本上是通过key来获取value，如果有两个相同的key，计算机将不知道到底获取哪个对应值；这时候有可能会问，那为什么我编程时候可以用put（）方法传入两个key值相同的键值对？那是因为源码中，传入key值相同的键值对，将作为覆盖处理）<br><br>2.每个 key 只能对应一个 value, 多个 key 可以对应一个 value（这就是映射的概念，最经典的例子就是射箭，一排射手，一排箭靶，一个射手只能射中一个箭靶，而每个箭靶可能被不同射手射中。这里每个射手只有一根箭，不存在三箭齐发还都中靶这种骚操作。将射手和射中的靶子连线，这根线加射手加靶子就是一个映射）<br><br>3.key,value 都可以是任何引用类型（包括 null）的数据（只能是引用类型）<br><br>4.Map 取代了古老的 Dictionary 抽象类（知道就行，可以忽略）<br>————————————————<br>版权声明：本文为CSDN博主「酒吧七」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：https://blog.csdn.net/qq_36711757/article/details/80394272<br></code></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"一、hash-方法的原理\"><a href=\"#一、hash-方法的原理\" class=\"headerlink\" title=\"一、hash 方法的原理\"></a>一、hash 方法的原理</h4><figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs markdown\">把任意长度的输入（输入叫做预映射，知道就行），通过一种函数（hashCode() 方法），变换成固定长度的输出，该输出就是<span class=\"hljs-strong\">**<span class=\"hljs-emphasis\">*\\*</span>哈希值\\**</span><span class=\"hljs-strong\">**（hashCode），这种函数就叫做**</span><span class=\"hljs-emphasis\">*\\*</span>哈希函数\\<span class=\"hljs-strong\">****</span>，而计算哈希值的过程就叫做<span class=\"hljs-strong\">**<span class=\"hljs-emphasis\">*\\*</span>哈希\\**</span><span class=\"hljs-strong\">**。哈希的主要应用是哈希表和分布式缓存。</span><br><span class=\"hljs-strong\"></span><br><span class=\"hljs-strong\">这里有个问题，哈希算法和哈希函数不是一个东西，哈希函数是哈希算法的一种实现，以后面试就说哈希函数就行。</span><br><span class=\"hljs-strong\"></span><br><span class=\"hljs-strong\">在将键值对存入数组之前，将key通过哈希算法计算出哈希值，把哈希值作为数组下标，把该下标对应的位置作为键值对的存储位置，通过该方法建立的数组就叫做**</span><span class=\"hljs-emphasis\">*\\*</span>哈希表\\<span class=\"hljs-strong\">****</span>，而这个存储位置就叫做<span class=\"hljs-strong\">**<span class=\"hljs-emphasis\">*\\*</span>桶（bucket）\\**</span><span class=\"hljs-strong\">**。数组是通过整数下标直接访问元素，哈希表是通过字符串key直接访问元素，也就说哈希表是一种特殊的数组（关联数组），哈希表广泛应用于实现数据的快速查找（在map的key[<span class=\"hljs-string\">集合</span>](<span class=\"hljs-link\">https://so.csdn.net/so/search?q=集合&amp;spm=1001.2101.3001.7020</span>)中，一旦存储的key的数量特别多，那么在要查找某个key的时候就会变得很麻烦，数组中的key需要挨个比较，哈希的出现，使得这样的比较次数大大减少。）</span><br><span class=\"hljs-strong\"></span><br><span class=\"hljs-strong\">哈希表选用哈希函数计算哈希值时，可能不同的 key 会得到相同的结果，一个地址怎么存放多个数据呢？这就是**</span><span class=\"hljs-emphasis\">*\\*</span>哈希冲突（碰撞）\\<span class=\"hljs-strong\">****</span>。解决哈希冲突有两种方法，拉链法（链接法）和开放定址法（这种没用过）。<span class=\"hljs-strong\">**<span class=\"hljs-emphasis\">*\\*</span>拉链法\\**</span><span class=\"hljs-strong\">**：将键值对对象封装为一个node结点，新增了next指向，这样就可以将碰撞的结点链接成一条单链表，保存在该地址（数组位置）中。</span><br></code></pre></td></tr></table></figure>\n\n<p>再来看一下 hash 方法的源码（JDK 8 中的 HashMap）：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">hash</span><span class=\"hljs-params\">(Object key)</span> &#123;<br>    <span class=\"hljs-type\">int</span> h;<br>    <span class=\"hljs-keyword\">return</span> (key == <span class=\"hljs-literal\">null</span>) ? <span class=\"hljs-number\">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class=\"hljs-number\">16</span>);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><code>key.hashCode()</code> 是用来获取键位的哈希值的，理论上，哈希值是一个 int 类型，范围从-2147483648 到 2147483648。前后加起来大概 40 亿的映射空间，只要哈希值映射得比较均匀松散，一般是不会出现哈希碰撞的。</p>\n<p>取模运算有两处。</p>\n<blockquote>\n<p>取模运算（“Modulo Operation”）和取余运算（“Remainder Operation ”）两个概念有重叠的部分但又不完全一致。主要的区别在于对负整数进行除法运算时操作不同。<strong>取模</strong>主要是用于<strong>计算机术语</strong>中，<strong>取余</strong>则更多是<strong>数学概念</strong>。</p>\n</blockquote>\n<p>一处是往 HashMap 中 put 的时候（<code>putVal</code> 方法中）：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">final</span> V <span class=\"hljs-title function_\">putVal</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> hash, K key, V value, <span class=\"hljs-type\">boolean</span> onlyIfAbsent, <span class=\"hljs-type\">boolean</span> evict)</span> &#123;<br>     HashMap.Node&lt;K,V&gt;[] tab; HashMap.Node&lt;K,V&gt; p; <span class=\"hljs-type\">int</span> n, i;<br>     <span class=\"hljs-keyword\">if</span> ((tab = table) == <span class=\"hljs-literal\">null</span> || (n = tab.length) == <span class=\"hljs-number\">0</span>)<br>         n = (tab = resize()).length;<br>     <span class=\"hljs-keyword\">if</span> ((p = tab[i = (n - <span class=\"hljs-number\">1</span>) &amp; hash]) == <span class=\"hljs-literal\">null</span>)<br>         tab[i] = newNode(hash, key, value, <span class=\"hljs-literal\">null</span>);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>一处是从 HashMap 中 get 的时候（<code>getNode</code> 方法中）：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">final</span> Node&lt;K,V&gt; <span class=\"hljs-title function_\">getNode</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> hash, Object key)</span> &#123;<br>     Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class=\"hljs-type\">int</span> n; K k;<br>     <span class=\"hljs-keyword\">if</span> ((tab = table) != <span class=\"hljs-literal\">null</span> &amp;&amp; (n = tab.length) &gt; <span class=\"hljs-number\">0</span> &amp;&amp;<br>            (first = tab[(n - <span class=\"hljs-number\">1</span>) &amp; hash]) != <span class=\"hljs-literal\">null</span>) &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>其中的 <code>(n - 1) &amp; hash</code> 正是取模运算，就是把哈希值和（数组长度-1）做了一个“与”运算。</p>\n<p>可能大家在疑惑：<strong>取模运算难道不该用 <code>%</code> 吗？为什么要用 <code>&amp;</code> 呢</strong>？</p>\n<p>这是因为 <code>&amp;</code> 运算比 <code>%</code> 更加高效，并且当 b 为 2 的 n 次方时，存在下面这样一个公式。</p>\n<blockquote>\n<p>a % b = a &amp; (b-1)</p>\n</blockquote>\n<p>用 $2^n$ 替换下 b 就是：</p>\n<blockquote>\n<p>a % 2^n = a &amp; (2^n-1)</p>\n</blockquote>\n<p>综上所述，hash 方法是用来做哈希值优化的，把哈希值右移 16 位，也就正好是自己长度的一半，之后与原哈希值做异或运算，这样就混合了原哈希值中的高位和低位，增大了随机性。</p>\n<p>说白了，<strong>hash 方法就是为了增加随机性，让数据元素更加均衡的分布，减少碰撞</strong>。</p>\n<p><strong><a href=\"https://mp.weixin.qq.com/s/aS2dg4Dj1Efwujmv-6YTBg\">为什么 HashMap 的数组长度要取 2 的整次方?</a></strong></p>\n<h4 id=\"二、扩容机制\"><a href=\"#二、扩容机制\" class=\"headerlink\" title=\"二、扩容机制\"></a>二、扩容机制</h4><p>大家都知道，数组一旦初始化后大小就无法改变了，所以就有了 [ArrayList]这种“动态数组”，可以自动扩容。</p>\n<p>HashMap 的底层用的也是数组。向 HashMap 里不停地添加元素，当数组无法装载更多元素时，就需要对数组进行扩容，以便装入更多的元素。</p>\n<p>当然了，数组是无法自动扩容的，所以如果要扩容的话，就需要新建一个大的数组，然后把小数组的元素复制过去。</p>\n<p>HashMap 的扩容是通过 resize 方法来实现的，JDK 8 中融入了红黑树，比较复杂，为了便于理解，就还使用 JDK 7 的源码，搞清楚了 JDK 7 的，我们后面再详细说明 JDK 8 和 JDK 7 之间的区别。</p>\n<h4 id=\"三、加载因子为什么是0-75\"><a href=\"#三、加载因子为什么是0-75\" class=\"headerlink\" title=\"三、加载因子为什么是0.75\"></a>三、加载因子为什么是0.75</h4><p>哈希函数计算结果越分散均匀，哈希碰撞的概率就越小，map的存取效率（时间复杂度）就会越高。</p>\n<p>哈希表长度越长，空间成本越大，哈希函数计算结果越分散均匀。</p>\n<p>****扩容机制****（实际上就是负载因子）和哈希函数越合理，空间成本越小，哈希函数计算结果越分散均匀。</p>\n<p>从HashMap的默认构造函数源码可知，构造函数就是对下面几个字段进行初始化。</p>\n<p>负载因子越大（长度一定），最大结点容量越大，resize次数越少，空间成本越小，map的存取效率就会越高。</p>\n<p>桶数组初始容量（长度）越大（加载因子一定），最大结点容量越大，resize次数越少，空间成本越大，map的存取效率就会越高。</p>\n<p>涉及到概率论的泊松分布与二项分布。</p>\n<p><em><strong>引入红黑树的概念：</strong></em></p>\n<p>这里存在一个问题，即使负载因子和哈希函数设计的再合理，也免不了会出现****拉链过长****（桶内结点过多）的情况，一旦出现拉链过长，则会严重影响HashMap的性能。于是，在JDK1.8版本中，对数据结构做了进一步的优化，引入了红黑树。而当链表长度太长（默认超过8）时，链表就转换为红黑树，利用红黑树快速增删改查的特点提高HashMap的性能。</p>\n<h4 id=\"四、线程不安全\"><a href=\"#四、线程不安全\" class=\"headerlink\" title=\"四、线程不安全\"></a>四、线程不安全</h4><p>有何体现：</p>\n<p>多线程下扩容会死循环、多线程下 put 会导致元素丢失、put 和 get 并发时会导致 get 到 null，也就是环链死循环、数据丢失、数据覆盖三个问题。其中环链在JDK1.8已经解决，但还是有数据覆盖的问题。</p>\n<p>究其根本：</p>\n<p>线程不安全主要是发生在扩容函数中，即根源是在<strong>transfer函数</strong>中：transfer函数代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Java\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">  *</span><br><span class=\"hljs-comment\">  <span class=\"hljs-doctag\">@version</span> JDK1.7</span><br><span class=\"hljs-comment\">  */</span><br><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">transfer</span><span class=\"hljs-params\">(Entry[] newTable, <span class=\"hljs-type\">boolean</span> rehash)</span> &#123;<br>        <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">newCapacity</span> <span class=\"hljs-operator\">=</span> newTable.length;<br>        <span class=\"hljs-keyword\">for</span> (Entry&lt;K,V&gt; e : table) &#123;<br>            <span class=\"hljs-keyword\">while</span>(<span class=\"hljs-literal\">null</span> != e) &#123;<br>                Entry&lt;K,V&gt; next = e.next;<br>                <span class=\"hljs-keyword\">if</span> (rehash) &#123;<br>                    e.hash = <span class=\"hljs-literal\">null</span> == e.key ? <span class=\"hljs-number\">0</span> : hash(e.key);<br>                &#125;<br>                <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">i</span> <span class=\"hljs-operator\">=</span> indexFor(e.hash, newCapacity);<br>                e.next = newTable[i];<br>                newTable[i] = e;<br>                e = next;<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>\n\n<p><code>HashMap</code>的扩容操作，重新定位每个桶的下标，并采用头插法将元素迁移到新数组中。头插法会将链表的顺序翻转，这也是形成死循环的关键点。</p>\n<p>key 用 Set 存放，所以想做到 <strong>key 不允许重复</strong>，key 对应的类（一般是String）需要重写 hashCode 和 equals 方法</p>\n<ul>\n<li>HashMap不是同步，HashTable是同步的，但HashTable已经弃用，如果需要线程安全，可以用synchronizedMap，例如       Map m = Collections.synchronizedMap(new HashMap(…));</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<ul>\n<li><em>写在前面：</em><ul>\n<li>【免责声明：】本笔记来源自互联，是笔者结合自己的理解进行整理归纳发表在hexo博客只便于个人学习使用，若涉及到侵权，请联系我，谢谢！</li>\n<li>个人博客地址：<a href=\"https://wl2o2o.github.io/\">https://wl2o2o.github.io/</a></li>\n</ul>\n</li>\n<li>写作背景:<ul>\n<li>笔者是一名大三在校生，目前正在努力学习Java方向，笔记书写于22年暑假期间，虽然起步有点晚，但是每天都在坚持，只要努力，光一定会shine向我的！</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"Essay笔记来源\"><a href=\"#Essay笔记来源\" class=\"headerlink\" title=\"Essay笔记来源\"></a>Essay笔记来源</h1><p><a href=\"https://www.pdai.tech/md/java/basic/java-basic-x-generic.html\">Java全栈知识体系</a>——泛型</p>\n<p><a href=\"https://www.bilibili.com/video/BV1mE411x7Wt\">哔哩哔哩老杜Java</a>——哔哩哔哩</p>\n<p><a href=\"https://tobebetterjavaer.com/home.html\">Java程序员进阶之路</a>——沉默王二</p>\n<h1 id=\"老杜Java零基础\"><a href=\"#老杜Java零基础\" class=\"headerlink\" title=\"老杜Java零基础\"></a>老杜Java零基础</h1><p><strong>P58</strong><br>具体的命名规范：<br>1、顾名思义；<br>2、驼峰原则：一高一低：例如：PowerNodeNotes；<br>3、类名、接口名首字母大写 ；<br>    变量名方法名首字母小写；<br>        常量名全部大写，单词之间用_下划线连接：USER_AGE;</p>\n<p><strong>P60</strong><br>关键字：<br>int、long、float…public static void boolean private protect 蓝色字体、小写显示</p>\n<p><strong>P63</strong><br>提取帮助文档：也就是写在/**            这里面的注释信息。<br>                *<br>                *@author<br>                *@version<br>                */<br>javadoc -d+文件夹名（文件夹绝对路径）+（需要提取的信息）+Java源文件<br>例如：javadoc -d javaapi -author -version VarTest02.java</p>\n<p><strong>P70</strong><br>1，变量的分类：<br>public class Test{<br>    int i;//全局变量<br>    public static void main(String[] args){<br>        int j;局部变量<br>  }<br>}</p>\n<p>2，变量的作用域：即有效范围（出了大括号就处于非作用域）！</p>\n<p><strong>P72</strong><br>标识符可以标志什么：<br>类名、方法名、常量、变量、接口名</p>\n<p>记录所有编程出现的错误，记录错误~！</p>\n<p><strong>P113</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Homework1</span>&#123;<br>\t<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span>&#123;<br>\t\t<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">10</span>;<br>\t\ti=i++;<br>\t\tSystem.out.println(i);\t<span class=\"hljs-comment\">//运行结果为10！</span><br>  &#125;<br>&#125;<br><span class=\"hljs-comment\">//Java和C++源代码运行结果不一样，C++结果为11、Java为10.</span><br></code></pre></td></tr></table></figure>\n\n<p>原因：编译器原理不一样，其中Java的代码可以理解为一下三行：<br>（在Java语言中i++，这种表达式在执行的时候，会提前将i变量找一个存储空间临时存储，不同于C++）<br>int temp=i;<br>i++;<br>i=temp;<br>因此！！！可以理解为：分号之后++再加一 </p>\n<p><strong>P116</strong><br>接收键盘输入：</p>\n<p>在Java中则怎么接收键盘信息呢？<br>第一种形式：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">//创建一个键盘扫描器对象(s为对象名，上下对应)</span><br>java.util.<span class=\"hljs-type\">Scanner</span> <span class=\"hljs-variable\">s</span> <span class=\"hljs-operator\">=</span><span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">java</span>.util.Scanner(System.in);\t<br>java.util.<span class=\"hljs-type\">Scanner</span> <span class=\"hljs-variable\">s</span> <span class=\"hljs-operator\">=</span><span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">java</span>.util.Scanner(System.in);\t<br><span class=\"hljs-type\">int</span> i=s.nextInt(); <br>System.out.println();\t<br><br><span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">str</span> <span class=\"hljs-operator\">=</span>s.next();<br>System.out.println();<br><span class=\"hljs-comment\">//接收用户的输入，从键盘上接受一个int类型的数据、</span><br><span class=\"hljs-comment\">//i变量有值了，并且i变量中保存的这个值是用户输入的数字。</span><br><span class=\"hljs-comment\">//i变量就是接收键盘数据的</span><br><span class=\"hljs-type\">int</span> i=s.nextInt();<br>System.out.println(<span class=\"hljs-string\">&quot;您输入的数字是：&quot;</span>+i);<br><br><span class=\"hljs-type\">int</span> j=s.nextInt();<br>System.out.println(<span class=\"hljs-string\">&quot;您输入的数字是：&quot;</span>+j);<br><span class=\"hljs-comment\">//字符串类型</span><br><span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">str</span> <span class=\"hljs-operator\">=</span> s.next();<br>其他数据类型类似<br>其中println:print为打印、ln为换行。<br></code></pre></td></tr></table></figure>\n\n<p>另外一种形式：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">import</span> java.util.Scanner;\t<span class=\"hljs-comment\">//idea可以自动引入</span><br><span class=\"hljs-comment\">//创建键盘扫描器对象</span><br><span class=\"hljs-type\">Scanner</span> <span class=\"hljs-variable\">s</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Scanner</span>(System.in);<br><span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">num1</span> <span class=\"hljs-operator\">=</span> s.nextInt();<br>System.out.println(num1+<span class=\"hljs-string\">&quot;+&quot;</span>+num2+<span class=\"hljs-string\">&quot;=&quot;</span>);<br></code></pre></td></tr></table></figure>\n\n<p>头歌实践教学平台项目案例练习：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">//什么是类、怎么创建类：</span><br><span class=\"hljs-keyword\">package</span> step1;<br><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Test</span> &#123;<br>\t<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> &#123;<br>\t\t<span class=\"hljs-comment\">/********** Begin **********/</span><br>\t\t<span class=\"hljs-comment\">//创建Dog对象</span><br>\t\t<span class=\"hljs-comment\">//设置Dog对象的属性</span><br>        <span class=\"hljs-type\">Dog</span> <span class=\"hljs-variable\">wuhuarou</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Dog</span>();<br>\t\twuhuarou.name=<span class=\"hljs-string\">&quot;五花肉&quot;</span>;<br>        wuhuarou.color=<span class=\"hljs-string\">&quot;棕色&quot;</span>;<br>        wuhuarou.variety=<span class=\"hljs-string\">&quot;阿拉斯加&quot;</span>;<br>\t\t<span class=\"hljs-comment\">//输出小狗的属性</span><br>\t\tSystem.out.println(<span class=\"hljs-string\">&quot;名字：&quot;</span> + wuhuarou.name + <span class=\"hljs-string\">&quot;，毛色：&quot;</span> + wuhuarou.color+ <span class=\"hljs-string\">&quot;，品种：&quot;</span> +wuhuarou.variety );<br>\t\t<span class=\"hljs-comment\">//调用方法</span><br>        wuhuarou.eat();<br>        wuhuarou.run();<br>\t\t<span class=\"hljs-comment\">/********** End **********/</span><br>\t&#125;<br>&#125;<br><span class=\"hljs-comment\">//在这里定义Dog类</span><br><span class=\"hljs-comment\">/********** Begin **********/</span><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Dog</span>&#123;<br>    String name,color,variety;<br>    <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">eat</span><span class=\"hljs-params\">()</span>&#123;<br>        System.out.println(<span class=\"hljs-string\">&quot;啃骨头&quot;</span>);<br>    &#125;<br>    <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">run</span><span class=\"hljs-params\">()</span>&#123;<br>        System.out.print(<span class=\"hljs-string\">&quot;叼着骨头跑&quot;</span>);<br>    &#125;<br>&#125;<br><span class=\"hljs-comment\">/********** End **********/</span><br></code></pre></td></tr></table></figure>\n\n<p>关于质数：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">package</span> step2;<br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">FindZhiShu</span> &#123;<br>\t<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> &#123;<br>\t\t   <span class=\"hljs-comment\">/*</span><br><span class=\"hljs-comment\">\t\t     打印输出质数的时候务必按照如下格式：System.out.print(质数+&quot; &quot;)；</span><br><span class=\"hljs-comment\">\t\t     使用print进行打印同时被打印输出的质数后加上一个空格，</span><br><span class=\"hljs-comment\">\t\t     以便于与平台提供的结果格式保持一致！</span><br><span class=\"hljs-comment\">            */</span>   <br>\t\t   <span class=\"hljs-comment\">/**********begin**********/</span><br>            a:<span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">i</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">2</span>;i &lt; <span class=\"hljs-number\">1000</span>;i++)&#123;\t\t<span class=\"hljs-comment\">//此循环遍历次数较多，若对代码效率有要求，则可进一步改进代码：如下：</span><br>                <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">j</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">2</span>;j&lt;i;j++)<br>                <span class=\"hljs-keyword\">if</span>(i%j==<span class=\"hljs-number\">0</span>)&#123;<br>                    <span class=\"hljs-keyword\">continue</span> a;<br>                &#125;<br>                System.out.print(i+<span class=\"hljs-string\">&quot; &quot;</span>);<br>            &#125;<br>           <span class=\"hljs-comment\">/**********end**********/</span>\t<br>\t&#125;<br>&#125;<br>\t\t**********************改进之后的代码*********************<br><span class=\"hljs-keyword\">package</span> step2;<br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">FindZhiShu</span> &#123;<br>\t<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> &#123;<br>\t\t   <span class=\"hljs-comment\">/*</span><br><span class=\"hljs-comment\">\t\t     打印输出质数的时候务必按照如下格式：System.out.print(质数+&quot; &quot;)；</span><br><span class=\"hljs-comment\">\t\t     使用print进行打印同时被打印输出的质数后加上一个空格，</span><br><span class=\"hljs-comment\">\t\t     以便于与平台提供的结果格式保持一致！</span><br><span class=\"hljs-comment\">            */</span>   <br>\t\t   <span class=\"hljs-comment\">/**********begin**********/</span><br><br>\tSystem.out.print(<span class=\"hljs-string\">&quot;2 &quot;</span>);\t<span class=\"hljs-comment\">//因为2是特殊的质数，又因下面循环会自动跳过偶数，因此先将2打印出来。</span><br>\t        a:<span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">i</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">3</span>;i &lt; <span class=\"hljs-number\">1000</span>;i+=<span class=\"hljs-number\">2</span>)&#123;<br>\t            <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">j</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">2</span>;j&lt;i;j++)<br>\t            <span class=\"hljs-keyword\">if</span>(i%j==<span class=\"hljs-number\">0</span>)&#123;<br>\t                <span class=\"hljs-keyword\">continue</span> a;\t\t<span class=\"hljs-comment\">//此方法运用了给循环做标记，以此可以对continue和break进行明确的命令指示。</span><br>\t            &#125;<br>\t            System.out.print(i+<span class=\"hljs-string\">&quot; &quot;</span>);<br>\t        &#125;<br>\t       <span class=\"hljs-comment\">/**********end**********/</span>\t<br>\t&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"《方法》\"><a href=\"#《方法》\" class=\"headerlink\" title=\"《方法》\"></a>《方法》</h2><h3 id=\"定义：\"><a href=\"#定义：\" class=\"headerlink\" title=\"定义：\"></a>定义：</h3><p>是可以完成某一个特定的功能，并且可被重复利用。</p>\n<p>在面向对象的语言中，函数称为方法，类似于C语言总的函数。方法写在类体中，可以写在main函数前后，不分顺序，因为main函数为执行入口。</p>\n<h3 id=\"方法结构定义：\"><a href=\"#方法结构定义：\" class=\"headerlink\" title=\"方法结构定义：\"></a>方法结构定义：</h3><p>【修饰符列表】 返回值类型 方法名 （形式参数列表）{</p>\n<p>​        方法体;</p>\n<p>}</p>\n<p>注意：</p>\n<p>【】符号叫中括号、以上中括号里的内容表是不是必须的，是可以选择的，方法体由Java语句构成；</p>\n<p>关于修饰符列表：</p>\n<p>也不是必须的，目前可写成public static（称为静态方法）</p>\n<p>break与return的区别：</p>\n<p>break：用来终止一个switch语句和距离最近的循环</p>\n<p>return：用来终止一个方法。 </p>\n<h3 id=\"方法优化：\"><a href=\"#方法优化：\" class=\"headerlink\" title=\"方法优化：\"></a>方法优化：</h3><p>例题：编写一个方法，输出大于某个正整数n的最小的质数（思考：这个方法应该取什么名字，这个方法的形参是什么，返回值类型是什么？）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Java\"> <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Homework2</span>&#123;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span>&#123;<br>        <span class=\"hljs-comment\">//假设目前系统给定一个正整数n，n为5</span><br>        <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">n</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">7</span>;<br>        <span class=\"hljs-comment\">//输出大于5的最小质数</span><br>        <span class=\"hljs-keyword\">while</span>(<span class=\"hljs-literal\">true</span>)&#123;<br>            n++;<br>\t\t\t<span class=\"hljs-comment\">//需要一个判断是否为质数的方法。。</span><br>            <span class=\"hljs-keyword\">if</span>(isZhiShu(n))&#123;\t\t\t\t<br>                System.out.print(<span class=\"hljs-string\">&quot;最小质数是&quot;</span>+n);<br>                <span class=\"hljs-keyword\">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>\t<span class=\"hljs-comment\">//该方法返回一个Boolean字符，用于main方法中的if判断语句。</span><br>\t<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">boolean</span> <span class=\"hljs-title function_\">isZhiShu</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> num)</span>&#123;<br>\t\t<span class=\"hljs-comment\">//判断num是否为质数</span><br>\t\t<span class=\"hljs-comment\">//可以利用循环取余的方法来判断是否可以整除除1和本身的数字</span><br>\t\t<span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">i</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">2</span>; i &lt; num;i++ )&#123;<br>\t\t\t<span class=\"hljs-keyword\">if</span>(num%i==<span class=\"hljs-number\">0</span>)&#123;<br>\t\t\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;<br>\t\t\t&#125;<br>\t\t&#125;<br>\t\t<span class=\"hljs-comment\">//return语句容易写在for循环里面，写在里面判断不完全</span><br>\t\t<span class=\"hljs-comment\">//return之所以写在外面是因为要让循环执行完毕，执行完毕才可以正确判断</span><br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;<br>\t&#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>编程思路以及改进版：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"> <br><span class=\"hljs-keyword\">import</span> java.util.Scanner;<br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Homework2</span>&#123;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span>&#123;<br>        <br>        <span class=\"hljs-comment\">//以下代码省略，新增打印质数的方法</span><br>\t\t<span class=\"hljs-comment\">/*</span><br><span class=\"hljs-comment\">\t\t//假设目前系统给定一个正整数n，n为5</span><br><span class=\"hljs-comment\">        int n = 7;</span><br><span class=\"hljs-comment\">\t\t//输出大于5的最小质数</span><br><span class=\"hljs-comment\">        while(true)&#123;</span><br><span class=\"hljs-comment\">            n++;</span><br><span class=\"hljs-comment\">\t\t\t//需要一个判断是否为质数的方法。。</span><br><span class=\"hljs-comment\">            if(isZhiShu(n))&#123;\t\t\t\t</span><br><span class=\"hljs-comment\">                System.out.print(&quot;最小质数是&quot;+n);</span><br><span class=\"hljs-comment\">                break;</span><br><span class=\"hljs-comment\">            &#125;</span><br><span class=\"hljs-comment\">        &#125;</span><br><span class=\"hljs-comment\">\t\t*/</span><br>\t\t<br>\t\t<span class=\"hljs-comment\">//引入用户输入的数据</span><br>\t\t<span class=\"hljs-type\">Scanner</span> <span class=\"hljs-variable\">s</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Scanner</span>(System.in);<br>\t\t<span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">num</span> <span class=\"hljs-operator\">=</span> s.nextInt();<br>\t\t<span class=\"hljs-comment\">//直接调用打印质数的方法</span><br>\t\tprintZhiShu(num);<br><br><br>    &#125;<br>\t<span class=\"hljs-comment\">//代码不够精简，还可以在main（）中调用打印输出质数的方法</span><br>\t<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">printZhiShu</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> num)</span>&#123;<br>\t\t<br>\t\t<span class=\"hljs-comment\">//while循环仍可精简，但是精简之后不易理解，代码如下：</span><br>\t\t<span class=\"hljs-comment\">/*\t\t</span><br><span class=\"hljs-comment\">\t\twhile(isZhiShu(num))&#123;</span><br><span class=\"hljs-comment\">\t\t&#125;</span><br><span class=\"hljs-comment\">\t\tSystem.out.print(&quot;最小质数是&quot;+num);</span><br><span class=\"hljs-comment\">\t\t*/</span><br><br>\t\t<span class=\"hljs-comment\">/*while(true)&#123;</span><br><span class=\"hljs-comment\">    \t\t//需要一个判断是否为质数的方法。。</span><br><span class=\"hljs-comment\">            if(isZhiShu(++num))&#123;\t\t\t\t</span><br><span class=\"hljs-comment\">                System.out.print(&quot;最小质数是&quot;+num);</span><br><span class=\"hljs-comment\">                break;</span><br><span class=\"hljs-comment\">            &#125;</span><br><span class=\"hljs-comment\">\t\t&#125;\t</span><br><span class=\"hljs-comment\">\t\t*/</span><br>\t\t<span class=\"hljs-keyword\">while</span>(!isZhiShu(++num))&#123;<br>\t\t&#125;<br>\t\tSystem.out.print(<span class=\"hljs-string\">&quot;最小质数是&quot;</span>+num);<br>        <br>\t&#125;<br><br>\t<span class=\"hljs-comment\">//该方法返回一个Boolean字符，用于main方法中的if判断语句。</span><br>\t<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">boolean</span> <span class=\"hljs-title function_\">isZhiShu</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> num)</span>&#123;<br>\t\t<span class=\"hljs-comment\">//判断num是否为质数</span><br>\t\t<span class=\"hljs-comment\">//可以利用循环取余的方法来判断是否可以整除除1和本身的数字</span><br>\t\t<span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">i</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">2</span>; i &lt; num;i++ )&#123;<br>\t\t\t<span class=\"hljs-keyword\">if</span>(num%i==<span class=\"hljs-number\">0</span>)&#123;<br>\t\t\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;<br>\t\t\t&#125;<br>\t\t&#125;<br>\t\t<span class=\"hljs-comment\">//return语句容易写在for循环里面，写在里面判断不完全</span><br>\t\t<span class=\"hljs-comment\">//return之所以写在外面是因为要让循环执行完毕，执行完毕才可以正确判断</span><br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;<br>\t&#125;<br><br>&#125;<br><br><span class=\"hljs-comment\">//以上代码为编程思路，以下为精简代码：</span><br><span class=\"hljs-comment\">/*</span><br><span class=\"hljs-comment\">import java.util.Scanner;</span><br><span class=\"hljs-comment\">public class Homework2&#123;</span><br><span class=\"hljs-comment\">    public static void main(String[] args)&#123;</span><br><span class=\"hljs-comment\">\t\tScanner s = new Scanner(System.in);</span><br><span class=\"hljs-comment\">\t\tint num = s.nextInt();</span><br><span class=\"hljs-comment\"></span><br><span class=\"hljs-comment\">\t\tprintZhiShu(num);</span><br><span class=\"hljs-comment\">    &#125;</span><br><span class=\"hljs-comment\"></span><br><span class=\"hljs-comment\">\tpublic static void printZhiShu(int num)&#123;</span><br><span class=\"hljs-comment\">\t\twhile(!isZhiShu(++num))&#123;</span><br><span class=\"hljs-comment\">\t\t&#125;</span><br><span class=\"hljs-comment\">\t\tSystem.out.print(&quot;最小质数是&quot;+num);</span><br><span class=\"hljs-comment\">\t&#125;</span><br><span class=\"hljs-comment\"></span><br><span class=\"hljs-comment\">\tpublic static boolean isZhiShu(int num)&#123;</span><br><span class=\"hljs-comment\">\t\tfor(int i = 2; i &lt; num;i++ )&#123;</span><br><span class=\"hljs-comment\">\t\t\tif(num%i==0)&#123;</span><br><span class=\"hljs-comment\">\t\t\t\treturn false;</span><br><span class=\"hljs-comment\">\t\t\t&#125;</span><br><span class=\"hljs-comment\">\t\t&#125;</span><br><span class=\"hljs-comment\">\t\treturn true;</span><br><span class=\"hljs-comment\">\t&#125;</span><br><span class=\"hljs-comment\"></span><br><span class=\"hljs-comment\">&#125;</span><br><span class=\"hljs-comment\">*/</span><br> <br><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"方法重载\"><a href=\"#方法重载\" class=\"headerlink\" title=\"方法重载\"></a>方法重载</h3><p>同一个类中：方法名相同，形参个数或者类型不同。</p>\n<p>优点：代码整齐美观，记忆方法名较少。</p>\n<p>含义：就是可以定义多个相同名字的方法（例如：public static int sum(int a,int b)和public static int sum(long a,long b)）</p>\n<p>原理：Java编译器会自动识别方法名，若方法名相同，则进行参数类型匹配，所以名方法重载。</p>\n<p>怎么判断：方法名相同、形参类型不同、形参个数不同、形参顺序不同</p>\n<h3 id=\"方法递归\"><a href=\"#方法递归\" class=\"headerlink\" title=\"方法递归\"></a>方法递归</h3><p>含义：方法调用自己的方法！</p>\n<p>典例：从前有座山，山里有个和尚说：{从前有座山，山里有个和尚说}：{从前有座山，山里有个和尚说}——递归。。。</p>\n<p>老杜这样说：</p>\n<p>方法递归？</p>\n<p>​    1、什么是方法递归？</p>\n<p>​            方法自己调用自己，这就是方法递归。</p>\n<p>​    2、当递归时程序没有结束条件，一定会发生：</p>\n<p>​            栈内存溢出错误：StackOverflowError</p>\n<p>​            所以：递归必须要有结束条件。（这是一个非常重要的知识点。）</p>\n<p>​            JVM发生错误之后一定会推出JVM。</p>\n<p>​    3、递归假设是有结束条件的，就一定不会发生栈内存溢出吗？</p>\n<p>​            假设这个结束条件时对的，是合法的，递归有时候也会出现栈内存溢出的错误。</p>\n<p>​            因为有时候，可能递归的太深，栈内存不够（因为一直在压栈）</p>\n<p>​    4、不建议在实际的开发中使用递归，，能用for循环while循环代替的尽量使用循环来做，因为循环的效率较高，耗费内存少。递归耗费的内存较多，另外递归若使用不当，则会导致JVM的死掉。</p>\n<p>​        （极少数的情况下是必须要用递归的。）</p>\n<p>​        所以：递归还是要认真学习的！</p>\n<p>老杜讲经验：</p>\n<p>​    如果遇到了栈内存溢出，怎么调bug?</p>\n<p>​    第一步：</p>\n<p>​        先检查递归的结束条件对不对。如果不对，则进一步修改，直到正确。</p>\n<p>​    第二步：</p>\n<p>​        如果假设条件没问题，这个时候需要手动调整JVM的栈内存初始大小（通过命令行适当调大。）</p>\n<p>​    第三步：</p>\n<p>​        如果还会栈内存溢出，则继续调大。（Java -X  这个命令可以查看调整堆栈大小的参数。具体格式如下图所示：）</p>\n<p>老杜栈内存溢出图：</p>\n<p><img src=\"http://images.rl0206.love/image-20220715183512822.png\" alt=\"image-20220715183512822\"></p>\n<p>如何指 定栈内存大小：</p>\n<p><img src=\"http://images.rl0206.love/image-20220715184629869.png\" alt=\"image-20220715184629869\"></p>\n<h3 id=\"递归实例\"><a href=\"#递归实例\" class=\"headerlink\" title=\"递归实例\"></a>递归实例</h3><p>题目：计算1~ 10的和。</p>\n<p>不用递归思路：写一个for循环方法，直接调用。</p>\n<p>用递归思路：（方法调用打法）</p>\n<p><img src=\"http://images.rl0206.love/image-20220716094554506.png\" alt=\"image-20220716094554506\"></p>\n<h2 id=\"《代码的包装与封装》\"><a href=\"#《代码的包装与封装》\" class=\"headerlink\" title=\"《代码的包装与封装》\"></a>《代码的包装与封装》</h2><p>封装及使用方法：</p>\n<p><img src=\"http://images.rl0206.love/image-20220715170415137.png\" alt=\"image-20220715170415137\"></p>\n<h2 id=\"《认识面向对象》\"><a href=\"#《认识面向对象》\" class=\"headerlink\" title=\"《认识面向对象》\"></a>《认识面向对象》</h2><p>面向对象与面向过程：</p>\n<p>​    面向过程的优缺点：</p>\n<p>​        缺点：（高度耦合）</p>\n<p>​            面向过程的程序的每一个功能之间都是因果关系，因为A所以B，AB联合成一个子模块，然后模块与模块之间形成因果关系。因此任何一个功能之间出现问题，就会导致另一出现问题。 这就是高度耦合！（耦合度就是粘连程度）</p>\n<p>​            耦合度高导致扩展力差（主板集成显卡）</p>\n<p>​            耦合度低导致扩展力强（独立下显卡，螺栓与螺母等）</p>\n<p>​        优点：（快速开发）</p>\n<p>​            对于小型项目，可以直接通过因果关系来写代码。不需要前期对象的提取、模型的建立，可以直接干活，从而实现功能。</p>\n<p>什么是面向对象的开发模式？</p>\n<p>​    万物皆为对象，人眼看到的是各个对象之间的联系，更符合人类的思维方式。因此，面向对象在成为主流。</p>\n<p>如何判断面向过程和面向对象？</p>\n<p>​    可以通过耦合度等判断。</p>\n<p>三个过程：</p>\n<p>​    OOA–&gt;OOD–&gt;OOP</p>\n<p>​    分析      设计     编程</p>\n<p>三大特征：</p>\n<p>封装、继承、多态。（任何一个面向对象的编程语言都包括这三个特征。）</p>\n<h2 id=\"类与对象\"><a href=\"#类与对象\" class=\"headerlink\" title=\"类与对象\"></a>类与对象</h2><h3 id=\"浅析类与对象：\"><a href=\"#浅析类与对象：\" class=\"headerlink\" title=\"浅析类与对象：\"></a>浅析类与对象：</h3><p>​    类是一个集合，包含对象的特征，是特征的总结。</p>\n<p>​    而对象是真实存在的，万物皆可对象。</p>\n<p>在Java语言中，要想得到对象，必须先定义类，，，对象是通过类创建的。</p>\n<p>​    例如：先定义人类，才可以定义魏磊。哈哈哈哈。</p>\n<p>重要概念：</p>\n<p>​    《实例化》</p>\n<p>​            含义：通过类创建对象的过程叫做实例化。</p>\n<p>​    《实例》</p>\n<p>​            含义：对象又被称为实例。</p>\n<p>（此处补充类与对象的图）</p>\n<p>​    《抽象》</p>\n<p>​            含义：魏磊到人类的过程程为抽象。</p>\n<p>​    类–【实例化】–&gt;对象（实例）</p>\n<p>​    对象–【抽象】–&gt;类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Java\"><span class=\"hljs-keyword\">public</span> class 明星类&#123;<br>    <span class=\"hljs-comment\">/*</span><br><span class=\"hljs-comment\">    类 = 属性 + 方法</span><br><span class=\"hljs-comment\"></span><br><span class=\"hljs-comment\">\t属性来源于状态； （名词）\t数据是以数据形式存在的，所以只能存放在变量中。\t\t即属性即变量。</span><br><span class=\"hljs-comment\"></span><br><span class=\"hljs-comment\">\t方法来源于动作； （动词）</span><br><span class=\"hljs-comment\">\t*/</span><br>    <span class=\"hljs-comment\">//属性</span><br>    <span class=\"hljs-type\">int</span> 身高;<br>    <span class=\"hljs-type\">int</span> 体重;<br>    <br>    <span class=\"hljs-comment\">//方法</span><br>    打篮球（）&#123;<br>        <br>    &#125;<br>    学习（）&#123;<br>        <br>    &#125;<br>    <br>    <br><br><br>&#125;<br></code></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"对象的创建：\"><a href=\"#对象的创建：\" class=\"headerlink\" title=\"对象的创建：\"></a>对象的创建：</h3><p>​    “没对象，new一个”</p>\n<p>​        创建对象语法：XueSheng  s1 = new XueSheng();</p>\n<p>​                                            XueSheng  s1 = new XueSheng()；此时此刻就相当于 ：int i = 1；</p>\n<pre><code>                                         XueSheng:数据类型\n</code></pre>\n<p>​                                            s1:变量名</p>\n<p>​                                            new:运算符</p>\n<p>​                                            XueSheng:类名</p>\n<h2 id=\"Java变量\"><a href=\"#Java变量\" class=\"headerlink\" title=\"Java变量\"></a>Java变量</h2><p>变量的分类：</p>\n<p>1局部变量</p>\n<p>2成员变量</p>\n<p>3静态变量</p>\n<p>4常量        （要求大写）</p>\n<p>————————————笔记分隔线———————————</p>\n<h1 id=\"Java进阶之路笔记\"><a href=\"#Java进阶之路笔记\" class=\"headerlink\" title=\"Java进阶之路笔记\"></a>Java进阶之路笔记</h1><h2 id=\"常用的48个关键字\"><a href=\"#常用的48个关键字\" class=\"headerlink\" title=\"常用的48个关键字\"></a>常用的48个关键字</h2><p><a href=\"https://tobebetterjavaer.com/about-the-author/\">沉默王二</a>2021年10月22日Java核心Java大约 4 分钟</p>\n<hr>\n<p>“二哥，就我之前学过的这些 Java 代码中，有 public、static、void、main 等等，它们应该都是关键字吧？”三妹的脸上泛着甜甜的笑容，我想她在学习 Java 方面已经变得越来越自信了。</p>\n<p>“是的，三妹。Java 中的关键字可不少呢！你一下子可能记不了那么多，不过，先保留个印象吧，对以后的学习会很有帮助。”</p>\n<p>PS：按照首字母的自然顺序排列。</p>\n<ol>\n<li><strong>abstract：</strong> 用于声明抽象类，以及抽象方法。</li>\n<li><strong>boolean：</strong> 用于将变量声明为布尔值类型，只有 true 和 false 两个值。</li>\n<li><strong>break：</strong> 用于中断循环或 switch 语句。</li>\n<li><strong>byte：</strong> 用于声明一个可以容纳 8 个比特的变量。</li>\n<li><strong>case：</strong> 用于在 switch 语句中标记条件的值。</li>\n<li><strong>catch：</strong> 用于捕获 try 语句中的异常。</li>\n<li><strong>char：</strong> 用于声明一个可以容纳无符号 16 位比特的 <a href=\"https://mp.weixin.qq.com/s/pNQjlXOivIgO3pbYc0GnpA\">Unicode 字符open in new window</a>的变量。</li>\n<li><strong>class：</strong> 用于声明一个类。</li>\n<li><strong>continue：</strong> 用于继续下一个循环，可以在指定条件下跳过其余代码。</li>\n<li><strong>default：</strong> 用于指定 switch 语句中除去 case 条件之外的默认代码块。</li>\n<li><strong>do：</strong> 通常和 while 关键字配合使用，do 后紧跟循环体。</li>\n<li><strong>double：</strong> 用于声明一个可以容纳 64 位浮点数的变量。</li>\n<li><strong>else：</strong> 用于指示 if 语句中的备用分支。</li>\n<li><strong>enum：</strong> 用于定义一组固定的常量（枚举）。</li>\n<li><strong>extends：</strong> 用于指示一个类是从另一个类或接口继承的。</li>\n<li><strong>final：</strong> 用于指示该变量是不可更改的。</li>\n<li><strong>finally：</strong> 和 <code>try-catch</code> 配合使用，表示无论是否处理异常，总是执行 finally 块中的代码。</li>\n<li><strong>float：</strong> 用于声明一个可以容纳 32 位浮点数的变量。</li>\n<li><strong>for：</strong> 用于声明一个 for 循环，如果循环次数是固定的，建议使用 for 循环。</li>\n<li><strong>if：</strong> 用于指定条件，如果条件为真，则执行对应代码。</li>\n<li><strong>implements：</strong> 用于实现接口。</li>\n<li><strong>import：</strong> 用于导入对应的类或者接口。</li>\n<li><strong>instanceof：</strong> 用于判断对象是否属于某个类型（class）。</li>\n<li><strong>int：</strong> 用于声明一个可以容纳 32 位带符号的整数变量。</li>\n<li><strong>interface：</strong> 用于声明接口。</li>\n<li><strong>long：</strong> 用于声明一个可以容纳 64 位整数的变量。</li>\n<li><strong>native：</strong> 用于指定一个方法是通过调用本机接口（非 Java）实现的。</li>\n<li><strong>new：</strong> 用于创建一个新的对象。</li>\n<li><strong>null：</strong> 如果一个变量是空的（什么引用也没有指向），就可以将它赋值为 null，和空指针异常息息相关。</li>\n<li><strong>package：</strong> 用于声明类所在的包。</li>\n<li><strong>private：</strong> 一个访问权限修饰符，表示方法或变量只对当前类可见。</li>\n<li><strong>protected：</strong> 一个访问权限修饰符，表示方法或变量对同一包内的类和所有子类可见。</li>\n<li><strong>public：</strong> 一个访问权限修饰符，除了可以声明方法和变量（所有类可见），还可以声明类。<code>main()</code> 方法必须声明为 public。</li>\n<li><strong>return：</strong> 用于在代码执行完成后返回（一个值）。</li>\n<li><strong>short：</strong> 用于声明一个可以容纳 16 位整数的变量。</li>\n<li><strong>static：</strong> 表示该变量或方法是静态变量或静态方法。</li>\n<li><strong>strictfp：</strong> 并不常见，通常用于修饰一个方法，确保方法体内的浮点数运算在每个平台上执行的结果相同。</li>\n<li><strong>super：</strong> 可用于调用父类的方法或者字段。</li>\n<li><strong>switch：</strong> 通常用于三个（以上）的条件判断。</li>\n<li><strong>synchronized：</strong> 用于指定多线程代码中的同步方法、变量或者代码块。</li>\n<li><strong>this：</strong> 可用于在方法或构造函数中引用当前对象。</li>\n<li><strong>throw：</strong> 主动抛出异常。</li>\n<li><strong>throws：</strong> 用于声明异常。</li>\n<li><strong>transient：</strong> 修饰的字段不会被序列化。</li>\n<li><strong>try：</strong> 于包裹要捕获异常的代码块。</li>\n<li><strong>void：</strong> 用于指定方法没有返回值。</li>\n<li><strong>volatile：</strong> 保证不同线程对它修饰的变量进行操作时的可见性，即一个线程修改了某个变量的值，新值对其他线程来说是立即可见的。</li>\n<li><strong>while：</strong> 如果循环次数不固定，建议使用 while 循环。</li>\n</ol>\n<h2 id=\"关键字顺序排序：\"><a href=\"#关键字顺序排序：\" class=\"headerlink\" title=\"关键字顺序排序：\"></a><strong>关键字顺序排序</strong>：</h2><p>byte&lt;short(char)&lt;int&lt;long&lt;float&lt;doublepackage step2;</p>\n<h2 id=\"用户自定义方法\"><a href=\"#用户自定义方法\" class=\"headerlink\" title=\"用户自定义方法\"></a><strong>用户自定义方法</strong></h2><h2 id=\"（tips：如果是静态方法，那么调用时就不用new关键字来创建对象来调用了）\"><a href=\"#（tips：如果是静态方法，那么调用时就不用new关键字来创建对象来调用了）\" class=\"headerlink\" title=\"（tips：如果是静态方法，那么调用时就不用new关键字来创建对象来调用了）\"></a>（tips：如果是静态方法，那么调用时就不用new关键字来创建对象来调用了）</h2><p>当预先定义方法无法满足我们的要求时，就需要自定义一些方法，比如说，我们来定义这样一个方法，用来检查数字是偶数还是奇数。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">findEvenOdd</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> num)</span> &#123;<br>    <span class=\"hljs-keyword\">if</span> (num % <span class=\"hljs-number\">2</span> == <span class=\"hljs-number\">0</span>) &#123;<br>        System.out.println(num + <span class=\"hljs-string\">&quot; 是偶数&quot;</span>);<br>    &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>        System.out.println(num + <span class=\"hljs-string\">&quot; 是奇数&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>方法名叫做 <code>findEvenOdd</code>，访问权限修饰符是 public，并且是静态的（static），返回类型是 void，参数有一个整型（int）的 num。方法体中有一个 if else 语句，如果 num 可以被 2 整除，那么就打印这个数字是偶数，否则就打印这个数字是奇数。</p>\n<p>方法被定义好后，如何被调用呢？</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * <span class=\"hljs-doctag\">@author</span> 微信搜「沉默王二」，回复关键字 PDF</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">EvenOddDemo</span> &#123;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> &#123;<br>        findEvenOdd(<span class=\"hljs-number\">10</span>);<br>        findEvenOdd(<span class=\"hljs-number\">11</span>);<br>    &#125;<br><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">findEvenOdd</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> num)</span> &#123;<br>        <span class=\"hljs-keyword\">if</span> (num % <span class=\"hljs-number\">2</span> == <span class=\"hljs-number\">0</span>) &#123;<br>            System.out.println(num + <span class=\"hljs-string\">&quot; 是偶数&quot;</span>);<br>        &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>            System.out.println(num + <span class=\"hljs-string\">&quot; 是奇数&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><code>main()</code> 方法是程序的入口，并且是静态的，那么就可以直接调用同样是静态方法的 <code>findEvenOdd()</code>。</p>\n<p>当一个方法被 static 关键字修饰时，它就是一个静态方法。换句话说，静态方法是属于类的，不属于类实例的（不需要通过 new 关键字创建对象来调用，直接通过类名就可以调用）。</p>\n<h2 id=\"访问权限控制\"><a href=\"#访问权限控制\" class=\"headerlink\" title=\"访问权限控制\"></a>访问权限控制</h2><h3 id=\"1-修饰类\"><a href=\"#1-修饰类\" class=\"headerlink\" title=\"1.修饰类\"></a><strong>1.修饰类</strong></h3><ul>\n<li>默认访问权限（包访问权限）：用来修饰类的话，表示该类只对同一个包中的其他类可见。</li>\n<li>public：用来修饰类的话，表示该类对其他所有的类都可见。</li>\n</ul>\n<h3 id=\"2-修饰类的方法和变量\"><a href=\"#2-修饰类的方法和变量\" class=\"headerlink\" title=\"2.修饰类的方法和变量\"></a><strong>2.修饰类的方法和变量</strong></h3><ul>\n<li>默认访问权限（包访问权限）：如果一个类的方法或变量被包访问权限修饰，也就意味着只能在同一个包中的其他类中显示地调用该类的方法或者变量，在不同包中的类中不能显式地调用该类的方法或变量。</li>\n<li>private：如果一个类的方法或者变量被 private 修饰，那么这个类的方法或者变量只能在该类本身中被访问，在类外以及其他类中都不能显式的进行访问。</li>\n<li>protected：如果一个类的方法或者变量被 protected 修饰，对于同一个包的类，这个类的方法或变量是可以被访问的。对于不同包的类，只有继承于该类的类才可以访问到该类的方法或者变量。</li>\n<li>public：被 public 修饰的方法或者变量，在任何地方都是可见的。</li>\n</ul>\n<h2 id=\"代码初始化块\"><a href=\"#代码初始化块\" class=\"headerlink\" title=\"代码初始化块\"></a>代码初始化块</h2><p>三个规则：</p>\n<ul>\n<li>类实例化的时候执行代码初始化块；</li>\n<li>实际上，代码初始化块是放在构造方法中执行的，只不过比较靠前；</li>\n<li>代码初始化块里的执行顺序是从前到后的。</li>\n</ul>\n<h2 id=\"补充：什么叫构造方法？有参？无参？\"><a href=\"#补充：什么叫构造方法？有参？无参？\" class=\"headerlink\" title=\"补充：什么叫构造方法？有参？无参？\"></a>补充：什么叫构造方法？有参？无参？</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">StudentDemo</span> &#123;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> &#123;<br>       <br>        <span class=\"hljs-comment\">// 类名称 对象名 = new 类名称();</span><br>        <span class=\"hljs-type\">Student</span> <span class=\"hljs-variable\">stu1</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Student</span>();           <span class=\"hljs-comment\">//无参构造方法执行</span><br>        <span class=\"hljs-type\">Student</span> <span class=\"hljs-variable\">stu2</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Student</span>(<span class=\"hljs-string\">&quot;张三&quot;</span>,<span class=\"hljs-number\">23</span>);   <span class=\"hljs-comment\">//全参构造方法执行</span><br>        <span class=\"hljs-comment\">//赋值</span><br>        stu1.setName(<span class=\"hljs-string\">&quot;李四&quot;</span>);<br>        stu1.setAge(<span class=\"hljs-number\">23</span>);<br>       <br>        <span class=\"hljs-comment\">//对象名.成员变量名；</span><br>        System.out.println(<span class=\"hljs-string\">&quot;姓名：&quot;</span>+stu1.getName()+<span class=\"hljs-string\">&quot;，年龄：&quot;</span>+ stu1.getAge());<br>        System.out.println(<span class=\"hljs-string\">&quot;姓名：&quot;</span>+stu2.getName()+<span class=\"hljs-string\">&quot;，年龄：&quot;</span>+ stu2.getAge());<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"方法的继承\"><a href=\"#方法的继承\" class=\"headerlink\" title=\"方法的继承\"></a>方法的继承</h2><p>关键字：extend，super（用于继承父类）</p>\n<p>“在默认情况下，子类的构造方法在执行的时候会主动去调用父类的构造方法。也就是说，其实是构造方法先执行的，再执行的代码初始化块。”</p>\n<p><strong>知识拓展：</strong></p>\n<p>什么是@Overwide?</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-meta\">@Override</span>是伪代码,表示重写(当然不写也可以)，不过写上有如下好处:<br><span class=\"hljs-number\">1</span>、可以当注释用,方便阅读；<br><span class=\"hljs-number\">2</span>、编译器可以给你验证<span class=\"hljs-meta\">@Override</span>下面的方法名是否是你父类中所有的，如果没有则报错。例如，你如果没写<span class=\"hljs-meta\">@Override</span>，而你下面的方法名又写错了，这时你的编译器是可以编译通过的，因为编译器以为这个方法是你的子类中自己增加的方法。<br> <br>举例：在重写父类的onCreate时，在方法前面加上<span class=\"hljs-meta\">@Override</span> 系统可以帮你检查方法的正确性。<br><span class=\"hljs-meta\">@Override</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">onCreate</span><span class=\"hljs-params\">(Bundle savedInstanceState)</span><br><br>&#123;…….&#125;<br>这种写法是正确的，如果你写成：<br><br><span class=\"hljs-meta\">@Override</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">oncreate</span><span class=\"hljs-params\">(Bundle savedInstanceState)</span><br>&#123;…….&#125;<br>编译器会报如下错误：The method <span class=\"hljs-title function_\">oncreate</span><span class=\"hljs-params\">(Bundle)</span> of type HelloWorld must override or implement a supertype method，以确保你正确重写onCreate方法（因为oncreate应该为onCreate）。而如果你不加<span class=\"hljs-meta\">@Override</span>，则编译器将不会检测出错误，而是会认为你为子类定义了一个新方法：oncreate<br></code></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"抽象类\"><a href=\"#抽象类\" class=\"headerlink\" title=\"抽象类\"></a>抽象类</h2><h3 id=\"敲黑板知识点：\"><a href=\"#敲黑板知识点：\" class=\"headerlink\" title=\"敲黑板知识点：\"></a>敲黑板知识点：</h3><p><strong>写在前面：</strong></p>\n<p>什么是抽象？抽象的含义？</p>\n<p>​        抽象是不确定的、不具体的概念或事物。在Java中的抽象类，是指需要在子类中通过方法扩展来实现新的方法。</p>\n<p><strong>关键字：</strong>abstract</p>\n<p><strong>语句格式：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Java\"><span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">AbstractPlayer</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><strong>命名规则：</strong></p>\n<p>关于抽象类的命名，《阿里的 Java 开发手册》上有强调，“抽象类命名要使用 Abstract 或 Base 开头”，这条规约还是值得遵守的。</p>\n<p><strong>Tips：</strong></p>\n<p>抽象类是不能实例化的，尝试通过 <code>new</code> 关键字实例化的话，编译器会报错，提示“类是抽象的，不能实例化”。</p>\n<p>虽然抽象类不能实例化，但可以有子类。子类通过 <code>extends</code> 关键字来继承抽象类。就像下面这样。</p>\n<p>Demo code:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">BasketballPlayer</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">AbstractPlayer</span> &#123;<br>&#125;<br><br></code></pre></td></tr></table></figure>\n\n<p>抽象的方法不能定义在普通类中。否则会在类和方法处出现两个报错。</p>\n<p>错误提示。第一处在类级别上，提示“这个类必须通过 <code>abstract</code> 关键字定义”，见下图。</p>\n<p><img src=\"http://cdn.tobebetterjavaer.com/tobebetterjavaer/images/object-class/abstract-02.png\" alt=\"img\"></p>\n<p>第二处在尝试定义 abstract 的方法上，提示“抽象方法所在的类不是抽象的”，见下图。</p>\n<p><img src=\"http://cdn.tobebetterjavaer.com/tobebetterjavaer/images/object-class/abstract-03.png\" alt=\"img\"></p>\n<p><strong>But,抽象类中既可以定义抽象方法、也可以普通方法。</strong></p>\n<h3 id=\"抽象方法的应用场景\"><a href=\"#抽象方法的应用场景\" class=\"headerlink\" title=\"抽象方法的应用场景\"></a>抽象方法的应用场景</h3><p><strong>第一种场景</strong>。</p>\n<p>当我们希望一些通用的功能被多个子类复用的时候，就可以使用抽象类。比如说，<code>AbstractPlayer</code> 抽象类中有一个普通的方法 <code>sleep()</code>，表明所有运动员都需要休息，那么这个方法就可以被子类复用。</p>\n<p>Demo:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">AbstractPlayer</span> &#123;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">sleep</span><span class=\"hljs-params\">()</span> &#123;<br>        System.out.println(<span class=\"hljs-string\">&quot;运动员也要休息而不是挑战极限&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>子类 <code>BasketballPlayer</code> 继承了 <code>AbstractPlayer</code> 类：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">BasketballPlayer</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">AbstractPlayer</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>也就拥有了 <code>sleep()</code> 方法。<code>BasketballPlayer </code>的对象可以直接调用父类的 <code>sleep() </code>方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-type\">BasketballPlayer</span> <span class=\"hljs-variable\">basketballPlayer</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">BasketballPlayer</span>();<br>basketballPlayer.sleep();<br></code></pre></td></tr></table></figure>\n\n<p>如此，就实现了代码的复用。</p>\n<p><strong>第二种场景</strong>。</p>\n<p>当我们需要在抽象类中定义好 <code>API</code>，然后在子类中扩展实现的时候就可以使用抽象类。比如说，<code>AbstractPlayer</code> 抽象类中定义了一个抽象方法 <code>play()</code>，表明所有运动员都可以从事某项运动，但需要对应子类去扩展实现，表明篮球运动员打篮球，足球运动员踢足球。</p>\n<p><strong>知识拓展：</strong></p>\n<p>什么是API？</p>\n<p>API（Application Programming Interface,应用程序编程接口）是一些预先定义的函数，目的是提供应用程序与开发人员基于某软件或硬件得以访问一组例程的能力，而又无需访问源码，或理解内部工作机制的细节。”</p>\n<p><strong>抽象类实例：</strong></p>\n<p>读取大小写helloworld：</p>\n<p><a href=\"\">https://tobebetterjavaer.com/oo/abstract.html</a></p>\n<h2 id=\"接口\"><a href=\"#接口\" class=\"headerlink\" title=\"接口\"></a>接口</h2><p>关键字：</p>\n<p>interface</p>\n<p>语法格式：</p>\n<p>public interface jiekou1</p>\n<p>class A extends B implements jiekou1,jiekou2,jiekou3</p>\n<p>小结论：</p>\n<ul>\n<li>接口中允许定义变量</li>\n<li>接口中允许定义抽象方法</li>\n<li>接口中允许定义静态方法（Java 8 之后）</li>\n<li>接口中允许定义默认方法（Java 8 之后）</li>\n</ul>\n<p>除此之外，我们还应该知道：</p>\n<p>1）接口不允许直接实例化，否则编译器会报错。</p>\n<p><img src=\"http://cdn.tobebetterjavaer.com/tobebetterjavaer/images/object-class/interface-04.png\" alt=\"img\"></p>\n<p>需要定义一个类去实现接口，见下例。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Computer</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title class_\">Electronic</span> &#123;<br><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> &#123;<br>        <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Computer</span>();<br>    &#125;<br><br>    <span class=\"hljs-meta\">@Override</span><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">getElectricityUse</span><span class=\"hljs-params\">()</span> &#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>然后再实例化。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Java\"><span class=\"hljs-type\">Electronic</span> <span class=\"hljs-variable\">e</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Computer</span>();<br></code></pre></td></tr></table></figure>\n\n<p>知识点拓展：</p>\n<p>JAVA中extends 与implements有啥区别？</p>\n<ol>\n<li>在类的声明中，通过关键字extends来创建一个类的子类。一个类通过关键字implements声明自己使用一个或者多个接口。<br>extends 是继承某个类, 继承之后可以使用父类的方法, 也可以重写父类的方法; implements 是实现多个接口, 接口的方法一般为空的, 必须重写才能使用</li>\n<li>extends是继承父类，只要那个类不是声明为final或者那个类定义为abstract的就能继承，JAVA中不支持多重继承，但是可以用接口 来实现，这样就要用到implements，继承只能继承一个类，但implements可以实现多个接口，用逗号分开就行了<br>比如<br>class A extends B implements C,D,E</li>\n</ol>\n<p><a href=\"https://blog.csdn.net/android_lover2014/article/details/52176814\">(56条消息) Java之implements_小白study的博客-CSDN博客_implements</a></p>\n<p>作业：多态与重载</p>\n<p>​            构造与重载</p>\n<p>​            抽象类与接口？</p>\n<h2 id=\"内部类\"><a href=\"#内部类\" class=\"headerlink\" title=\"内部类\"></a>内部类</h2><p><strong>== = = = = = = <a href=\"https://so.csdn.net/so/search?q=%E5%86%85%E9%83%A8%E7%B1%BB&spm=1001.2101.3001.7020\">内部类</a>（四种内部类详解）= = = = = = = ==</strong></p>\n<p><strong>一、基本介绍：一个类的内部又完整的嵌套了另一个类结构。被嵌套的类称为内部类(inner class),嵌套其他类的类称为外部类(outer class)。是我们类的第五大成员【思考:类的五大成员是哪些?[属性、方法、构造器、代码块、内部类]】，内部类最大的特点就是可以直接访问私有属性，并且可以体现类与类之间的包含关系，注意:内部类是学习的难点,同时也是重点,后面看底层源码时,有大量的内部类.</strong><br><strong>如果定义类在局部位置(方法中/代码块) :(1) 局部内部类 (2) 匿名内部类<br>定义在成员位置 (1) 成员内部类 (2)静态内部类</strong></p>\n<p>在 Java 中，可以将一个类定义在另外一个类里面或者一个方法里面，这样的类叫做内部类。</p>\n<p><strong>二、基本语法</strong><br><strong>class Outer{ //外部类<br>class Inner{ //内部类<br>}<br>}<br>class Other{ //外部其他类<br>}</strong></p>\n<p>三、分类</p>\n<p>一般来说，内部类分为成员内部类、局部内部类、匿名内部类和静态内部类。</p>\n<p>定义在外部类的局部位置上(如方法内):<br>1)局部内部类(有类名)<br>2)匿名内部类(没有类名，重点!!!)</p>\n<p>定义在外部类的成员位置上:<br>1)成员内部类(没用static修饰)<br>2)静态内部类（使用static修饰)</p>\n<p><strong>1.成员内部类：</strong></p>\n<p>成员内部类可以无限制访问外部类的所有成员属性。</p>\n<p>内部类可以随心所欲地访问外部类的成员，但外部类想要访问内部类的成员，就不那么容易了，必须先创建一个成员内部类的对象，再通过这个对象来访问：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Wanger</span> &#123;<br>    <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">age</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">18</span>;<br>    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">name</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;沉默王二&quot;</span>;<br>    <span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">double</span> <span class=\"hljs-variable\">money</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">1</span>;<br><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-title function_\">Wanger</span> <span class=\"hljs-params\">()</span> &#123;<br>        <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Wangxiaoer</span>().print();<br>    &#125;<br><br>    <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Wangxiaoer</span> &#123;<br>        <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">age</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">81</span>;<br><br>        <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">print</span><span class=\"hljs-params\">()</span> &#123;<br>            System.out.println(name);<br>            System.out.println(money);<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>\n\n<p>这种创建内部类的方式在实际开发中并不常用，因为内部类和外部类紧紧地绑定在一起，使用起来非常不便。</p>\n<p><strong>2.局部内部类</strong></p>\n<p><strong>3.匿名内部类</strong></p>\n<p><strong>4.静态内部类</strong></p>\n<p>第一，静态内部类不能访问外部类的所有成员变量；</p>\n<p>第二，静态内部类可以访问外部类的所有静态变量，包括私有静态变量。</p>\n<p>第三，外部类不能声明为 static。”</p>\n<p>“三妹，你看，在 Singleton 类上加 static 后，编译器就提示错误了。”</p>\n<p><img src=\"http://cdn.tobebetterjavaer.com/tobebetterjavaer/images/keywords/19-08.png\" alt=\"img\"></p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>为什么要使用内部类？</p>\n<p>在《Think in java》中有这样一句话：</p>\n<blockquote>\n<p>使用内部类最吸引人的原因是：每个内部类都能独立地继承一个（接口的）实现，所以无论外围类是否已经继承了某个（接口的）实现，对于内部类都没有影响。</p>\n</blockquote>\n<p>在我们程序设计中有时候会存在一些使用接口很难解决的问题，这个时候我们可以利用内部类提供的、可以继承多个具体的或者抽象的类的能力来解决这些程序设计问题。可以这样说，接口只是解决了部分问题，而内部类使得多重继承的解决方案变得更加完整。</p>\n<p>使用内部类还能够为我们带来如下特性（摘自《Think in java》）：</p>\n<ul>\n<li>1、内部类可以使用多个实例，每个实例都有自己的状态信息，并且与其他外围对象的信息相互独立。</li>\n<li>2、在单个外部类中，可以让多个内部类以不同的方式实现同一个接口，或者继承同一个类。</li>\n<li>3、创建内部类对象的时刻并不依赖于外部类对象的创建。</li>\n<li>4、内部类并没有令人迷惑的“is-a”关系，他就是一个独立的实体。</li>\n<li>5、内部类提供了更好的封装，除了该外围类，其他类都不能访问。</li>\n</ul>\n<h2 id=\"关键字\"><a href=\"#关键字\" class=\"headerlink\" title=\"关键字\"></a>关键字</h2><h3 id=\"1-static\"><a href=\"#1-static\" class=\"headerlink\" title=\"1.static\"></a>1.static</h3><p><strong>static的作用</strong></p>\n<p>“static 关键字的作用可以用一句话来描述：‘<strong>方便在没有创建对象的情况下进行调用</strong>，包括变量和方法’。也就是说，只要类被加载了，就可以通过类名进行访问。”我扶了扶沉重眼镜，继续说到，“static 可以用来修饰类的成员变量，以及成员方法。我们一个个来看。”</p>\n<p>demo：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Counter</span> &#123;<br>    <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">count</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span>;<br><br>    Counter() &#123;<br>        count++;<br>        System.out.println(count);<br>    &#125;<br><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String args[])</span> &#123;<br>        <span class=\"hljs-type\">Counter</span> <span class=\"hljs-variable\">c1</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Counter</span>();<br>        <span class=\"hljs-type\">Counter</span> <span class=\"hljs-variable\">c2</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Counter</span>();<br>        <span class=\"hljs-type\">Counter</span> <span class=\"hljs-variable\">c3</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Counter</span>();<br>    &#125;<br>&#125;<br><span class=\"hljs-comment\">/*</span><br><span class=\"hljs-comment\">我们创建一个成员变量 count，并且在构造函数中让它自增。因为成员变量会在创建对象的时候获取内存，因此每一个对象都会有一个 count 的副本， count 的值并不会随着对象的增多而递增。</span><br><span class=\"hljs-comment\">*/</span><br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">StaticCounter</span> &#123;<br>    <span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">count</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span>;<br><br>    StaticCounter() &#123;<br>        count++;<br>        System.out.println(count);<br>    &#125;<br><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String args[])</span> &#123;<br>        <span class=\"hljs-type\">StaticCounter</span> <span class=\"hljs-variable\">c1</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">StaticCounter</span>();<br>        <span class=\"hljs-type\">StaticCounter</span> <span class=\"hljs-variable\">c2</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">StaticCounter</span>();<br>        <span class=\"hljs-type\">StaticCounter</span> <span class=\"hljs-variable\">c3</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">StaticCounter</span>();<br>    &#125;<br>&#125;<br><span class=\"hljs-comment\">/*</span><br><span class=\"hljs-comment\">简单解释一下哈，由于静态变量只会获取一次内存空间，所以任何对象对它的修改都会得到保留，所以每创建一个对象，count 的值就会加 1，所以最终的结果是 3，明白了吧？三妹。这就是静态变量和成员变量之间的差别。</span><br><span class=\"hljs-comment\">*/</span><br></code></pre></td></tr></table></figure>\n\n<p>warnning:</p>\n<p>“另外，需要注意的是，由于静态变量属于一个类，所以不要通过对象引用来访问，而应该直接通过类名来访问，否则编译器会发出警告。”</p>\n<p><img src=\"http://cdn.tobebetterjavaer.com/tobebetterjavaer/images/keywords/19-03.png\" alt=\"img\"></p>\n<p>static的特点：</p>\n<ul>\n<li>静态方法属于这个类而不是这个类的对象；</li>\n</ul>\n<p>​        （因为静态方法不用类的实例化，所以直接通过类来调用，不通过类的实例来调用，因此不应通过对象调用）</p>\n<ul>\n<li>调用静态方法的时候不需要创建这个类的对象；</li>\n<li>静态方法可以访问静态变量。</li>\n</ul>\n<p>那么问题来了，为什么main方法是静态的，这就涉及到Java的编译器JVM了，为了代码简洁与方便调用，main函数作为程序的入口，所以设为静态更为合适。</p>\n<p>二哥这么说：</p>\n<p><code>“如果 main 方法不是静态的，就意味着 Java 虚拟机在执行的时候需要先创建一个对象才能调用 main 方法，而 main 方法作为程序的入口，创建一个额外的对象显得非常多余。”我不假思索的回答令三妹感到非常的钦佩。</code></p>\n<p>“java.lang.Math 类的几乎所有方法都是静态的，可以直接通过类名来调用，不需要创建类的对象。”</p>\n<p><img src=\"http://cdn.tobebetterjavaer.com/tobebetterjavaer/images/keywords/19-06.png\" alt=\"img\"></p>\n<p>综上所述（由上可得）：</p>\n<p>一些函数基本上都是静态的。</p>\n<h3 id=\"静态代码块\"><a href=\"#静态代码块\" class=\"headerlink\" title=\"静态代码块\"></a>静态代码块</h3><p>“除了静态变量和静态方法，static 关键字还有一个重要的作用。”我心情愉悦地对三妹说，“用一个 static 关键字，外加一个大括号括起来的代码被称为静态代码块。”</p>\n<p>“就像下面这串代码。”</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">StaticBlock</span> &#123;<br>    <span class=\"hljs-keyword\">static</span> &#123;<br>        System.out.println(<span class=\"hljs-string\">&quot;静态代码块&quot;</span>);<br>    &#125;<br><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> &#123;<br>        System.out.println(<span class=\"hljs-string\">&quot;main 方法&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>“静态代码块通常用来初始化一些静态变量，它会优先于 <code>main()</code> 方法执行。”</p>\n<h3 id=\"2-this\"><a href=\"#2-this\" class=\"headerlink\" title=\"2.this\"></a>2.this</h3><p>this除了可以指向当前方法或者构造函数的对象，还可以完成以下工作：</p>\n<ul>\n<li>调用当前类的方法；</li>\n<li><code>this()</code> 可以调用当前类的构造方法；</li>\n<li>this 可以作为参数在方法中传递；</li>\n<li>this 可以作为参数在构造方法中传递；</li>\n<li>this 可以作为方法的返回值，返回当前类的对象。</li>\n</ul>\n<h3 id=\"01、-指向当前对象\"><a href=\"#01、-指向当前对象\" class=\"headerlink\" title=\"01、 指向当前对象\"></a>01、 指向当前对象</h3><p><strong>demo</strong>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Java\">WithoutThisStudent(String name, <span class=\"hljs-type\">int</span> age) &#123;<br>        name = name;<br>        age = age;<br>    &#125;<br><br></code></pre></td></tr></table></figure>\n\n<p>伪代码运行结果：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Java\"><span class=\"hljs-literal\">null</span>\t<span class=\"hljs-number\">0</span><br><br><span class=\"hljs-literal\">null</span>\t<span class=\"hljs-number\">0</span><br></code></pre></td></tr></table></figure>\n\n<p>更改之后的demo:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">WithThisStudent(String name, <span class=\"hljs-type\">int</span> age) &#123;<br>        <span class=\"hljs-built_in\">this</span>.name = name;<br>        <span class=\"hljs-built_in\">this</span>.age = age;<br>    &#125;<br></code></pre></td></tr></table></figure>\n\n<p>运行正确√</p>\n<h3 id=\"02、调用当前类的方法\"><a href=\"#02、调用当前类的方法\" class=\"headerlink\" title=\"02、调用当前类的方法\"></a>02、调用当前类的方法</h3><p>“我们可以在一个类中使用 this 关键字来调用另外一个方法，如果没有使用的话，编译器会自动帮我们加上。”我对自己深厚的编程功底充满自信，“在源代码中，<code>method2()</code> 在调用 <code>method1()</code> 的时候并没有使用 this 关键字，但通过反编译后的字节码可以看得到。”</p>\n<h3 id=\"03、调用当前类的构造方法\"><a href=\"#03、调用当前类的构造方法\" class=\"headerlink\" title=\"03、调用当前类的构造方法\"></a>03、调用当前类的构造方法</h3><p>调用无参的constructor</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">InvokeConstrutor</span> &#123;<br>    InvokeConstrutor() &#123;<br>        System.out.println(<span class=\"hljs-string\">&quot;hello&quot;</span>);<br>    &#125;<br><br>    InvokeConstrutor(<span class=\"hljs-type\">int</span> count) &#123;<br>        <span class=\"hljs-built_in\">this</span>();<br>        System.out.println(count);<br>    &#125;<br><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> &#123;<br>        <span class=\"hljs-type\">InvokeConstrutor</span> <span class=\"hljs-variable\">invokeConstrutor</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">InvokeConstrutor</span>(<span class=\"hljs-number\">10</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n\n\n<p>“也可以在无参构造方法中使用 <code>this()</code> 并传递参数来调用有参构造方法。”话音没落，我就在键盘上敲了起来，“来看下面这段代码。”</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">InvokeParamConstrutor</span> &#123;<br>    InvokeParamConstrutor() &#123;<br>        <span class=\"hljs-built_in\">this</span>(<span class=\"hljs-number\">10</span>);<br>        System.out.println(<span class=\"hljs-string\">&quot;hello&quot;</span>);<br>    &#125;<br><br>    InvokeParamConstrutor(<span class=\"hljs-type\">int</span> count) &#123;<br>        System.out.println(count);<br>    &#125;<br><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> &#123;<br>        <span class=\"hljs-type\">InvokeParamConstrutor</span> <span class=\"hljs-variable\">invokeConstrutor</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">InvokeParamConstrutor</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n\n\n<p>warning：</p>\n<p>“不过，需要注意的是，<code>this()</code> 必须放在构造方法的第一行，否则就报错了。”</p>\n<p><img src=\"http://cdn.tobebetterjavaer.com/tobebetterjavaer/images/keywords/20-01.png\" alt=\"img\"></p>\n<h3 id=\"04、作为参数在方法中传递（没看懂\"><a href=\"#04、作为参数在方法中传递（没看懂\" class=\"headerlink\" title=\"*04、作为参数在方法中传递（没看懂\"></a>*04、作为参数在方法中传递（没看懂</h3><h3 id=\"05、作为参数在构造方法中传递\"><a href=\"#05、作为参数在构造方法中传递\" class=\"headerlink\" title=\"05、作为参数在构造方法中传递\"></a>05、作为参数在构造方法中传递</h3><h3 id=\"06、作为方法的返回值\"><a href=\"#06、作为方法的返回值\" class=\"headerlink\" title=\"06、作为方法的返回值\"></a>06、作为方法的返回值</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ThisAsMethodResult</span> &#123;<br>    ThisAsMethodResult <span class=\"hljs-title function_\">getThisAsMethodResult</span><span class=\"hljs-params\">()</span> &#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">this</span>;<br>    &#125;<br>    <br>    <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">out</span><span class=\"hljs-params\">()</span> &#123;<br>        System.out.println(<span class=\"hljs-string\">&quot;hello&quot;</span>);<br>    &#125;<br><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> &#123;<br>        <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ThisAsMethodResult</span>().getThisAsMethodResult().out();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>“<code>getThisAsMethodResult()</code> 方法返回了 this 关键字，指向的就是 <code>new ThisAsMethodResult()</code> 这个对象，所以可以紧接着调用 <code>out()</code> 方法——达到了链式调用的目的，这也是 this 关键字非常经典的一种用法。”</p>\n<h3 id=\"3-super\"><a href=\"#3-super\" class=\"headerlink\" title=\"3.super\"></a>3.super</h3><p>“super 关键字的用法主要有三种。”</p>\n<ul>\n<li>指向父类对象；</li>\n<li>调用父类的方法；</li>\n<li><code>super()</code> 可以调用父类的构造方法。</li>\n</ul>\n<h3 id=\"4-final\"><a href=\"#4-final\" class=\"headerlink\" title=\"4.final\"></a>4.final</h3><p>什么是序列化？</p>\n<p>序列化是什么意思呢？Java 的序列化是指，将对象转换成以字节序列的形式来表示，这些字节序中包含了对象的字段和方法。序列化后的对象可以被写到数据库、写到文件，也可用于网络传输。</p>\n<p>“被 final 修饰的变量无法重新赋值。换句话说，final 变量一旦初始化，就无法更改。”</p>\n<p><strong>final类：</strong></p>\n<p>“如果一个类使用了 final 关键字修饰，那么它就无法被继承…..”</p>\n<p>“等等，哥，我知道，String 类就是一个 final 类。”还没等我说完，三妹就抢着说到。</p>\n<p>“说得没毛病。”</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">String</span><br>    <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title class_\">java</span>.io.Serializable, Comparable&lt;String&gt;, CharSequence,<br>               Constable, ConstantDesc &#123;&#125;<br></code></pre></td></tr></table></figure>\n\n<p>⚠️⚠️⚠️：String 是 immutable 类（不可变对象）</p>\n<p>“那三妹你知道为什么 String 类要设计成 final 吗？”</p>\n<p>“这个还真不知道。”三妹的表情透露出这种无奈。</p>\n<p>“原因大致有 3 个。”</p>\n<ul>\n<li>为了实现字符串常量池的需要</li>\n<li>为了线程安全的需要</li>\n<li>为了 HashCode 的不可变性的需要</li>\n</ul>\n<p>“想了解更详细的原因，可以一会看看我之前写的这篇文章。”</p>\n<p><a href=\"https://mp.weixin.qq.com/s/CRQrm5zGpqWxYL_ztk-b2Q\">为什么 Java 字符串是不可变的？</a></p>\n<h3 id=\"5-instanceof\"><a href=\"#5-instanceof\" class=\"headerlink\" title=\"5.instanceof\"></a>5.instanceof</h3><p>语法格式：</p>\n<p><code>(object) instanceof (type)</code></p>\n<p>​    对象                                类型</p>\n<p>用意也非常简单，判断对象是否符合指定的类型，结果要么是 true，要么是 false。在反序列化的时候，instanceof 操作符还是蛮常用的，因为这时候我们不太确定对象属不属于指定的类型，如果不进行判断的话，就容易抛出 ClassCastException 异常。</p>\n<p>Java 是一门面向对象的编程语言，也就意味着除了基本数据类型，所有的类都会隐式继承 Object 类。所以下面的结果肯定也会输出 true。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-type\">Thread</span> <span class=\"hljs-variable\">thread</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Thread</span>();<br>System.out.println(thread <span class=\"hljs-keyword\">instanceof</span> Object);<br></code></pre></td></tr></table></figure>\n\n<p>如何使用？</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">// 先判断类型</span><br><span class=\"hljs-keyword\">if</span> (obj <span class=\"hljs-keyword\">instanceof</span> String) &#123;<br>    <span class=\"hljs-comment\">// 然后强制转换</span><br>    <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">s</span> <span class=\"hljs-operator\">=</span> (String) obj;<br>    <span class=\"hljs-comment\">// 然后才能使用</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>先用 instanceof 进行类型判断，然后再把 obj 强制转换成我们期望的类型再进行使用。</p>\n<p>JDK 16 的时候，instanceof 模式匹配转了正，意味着使用 instanceof 的时候更便捷了。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">if</span> (obj <span class=\"hljs-keyword\">instanceof</span> String s) &#123;<br>    <span class=\"hljs-comment\">// 如果类型匹配 直接使用 s</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"不可变对象\"><a href=\"#不可变对象\" class=\"headerlink\" title=\"*不可变对象\"></a>*不可变对象</h2><h3 id=\"01、什么是不可变类？\"><a href=\"#01、什么是不可变类？\" class=\"headerlink\" title=\"01、什么是不可变类？\"></a>01、什么是不可变类？</h3><p>一个类的对象在通过构造方法创建后如果状态不会再被改变，那么它就是一个不可变（immutable）类。它的所有成员变量的赋值仅在构造方法中完成，不会提供任何 setter 方法供外部类去修改。</p>\n<p>自从有了<strong>多线程</strong>，生产力就被无限地放大了，所有的程序员都爱它，因为强大的硬件能力被充分地利用了。但与此同时，所有的程序员都对它心生忌惮，因为一不小心，多线程就会把<strong>对象的状态变得混乱不堪</strong>。</p>\n<p>引入关键字：synchronized(同步)</p>\n<p>为了保护状态的原子性、可见性、有序性，我们程序员可以说是竭尽所能。其中，synchronized（同步）关键字是最简单最入门的一种解决方案。</p>\n<p>假如说类是不可变的，那么对象的状态就也是不可变的。这样的话，每次修改对象的状态，就会产生一个新的对象供不同的线程使用，我们程序员就不必再担心并发问题了。</p>\n<h3 id=\"02、常见的不可变类\"><a href=\"#02、常见的不可变类\" class=\"headerlink\" title=\"02、常见的不可变类\"></a>02、常见的不可变类</h3><p>String类</p>\n<p>为什么要将String类设置为不可变类？</p>\n<p>原因如下：</p>\n<p>1）常量池的需要</p>\n<p>字符串常量池是 Java 堆内存中一个特殊的存储区域，当创建一个 String 对象时，假如此字符串在常量池中不存在，那么就创建一个；假如已经存，就不会再创建了，而是直接引用已经存在的对象。这样做能够减少 JVM 的内存开销，提高效率。</p>\n<p>2）hashCode 的需要</p>\n<p>因为字符串是不可变的，所以在它创建的时候，其 hashCode 就被缓存了，因此非常适合作为哈希值（比如说作为 HashMap 的键），多次调用只返回同一个值，来提高效率。</p>\n<p>3）线程安全</p>\n<p>就像之前说的那样，如果对象的状态是可变的，那么在多线程环境下，就很容易造成不可预期的结果。而 String 是不可变的，就可以在多个线程之间共享，不需要同步处理。</p>\n<p>因此，当我们调用 String 类的任何方法（比如说 <code>trim()</code>、<code>substring()</code>、<code>toLowerCase()</code>）时，总会返回一个新的对象，而不影响之前的值。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">cmower</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;沉默王二，一枚有趣的</span><br></code></pre></td></tr></table></figure>\n\n\n\n\n\n<h2 id=\"可变参数\"><a href=\"#可变参数\" class=\"headerlink\" title=\"*可变参数\"></a>*可变参数</h2><h2 id=\"泛型\"><a href=\"#泛型\" class=\"headerlink\" title=\"泛型\"></a>泛型</h2><h3 id=\"什么是泛型\"><a href=\"#什么是泛型\" class=\"headerlink\" title=\"什么是泛型\"></a>什么是泛型</h3><blockquote>\n<p>泛型：就是指在类定义时不会设置类中的属性或方法参数的具体类型，而是在类使用时（创建对象）再进行类型的定义。会在编译期检查类型是否错误。</p>\n</blockquote>\n<p><img src=\"https://img-blog.csdnimg.cn/101412155b854d98891f6c0facdfde7f.png\"></p>\n<p>类声明后的&lt;&gt;中这个T被称为类型参数，用于指代任意类型，实际上这个T只是个代表，写什么都可以。表示此时的value1，value2都是在类定义时没有明确类型，只有在使用时才告知编译器类型。出于规范，类型参数用单个的大写字母来代替，常见如下：</p>\n<ul>\n<li>T：代表任意类</li>\n<li>E：表示Element的意思，或是异常</li>\n<li>K：与V搭配使用</li>\n<li>V：与K搭配使用</li>\n</ul>\n<p>以下内容来源于<a href=\"https://www.pdai.tech/md/java/basic/java-basic-x-generic.html\">Java全栈体系</a>:</p>\n<p><strong>通过泛型可以将不同数据类型的add()方法复用为一个方法：</strong></p>\n<p><code>eg:</code>泛型add()方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Java\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> &lt;T <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">Number</span>&gt; <span class=\"hljs-type\">double</span> <span class=\"hljs-title function_\">add</span><span class=\"hljs-params\">(T a, T b)</span> &#123;<br>    System.out.println(a + <span class=\"hljs-string\">&quot;+&quot;</span> + b + <span class=\"hljs-string\">&quot;=&quot;</span> + (a.doubleValue() + b.doubleValue()));<br>    <span class=\"hljs-keyword\">return</span> a.doubleValue() + b.doubleValue();<br>&#125;<br></code></pre></td></tr></table></figure>\n\n\n\n<ul>\n<li>泛型中的类型在使用时指定，不需要强制类型转换（<strong>类型安全</strong>，编译器会<strong>检查类型</strong>）</li>\n</ul>\n<p>看下这个例子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-type\">List</span> <span class=\"hljs-variable\">list</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ArrayList</span>();<br>list.add(<span class=\"hljs-string\">&quot;xxString&quot;</span>);<br>list.add(<span class=\"hljs-number\">100d</span>);<br>list.add(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Person</span>());        <br></code></pre></td></tr></table></figure>\n\n<p>我们在使用上述list中，list中的元素都是Object类型（无法约束其中的类型），所以在取出集合元素时需要人为的强制类型转化到具体的目标类型，且很容易出现<code>java.lang.ClassCastException</code>异常。</p>\n<p>引入泛型，它将提供类型的约束，提供编译前的检查：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Java\">List&lt;String&gt; list = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ArrayList</span>&lt;String&gt;();<br><br><span class=\"hljs-comment\">// list中只能放String, 不能放其它类型的元素</span><br></code></pre></td></tr></table></figure>\n\n<p>更多内容请见：</p>\n<p><a href=\"https://www.pdai.tech/md/java/basic/java-basic-x-generic.html\">https://www.pdai.tech/md/java/basic/java-basic-x-generic.html</a></p>\n<h2 id=\"注解\"><a href=\"#注解\" class=\"headerlink\" title=\"注解\"></a>注解</h2><p>直接开始上实例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Java\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">A</span>&#123;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">test</span><span class=\"hljs-params\">()</span> &#123;<br>        <br>    &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">B</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">A</span>&#123;<br><br>    <span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">        * 重载父类的test方法</span><br><span class=\"hljs-comment\">        */</span><br>    <span class=\"hljs-meta\">@Override</span><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">test</span><span class=\"hljs-params\">()</span> &#123;<br>    &#125;<br><br>    <span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">        * 被弃用的方法</span><br><span class=\"hljs-comment\">        */</span><br>    <span class=\"hljs-meta\">@Deprecated</span><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">oldMethod</span><span class=\"hljs-params\">()</span> &#123;<br>    &#125;<br><br>    <span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">        * 忽略告警</span><br><span class=\"hljs-comment\">        * </span><br><span class=\"hljs-comment\">        * <span class=\"hljs-doctag\">@return</span></span><br><span class=\"hljs-comment\">        */</span><br>    <span class=\"hljs-meta\">@SuppressWarnings(&quot;rawtypes&quot;)</span><br>    <span class=\"hljs-keyword\">public</span> List <span class=\"hljs-title function_\">processList</span><span class=\"hljs-params\">()</span> &#123;<br>        <span class=\"hljs-type\">List</span> <span class=\"hljs-variable\">list</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ArrayList</span>();<br>        <span class=\"hljs-keyword\">return</span> list;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>\n\n<p>Java 1.5开始自带的标准注解，包括<code>@Override</code>、<code>@Deprecated</code>和<code>@SuppressWarnings</code>：</p>\n<ul>\n<li><code>@Override</code>：表示当前的方法定义将覆盖父类中的方法</li>\n<li><code>@Deprecated</code>：表示代码被弃用，如果使用了被@Deprecated注解的代码则编译器将发出警告</li>\n<li><code>@SuppressWarnings</code>：表示关闭编译器警告信息</li>\n</ul>\n<h2 id=\"枚举（enum）\"><a href=\"#枚举（enum）\" class=\"headerlink\" title=\"枚举（enum）\"></a>枚举（enum）</h2><p><strong>定义：</strong></p>\n<p>“枚举（enum），是 Java 1.5 时引入的关键字，它表示一种特殊类型的类，继承自 java.lang.Enum。”</p>\n<p>“我们来新建一个枚举 PlayerType。”</p>\n<p>eg:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">enum</span> <span class=\"hljs-title class_\">PlayerType</span> &#123;<br>    TENNIS,<br>    FOOTBALL,<br>    BASKETBALL<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>01 “既然枚举是一种特殊的类，那它其实是可以定义在一个类的内部的，这样它的作用域就可以限定于这个外部类中使用。”我说。</p>\n<p>eg:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Player</span> &#123;<br>    <span class=\"hljs-keyword\">private</span> PlayerType type;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">enum</span> <span class=\"hljs-title class_\">PlayerType</span> &#123;<br>        TENNIS,<br>        FOOTBALL,<br>        BASKETBALL<br>    &#125;<br>    <br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-type\">boolean</span> <span class=\"hljs-title function_\">isBasketballPlayer</span><span class=\"hljs-params\">()</span> &#123;<br>      <span class=\"hljs-keyword\">return</span> getType() == PlayerType.BASKETBALL;<br>    &#125;<br><br>    <span class=\"hljs-keyword\">public</span> PlayerType <span class=\"hljs-title function_\">getType</span><span class=\"hljs-params\">()</span> &#123;<br>        <span class=\"hljs-keyword\">return</span> type;<br>    &#125;<br><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">setType</span><span class=\"hljs-params\">(PlayerType type)</span> &#123;<br>        <span class=\"hljs-built_in\">this</span>.type = type;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>\n\n<p>02 由于枚举是 final 的，所以可以确保在 Java 虚拟机中仅有一个常量对象，基于这个原因，我们可以使用“==”运算符来比较两个枚举是否相等，参照 <code>isBasketballPlayer()</code> 方法。</p>\n<p>03 “枚举还可用于 switch 语句，和基本数据类型的用法一致。”我说。</p>\n<p>04 “如果枚举中需要包含更多信息的话，可以为其添加一些字段，比如下面示例中的 name，此时需要为枚举添加一个带参的构造方法，这样就可以在定义枚举时添加对应的名称了。”我继续说。</p>\n<p>eg:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">enum</span> <span class=\"hljs-title class_\">PlayerType</span> &#123;<br>    TENNIS(<span class=\"hljs-string\">&quot;网球&quot;</span>),<br>    FOOTBALL(<span class=\"hljs-string\">&quot;足球&quot;</span>),<br>    BASKETBALL(<span class=\"hljs-string\">&quot;篮球&quot;</span>);<br><br>    <span class=\"hljs-keyword\">private</span> String name;<br>    <br>    PlayerType(String name) &#123;<br>        <span class=\"hljs-built_in\">this</span>.name = name;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>05 “EnumSet 是一个专门针对枚举类型的 Set 接口（后面会讲）的实现类，它是处理枚举类型数据的一把利器，非常高效。”我说，“从名字上就可以看得出，EnumSet 不仅和 Set 有关系，和枚举也有关系。”</p>\n<p>06 “因为 EnumSet 是一个抽象类，所以创建 EnumSet 时不能使用 new 关键字。不过，EnumSet 提供了很多有用的静态工厂方法。”</p>\n<p><img src=\"http://cdn.tobebetterjavaer.com/tobebetterjavaer/images/enum/enum-02.png\" alt=\"img\"></p>\n<p>07 “除了 EnumSet，还有 EnumMap，是一个专门针对枚举类型的 Map 接口的实现类，它可以将枚举常量作为键来使用。EnumMap 的效率比 HashMap 还要高，可以直接通过数组下标（枚举的 ordinal 值）访问到元素。”</p>\n<p>08 “和 EnumSet 不同，EnumMap 不是一个抽象类，所以创建 EnumMap 时可以使用 new 关键字。”</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">EnumMap&lt;PlayerType, String&gt; enumMap = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">EnumMap</span>&lt;&gt;(PlayerType.class);<br></code></pre></td></tr></table></figure>\n\n<p>09 有了 EnumMap 对象后就可以使用 Map 的一些方法了，见下图。</p>\n<p><img src=\"http://cdn.tobebetterjavaer.com/tobebetterjavaer/images/enum/enum-04.png\" alt=\"img\"></p>\n<p>和 HashMap（后面会讲）的使用方法大致相同，来看下面的例子。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">EnumMap&lt;PlayerType, String&gt; enumMap = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">EnumMap</span>&lt;&gt;(PlayerType.class);<br>enumMap.put(PlayerType.BASKETBALL,<span class=\"hljs-string\">&quot;篮球运动员&quot;</span>);<br>enumMap.put(PlayerType.FOOTBALL,<span class=\"hljs-string\">&quot;足球运动员&quot;</span>);<br>enumMap.put(PlayerType.TENNIS,<span class=\"hljs-string\">&quot;网球运动员&quot;</span>);<br>System.out.println(enumMap);<br><br>System.out.println(enumMap.get(PlayerType.BASKETBALL));<br>System.out.println(enumMap.containsKey(PlayerType.BASKETBALL));<br>System.out.println(enumMap.remove(PlayerType.BASKETBALL));<br></code></pre></td></tr></table></figure>\n\n<p>“来看一下输出结果。”</p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs text\">&#123;TENNIS=网球运动员, FOOTBALL=足球运动员, BASKETBALL=篮球运动员&#125;<br>篮球运动员<br>true<br>篮球运动员<br></code></pre></td></tr></table></figure>\n\n<p>“除了以上这些，《Effective Java》这本书里还提到了一点，如果要实现单例的话，最好使用枚举的方式。”我说。</p>\n<h3 id=\"单例：。。。\"><a href=\"#单例：。。。\" class=\"headerlink\" title=\"单例：。。。\"></a>单例：。。。</h3><h2 id=\"反射\"><a href=\"#反射\" class=\"headerlink\" title=\"反射\"></a>反射</h2><p>何为正射？何为反射？</p>\n<p>“一般情况下，我们在使用某个类之前已经确定它到底是个什么类了，拿到手就直接可以使用 <code>new</code> 关键字来调用构造方法进行初始化，之后使用这个类的对象来进行操作。”</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Java\"><span class=\"hljs-type\">Writer</span> <span class=\"hljs-variable\">writer</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Writer</span>();<br>writer.setName(<span class=\"hljs-string\">&quot;沉默王二&quot;</span>);<br><br></code></pre></td></tr></table></figure>\n\n<p>像上面这个例子，就可以理解为“正射”。而反射就意味着一开始我们不知道要初始化的类到底是什么，也就没法直接使用 <code>new</code> 关键字创建对象了。</p>\n<p>我们只知道这个类的一些基本信息，就好像我们看电影的时候，为了抓住一个犯罪嫌疑人，警察就会问一些目击证人，根据这些证人提供的信息，找专家把犯罪嫌疑人的样貌给画出来——这个过程，就可以称之为<strong>反射</strong>。</p>\n<p>反射的缺点：</p>\n<ul>\n<li><strong>破坏封装</strong>：由于反射允许访问私有字段和私有方法，所以可能会破坏封装而导致安全问题。</li>\n<li><strong>性能开销</strong>：由于反射涉及到动态解析，因此无法执行 Java 虚拟机优化，再加上反射的写法的确要复杂得多，所以性能要比“正射”差很多，在一些性能敏感的程序中应该避免使用反射。</li>\n</ul>\n<p>好处：</p>\n<ul>\n<li><strong>开发通用框架</strong>：像 Spring，为了保持通用性，通过配置文件来加载不同的对象，调用不同的方法。</li>\n<li><strong>动态代理</strong>：在面向切面编程中，需要拦截特定的方法，就会选择动态代理的方式，而动态代理的底层技术就是反射。</li>\n<li><strong>注解</strong>：注解本身只是起到一个标记符的作用，它需要利用发射机制，根据标记符去执行特定的行为。</li>\n</ul>\n<p>详情参考：</p>\n<p><a href=\"https://www.cnblogs.com/chanshuyi/p/head_first_of_reflection.html\">浅析</a></p>\n<p><a href=\"https://dunwu.github.io/javacore/basics/java-reflection.html#_1-%E5%8F%8D%E5%B0%84%E7%AE%80%E4%BB%8B\">深入理解</a></p>\n<h2 id=\"集合框架（容器）\"><a href=\"#集合框架（容器）\" class=\"headerlink\" title=\"集合框架（容器）\"></a>集合框架（容器）</h2><p>集合框架的结构图：</p>\n<img src=\"http://cdn.tobebetterjavaer.com/tobebetterjavaer/images/collection/gailan-01.png\" alt=\"img\" style=\"zoom:200%;\" />\n\n<p>单词：</p>\n<p>Collection——集合；</p>\n<p>Map——图、表（两个类间的映射关系）；</p>\n<p>List——列举、列表；</p>\n<p>Array——数组；</p>\n<p>Arraylist——数组列表；</p>\n<p>Linkedlist——链表；</p>\n<p>Stack——栈；                  <code>执行效率较低</code></p>\n<p>Vector——矩阵、模型    <code>线程安全</code></p>\n<p>Java 集合框架可以分为两条大的支线：</p>\n<ul>\n<li>Collection，主要由 List、Set、Queue 组成，List 代表有序、可重复的集合，典型代表就是封装了动态数组的 ArrayList 和封装了链表的 LinkedList；Set 代表无序、不可重复的集合，典型代表就是 HashSet 和 TreeSet；Queue 代表队列，典型代表就是双端队列 ArrayDeque，以及优先级队列 PriorityQue。</li>\n<li>Map，代表键值对的集合，典型代表就是 HashMap。</li>\n</ul>\n<h3 id=\"01、List\"><a href=\"#01、List\" class=\"headerlink\" title=\"01、List\"></a>01、List</h3><blockquote>\n<p>List 的特点是存取有序，可以存放重复的元素，可以用下标对元素进行操作</p>\n</blockquote>\n<h3 id=\"02、Set\"><a href=\"#02、Set\" class=\"headerlink\" title=\"02、Set\"></a>02、Set</h3><p>说在前面：</p>\n<p>Set 集合不是关注的重点，因为底层都是由 Map 实现的，为什么要用 Map 实现呢？</p>\n<p>因为 Map 的键不允许重复、无序吗</p>\n<blockquote>\n<p>Set 的特点是存取无序，不可以存放重复的元素，不可以用下标对元素进行操作，和 List 有很多不同</p>\n</blockquote>\n<p>Set是Java中的<strong>集合类，提供了一种无顺序，不重复的集合</strong>。常用的子类包括HashSet, TreeSet等。</p>\n<h3 id=\"03、Queue\"><a href=\"#03、Queue\" class=\"headerlink\" title=\"03、Queue\"></a>03、Queue</h3><blockquote>\n<p>Queue，也就是队列，通常遵循先进先出（FIFO）的原则，新元素插入到队列的尾部，访问元素返回队列的头部。</p>\n</blockquote>\n<h3 id=\"04、Map\"><a href=\"#04、Map\" class=\"headerlink\" title=\"04、Map\"></a>04、Map</h3><blockquote>\n<p>Map 保存的是键值对，键要求保持唯一性，值可以重复。</p>\n</blockquote>\n<h3 id=\"浅析ArrayList（动态数组）\"><a href=\"#浅析ArrayList（动态数组）\" class=\"headerlink\" title=\"浅析ArrayList（动态数组）\"></a>浅析ArrayList（动态数组）</h3><p>arraylist是接口list的实现类，有很多方便调用的预定义方法，便于用户直接调用。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Java\">List接口常用方法：<br><span class=\"hljs-number\">1</span>、add(Object element)： 向列表的尾部添加指定的元素。<br>    <span class=\"hljs-comment\">/*</span><br><span class=\"hljs-comment\">    \tList&lt;String&gt; alist = new ArrayList&lt;&gt;();</span><br><span class=\"hljs-comment\">    \talist.add(&quot;沉默王二&quot;);</span><br><span class=\"hljs-comment\">\t*/</span><br><span class=\"hljs-number\">2</span>、size()： 返回列表中的元素个数。<br><br><span class=\"hljs-number\">3</span>、get(<span class=\"hljs-type\">int</span> index)： 返回列表中指定位置的元素，index从<span class=\"hljs-number\">0</span>开始。<br><br><span class=\"hljs-number\">4</span>、add(<span class=\"hljs-type\">int</span> index, Object element)： 在列表的指定位置插入指定元素。<br><br><span class=\"hljs-number\">5</span>、set(<span class=\"hljs-type\">int</span> i, Object element)： 将索引i位置元素替换为元素element并返回被替换的元素。<br><br><span class=\"hljs-number\">6</span>、clear()： 从列表中移除所有元素。<br><br><span class=\"hljs-number\">7</span>、isEmpty()： 判断列表是否包含元素，不包含元素则返回 <span class=\"hljs-literal\">true</span>，否则返回<span class=\"hljs-literal\">false</span>。<br><br><span class=\"hljs-number\">8</span>、contains(Object o)： 如果列表包含指定的元素，则返回 <span class=\"hljs-literal\">true</span>。<br><br><span class=\"hljs-number\">9</span>、remove(<span class=\"hljs-type\">int</span> index)： 移除列表中指定位置的元素，并返回被删元素。<br><br><span class=\"hljs-number\">10</span>、remove(Object o)： 移除集合中第一次出现的指定元素，移除成功返回<span class=\"hljs-literal\">true</span>，否则返回<span class=\"hljs-literal\">false</span>。<br><br><span class=\"hljs-number\">11</span>、iterator()： 返回按适当顺序在列表的元素上进行迭代的迭代器。    <br></code></pre></td></tr></table></figure>\n\n<p>12、indexof()：正序查找一个元素。倒叙查找为lastIndexOf()</p>\n<p>ArrayList 可以称得上是集合框架方面最常用的类了，可以和 HashMap 一较高下。</p>\n<p>ArrayList 在数组的基础上实现了自动扩容，并且提供了比数组更丰富的预定义方法（各种增删改查），非常灵活。</p>\n<p>创建一个ArrayList的语法格式：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Java\">ArrayList&lt;String&gt; alist = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ArrayList</span>&lt;String&gt;();<span class=\"hljs-comment\">//标准</span><br><span class=\"hljs-comment\">/*可以通过上面的语句来创建一个字符串类型的 ArrayList（通过尖括号来限定 ArrayList 中元素的类型，如果尝试添加其他类型的元素，将会产生编译错误），更简化的写法如下：*/</span><br>List&lt;String&gt; alist = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ArrayList</span>&lt;&gt;();<br></code></pre></td></tr></table></figure>\n\n<p>由于 ArrayList 实现了 List 接口，所以 alist 变量的类型可以是 List 类型；new 关键字声明后的尖括号中可以不再指定元素的类型，因为编译器可以通过前面尖括号中的类型进行智能推断。</p>\n<p>如果非常确定 ArrayList 中元素的个数，在创建的时候还可以指定初始大小。</p>\n<h3 id=\"浅析linkedList（链表）\"><a href=\"#浅析linkedList（链表）\" class=\"headerlink\" title=\"浅析linkedList（链表）\"></a>浅析linkedList（链表）</h3><p>链表这门内功大致分为三个层次：</p>\n<ul>\n<li>第一层叫做“单向链表”，我只有一个后指针，指向下一个数据；</li>\n<li>第二层叫做“双向链表”，我有两个指针，后指针指向下一个数据，前指针指向上一个数据。</li>\n<li>第三层叫做“二叉树”，把后指针去掉，换成左右指针。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Java\">创建一个LinkedList的语法格式：<br>LinkedList&lt;String&gt; list = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">LinkedList</span>();<br></code></pre></td></tr></table></figure>\n\n\n\n<p><strong>1）招式一：增</strong></p>\n<p>可以调用 add 方法添加元素：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">list.add(<span class=\"hljs-string\">&quot;沉默王二&quot;</span>);<br>list.add(<span class=\"hljs-string\">&quot;沉默王三&quot;</span>);<br>list.add(<span class=\"hljs-string\">&quot;沉默王四&quot;</span>);<br></code></pre></td></tr></table></figure>\n\n<p>add 方法内部其实调用的是 linkLast 方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-type\">boolean</span> <span class=\"hljs-title function_\">add</span><span class=\"hljs-params\">(E e)</span> &#123;<br>    linkLast(e);<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>linkLast，顾名思义，就是在链表的尾部链接：</p>\n<ul>\n<li>添加第一个元素的时候，first 和 last 都为 null。</li>\n<li>然后新建一个节点 newNode，它的 prev 和 next 也为 null。</li>\n<li>然后把 last 和 first 都赋值为 newNode。</li>\n</ul>\n<p>此时还不能称之为链表，因为前后节点都是断裂的。</p>\n<p><img src=\"http://cdn.tobebetterjavaer.com/tobebetterjavaer/images/collection/linkedlist-02.png\" alt=\"img\"></p>\n<ul>\n<li>添加第二个元素的时候，first 和 last 都指向的是第一个节点。</li>\n<li>然后新建一个节点 newNode，它的 prev 指向的是第一个节点，next 为 null。</li>\n<li>然后把第一个节点的 next 赋值为 newNode。</li>\n</ul>\n<p>此时的链表还不完整。</p>\n<p><img src=\"http://cdn.tobebetterjavaer.com/tobebetterjavaer/images/collection/linkedlist-03.png\" alt=\"img\"></p>\n<ul>\n<li>添加第三个元素的时候，first 指向的是第一个节点，last 指向的是最后一个节点。</li>\n<li>然后新建一个节点 newNode，它的 prev 指向的是第二个节点，next 为 null。</li>\n<li>然后把第二个节点的 next 赋值为 newNode。</li>\n</ul>\n<p>此时的链表已经完整了。</p>\n<p><img src=\"http://cdn.tobebetterjavaer.com/tobebetterjavaer/images/collection/linkedlist-04.png\" alt=\"img\"></p>\n<p>我这个增的招式，还可以演化成另外两个：</p>\n<ul>\n<li><code>addFirst()</code> 方法将元素添加到第一位；</li>\n<li><code>addLast()</code> 方法将元素添加到末尾。</li>\n</ul>\n<p>addFirst 内部其实调用的是 linkFirst：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">addFirst</span><span class=\"hljs-params\">(E e)</span> &#123;<br>    linkFirst(e);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>linkFirst 负责把新的节点设为 first，并将新的 first 的 next 更<strong>2）招式二：删</strong></p>\n<p>我这个删的招式还挺多的：</p>\n<ul>\n<li><code>remove()</code>：删除第一个节点</li>\n<li><code>remove(int)</code>：删除指定位置的节点</li>\n<li><code>remove(Object)</code>：删除指定元素的节点</li>\n<li><code>removeFirst()</code>：删除第一个节点</li>\n<li><code>removeLast()</code>：删除最后一个节点</li>\n</ul>\n<p>remove 内部调用的是 removeFirst，所以这两个招式的功效一样。</p>\n<p><code>remove(int)</code> 内部其实调用的是 unlink 方法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> E <span class=\"hljs-title function_\">remove</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> index)</span> &#123;<br>    checkElementIndex(index);<br>    <span class=\"hljs-keyword\">return</span> unlink(node(index));<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>新为之前的 first。</p>\n<p>unlink 方法其实很好理解，就是更新当前节点的 next 和 prev，然后把当前节点上的元素设为 null。</p>\n<p><strong>3）招式三：改</strong></p>\n<p>可以调用 <code>set()</code> 方法来更新元素：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">list.set(<span class=\"hljs-number\">0</span>, <span class=\"hljs-string\">&quot;沉默王五&quot;</span>);<br></code></pre></td></tr></table></figure>\n\n<p>来看一下 <code>set()</code> 方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> E <span class=\"hljs-title function_\">set</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> index, E element)</span> &#123;<br>    checkElementIndex(index);<br>    Node&lt;E&gt; x = node(index);<br>    <span class=\"hljs-type\">E</span> <span class=\"hljs-variable\">oldVal</span> <span class=\"hljs-operator\">=</span> x.item;<br>    x.item = element;<br>    <span class=\"hljs-keyword\">return</span> oldVal;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>首先对指定的下标进行检查，看是否越界；然后根据下标查找原有的节点：</p>\n<p><code>size &gt;&gt; 1</code>：也就是右移一位，相当于除以 2。对于计算机来说，移位比除法运算效率更高，因为数据在计算机内部都是二进制存储的。</p>\n<p>换句话说，node 方法会对下标进行一个初步判断，如果靠近前半截，就从下标 0 开始遍历；如果靠近后半截，就从末尾开始遍历。</p>\n<p>找到指定下标的节点就简单了，直接把原有节点的元素替换成新的节点就 OK 了，prev 和 next 都不用改动。</p>\n<p><strong>4）招式四：查</strong></p>\n<p>我这个查的招式可以分为两种：</p>\n<ul>\n<li>indexOf(Object)：查找某个元素所在的位置</li>\n<li>get(int)：查找某个位置上的元素</li>\n</ul>\n<p>indexOf 的内部分为两种，一种是元素为 null 的时候，必须使用 == 来判断；一种是元素为非 null 的时候，要使用 equals 来判断。因为 equals 是不能用来判 null 的，会抛出 NPE 错误。</p>\n<p>get 方法的内核其实还是 node 方法，这个之前已经说明过了，这里略过。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> E <span class=\"hljs-title function_\">get</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> index)</span> &#123;<br>    checkElementIndex(index);<br>    <span class=\"hljs-keyword\">return</span> node(index).item;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>其实，查这个招式还可以演化为其他的一些，比如说：</p>\n<ul>\n<li><code>getFirst()</code> 方法用于获取第一个元素；</li>\n<li><code>getLast()</code> 方法用于获取最后一个元素；</li>\n<li><code>poll()</code> 和 <code>pollFirst()</code> 方法用于删除并返回第一个元素（两个方法尽管名字不同，但方法体是完全相同的）；</li>\n<li><code>pollLast()</code> 方法用于删除并返回最后一个元素；</li>\n<li><code>peekFirst()</code> 方法用于返回但不删除第一个元素。</li>\n</ul>\n<p>虽然ArrayList经常喊LinkedList一声师弟，但二者之间其实挺和谐的。但我知道，在外人眼里，同门师兄弟，总要一较高下的。</p>\n<p>比如说，我们俩在增删改查时候的时间复杂度。</p>\n<h3 id=\"ArrayList和LinkedList的区别\"><a href=\"#ArrayList和LinkedList的区别\" class=\"headerlink\" title=\"ArrayList和LinkedList的区别\"></a>ArrayList和LinkedList的区别</h3><p>增删改查时候的时间复杂度。</p>\n<p>由此，可以得出这样的结论：<strong>遍历 LinkedList 的时候，千万不要使用 for 循环，要使用迭代器。</strong></p>\n<h3 id=\"Java中的Iterator和Iterable区别\"><a href=\"#Java中的Iterator和Iterable区别\" class=\"headerlink\" title=\"Java中的Iterator和Iterable区别\"></a>Java中的Iterator和Iterable区别</h3><p>Iterator：迭代器</p>\n<p>Iterable：可迭代的</p>\n<p>什么是迭代器？</p>\n<figure class=\"highlight txt\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs txt\">迭代器 （iterator）有时又称 光标 （cursor）是**程序设计的 软件设计模式** ，可在容器对象（container，例如 链表 或 数组 ）上遍访的接口，设计人员无需关心容器对象的内存分配的实现细节。<br><br>**中文名:** 迭代器<br><br>**外文名:** iterator<br></code></pre></td></tr></table></figure>\n\n<p>在 Java 中，我们对 List 进行遍历的时候，主要有这么三种方式。</p>\n<p>第一种：for 循环。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">i</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span>; i &lt; list.size(); i++) &#123;<br>    System.out.print(list.get(i) + <span class=\"hljs-string\">&quot;，&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>第二种：迭代器。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-type\">Iterator</span> <span class=\"hljs-variable\">it</span> <span class=\"hljs-operator\">=</span> list.iterator();<br><span class=\"hljs-keyword\">while</span> (it.hasNext()) &#123;<br>    System.out.print(it.next() + <span class=\"hljs-string\">&quot;，&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>第三种：for-each。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">for</span> (String str : list) &#123;<br>    System.out.print(str + <span class=\"hljs-string\">&quot;，&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"fail-fast\"><a href=\"#fail-fast\" class=\"headerlink\" title=\"fail-fast\"></a>fail-fast</h3><p>官翻：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs txet\">In systems design, a fail-fast system is one which immediately reports at its interface any condition that is likely to indicate a failure. Fail-fast systems are usually designed to stop normal operation rather than attempt to continue a possibly flawed process. Such designs often check the system&#x27;s state at several points in an operation, so any failures can be detected early. The responsibility of a fail-fast module is detecting errors, then letting the next-highest level of the system handle them.<br></code></pre></td></tr></table></figure>\n\n<p>fail-fast 是一种通用的系统设计思想，一旦检测到可能会发生错误，就立马抛出异常，程序将不再往下执行。——一种保护机制。</p>\n<p>demo：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">List&lt;String&gt; list = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ArrayList</span>&lt;&gt;();<br>list.add(<span class=\"hljs-string\">&quot;沉默王二&quot;</span>);<br>list.add(<span class=\"hljs-string\">&quot;沉默王三&quot;</span>);<br>list.add(<span class=\"hljs-string\">&quot;一个文章真特么有趣的程序员&quot;</span>);<br><br><span class=\"hljs-keyword\">for</span> (String str : list) &#123;<br>\t<span class=\"hljs-keyword\">if</span> (<span class=\"hljs-string\">&quot;沉默王二&quot;</span>.equals(str)) &#123;<br>\t\tlist.remove(str);<br>\t&#125;<br>&#125;<br><br>System.out.println(list);<br></code></pre></td></tr></table></figure>\n\n<p>这段代码看起来没有任何问题，但运行起来就报错了。</p>\n<p><img src=\"http://cdn.tobebetterjavaer.com/tobebetterjavaer/images/collection/fail-fast-01.png\" alt=\"img\"></p>\n<p><strong><img src=\"http://cdn.tobebetterjavaer.com/tobebetterjavaer/images/collection/fail-fast-02.png\" alt=\"img\">那该如何正确地删除元素呢</strong>？</p>\n<p><strong>1）remove 后 break</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">List&lt;String&gt; list = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ArrayList</span>&lt;&gt;();<br>list.add(<span class=\"hljs-string\">&quot;沉默王二&quot;</span>);<br>list.add(<span class=\"hljs-string\">&quot;沉默王三&quot;</span>);<br>list.add(<span class=\"hljs-string\">&quot;一个文章真特么有趣的程序员&quot;</span>);<br><br><span class=\"hljs-keyword\">for</span> (String str : list) &#123;<br>\t<span class=\"hljs-keyword\">if</span> (<span class=\"hljs-string\">&quot;沉默王二&quot;</span>.equals(str)) &#123;<br>\t\tlist.remove(str);<br>\t\t<span class=\"hljs-keyword\">break</span>;<br>\t&#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>break 后循环就不再遍历了，意味着 Iterator 的 next 方法不再执行了，也就意味着 <code>checkForComodification</code> 方法不再执行了，所以异常也就不会抛出了。</p>\n<p>但是呢，当 List 中有重复元素要删除的时候，break 就不合适了。</p>\n<p><strong>3）使用 Iterator</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">List&lt;String&gt; list = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ArrayList</span>&lt;&gt;();<br>list.add(<span class=\"hljs-string\">&quot;沉默王二&quot;</span>);<br>list.add(<span class=\"hljs-string\">&quot;沉默王三&quot;</span>);<br>list.add(<span class=\"hljs-string\">&quot;一个文章真特么有趣的程序员&quot;</span>);<br><br>Iterator&lt;String&gt; itr = list.iterator();<br><br><span class=\"hljs-keyword\">while</span> (itr.hasNext()) &#123;<br>\t<span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">str</span> <span class=\"hljs-operator\">=</span> itr.next();<br>\t<span class=\"hljs-keyword\">if</span> (<span class=\"hljs-string\">&quot;沉默王二&quot;</span>.equals(str)) &#123;<br>\t\titr.remove();<br>\t&#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>为什么使用 Iterator 的 remove 方法就可以避开 fail-fast 保护机制呢？看一下 remove 的源码就明白了。** 循环**</p>\n<p>简单地总结一下，fail-fast 是一种保护机制，可以通过 for-each 循环删除集合的元素的方式验证这种保护机制。</p>\n<p>那也就是说，for-each 本质上是一种语法糖，遍历集合时很方面，但并不适合拿来操作集合中的元素（增删）。</p>\n<h3 id=\"HashMap\"><a href=\"#HashMap\" class=\"headerlink\" title=\"HashMap\"></a>HashMap</h3><p>什么是hashmap？</p>\n<p>说在前面：</p>\n<figure class=\"highlight txt\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs txt\">说到HashMap，就先说一下Map<br>map是用于存储键值对（&lt;key,value&gt;）的集合类，也可以说是一组键值对的映射（数学概念）。<br>Map的特点<br>1.没有重复的 key（一方面，key用set保存，所以key必须是唯一，无序的；另一方面，map的取值基本上是通过key来获取value，如果有两个相同的key，计算机将不知道到底获取哪个对应值；这时候有可能会问，那为什么我编程时候可以用put（）方法传入两个key值相同的键值对？那是因为源码中，传入key值相同的键值对，将作为覆盖处理）<br><br>2.每个 key 只能对应一个 value, 多个 key 可以对应一个 value（这就是映射的概念，最经典的例子就是射箭，一排射手，一排箭靶，一个射手只能射中一个箭靶，而每个箭靶可能被不同射手射中。这里每个射手只有一根箭，不存在三箭齐发还都中靶这种骚操作。将射手和射中的靶子连线，这根线加射手加靶子就是一个映射）<br><br>3.key,value 都可以是任何引用类型（包括 null）的数据（只能是引用类型）<br><br>4.Map 取代了古老的 Dictionary 抽象类（知道就行，可以忽略）<br>————————————————<br>版权声明：本文为CSDN博主「酒吧七」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：https://blog.csdn.net/qq_36711757/article/details/80394272<br></code></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"一、hash-方法的原理\"><a href=\"#一、hash-方法的原理\" class=\"headerlink\" title=\"一、hash 方法的原理\"></a>一、hash 方法的原理</h4><figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs markdown\">把任意长度的输入（输入叫做预映射，知道就行），通过一种函数（hashCode() 方法），变换成固定长度的输出，该输出就是<span class=\"hljs-strong\">**<span class=\"hljs-emphasis\">*\\*</span>哈希值\\**</span><span class=\"hljs-strong\">**（hashCode），这种函数就叫做**</span><span class=\"hljs-emphasis\">*\\*</span>哈希函数\\<span class=\"hljs-strong\">****</span>，而计算哈希值的过程就叫做<span class=\"hljs-strong\">**<span class=\"hljs-emphasis\">*\\*</span>哈希\\**</span><span class=\"hljs-strong\">**。哈希的主要应用是哈希表和分布式缓存。</span><br><span class=\"hljs-strong\"></span><br><span class=\"hljs-strong\">这里有个问题，哈希算法和哈希函数不是一个东西，哈希函数是哈希算法的一种实现，以后面试就说哈希函数就行。</span><br><span class=\"hljs-strong\"></span><br><span class=\"hljs-strong\">在将键值对存入数组之前，将key通过哈希算法计算出哈希值，把哈希值作为数组下标，把该下标对应的位置作为键值对的存储位置，通过该方法建立的数组就叫做**</span><span class=\"hljs-emphasis\">*\\*</span>哈希表\\<span class=\"hljs-strong\">****</span>，而这个存储位置就叫做<span class=\"hljs-strong\">**<span class=\"hljs-emphasis\">*\\*</span>桶（bucket）\\**</span><span class=\"hljs-strong\">**。数组是通过整数下标直接访问元素，哈希表是通过字符串key直接访问元素，也就说哈希表是一种特殊的数组（关联数组），哈希表广泛应用于实现数据的快速查找（在map的key[<span class=\"hljs-string\">集合</span>](<span class=\"hljs-link\">https://so.csdn.net/so/search?q=集合&amp;spm=1001.2101.3001.7020</span>)中，一旦存储的key的数量特别多，那么在要查找某个key的时候就会变得很麻烦，数组中的key需要挨个比较，哈希的出现，使得这样的比较次数大大减少。）</span><br><span class=\"hljs-strong\"></span><br><span class=\"hljs-strong\">哈希表选用哈希函数计算哈希值时，可能不同的 key 会得到相同的结果，一个地址怎么存放多个数据呢？这就是**</span><span class=\"hljs-emphasis\">*\\*</span>哈希冲突（碰撞）\\<span class=\"hljs-strong\">****</span>。解决哈希冲突有两种方法，拉链法（链接法）和开放定址法（这种没用过）。<span class=\"hljs-strong\">**<span class=\"hljs-emphasis\">*\\*</span>拉链法\\**</span><span class=\"hljs-strong\">**：将键值对对象封装为一个node结点，新增了next指向，这样就可以将碰撞的结点链接成一条单链表，保存在该地址（数组位置）中。</span><br></code></pre></td></tr></table></figure>\n\n<p>再来看一下 hash 方法的源码（JDK 8 中的 HashMap）：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">hash</span><span class=\"hljs-params\">(Object key)</span> &#123;<br>    <span class=\"hljs-type\">int</span> h;<br>    <span class=\"hljs-keyword\">return</span> (key == <span class=\"hljs-literal\">null</span>) ? <span class=\"hljs-number\">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class=\"hljs-number\">16</span>);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><code>key.hashCode()</code> 是用来获取键位的哈希值的，理论上，哈希值是一个 int 类型，范围从-2147483648 到 2147483648。前后加起来大概 40 亿的映射空间，只要哈希值映射得比较均匀松散，一般是不会出现哈希碰撞的。</p>\n<p>取模运算有两处。</p>\n<blockquote>\n<p>取模运算（“Modulo Operation”）和取余运算（“Remainder Operation ”）两个概念有重叠的部分但又不完全一致。主要的区别在于对负整数进行除法运算时操作不同。<strong>取模</strong>主要是用于<strong>计算机术语</strong>中，<strong>取余</strong>则更多是<strong>数学概念</strong>。</p>\n</blockquote>\n<p>一处是往 HashMap 中 put 的时候（<code>putVal</code> 方法中）：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">final</span> V <span class=\"hljs-title function_\">putVal</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> hash, K key, V value, <span class=\"hljs-type\">boolean</span> onlyIfAbsent, <span class=\"hljs-type\">boolean</span> evict)</span> &#123;<br>     HashMap.Node&lt;K,V&gt;[] tab; HashMap.Node&lt;K,V&gt; p; <span class=\"hljs-type\">int</span> n, i;<br>     <span class=\"hljs-keyword\">if</span> ((tab = table) == <span class=\"hljs-literal\">null</span> || (n = tab.length) == <span class=\"hljs-number\">0</span>)<br>         n = (tab = resize()).length;<br>     <span class=\"hljs-keyword\">if</span> ((p = tab[i = (n - <span class=\"hljs-number\">1</span>) &amp; hash]) == <span class=\"hljs-literal\">null</span>)<br>         tab[i] = newNode(hash, key, value, <span class=\"hljs-literal\">null</span>);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>一处是从 HashMap 中 get 的时候（<code>getNode</code> 方法中）：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">final</span> Node&lt;K,V&gt; <span class=\"hljs-title function_\">getNode</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> hash, Object key)</span> &#123;<br>     Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class=\"hljs-type\">int</span> n; K k;<br>     <span class=\"hljs-keyword\">if</span> ((tab = table) != <span class=\"hljs-literal\">null</span> &amp;&amp; (n = tab.length) &gt; <span class=\"hljs-number\">0</span> &amp;&amp;<br>            (first = tab[(n - <span class=\"hljs-number\">1</span>) &amp; hash]) != <span class=\"hljs-literal\">null</span>) &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>其中的 <code>(n - 1) &amp; hash</code> 正是取模运算，就是把哈希值和（数组长度-1）做了一个“与”运算。</p>\n<p>可能大家在疑惑：<strong>取模运算难道不该用 <code>%</code> 吗？为什么要用 <code>&amp;</code> 呢</strong>？</p>\n<p>这是因为 <code>&amp;</code> 运算比 <code>%</code> 更加高效，并且当 b 为 2 的 n 次方时，存在下面这样一个公式。</p>\n<blockquote>\n<p>a % b = a &amp; (b-1)</p>\n</blockquote>\n<p>用 $2^n$ 替换下 b 就是：</p>\n<blockquote>\n<p>a % 2^n = a &amp; (2^n-1)</p>\n</blockquote>\n<p>综上所述，hash 方法是用来做哈希值优化的，把哈希值右移 16 位，也就正好是自己长度的一半，之后与原哈希值做异或运算，这样就混合了原哈希值中的高位和低位，增大了随机性。</p>\n<p>说白了，<strong>hash 方法就是为了增加随机性，让数据元素更加均衡的分布，减少碰撞</strong>。</p>\n<p><strong><a href=\"https://mp.weixin.qq.com/s/aS2dg4Dj1Efwujmv-6YTBg\">为什么 HashMap 的数组长度要取 2 的整次方?</a></strong></p>\n<h4 id=\"二、扩容机制\"><a href=\"#二、扩容机制\" class=\"headerlink\" title=\"二、扩容机制\"></a>二、扩容机制</h4><p>大家都知道，数组一旦初始化后大小就无法改变了，所以就有了 [ArrayList]这种“动态数组”，可以自动扩容。</p>\n<p>HashMap 的底层用的也是数组。向 HashMap 里不停地添加元素，当数组无法装载更多元素时，就需要对数组进行扩容，以便装入更多的元素。</p>\n<p>当然了，数组是无法自动扩容的，所以如果要扩容的话，就需要新建一个大的数组，然后把小数组的元素复制过去。</p>\n<p>HashMap 的扩容是通过 resize 方法来实现的，JDK 8 中融入了红黑树，比较复杂，为了便于理解，就还使用 JDK 7 的源码，搞清楚了 JDK 7 的，我们后面再详细说明 JDK 8 和 JDK 7 之间的区别。</p>\n<h4 id=\"三、加载因子为什么是0-75\"><a href=\"#三、加载因子为什么是0-75\" class=\"headerlink\" title=\"三、加载因子为什么是0.75\"></a>三、加载因子为什么是0.75</h4><p>哈希函数计算结果越分散均匀，哈希碰撞的概率就越小，map的存取效率（时间复杂度）就会越高。</p>\n<p>哈希表长度越长，空间成本越大，哈希函数计算结果越分散均匀。</p>\n<p>****扩容机制****（实际上就是负载因子）和哈希函数越合理，空间成本越小，哈希函数计算结果越分散均匀。</p>\n<p>从HashMap的默认构造函数源码可知，构造函数就是对下面几个字段进行初始化。</p>\n<p>负载因子越大（长度一定），最大结点容量越大，resize次数越少，空间成本越小，map的存取效率就会越高。</p>\n<p>桶数组初始容量（长度）越大（加载因子一定），最大结点容量越大，resize次数越少，空间成本越大，map的存取效率就会越高。</p>\n<p>涉及到概率论的泊松分布与二项分布。</p>\n<p><em><strong>引入红黑树的概念：</strong></em></p>\n<p>这里存在一个问题，即使负载因子和哈希函数设计的再合理，也免不了会出现****拉链过长****（桶内结点过多）的情况，一旦出现拉链过长，则会严重影响HashMap的性能。于是，在JDK1.8版本中，对数据结构做了进一步的优化，引入了红黑树。而当链表长度太长（默认超过8）时，链表就转换为红黑树，利用红黑树快速增删改查的特点提高HashMap的性能。</p>\n<h4 id=\"四、线程不安全\"><a href=\"#四、线程不安全\" class=\"headerlink\" title=\"四、线程不安全\"></a>四、线程不安全</h4><p>有何体现：</p>\n<p>多线程下扩容会死循环、多线程下 put 会导致元素丢失、put 和 get 并发时会导致 get 到 null，也就是环链死循环、数据丢失、数据覆盖三个问题。其中环链在JDK1.8已经解决，但还是有数据覆盖的问题。</p>\n<p>究其根本：</p>\n<p>线程不安全主要是发生在扩容函数中，即根源是在<strong>transfer函数</strong>中：transfer函数代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Java\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">  *</span><br><span class=\"hljs-comment\">  <span class=\"hljs-doctag\">@version</span> JDK1.7</span><br><span class=\"hljs-comment\">  */</span><br><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">transfer</span><span class=\"hljs-params\">(Entry[] newTable, <span class=\"hljs-type\">boolean</span> rehash)</span> &#123;<br>        <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">newCapacity</span> <span class=\"hljs-operator\">=</span> newTable.length;<br>        <span class=\"hljs-keyword\">for</span> (Entry&lt;K,V&gt; e : table) &#123;<br>            <span class=\"hljs-keyword\">while</span>(<span class=\"hljs-literal\">null</span> != e) &#123;<br>                Entry&lt;K,V&gt; next = e.next;<br>                <span class=\"hljs-keyword\">if</span> (rehash) &#123;<br>                    e.hash = <span class=\"hljs-literal\">null</span> == e.key ? <span class=\"hljs-number\">0</span> : hash(e.key);<br>                &#125;<br>                <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">i</span> <span class=\"hljs-operator\">=</span> indexFor(e.hash, newCapacity);<br>                e.next = newTable[i];<br>                newTable[i] = e;<br>                e = next;<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>\n\n<p><code>HashMap</code>的扩容操作，重新定位每个桶的下标，并采用头插法将元素迁移到新数组中。头插法会将链表的顺序翻转，这也是形成死循环的关键点。</p>\n<p>key 用 Set 存放，所以想做到 <strong>key 不允许重复</strong>，key 对应的类（一般是String）需要重写 hashCode 和 equals 方法</p>\n<ul>\n<li>HashMap不是同步，HashTable是同步的，但HashTable已经弃用，如果需要线程安全，可以用synchronizedMap，例如       Map m = Collections.synchronizedMap(new HashMap(…));</li>\n</ul>\n"},{"title":"LCR-003-比特位计数","excerpt":"被chatGPT吊打的一天","index_img":"https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202309111618303.png","abbrlink":45029,"date":"2023-10-24T03:06:02.000Z","_content":"\n[LCR 003. 比特位计数](https://leetcode.cn/problems/w3tCBm/)\n\n给定一个非负整数 `n` ，请计算 `0` 到 `n` 之间的每个数字的二进制表示中 1 的个数，并输出一个数组。\n\n \n\n**示例 1:**\n\n```\n输入: n = 2\n输出: [0,1,1]\n解释: \n0 --> 0\n1 --> 1\n2 --> 10\n```\n\n**示例 2:**\n\n```\n输入: n = 5\n输出: [0,1,1,2,1,2]\n解释:\n0 --> 0\n1 --> 1\n2 --> 10\n3 --> 11\n4 --> 100\n5 --> 101\n```\n\n \n\n**说明 :**\n\n- `0 <= n <= 105`\n\n \n\n**进阶:**\n\n- 给出时间复杂度为 `O(n*sizeof(integer))` 的解答非常容易。但你可以在线性时间 `O(n)` 内用一趟扫描做到吗？\n- 要求算法的空间复杂度为 `O(n)` 。\n- 你能进一步完善解法吗？要求在C++或任何其他语言中不使用任何内置函数（如 C++ 中的 `__builtin_popcount` ）来执行此操作。\n\n\n\n```Java\n// import java.util.ArrayList;\n\n// class Solution {\n//     public int[] countBits(int n) {\n        \n//         ArrayList<Integer> list = new ArrayList<>();\n//         // 将0-n每一个数字首先转换为二进制数，存放于list中\n//         for (int i = 0; i <= n; i++) {\n//             String str = Integer.toBinaryString(i);\n//             int ans = Integer.parseInt(str, 2);\n//             list.add(ans);\n//         }\n\n//         return count(list);\n        \n\n\n\n//     }\n//     // 计数函数\n//     public int[] count(ArrayList<Integer> list) {\n//         int[] res = new int[list.size()];\n//         res[0] = 0;\n//         res[1] = 1;\n//         int count = 0;\n//         int size = res.length;\n\n//         for (int i = 0; i < size; i++) {\n//             int a = list.get(i);\n//             int b = list.get(i);\n\n//             if ((a & (b - 1)) == 0)\n//                 res[i] = 1;\n//             else {\n//                 char[] ch = String.valueOf(a).toCharArray();\n//                 for (int j = 0; j < ch.length; j++) {\n//                     if (ch[j] == '1') {\n//                         count++;\n//                     }\n//                 }\n//                 res[i] = count;\n//             }\n//             count = 0;\n//         }\n\n//         return res;\n//     }\n// }\n\nclass Solution {\n    public int[] countBits(int n) {\n        int[] res = new int[n + 1];\n        res[0] = 0;\n\n        for (int i = 1; i <= n; i++) {\n            // 使用 i & (i - 1) 来计算 i 的二进制表示中包含的 1 的个数\n            res[i] = res[i & (i - 1)] + 1;\n        }\n\n        return res;\n    }\n}\n```\n\n","source":"_posts/LCR-003-比特位计数.md","raw":"---\ntitle: LCR-003-比特位计数\nexcerpt: 被chatGPT吊打的一天\nindex_img: https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202309111618303.png\ncategories:\n  - 算法\ntags:\n  - “&”运算\n  - 位运算\nabbrlink: 45029\ndate: 2023-10-24 11:06:02\n---\n\n[LCR 003. 比特位计数](https://leetcode.cn/problems/w3tCBm/)\n\n给定一个非负整数 `n` ，请计算 `0` 到 `n` 之间的每个数字的二进制表示中 1 的个数，并输出一个数组。\n\n \n\n**示例 1:**\n\n```\n输入: n = 2\n输出: [0,1,1]\n解释: \n0 --> 0\n1 --> 1\n2 --> 10\n```\n\n**示例 2:**\n\n```\n输入: n = 5\n输出: [0,1,1,2,1,2]\n解释:\n0 --> 0\n1 --> 1\n2 --> 10\n3 --> 11\n4 --> 100\n5 --> 101\n```\n\n \n\n**说明 :**\n\n- `0 <= n <= 105`\n\n \n\n**进阶:**\n\n- 给出时间复杂度为 `O(n*sizeof(integer))` 的解答非常容易。但你可以在线性时间 `O(n)` 内用一趟扫描做到吗？\n- 要求算法的空间复杂度为 `O(n)` 。\n- 你能进一步完善解法吗？要求在C++或任何其他语言中不使用任何内置函数（如 C++ 中的 `__builtin_popcount` ）来执行此操作。\n\n\n\n```Java\n// import java.util.ArrayList;\n\n// class Solution {\n//     public int[] countBits(int n) {\n        \n//         ArrayList<Integer> list = new ArrayList<>();\n//         // 将0-n每一个数字首先转换为二进制数，存放于list中\n//         for (int i = 0; i <= n; i++) {\n//             String str = Integer.toBinaryString(i);\n//             int ans = Integer.parseInt(str, 2);\n//             list.add(ans);\n//         }\n\n//         return count(list);\n        \n\n\n\n//     }\n//     // 计数函数\n//     public int[] count(ArrayList<Integer> list) {\n//         int[] res = new int[list.size()];\n//         res[0] = 0;\n//         res[1] = 1;\n//         int count = 0;\n//         int size = res.length;\n\n//         for (int i = 0; i < size; i++) {\n//             int a = list.get(i);\n//             int b = list.get(i);\n\n//             if ((a & (b - 1)) == 0)\n//                 res[i] = 1;\n//             else {\n//                 char[] ch = String.valueOf(a).toCharArray();\n//                 for (int j = 0; j < ch.length; j++) {\n//                     if (ch[j] == '1') {\n//                         count++;\n//                     }\n//                 }\n//                 res[i] = count;\n//             }\n//             count = 0;\n//         }\n\n//         return res;\n//     }\n// }\n\nclass Solution {\n    public int[] countBits(int n) {\n        int[] res = new int[n + 1];\n        res[0] = 0;\n\n        for (int i = 1; i <= n; i++) {\n            // 使用 i & (i - 1) 来计算 i 的二进制表示中包含的 1 的个数\n            res[i] = res[i & (i - 1)] + 1;\n        }\n\n        return res;\n    }\n}\n```\n\n","slug":"LCR-003-比特位计数","published":1,"updated":"2023-11-15T08:30:24.366Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clpkicziq000rfkfo7j3ca748","content":"<p><a href=\"https://leetcode.cn/problems/w3tCBm/\">LCR 003. 比特位计数</a></p>\n<p>给定一个非负整数 <code>n</code> ，请计算 <code>0</code> 到 <code>n</code> 之间的每个数字的二进制表示中 1 的个数，并输出一个数组。</p>\n<p><strong>示例 1:</strong></p>\n<figure class=\"highlight ada\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ada\">输入: n = <span class=\"hljs-number\">2</span><br>输出: [<span class=\"hljs-number\">0</span>,<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">1</span>]<br>解释: <br><span class=\"hljs-number\">0</span> <span class=\"hljs-comment\">--&gt; 0</span><br><span class=\"hljs-number\">1</span> <span class=\"hljs-comment\">--&gt; 1</span><br><span class=\"hljs-number\">2</span> <span class=\"hljs-comment\">--&gt; 10</span><br></code></pre></td></tr></table></figure>\n\n<p><strong>示例 2:</strong></p>\n<figure class=\"highlight ada\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ada\">输入: n = <span class=\"hljs-number\">5</span><br>输出: [<span class=\"hljs-number\">0</span>,<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>]<br>解释:<br><span class=\"hljs-number\">0</span> <span class=\"hljs-comment\">--&gt; 0</span><br><span class=\"hljs-number\">1</span> <span class=\"hljs-comment\">--&gt; 1</span><br><span class=\"hljs-number\">2</span> <span class=\"hljs-comment\">--&gt; 10</span><br><span class=\"hljs-number\">3</span> <span class=\"hljs-comment\">--&gt; 11</span><br><span class=\"hljs-number\">4</span> <span class=\"hljs-comment\">--&gt; 100</span><br><span class=\"hljs-number\">5</span> <span class=\"hljs-comment\">--&gt; 101</span><br></code></pre></td></tr></table></figure>\n\n<p><strong>说明 :</strong></p>\n<ul>\n<li><code>0 &lt;= n &lt;= 105</code></li>\n</ul>\n<p><strong>进阶:</strong></p>\n<ul>\n<li>给出时间复杂度为 <code>O(n*sizeof(integer))</code> 的解答非常容易。但你可以在线性时间 <code>O(n)</code> 内用一趟扫描做到吗？</li>\n<li>要求算法的空间复杂度为 <code>O(n)</code> 。</li>\n<li>你能进一步完善解法吗？要求在C++或任何其他语言中不使用任何内置函数（如 C++ 中的 <code>__builtin_popcount</code> ）来执行此操作。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Java\"><span class=\"hljs-comment\">// import java.util.ArrayList;</span><br><br><span class=\"hljs-comment\">// class Solution &#123;</span><br><span class=\"hljs-comment\">//     public int[] countBits(int n) &#123;</span><br>        <br><span class=\"hljs-comment\">//         ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br><span class=\"hljs-comment\">//         // 将0-n每一个数字首先转换为二进制数，存放于list中</span><br><span class=\"hljs-comment\">//         for (int i = 0; i &lt;= n; i++) &#123;</span><br><span class=\"hljs-comment\">//             String str = Integer.toBinaryString(i);</span><br><span class=\"hljs-comment\">//             int ans = Integer.parseInt(str, 2);</span><br><span class=\"hljs-comment\">//             list.add(ans);</span><br><span class=\"hljs-comment\">//         &#125;</span><br><br><span class=\"hljs-comment\">//         return count(list);</span><br>        <br><br><br><br><span class=\"hljs-comment\">//     &#125;</span><br><span class=\"hljs-comment\">//     // 计数函数</span><br><span class=\"hljs-comment\">//     public int[] count(ArrayList&lt;Integer&gt; list) &#123;</span><br><span class=\"hljs-comment\">//         int[] res = new int[list.size()];</span><br><span class=\"hljs-comment\">//         res[0] = 0;</span><br><span class=\"hljs-comment\">//         res[1] = 1;</span><br><span class=\"hljs-comment\">//         int count = 0;</span><br><span class=\"hljs-comment\">//         int size = res.length;</span><br><br><span class=\"hljs-comment\">//         for (int i = 0; i &lt; size; i++) &#123;</span><br><span class=\"hljs-comment\">//             int a = list.get(i);</span><br><span class=\"hljs-comment\">//             int b = list.get(i);</span><br><br><span class=\"hljs-comment\">//             if ((a &amp; (b - 1)) == 0)</span><br><span class=\"hljs-comment\">//                 res[i] = 1;</span><br><span class=\"hljs-comment\">//             else &#123;</span><br><span class=\"hljs-comment\">//                 char[] ch = String.valueOf(a).toCharArray();</span><br><span class=\"hljs-comment\">//                 for (int j = 0; j &lt; ch.length; j++) &#123;</span><br><span class=\"hljs-comment\">//                     if (ch[j] == &#x27;1&#x27;) &#123;</span><br><span class=\"hljs-comment\">//                         count++;</span><br><span class=\"hljs-comment\">//                     &#125;</span><br><span class=\"hljs-comment\">//                 &#125;</span><br><span class=\"hljs-comment\">//                 res[i] = count;</span><br><span class=\"hljs-comment\">//             &#125;</span><br><span class=\"hljs-comment\">//             count = 0;</span><br><span class=\"hljs-comment\">//         &#125;</span><br><br><span class=\"hljs-comment\">//         return res;</span><br><span class=\"hljs-comment\">//     &#125;</span><br><span class=\"hljs-comment\">// &#125;</span><br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span> &#123;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-type\">int</span>[] countBits(<span class=\"hljs-type\">int</span> n) &#123;<br>        <span class=\"hljs-type\">int</span>[] res = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">int</span>[n + <span class=\"hljs-number\">1</span>];<br>        res[<span class=\"hljs-number\">0</span>] = <span class=\"hljs-number\">0</span>;<br><br>        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">i</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">1</span>; i &lt;= n; i++) &#123;<br>            <span class=\"hljs-comment\">// 使用 i &amp; (i - 1) 来计算 i 的二进制表示中包含的 1 的个数</span><br>            res[i] = res[i &amp; (i - <span class=\"hljs-number\">1</span>)] + <span class=\"hljs-number\">1</span>;<br>        &#125;<br><br>        <span class=\"hljs-keyword\">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n","site":{"data":{}},"more":"<p><a href=\"https://leetcode.cn/problems/w3tCBm/\">LCR 003. 比特位计数</a></p>\n<p>给定一个非负整数 <code>n</code> ，请计算 <code>0</code> 到 <code>n</code> 之间的每个数字的二进制表示中 1 的个数，并输出一个数组。</p>\n<p><strong>示例 1:</strong></p>\n<figure class=\"highlight ada\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ada\">输入: n = <span class=\"hljs-number\">2</span><br>输出: [<span class=\"hljs-number\">0</span>,<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">1</span>]<br>解释: <br><span class=\"hljs-number\">0</span> <span class=\"hljs-comment\">--&gt; 0</span><br><span class=\"hljs-number\">1</span> <span class=\"hljs-comment\">--&gt; 1</span><br><span class=\"hljs-number\">2</span> <span class=\"hljs-comment\">--&gt; 10</span><br></code></pre></td></tr></table></figure>\n\n<p><strong>示例 2:</strong></p>\n<figure class=\"highlight ada\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ada\">输入: n = <span class=\"hljs-number\">5</span><br>输出: [<span class=\"hljs-number\">0</span>,<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>]<br>解释:<br><span class=\"hljs-number\">0</span> <span class=\"hljs-comment\">--&gt; 0</span><br><span class=\"hljs-number\">1</span> <span class=\"hljs-comment\">--&gt; 1</span><br><span class=\"hljs-number\">2</span> <span class=\"hljs-comment\">--&gt; 10</span><br><span class=\"hljs-number\">3</span> <span class=\"hljs-comment\">--&gt; 11</span><br><span class=\"hljs-number\">4</span> <span class=\"hljs-comment\">--&gt; 100</span><br><span class=\"hljs-number\">5</span> <span class=\"hljs-comment\">--&gt; 101</span><br></code></pre></td></tr></table></figure>\n\n<p><strong>说明 :</strong></p>\n<ul>\n<li><code>0 &lt;= n &lt;= 105</code></li>\n</ul>\n<p><strong>进阶:</strong></p>\n<ul>\n<li>给出时间复杂度为 <code>O(n*sizeof(integer))</code> 的解答非常容易。但你可以在线性时间 <code>O(n)</code> 内用一趟扫描做到吗？</li>\n<li>要求算法的空间复杂度为 <code>O(n)</code> 。</li>\n<li>你能进一步完善解法吗？要求在C++或任何其他语言中不使用任何内置函数（如 C++ 中的 <code>__builtin_popcount</code> ）来执行此操作。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Java\"><span class=\"hljs-comment\">// import java.util.ArrayList;</span><br><br><span class=\"hljs-comment\">// class Solution &#123;</span><br><span class=\"hljs-comment\">//     public int[] countBits(int n) &#123;</span><br>        <br><span class=\"hljs-comment\">//         ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br><span class=\"hljs-comment\">//         // 将0-n每一个数字首先转换为二进制数，存放于list中</span><br><span class=\"hljs-comment\">//         for (int i = 0; i &lt;= n; i++) &#123;</span><br><span class=\"hljs-comment\">//             String str = Integer.toBinaryString(i);</span><br><span class=\"hljs-comment\">//             int ans = Integer.parseInt(str, 2);</span><br><span class=\"hljs-comment\">//             list.add(ans);</span><br><span class=\"hljs-comment\">//         &#125;</span><br><br><span class=\"hljs-comment\">//         return count(list);</span><br>        <br><br><br><br><span class=\"hljs-comment\">//     &#125;</span><br><span class=\"hljs-comment\">//     // 计数函数</span><br><span class=\"hljs-comment\">//     public int[] count(ArrayList&lt;Integer&gt; list) &#123;</span><br><span class=\"hljs-comment\">//         int[] res = new int[list.size()];</span><br><span class=\"hljs-comment\">//         res[0] = 0;</span><br><span class=\"hljs-comment\">//         res[1] = 1;</span><br><span class=\"hljs-comment\">//         int count = 0;</span><br><span class=\"hljs-comment\">//         int size = res.length;</span><br><br><span class=\"hljs-comment\">//         for (int i = 0; i &lt; size; i++) &#123;</span><br><span class=\"hljs-comment\">//             int a = list.get(i);</span><br><span class=\"hljs-comment\">//             int b = list.get(i);</span><br><br><span class=\"hljs-comment\">//             if ((a &amp; (b - 1)) == 0)</span><br><span class=\"hljs-comment\">//                 res[i] = 1;</span><br><span class=\"hljs-comment\">//             else &#123;</span><br><span class=\"hljs-comment\">//                 char[] ch = String.valueOf(a).toCharArray();</span><br><span class=\"hljs-comment\">//                 for (int j = 0; j &lt; ch.length; j++) &#123;</span><br><span class=\"hljs-comment\">//                     if (ch[j] == &#x27;1&#x27;) &#123;</span><br><span class=\"hljs-comment\">//                         count++;</span><br><span class=\"hljs-comment\">//                     &#125;</span><br><span class=\"hljs-comment\">//                 &#125;</span><br><span class=\"hljs-comment\">//                 res[i] = count;</span><br><span class=\"hljs-comment\">//             &#125;</span><br><span class=\"hljs-comment\">//             count = 0;</span><br><span class=\"hljs-comment\">//         &#125;</span><br><br><span class=\"hljs-comment\">//         return res;</span><br><span class=\"hljs-comment\">//     &#125;</span><br><span class=\"hljs-comment\">// &#125;</span><br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span> &#123;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-type\">int</span>[] countBits(<span class=\"hljs-type\">int</span> n) &#123;<br>        <span class=\"hljs-type\">int</span>[] res = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">int</span>[n + <span class=\"hljs-number\">1</span>];<br>        res[<span class=\"hljs-number\">0</span>] = <span class=\"hljs-number\">0</span>;<br><br>        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">i</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">1</span>; i &lt;= n; i++) &#123;<br>            <span class=\"hljs-comment\">// 使用 i &amp; (i - 1) 来计算 i 的二进制表示中包含的 1 的个数</span><br>            res[i] = res[i &amp; (i - <span class=\"hljs-number\">1</span>)] + <span class=\"hljs-number\">1</span>;<br>        &#125;<br><br>        <span class=\"hljs-keyword\">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n"},{"title":"LCR-136-删除链表结点","index_img":"https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202309111618303.png","abbrlink":61716,"date":"2023-10-16T08:36:11.000Z","_content":"\n# 删除链表结点的两种解法\n\n```Java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public ListNode deleteNode(ListNode head, int val) {\n        if(head == null) return null;\n        if(head.val == val) return head.next;\n        else head.next = deleteNode(head.next,val);\n        return head;\n\n    }\n}\n```\n\n```Java\nclass Solution {\n    public ListNode deleteNode(ListNode head, int val) {\n        ListNode pre = head;\n        ListNode cur = head.next;\n        \n        if (head.val == val)  return head.next;\n\n        while (cur != null) {\n            if (cur.val == val) {\n                pre.next = cur.next;\n            }\n            pre = cur;\n            cur = cur.next;\n\n        }\n        return head;\n    }\n}\n```\n\n","source":"_posts/LCR-136-删除链表结点.md","raw":"---\ntitle: LCR-136-删除链表结点\nindex_img: https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202309111618303.png\ncategories:\n  - 算法\ntags:\n  - 链表\n  - 递归\nabbrlink: 61716\ndate: 2023-10-16 16:36:11\n---\n\n# 删除链表结点的两种解法\n\n```Java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public ListNode deleteNode(ListNode head, int val) {\n        if(head == null) return null;\n        if(head.val == val) return head.next;\n        else head.next = deleteNode(head.next,val);\n        return head;\n\n    }\n}\n```\n\n```Java\nclass Solution {\n    public ListNode deleteNode(ListNode head, int val) {\n        ListNode pre = head;\n        ListNode cur = head.next;\n        \n        if (head.val == val)  return head.next;\n\n        while (cur != null) {\n            if (cur.val == val) {\n                pre.next = cur.next;\n            }\n            pre = cur;\n            cur = cur.next;\n\n        }\n        return head;\n    }\n}\n```\n\n","slug":"LCR-136-删除链表结点","published":1,"updated":"2023-11-15T08:30:35.079Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clpkiczir000ufkfoe6be08wp","content":"<h1 id=\"删除链表结点的两种解法\"><a href=\"#删除链表结点的两种解法\" class=\"headerlink\" title=\"删除链表结点的两种解法\"></a>删除链表结点的两种解法</h1><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Java\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * Definition for singly-linked list.</span><br><span class=\"hljs-comment\"> * public class ListNode &#123;</span><br><span class=\"hljs-comment\"> *     int val;</span><br><span class=\"hljs-comment\"> *     ListNode next;</span><br><span class=\"hljs-comment\"> *     ListNode(int x) &#123; val = x; &#125;</span><br><span class=\"hljs-comment\"> * &#125;</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span> &#123;<br>    <span class=\"hljs-keyword\">public</span> ListNode <span class=\"hljs-title function_\">deleteNode</span><span class=\"hljs-params\">(ListNode head, <span class=\"hljs-type\">int</span> val)</span> &#123;<br>        <span class=\"hljs-keyword\">if</span>(head == <span class=\"hljs-literal\">null</span>) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">null</span>;<br>        <span class=\"hljs-keyword\">if</span>(head.val == val) <span class=\"hljs-keyword\">return</span> head.next;<br>        <span class=\"hljs-keyword\">else</span> head.next = deleteNode(head.next,val);<br>        <span class=\"hljs-keyword\">return</span> head;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Java\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span> &#123;<br>    <span class=\"hljs-keyword\">public</span> ListNode <span class=\"hljs-title function_\">deleteNode</span><span class=\"hljs-params\">(ListNode head, <span class=\"hljs-type\">int</span> val)</span> &#123;<br>        <span class=\"hljs-type\">ListNode</span> <span class=\"hljs-variable\">pre</span> <span class=\"hljs-operator\">=</span> head;<br>        <span class=\"hljs-type\">ListNode</span> <span class=\"hljs-variable\">cur</span> <span class=\"hljs-operator\">=</span> head.next;<br>        <br>        <span class=\"hljs-keyword\">if</span> (head.val == val)  <span class=\"hljs-keyword\">return</span> head.next;<br><br>        <span class=\"hljs-keyword\">while</span> (cur != <span class=\"hljs-literal\">null</span>) &#123;<br>            <span class=\"hljs-keyword\">if</span> (cur.val == val) &#123;<br>                pre.next = cur.next;<br>            &#125;<br>            pre = cur;<br>            cur = cur.next;<br><br>        &#125;<br>        <span class=\"hljs-keyword\">return</span> head;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"删除链表结点的两种解法\"><a href=\"#删除链表结点的两种解法\" class=\"headerlink\" title=\"删除链表结点的两种解法\"></a>删除链表结点的两种解法</h1><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Java\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * Definition for singly-linked list.</span><br><span class=\"hljs-comment\"> * public class ListNode &#123;</span><br><span class=\"hljs-comment\"> *     int val;</span><br><span class=\"hljs-comment\"> *     ListNode next;</span><br><span class=\"hljs-comment\"> *     ListNode(int x) &#123; val = x; &#125;</span><br><span class=\"hljs-comment\"> * &#125;</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span> &#123;<br>    <span class=\"hljs-keyword\">public</span> ListNode <span class=\"hljs-title function_\">deleteNode</span><span class=\"hljs-params\">(ListNode head, <span class=\"hljs-type\">int</span> val)</span> &#123;<br>        <span class=\"hljs-keyword\">if</span>(head == <span class=\"hljs-literal\">null</span>) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">null</span>;<br>        <span class=\"hljs-keyword\">if</span>(head.val == val) <span class=\"hljs-keyword\">return</span> head.next;<br>        <span class=\"hljs-keyword\">else</span> head.next = deleteNode(head.next,val);<br>        <span class=\"hljs-keyword\">return</span> head;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Java\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span> &#123;<br>    <span class=\"hljs-keyword\">public</span> ListNode <span class=\"hljs-title function_\">deleteNode</span><span class=\"hljs-params\">(ListNode head, <span class=\"hljs-type\">int</span> val)</span> &#123;<br>        <span class=\"hljs-type\">ListNode</span> <span class=\"hljs-variable\">pre</span> <span class=\"hljs-operator\">=</span> head;<br>        <span class=\"hljs-type\">ListNode</span> <span class=\"hljs-variable\">cur</span> <span class=\"hljs-operator\">=</span> head.next;<br>        <br>        <span class=\"hljs-keyword\">if</span> (head.val == val)  <span class=\"hljs-keyword\">return</span> head.next;<br><br>        <span class=\"hljs-keyword\">while</span> (cur != <span class=\"hljs-literal\">null</span>) &#123;<br>            <span class=\"hljs-keyword\">if</span> (cur.val == val) &#123;<br>                pre.next = cur.next;<br>            &#125;<br>            pre = cur;<br>            cur = cur.next;<br><br>        &#125;<br>        <span class=\"hljs-keyword\">return</span> head;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n"},{"title":"Linux 常用命令积累","index_img":"https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202309111619818.jpg","abbrlink":44958,"date":"2022-09-07T00:58:32.000Z","_content":"```cmd\n docker相关命令：\n \t#docker pull之后，使用如下命令进行创建和启动容器，因为懒的配置，所以使用默认配置。\n \t\tdocker run -itd --name redis -p 6379:6379 redis\n \t#docker ps：查看运行中的CONTAINER\n \t#docker进入容器\n \t\tdocker exec -it mymongo /bin/bash\n \t#这个是使容器处于docker运行便自启动\n \t\tdocker update redis --restart=always \n \t#docker重启命令\n \t\tsystemctl restart docker\n \t#容器重启命令\n \t\tdocker restart redis(自己命的名字或者CONTAINER ID)\n 启动     systemctl start firewalld\n 关闭     systemctl stop firewalld\n 查看状态  systemctl status firewalld\n 查看状态  firewall-cmd --state\n 开机启用  systemctl enable firewalld\n 开机禁用  systemctl disable firewalld\n 查看端口  firewall-cmd --zone=public --list-ports\n 添加端口  firewall-cmd --add-port=443/tcp --permanent //永久添加443端口,协议为tcp \n 重新加载  firewall-cmd --reload //重新加载\n\n 删除端口  firewall-cmd --zone=public --remove-port=80/tcp --permanent //删除tcp下的80端口\n\n \n\n 参数介绍：\n firewall-cmd：是Linux提供的操作firewall的一个工具(注意没有字母“d”)；\n --permanent：表示设置为持久；\n --add-port：标识添加的端口\n --remove-port:标识删除的端口\n```\n\n> Linux常用命令？怎么查看项目的日志？\n    >\n    > 1. ls：列出当前目录下的文件和子目录。\n    >\n    > 2. cd：改变当前工作目录。\n    >\n    > 3. mkdir：创建一个新目录。\n    >\n    > 4. rm：删除文件或目录。\n    >\n    > 5. cp：复制文件或目录。\n    >\n    > 6. mv：移动文件或目录。\n    >\n    > 7. touch：创建一个新文件或修改文件的时间戳。\n    >\n    > 8. cat：查看文件的内容。\n    >\n    > 9. grep：在文件中查找指定的字符串。\n    >\n    > 10. ps：查看当前运行的进程。\n    >\n    > 11. top：查看系统资源使用情况。\n    >\n    > 12. df：查看文件系统使用情况。\n    >\n    > 13. du：查看目录大小。\n    >\n    > 14. tar：归档和压缩文件。\n    >\n    > 15. ssh：远程登录到另一台主机。\n    >\n    > 要查看部署到Linux上的项目日志，可以使用以下命令：\n    >\n    > 1. tail：查看文件的末尾几行。\n    >\n    > 例如，要查看Tomcat日志文件的最后100行，可以使用以下命令：\n    >\n    > ```\n    > tail -n 100 /var/log/tomcat/catalina.out\n    > ```\n    >\n    > 2. less：查看大文件的内容。\n    >\n    > 例如，要查看一个1GB的日志文件，可以使用以下命令：\n    >\n    > ```\n    > less /var/log/myapp.log\n    > ```\n    >\n    > 在less中，可以使用Page Up、Page Down、上下方向键等进行滚动和搜索。要退出less，可以使用q键。\n    >\n    > 3. grep：在日志文件中查找指定的字符串。\n    >\n    > 例如，要查找myapp日志文件中包含ERROR的行，可以使用以下命令：\n    >\n    > ```\n    > grep ERROR /var/log/myapp.log\n    > ```\n    >\n    > 以上是一些常用的Linux命令，可以帮助开发者快速定位和解决问题。\n\n## 基础篇\n\nLinux常用命令\n\n实验步骤：\n\nSTEP 1 普通用户登录到系统，使用pwd查看当前用户的家目录。\n\n​                               \n\nSTEP 2 使用su命令进行用户切换\n\n \n\nSTEP 3 切换到root用户的家目录，并使用pwd命令进行查看。\n\n \n\nSTEP 4 用ls命令列出普通用户家目录下的目录及文件。\n\n \n\nSTEP 5 用ls命令列出root用户家目录下的目录及文件。\n\n \n\nSTEP 6 用-a选项列出root用户家目录下的包括隐藏文件在内的所有文件和目录。\n\n \n\nSTEP 7 用man命令查看ls命令的使用手册。\n\n \n\nSTEP 8 切换回普通用户，在其家目录下创建名为test的目录。\n\n创建错误，误在超级用户下创建了text：\n\n \n\n已更正：\n\n \n\n \n\nSTEP 9利用ls命令列出文件和目录，确认test目录创建成功\n\n \n\nSTEP 10 切换到/tmp目录下，在当前目录下创建xg目录，在xg目录下创建jk目录。\n\n \n\nSTEP 11利用ls -l命令列出文件/tmp/xg下的内容。 \n\nSTEP 12利用touch命令，在普通用户家目录中创建一个新的文本文件newfile。\n\n \n\nSTEP 13 利用cp命令复制系统文件/etc/profile到当前目录下。\n\n \n\nSTEP 14 复制文件profile，名称为profile.bak，作为备份。\n\n ","source":"_posts/Linux.md","raw":"---\ntitle: Linux 常用命令积累\nindex_img: >-\n  https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202309111619818.jpg\ncategories:\n  - Linux\ntags:\n  - Linux\nabbrlink: 44958\ndate: 2022-09-07 08:58:32\n---\n```cmd\n docker相关命令：\n \t#docker pull之后，使用如下命令进行创建和启动容器，因为懒的配置，所以使用默认配置。\n \t\tdocker run -itd --name redis -p 6379:6379 redis\n \t#docker ps：查看运行中的CONTAINER\n \t#docker进入容器\n \t\tdocker exec -it mymongo /bin/bash\n \t#这个是使容器处于docker运行便自启动\n \t\tdocker update redis --restart=always \n \t#docker重启命令\n \t\tsystemctl restart docker\n \t#容器重启命令\n \t\tdocker restart redis(自己命的名字或者CONTAINER ID)\n 启动     systemctl start firewalld\n 关闭     systemctl stop firewalld\n 查看状态  systemctl status firewalld\n 查看状态  firewall-cmd --state\n 开机启用  systemctl enable firewalld\n 开机禁用  systemctl disable firewalld\n 查看端口  firewall-cmd --zone=public --list-ports\n 添加端口  firewall-cmd --add-port=443/tcp --permanent //永久添加443端口,协议为tcp \n 重新加载  firewall-cmd --reload //重新加载\n\n 删除端口  firewall-cmd --zone=public --remove-port=80/tcp --permanent //删除tcp下的80端口\n\n \n\n 参数介绍：\n firewall-cmd：是Linux提供的操作firewall的一个工具(注意没有字母“d”)；\n --permanent：表示设置为持久；\n --add-port：标识添加的端口\n --remove-port:标识删除的端口\n```\n\n> Linux常用命令？怎么查看项目的日志？\n    >\n    > 1. ls：列出当前目录下的文件和子目录。\n    >\n    > 2. cd：改变当前工作目录。\n    >\n    > 3. mkdir：创建一个新目录。\n    >\n    > 4. rm：删除文件或目录。\n    >\n    > 5. cp：复制文件或目录。\n    >\n    > 6. mv：移动文件或目录。\n    >\n    > 7. touch：创建一个新文件或修改文件的时间戳。\n    >\n    > 8. cat：查看文件的内容。\n    >\n    > 9. grep：在文件中查找指定的字符串。\n    >\n    > 10. ps：查看当前运行的进程。\n    >\n    > 11. top：查看系统资源使用情况。\n    >\n    > 12. df：查看文件系统使用情况。\n    >\n    > 13. du：查看目录大小。\n    >\n    > 14. tar：归档和压缩文件。\n    >\n    > 15. ssh：远程登录到另一台主机。\n    >\n    > 要查看部署到Linux上的项目日志，可以使用以下命令：\n    >\n    > 1. tail：查看文件的末尾几行。\n    >\n    > 例如，要查看Tomcat日志文件的最后100行，可以使用以下命令：\n    >\n    > ```\n    > tail -n 100 /var/log/tomcat/catalina.out\n    > ```\n    >\n    > 2. less：查看大文件的内容。\n    >\n    > 例如，要查看一个1GB的日志文件，可以使用以下命令：\n    >\n    > ```\n    > less /var/log/myapp.log\n    > ```\n    >\n    > 在less中，可以使用Page Up、Page Down、上下方向键等进行滚动和搜索。要退出less，可以使用q键。\n    >\n    > 3. grep：在日志文件中查找指定的字符串。\n    >\n    > 例如，要查找myapp日志文件中包含ERROR的行，可以使用以下命令：\n    >\n    > ```\n    > grep ERROR /var/log/myapp.log\n    > ```\n    >\n    > 以上是一些常用的Linux命令，可以帮助开发者快速定位和解决问题。\n\n## 基础篇\n\nLinux常用命令\n\n实验步骤：\n\nSTEP 1 普通用户登录到系统，使用pwd查看当前用户的家目录。\n\n​                               \n\nSTEP 2 使用su命令进行用户切换\n\n \n\nSTEP 3 切换到root用户的家目录，并使用pwd命令进行查看。\n\n \n\nSTEP 4 用ls命令列出普通用户家目录下的目录及文件。\n\n \n\nSTEP 5 用ls命令列出root用户家目录下的目录及文件。\n\n \n\nSTEP 6 用-a选项列出root用户家目录下的包括隐藏文件在内的所有文件和目录。\n\n \n\nSTEP 7 用man命令查看ls命令的使用手册。\n\n \n\nSTEP 8 切换回普通用户，在其家目录下创建名为test的目录。\n\n创建错误，误在超级用户下创建了text：\n\n \n\n已更正：\n\n \n\n \n\nSTEP 9利用ls命令列出文件和目录，确认test目录创建成功\n\n \n\nSTEP 10 切换到/tmp目录下，在当前目录下创建xg目录，在xg目录下创建jk目录。\n\n \n\nSTEP 11利用ls -l命令列出文件/tmp/xg下的内容。 \n\nSTEP 12利用touch命令，在普通用户家目录中创建一个新的文本文件newfile。\n\n \n\nSTEP 13 利用cp命令复制系统文件/etc/profile到当前目录下。\n\n \n\nSTEP 14 复制文件profile，名称为profile.bak，作为备份。\n\n ","slug":"Linux","published":1,"updated":"2023-11-13T09:03:55.971Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clpkiczis000zfkfo254fdkw5","content":"<figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmd\">docker相关命令：<br>\t#docker pull之后，使用如下命令进行创建和启动容器，因为懒的配置，所以使用默认配置。<br>\t\tdocker run -itd --name redis -p <span class=\"hljs-number\">6379</span>:<span class=\"hljs-number\">6379</span> redis<br>\t#docker ps：查看运行中的CONTAINER<br>\t#docker进入容器<br>\t\tdocker exec -it mymongo /bin/bash<br>\t#这个是使容器处于docker运行便自启动<br>\t\tdocker update redis --restart=always <br>\t#docker重启命令<br>\t\tsystemctl restart docker<br>\t#容器重启命令<br>\t\tdocker restart redis(自己命的名字或者CONTAINER ID)<br>启动     systemctl <span class=\"hljs-built_in\">start</span> firewalld<br>关闭     systemctl stop firewalld<br>查看状态  systemctl status firewalld<br>查看状态  firewall-<span class=\"hljs-built_in\">cmd</span> --state<br>开机启用  systemctl enable firewalld<br>开机禁用  systemctl disable firewalld<br>查看端口  firewall-<span class=\"hljs-built_in\">cmd</span> --zone=public --list-ports<br>添加端口  firewall-<span class=\"hljs-built_in\">cmd</span> --add-port=<span class=\"hljs-number\">443</span>/tcp --permanent //永久添加<span class=\"hljs-number\">443</span>端口,协议为tcp <br>重新加载  firewall-<span class=\"hljs-built_in\">cmd</span> --reload //重新加载<br><br>删除端口  firewall-<span class=\"hljs-built_in\">cmd</span> --zone=public --remove-port=<span class=\"hljs-number\">80</span>/tcp --permanent //删除tcp下的<span class=\"hljs-number\">80</span>端口<br><br><br><br>参数介绍：<br>firewall-<span class=\"hljs-built_in\">cmd</span>：是Linux提供的操作firewall的一个工具(注意没有字母“d”)；<br>--permanent：表示设置为持久；<br>--add-port：标识添加的端口<br>--remove-port:标识删除的端口<br></code></pre></td></tr></table></figure>\n\n<blockquote>\n<p>Linux常用命令？怎么查看项目的日志？</p>\n<ol>\n<li><p>ls：列出当前目录下的文件和子目录。</p>\n</li>\n<li><p>cd：改变当前工作目录。</p>\n</li>\n<li><p>mkdir：创建一个新目录。</p>\n</li>\n<li><p>rm：删除文件或目录。</p>\n</li>\n<li><p>cp：复制文件或目录。</p>\n</li>\n<li><p>mv：移动文件或目录。</p>\n</li>\n<li><p>touch：创建一个新文件或修改文件的时间戳。</p>\n</li>\n<li><p>cat：查看文件的内容。</p>\n</li>\n<li><p>grep：在文件中查找指定的字符串。</p>\n</li>\n<li><p>ps：查看当前运行的进程。</p>\n</li>\n<li><p>top：查看系统资源使用情况。</p>\n</li>\n<li><p>df：查看文件系统使用情况。</p>\n</li>\n<li><p>du：查看目录大小。</p>\n</li>\n<li><p>tar：归档和压缩文件。</p>\n</li>\n<li><p>ssh：远程登录到另一台主机。</p>\n</li>\n</ol>\n<p>要查看部署到Linux上的项目日志，可以使用以下命令：</p>\n<ol>\n<li>tail：查看文件的末尾几行。</li>\n</ol>\n<p>例如，要查看Tomcat日志文件的最后100行，可以使用以下命令：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs awk\">tail -n <span class=\"hljs-number\">100</span> <span class=\"hljs-regexp\">/var/</span>log<span class=\"hljs-regexp\">/tomcat/</span>catalina.out<br></code></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>less：查看大文件的内容。</li>\n</ol>\n<p>例如，要查看一个1GB的日志文件，可以使用以下命令：</p>\n<figure class=\"highlight arcade\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs arcade\">less /<span class=\"hljs-keyword\">var</span>/<span class=\"hljs-built_in\">log</span>/myapp.<span class=\"hljs-built_in\">log</span><br></code></pre></td></tr></table></figure>\n\n<p>在less中，可以使用Page Up、Page Down、上下方向键等进行滚动和搜索。要退出less，可以使用q键。</p>\n<ol start=\"3\">\n<li>grep：在日志文件中查找指定的字符串。</li>\n</ol>\n<p>例如，要查找myapp日志文件中包含ERROR的行，可以使用以下命令：</p>\n<figure class=\"highlight stata\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stata\">grep <span class=\"hljs-keyword\">ERROR</span> /<span class=\"hljs-keyword\">var</span>/<span class=\"hljs-keyword\">log</span>/myapp.<span class=\"hljs-keyword\">log</span><br></code></pre></td></tr></table></figure>\n\n<p>以上是一些常用的Linux命令，可以帮助开发者快速定位和解决问题。</p>\n</blockquote>\n<h2 id=\"基础篇\"><a href=\"#基础篇\" class=\"headerlink\" title=\"基础篇\"></a>基础篇</h2><p>Linux常用命令</p>\n<p>实验步骤：</p>\n<p>STEP 1 普通用户登录到系统，使用pwd查看当前用户的家目录。</p>\n<p>​                               </p>\n<p>STEP 2 使用su命令进行用户切换</p>\n<p>STEP 3 切换到root用户的家目录，并使用pwd命令进行查看。</p>\n<p>STEP 4 用ls命令列出普通用户家目录下的目录及文件。</p>\n<p>STEP 5 用ls命令列出root用户家目录下的目录及文件。</p>\n<p>STEP 6 用-a选项列出root用户家目录下的包括隐藏文件在内的所有文件和目录。</p>\n<p>STEP 7 用man命令查看ls命令的使用手册。</p>\n<p>STEP 8 切换回普通用户，在其家目录下创建名为test的目录。</p>\n<p>创建错误，误在超级用户下创建了text：</p>\n<p>已更正：</p>\n<p>STEP 9利用ls命令列出文件和目录，确认test目录创建成功</p>\n<p>STEP 10 切换到/tmp目录下，在当前目录下创建xg目录，在xg目录下创建jk目录。</p>\n<p>STEP 11利用ls -l命令列出文件/tmp/xg下的内容。 </p>\n<p>STEP 12利用touch命令，在普通用户家目录中创建一个新的文本文件newfile。</p>\n<p>STEP 13 利用cp命令复制系统文件/etc/profile到当前目录下。</p>\n<p>STEP 14 复制文件profile，名称为profile.bak，作为备份。</p>\n","site":{"data":{}},"excerpt":"","more":"<figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmd\">docker相关命令：<br>\t#docker pull之后，使用如下命令进行创建和启动容器，因为懒的配置，所以使用默认配置。<br>\t\tdocker run -itd --name redis -p <span class=\"hljs-number\">6379</span>:<span class=\"hljs-number\">6379</span> redis<br>\t#docker ps：查看运行中的CONTAINER<br>\t#docker进入容器<br>\t\tdocker exec -it mymongo /bin/bash<br>\t#这个是使容器处于docker运行便自启动<br>\t\tdocker update redis --restart=always <br>\t#docker重启命令<br>\t\tsystemctl restart docker<br>\t#容器重启命令<br>\t\tdocker restart redis(自己命的名字或者CONTAINER ID)<br>启动     systemctl <span class=\"hljs-built_in\">start</span> firewalld<br>关闭     systemctl stop firewalld<br>查看状态  systemctl status firewalld<br>查看状态  firewall-<span class=\"hljs-built_in\">cmd</span> --state<br>开机启用  systemctl enable firewalld<br>开机禁用  systemctl disable firewalld<br>查看端口  firewall-<span class=\"hljs-built_in\">cmd</span> --zone=public --list-ports<br>添加端口  firewall-<span class=\"hljs-built_in\">cmd</span> --add-port=<span class=\"hljs-number\">443</span>/tcp --permanent //永久添加<span class=\"hljs-number\">443</span>端口,协议为tcp <br>重新加载  firewall-<span class=\"hljs-built_in\">cmd</span> --reload //重新加载<br><br>删除端口  firewall-<span class=\"hljs-built_in\">cmd</span> --zone=public --remove-port=<span class=\"hljs-number\">80</span>/tcp --permanent //删除tcp下的<span class=\"hljs-number\">80</span>端口<br><br><br><br>参数介绍：<br>firewall-<span class=\"hljs-built_in\">cmd</span>：是Linux提供的操作firewall的一个工具(注意没有字母“d”)；<br>--permanent：表示设置为持久；<br>--add-port：标识添加的端口<br>--remove-port:标识删除的端口<br></code></pre></td></tr></table></figure>\n\n<blockquote>\n<p>Linux常用命令？怎么查看项目的日志？</p>\n<ol>\n<li><p>ls：列出当前目录下的文件和子目录。</p>\n</li>\n<li><p>cd：改变当前工作目录。</p>\n</li>\n<li><p>mkdir：创建一个新目录。</p>\n</li>\n<li><p>rm：删除文件或目录。</p>\n</li>\n<li><p>cp：复制文件或目录。</p>\n</li>\n<li><p>mv：移动文件或目录。</p>\n</li>\n<li><p>touch：创建一个新文件或修改文件的时间戳。</p>\n</li>\n<li><p>cat：查看文件的内容。</p>\n</li>\n<li><p>grep：在文件中查找指定的字符串。</p>\n</li>\n<li><p>ps：查看当前运行的进程。</p>\n</li>\n<li><p>top：查看系统资源使用情况。</p>\n</li>\n<li><p>df：查看文件系统使用情况。</p>\n</li>\n<li><p>du：查看目录大小。</p>\n</li>\n<li><p>tar：归档和压缩文件。</p>\n</li>\n<li><p>ssh：远程登录到另一台主机。</p>\n</li>\n</ol>\n<p>要查看部署到Linux上的项目日志，可以使用以下命令：</p>\n<ol>\n<li>tail：查看文件的末尾几行。</li>\n</ol>\n<p>例如，要查看Tomcat日志文件的最后100行，可以使用以下命令：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs awk\">tail -n <span class=\"hljs-number\">100</span> <span class=\"hljs-regexp\">/var/</span>log<span class=\"hljs-regexp\">/tomcat/</span>catalina.out<br></code></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>less：查看大文件的内容。</li>\n</ol>\n<p>例如，要查看一个1GB的日志文件，可以使用以下命令：</p>\n<figure class=\"highlight arcade\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs arcade\">less /<span class=\"hljs-keyword\">var</span>/<span class=\"hljs-built_in\">log</span>/myapp.<span class=\"hljs-built_in\">log</span><br></code></pre></td></tr></table></figure>\n\n<p>在less中，可以使用Page Up、Page Down、上下方向键等进行滚动和搜索。要退出less，可以使用q键。</p>\n<ol start=\"3\">\n<li>grep：在日志文件中查找指定的字符串。</li>\n</ol>\n<p>例如，要查找myapp日志文件中包含ERROR的行，可以使用以下命令：</p>\n<figure class=\"highlight stata\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stata\">grep <span class=\"hljs-keyword\">ERROR</span> /<span class=\"hljs-keyword\">var</span>/<span class=\"hljs-keyword\">log</span>/myapp.<span class=\"hljs-keyword\">log</span><br></code></pre></td></tr></table></figure>\n\n<p>以上是一些常用的Linux命令，可以帮助开发者快速定位和解决问题。</p>\n</blockquote>\n<h2 id=\"基础篇\"><a href=\"#基础篇\" class=\"headerlink\" title=\"基础篇\"></a>基础篇</h2><p>Linux常用命令</p>\n<p>实验步骤：</p>\n<p>STEP 1 普通用户登录到系统，使用pwd查看当前用户的家目录。</p>\n<p>​                               </p>\n<p>STEP 2 使用su命令进行用户切换</p>\n<p>STEP 3 切换到root用户的家目录，并使用pwd命令进行查看。</p>\n<p>STEP 4 用ls命令列出普通用户家目录下的目录及文件。</p>\n<p>STEP 5 用ls命令列出root用户家目录下的目录及文件。</p>\n<p>STEP 6 用-a选项列出root用户家目录下的包括隐藏文件在内的所有文件和目录。</p>\n<p>STEP 7 用man命令查看ls命令的使用手册。</p>\n<p>STEP 8 切换回普通用户，在其家目录下创建名为test的目录。</p>\n<p>创建错误，误在超级用户下创建了text：</p>\n<p>已更正：</p>\n<p>STEP 9利用ls命令列出文件和目录，确认test目录创建成功</p>\n<p>STEP 10 切换到/tmp目录下，在当前目录下创建xg目录，在xg目录下创建jk目录。</p>\n<p>STEP 11利用ls -l命令列出文件/tmp/xg下的内容。 </p>\n<p>STEP 12利用touch命令，在普通用户家目录中创建一个新的文本文件newfile。</p>\n<p>STEP 13 利用cp命令复制系统文件/etc/profile到当前目录下。</p>\n<p>STEP 14 复制文件profile，名称为profile.bak，作为备份。</p>\n"},{"title":"面试官的突袭问题：解密多态，让你从懵逼到彻底掌握！","index_img":"https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311151627635.png","excerpt":"面试官的突袭问题：解密多态，让你从懵逼到彻底掌握！","abbrlink":47559,"date":"2023-10-16T00:57:50.000Z","_content":"\n# Java多态揭秘：从疑惑到真正掌握！面试官的突袭问题让你茫然？解开多态的魔法！\n\n> 无论是在课堂上、面试中还是与朋友交谈时，当被问到是否理解多态时，我们可能都感到无从下手。这时候，让我通过一个生动的例子，为你彻底解析多态的奥秘！在这个秋招季，面试官的提问可能让你措手不及。但别担心，让我们一起揭开这个问题，带你从茫然到彻底掌握！\n\n本文已发表在`CSDN`,[阅读链接](http://t.csdnimg.cn/x02pb)\n\n## 继承与重写\n\n假设我们有一个Animal类，它有一个makeSound()方法，用于输出动物发出的声音。现在，我们再创建一个Dog类，继承自Animal类，并重写makeSound()方法，让它输出狗狗特有的吠声。\n\n```java\nclass Animal {\n    public void makeSound() {\n        System.out.println(\"Animal makes sound\");\n    }\n}\n\nclass Dog extends Animal {\n    @Override\n    public void makeSound() {\n        System.out.println(\"Dog barks\");\n    }\n}\n```\n\n## 向上转型\n\n现在，让我们来看看这段代码中隐藏的多态之美！\n\n```java\nAnimal animal = new Dog();\nanimal.makeSound();  // 输出: \"Dog barks\"\n```\n\n在这段代码中，我们创建了一个Animal类型的引用变量animal，并将其指向一个Dog对象。这就是向上转型，让我们能够使用父类类型的引用来引用子类对象。\n\n当我们调用animal的makeSound()方法时，输出的却是\"Dog barks\"，而不是我们在Animal类中定义的\"Animal makes sound\"。这就是多态的奇妙之处！\n\n在编译时，编译器只知道animal的类型是Animal，因此它只能访问Animal类中定义的方法和属性。但在运行时，实际执行的却是Dog类中重写的makeSound()方法。这是因为Java的运行时系统会根据实际对象的类型来动态决定调用哪个类的方法。\n\n通过这种方式，我们可以根据实际对象的类型，在运行时决定调用哪个类的方法，实现了多态性。这种灵活性和可扩展性使我们能够编写更通用、灵活的代码，同时提高代码的可维护性和可复用性。\n\n掌握**继承、重写和向上转型**这三个必要条件，你就能够在面试中从容应对关于多态性的问题。多态性是面向对象编程中不可或缺的核心概念，它为我们打开了编程世界的大门。\n\n所以，别再为面试官的突袭问题而困惑了！现在，你已经揭开了多态的魔法，让多态性成为你的利器，展现你对Java编程的真正掌握！\n\n\n\n附图：\n\n![由一张图片引发的深思](https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202310160943256.png)\n\n","source":"_posts/Polymorphism.md","raw":"---\ntitle: 面试官的突袭问题：解密多态，让你从懵逼到彻底掌握！\nindex_img: https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311151627635.png\nexcerpt: 面试官的突袭问题：解密多态，让你从懵逼到彻底掌握！\ncategories:\n  - Blog\ntags:\n  - Polymorphism\nabbrlink: 47559\ndate: 2023-10-16 08:57:50\n---\n\n# Java多态揭秘：从疑惑到真正掌握！面试官的突袭问题让你茫然？解开多态的魔法！\n\n> 无论是在课堂上、面试中还是与朋友交谈时，当被问到是否理解多态时，我们可能都感到无从下手。这时候，让我通过一个生动的例子，为你彻底解析多态的奥秘！在这个秋招季，面试官的提问可能让你措手不及。但别担心，让我们一起揭开这个问题，带你从茫然到彻底掌握！\n\n本文已发表在`CSDN`,[阅读链接](http://t.csdnimg.cn/x02pb)\n\n## 继承与重写\n\n假设我们有一个Animal类，它有一个makeSound()方法，用于输出动物发出的声音。现在，我们再创建一个Dog类，继承自Animal类，并重写makeSound()方法，让它输出狗狗特有的吠声。\n\n```java\nclass Animal {\n    public void makeSound() {\n        System.out.println(\"Animal makes sound\");\n    }\n}\n\nclass Dog extends Animal {\n    @Override\n    public void makeSound() {\n        System.out.println(\"Dog barks\");\n    }\n}\n```\n\n## 向上转型\n\n现在，让我们来看看这段代码中隐藏的多态之美！\n\n```java\nAnimal animal = new Dog();\nanimal.makeSound();  // 输出: \"Dog barks\"\n```\n\n在这段代码中，我们创建了一个Animal类型的引用变量animal，并将其指向一个Dog对象。这就是向上转型，让我们能够使用父类类型的引用来引用子类对象。\n\n当我们调用animal的makeSound()方法时，输出的却是\"Dog barks\"，而不是我们在Animal类中定义的\"Animal makes sound\"。这就是多态的奇妙之处！\n\n在编译时，编译器只知道animal的类型是Animal，因此它只能访问Animal类中定义的方法和属性。但在运行时，实际执行的却是Dog类中重写的makeSound()方法。这是因为Java的运行时系统会根据实际对象的类型来动态决定调用哪个类的方法。\n\n通过这种方式，我们可以根据实际对象的类型，在运行时决定调用哪个类的方法，实现了多态性。这种灵活性和可扩展性使我们能够编写更通用、灵活的代码，同时提高代码的可维护性和可复用性。\n\n掌握**继承、重写和向上转型**这三个必要条件，你就能够在面试中从容应对关于多态性的问题。多态性是面向对象编程中不可或缺的核心概念，它为我们打开了编程世界的大门。\n\n所以，别再为面试官的突袭问题而困惑了！现在，你已经揭开了多态的魔法，让多态性成为你的利器，展现你对Java编程的真正掌握！\n\n\n\n附图：\n\n![由一张图片引发的深思](https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202310160943256.png)\n\n","slug":"Polymorphism","published":1,"updated":"2023-11-15T09:22:02.276Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clpkiczit0012fkfofud29m9q","content":"<h1 id=\"Java多态揭秘：从疑惑到真正掌握！面试官的突袭问题让你茫然？解开多态的魔法！\"><a href=\"#Java多态揭秘：从疑惑到真正掌握！面试官的突袭问题让你茫然？解开多态的魔法！\" class=\"headerlink\" title=\"Java多态揭秘：从疑惑到真正掌握！面试官的突袭问题让你茫然？解开多态的魔法！\"></a>Java多态揭秘：从疑惑到真正掌握！面试官的突袭问题让你茫然？解开多态的魔法！</h1><blockquote>\n<p>无论是在课堂上、面试中还是与朋友交谈时，当被问到是否理解多态时，我们可能都感到无从下手。这时候，让我通过一个生动的例子，为你彻底解析多态的奥秘！在这个秋招季，面试官的提问可能让你措手不及。但别担心，让我们一起揭开这个问题，带你从茫然到彻底掌握！</p>\n</blockquote>\n<p>本文已发表在<code>CSDN</code>,<a href=\"http://t.csdnimg.cn/x02pb\">阅读链接</a></p>\n<h2 id=\"继承与重写\"><a href=\"#继承与重写\" class=\"headerlink\" title=\"继承与重写\"></a>继承与重写</h2><p>假设我们有一个Animal类，它有一个makeSound()方法，用于输出动物发出的声音。现在，我们再创建一个Dog类，继承自Animal类，并重写makeSound()方法，让它输出狗狗特有的吠声。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Animal</span> &#123;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">makeSound</span><span class=\"hljs-params\">()</span> &#123;<br>        System.out.println(<span class=\"hljs-string\">&quot;Animal makes sound&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Dog</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">Animal</span> &#123;<br>    <span class=\"hljs-meta\">@Override</span><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">makeSound</span><span class=\"hljs-params\">()</span> &#123;<br>        System.out.println(<span class=\"hljs-string\">&quot;Dog barks&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"向上转型\"><a href=\"#向上转型\" class=\"headerlink\" title=\"向上转型\"></a>向上转型</h2><p>现在，让我们来看看这段代码中隐藏的多态之美！</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-type\">Animal</span> <span class=\"hljs-variable\">animal</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Dog</span>();<br>animal.makeSound();  <span class=\"hljs-comment\">// 输出: &quot;Dog barks&quot;</span><br></code></pre></td></tr></table></figure>\n\n<p>在这段代码中，我们创建了一个Animal类型的引用变量animal，并将其指向一个Dog对象。这就是向上转型，让我们能够使用父类类型的引用来引用子类对象。</p>\n<p>当我们调用animal的makeSound()方法时，输出的却是”Dog barks”，而不是我们在Animal类中定义的”Animal makes sound”。这就是多态的奇妙之处！</p>\n<p>在编译时，编译器只知道animal的类型是Animal，因此它只能访问Animal类中定义的方法和属性。但在运行时，实际执行的却是Dog类中重写的makeSound()方法。这是因为Java的运行时系统会根据实际对象的类型来动态决定调用哪个类的方法。</p>\n<p>通过这种方式，我们可以根据实际对象的类型，在运行时决定调用哪个类的方法，实现了多态性。这种灵活性和可扩展性使我们能够编写更通用、灵活的代码，同时提高代码的可维护性和可复用性。</p>\n<p>掌握<strong>继承、重写和向上转型</strong>这三个必要条件，你就能够在面试中从容应对关于多态性的问题。多态性是面向对象编程中不可或缺的核心概念，它为我们打开了编程世界的大门。</p>\n<p>所以，别再为面试官的突袭问题而困惑了！现在，你已经揭开了多态的魔法，让多态性成为你的利器，展现你对Java编程的真正掌握！</p>\n<p>附图：</p>\n<p><img src=\"https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202310160943256.png\" alt=\"由一张图片引发的深思\"></p>\n","site":{"data":{}},"more":"<h1 id=\"Java多态揭秘：从疑惑到真正掌握！面试官的突袭问题让你茫然？解开多态的魔法！\"><a href=\"#Java多态揭秘：从疑惑到真正掌握！面试官的突袭问题让你茫然？解开多态的魔法！\" class=\"headerlink\" title=\"Java多态揭秘：从疑惑到真正掌握！面试官的突袭问题让你茫然？解开多态的魔法！\"></a>Java多态揭秘：从疑惑到真正掌握！面试官的突袭问题让你茫然？解开多态的魔法！</h1><blockquote>\n<p>无论是在课堂上、面试中还是与朋友交谈时，当被问到是否理解多态时，我们可能都感到无从下手。这时候，让我通过一个生动的例子，为你彻底解析多态的奥秘！在这个秋招季，面试官的提问可能让你措手不及。但别担心，让我们一起揭开这个问题，带你从茫然到彻底掌握！</p>\n</blockquote>\n<p>本文已发表在<code>CSDN</code>,<a href=\"http://t.csdnimg.cn/x02pb\">阅读链接</a></p>\n<h2 id=\"继承与重写\"><a href=\"#继承与重写\" class=\"headerlink\" title=\"继承与重写\"></a>继承与重写</h2><p>假设我们有一个Animal类，它有一个makeSound()方法，用于输出动物发出的声音。现在，我们再创建一个Dog类，继承自Animal类，并重写makeSound()方法，让它输出狗狗特有的吠声。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Animal</span> &#123;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">makeSound</span><span class=\"hljs-params\">()</span> &#123;<br>        System.out.println(<span class=\"hljs-string\">&quot;Animal makes sound&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Dog</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">Animal</span> &#123;<br>    <span class=\"hljs-meta\">@Override</span><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">makeSound</span><span class=\"hljs-params\">()</span> &#123;<br>        System.out.println(<span class=\"hljs-string\">&quot;Dog barks&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"向上转型\"><a href=\"#向上转型\" class=\"headerlink\" title=\"向上转型\"></a>向上转型</h2><p>现在，让我们来看看这段代码中隐藏的多态之美！</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-type\">Animal</span> <span class=\"hljs-variable\">animal</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Dog</span>();<br>animal.makeSound();  <span class=\"hljs-comment\">// 输出: &quot;Dog barks&quot;</span><br></code></pre></td></tr></table></figure>\n\n<p>在这段代码中，我们创建了一个Animal类型的引用变量animal，并将其指向一个Dog对象。这就是向上转型，让我们能够使用父类类型的引用来引用子类对象。</p>\n<p>当我们调用animal的makeSound()方法时，输出的却是”Dog barks”，而不是我们在Animal类中定义的”Animal makes sound”。这就是多态的奇妙之处！</p>\n<p>在编译时，编译器只知道animal的类型是Animal，因此它只能访问Animal类中定义的方法和属性。但在运行时，实际执行的却是Dog类中重写的makeSound()方法。这是因为Java的运行时系统会根据实际对象的类型来动态决定调用哪个类的方法。</p>\n<p>通过这种方式，我们可以根据实际对象的类型，在运行时决定调用哪个类的方法，实现了多态性。这种灵活性和可扩展性使我们能够编写更通用、灵活的代码，同时提高代码的可维护性和可复用性。</p>\n<p>掌握<strong>继承、重写和向上转型</strong>这三个必要条件，你就能够在面试中从容应对关于多态性的问题。多态性是面向对象编程中不可或缺的核心概念，它为我们打开了编程世界的大门。</p>\n<p>所以，别再为面试官的突袭问题而困惑了！现在，你已经揭开了多态的魔法，让多态性成为你的利器，展现你对Java编程的真正掌握！</p>\n<p>附图：</p>\n<p><img src=\"https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202310160943256.png\" alt=\"由一张图片引发的深思\"></p>\n"},{"title":"蓝桥杯","index_img":"https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311151627636.png","banner_img":"https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311151627628.png","abbrlink":48363,"date":"2023-05-11T04:23:11.000Z","_content":"\n# 第一章 基础数学思维与技巧\n\n## \t最大公约数\n\n#### 求最大公约数----欧几里得辗转相除法\n\n``` java\npublic static int gcd(int a,int b){\n   \twhile(b>0){\n        int temp = a%b;\n        a=b;\n        b=temp;\n    }\n    return a;\n}\n```\n\n```java\npublic static int gcd(int a,int b){\n    return b==0?a:gcd(b,a%b);\n}\n```\n\n## 最小公倍数\n\n#### 求最大公倍数\n\n``` java\npublic static int lcm(int a,int b){\n    return a * b / gcd(a,b);\n}\n```\n\n## 进制转换\n\n``` java\nString s = Integer.toString(a,m);//10进制a数转m进制数,结果为字符串\n\nint a = Integer.parseInt(s,m);//把字符串s当做m进制数,将结果转为10进制数\n\nBigInteger biginteger = new BigInteger(s,m);//把m进制的字符串s转换成10进制数后封装成大数对象\n```\n\n## 位运算\n\n### \t与 & (全1为1,有0为0)\n\n#### 判断奇偶数\n\n奇数-二进制最后一位一定为1\n偶数-二进制最后一位一定为0\n\n``` java\npublic static boolean check(int m){\n    return (m&1)==1;\n}\n```\n\n#### \t\t判断m是否为2的x次方\n\n若m为2的x次方:m的二进制只有最高位为1,其余全为0,(m-1)的二进制除最高位都为1.\n\n``` java\npublic static boolean check(int m){\n    return m&(m-1)==0;\n}\n```\n\n### \t异或 ^ (相同为0,不同为1)\n\n#### 找到数组中只出现了一次的数\n\n按位异或：相同为0，不同为1\n\n```java\nx^x=0;\n0^x=x;\na^b^c=a^c^b;\n\npublic static int num(int[] s){\n    int ans = 0;\n    for(int i=0;i<s.length;i++){\n        ans = ans ^ s[i];\n    }\n    return ans;\n}\n```\n\n\n\n### \t移位 >> 和<< \n\n```java\n8>>1 == 4\n4>>1 == 2\n    \n2<<1 == 4\n4<<1 == 8\n\nn >> m == n / (2 ^ m)\nn << m == n * (2 ^ m)\n```\n\n## 素数\n\n#### 判断素数\n\n素数:只有1和它本身是因数 。\n\n首先，0和1不是素数，然后 i 从 2 开始判断 i 是不是 n 的因数，如果是因数，则直接返回 n 不是素数，否则，判断 i+1是不是 n 的因数，直到 i=√n 的时候，如果 i 仍然不是 n 的因数，那么 n 就是素数。\n\n注：如果一个数 a 能够整除 i ，那么 i 和 a/i 一定满足：假设 i<=a/i , 那么 i<=√n , && a/i>= √n 。\n\n```java\npublic static boolean isprime(int n){\n    if(n==0 || n==1)\n        return false;\n    for(int i=2;i<=n/i;i++){\n        if(n%i==0)\n            return false;\n    }\n    return true;\n}\n```\n\n#### 求1~n中的所有素数----埃氏筛法\n\n思路：如果一个数不是素数，那么这个数一定是 n 个素数的乘积（0和1除外），同理，素数的 k 倍数一定是合数（k>=2）。\n\n```java\npublic static void isprime(int n){\n    boolean[] isprime = new boolean[n+1];//false表示素数，true表示合数\n    for(int i=2;i*i<=n;i++) \n        if(!isprime[i]) //i是质数\n            for(int j=2;j*i<=n;j++)//将i的倍数全部标记为合数\n                isprime[i*j] = true;\n    for(int i=2;i<=n;i++)\n        if(!isprime[i])\n            System.out.println(i);\n}\n```\n\n#### 求1~n中的所有素数----欧拉筛法\n\n思路：每个合数，只被他最小的质因子筛一次。\n\n注：与埃氏筛法不同，埃氏筛法是将素数的倍数，标记为合数；欧拉筛法是将目前已经找到的每一个素数的 i 倍标记为合数，无论 i 是否是素数，同时，如果 i 本身就是素数的倍数，那么就去执行下一个 i 。 \n\n```java\npublic static void isprime(int n){\n    boolean[] isprime = new boolean[n+1];\n    int[] prime = new int[n];//存储素数\n    int count = 0;//统计目前素数个数\n    for(int i=2;i<=n;i++) {\n        if(!isprime[i])  //i是质数\n            prime[count++] = i;//把当前素数存储到数组中count位置\n        for(int j=0;j<count && i*prime[j]<=n;j++){//将i的倍数全部标记为合数\n            isprime[i*prime[j]] = true;\n            if(i%prime[j]==0) break;//欧拉筛法精髓\n        }\n    }\n    for(int i=0;i<count;i++)\n        System.out.println(prime[i]);\n}\n```\n\n#### 例题：最小质因子之和\n\n题目链接：[最小质因子之和(Easy Version) - 蓝桥云课 (lanqiao.cn)](https://www.lanqiao.cn/problems/1151/learning/)\n\n![最小质因子之和题目描述](https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311182102197.png)\n\n思路：因为题目输入为T组数据，如果单独计算每组数据，则会有部分区间的数据被重复计算，所以先通过埃氏筛法，求出每一个数的最小质因子，将结果存放在 ans 数组中，然后将 ans 数组表示为前缀和数组，此时 ans 数组中的结果就为2~n的质因子之和，此时，题目若输入 15 ，则直接输出 ans[15] 即可。\n\n```java\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\n\npublic class 最小质因子之和 {\n\tstatic boolean[] isprime  = new boolean[3000001];//是否是素数\n\tstatic long[] ans = new long[3000001];//存储最小质因子 i的最小质因子为ans[i]，例：ans[4] = 2\n\tstatic BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\tstatic PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));\n\t\n\tpublic static void main(String[] args) throws IOException{\n\t\tget(3000000);//题目数据范围，N最大值为3*10^6，将2~3*10^6中每一个数的最小质因子全部求出\n\t\tfor(int i=2;i<=3000000;i++) {\n\t\t\tans[i] = ans[i] + ans[i-1];//求前缀和，此时ans[i]中存放的数就是2~i中每一个数的最小质因子的和\n\t\t}\n\t\tint n = Integer.parseInt(in.readLine());\n\t\twhile(n-->0) {\n\t\t\tout.println(ans[Integer.parseInt(in.readLine())]);\n\t\t}\n\t\tout.flush();\n\t}\n\t\n\t//找出每个数的质因子\n\tstatic void get(int n) {\n\t\tfor(int i=2;i<=n;i++) {\n\t\t\tif(isprime[i])//i不是质数直接跳过,不考虑,i不能作为筛除条件\n\t\t\t\tcontinue;\n\t\t\tans[i] = i;//i为素数，素数的最小质因子就是其本身\n\t\t\tfor(int j=2;j<=n/i;j++) {//j为倍数，将素数i的j倍数标记为合数，并将此数的最小质因子标记为i\n\t\t\t\tif(!isprime[j*i]) {//判断是否已经被标记过\n\t\t\t\t\tisprime[j*i] = true;//将i*j标记为合数\n\t\t\t\t\tans[j*i] = i;//j*i的最小质因子是i\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n```\n\n## 回文数\n\n#### 判断回文数\n\n思路：将数字转换为字符串类型后，将此字符串倒转后，判断与原字符串是否相同\n\n```java\npublic static boolean check(int m){\n    return Integer.toString(m).equals(new StringBuffer(Integer.toString(m)).reverse().toString());\n}\n```\n\n## 判断数组中元素是否相同\n\n思路：若数组中元素全部相同，则数组中的最大值应当==最小值。\n\n```java\npublic static boolean check(int[] n){\n    Arrays.sort(n);\n    return n[0]==n[n.length-1];\n}\n```\n\n思路：利用Set集合自动去重，将数组中所有元素全部添加到集合中后，如果集合中只有一个元素，则表示数组中所有元素全部相同。\n\n```java\npublic static boolean check(int[] n){\n    Set<Integer> set = new HashSet<>();\n    for(int i=0;i<n.length;i++) {\n        set.add(n[i]);\n    }\n    return set.size()==1;\n}\n```\n\n## 日期+星期模拟\n\n```java\npublic static Main{\n    static int[] date = {0,31,28,31,30,31,30,31,31,30,31,30,31};//存储每月天数\n    static int y = 2001,m = 1;d = 1,week = 1;//初始年,月,日,星期(根据题意选择是否需要)\n    //week==0,表示周日,week==1,表示周一 ... week==6,表示周六\n    public static void main(String[] args){\n        int ans = 0;//计数\n        while(y!=9999 || m!=12|| d!=31){//设置日期判断范围\n            //判断闰年(满足其一即可):\n            //1.可以整除400\n            //2.可以整除4但不能整除100\n            if(y%400==0 || (y%4==0&& y%100!=0) date[2] = 29;\n            else date[2] = 28;\n            if(check()) ans++;//满足条件,计数器++;\n            d++;\n            week++;\n            week%=7;\n            if(d>date[m]){\n                d = 1;\n                m++;\n            }\n            if(m>12){\n                m = 1;\n                y++;\n            }\n        }\n        if(check()) ans++;//之前结束日期并未判断,判断结束日期\n        System.out.println(ans);\n    }\n    public static boolean check(){}//根据题目要求完成\n}\n```\n\n## 约数\n\n#### 唯一分解定理\n\n![image-20231118203136873](https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311182102199.png)\n\n#### n的质因数个数----唯一分解定理\n\n```java\npublic static int num(long n){   \n    int ans = 0;    \n    for(int i=2;i<=n/i;i++){        \n        while(n%i==0){            \n            ans++;              \n            n/=i;        \n        }    \n    }    \n    if(n>1)        \n        ans++;    \n    return ans;\n}\n```\n\n#### n的约数个数----唯一分解定理\n\n```java\npublic static int num(int n){\n    int cnt = 1;//乘法初始值为1\n    int bak = n;//备份n\n    for(int i=2;i*i<=n;i++){\n        int sum = 0;\n        while(bak%i==0){\n            sum++;\n            bak = bak / i;\n        }\n        cnt = cnt * (sum + 1);\n    }\n    if(bak>1) cnt*=2;\n    return cnt;\n}\n```\n\n#### 求n!的约数个数----唯一分解定理\n\n```java\npublic static long num(int n){\n    int[] prime = new int[n+1];//prime[i]表示素数i这个因子出现的次数\n    for(int i=2;i<=n;i++){\n        int bak = i;\n        for(int j=2;j*j<=bak;j++){\n            int sum = 0;\n            while(bak%j==0){\n                prime[j]++;\n                bak = bak / j;\n            }\n    \t}\n    \tif(bak>1) prime[bak]++;\n    }\n    long ans = 1;\n    for(int i=2;i<=n;i++){\n        if(prime[i]>1)\n            ans = ans * (prime[i]+1);\n    }\n    return ans;\t\n}\n```\n\n#### 例题：数数\n\n题目链接：[数数 - 蓝桥云课 (lanqiao.cn)](https://www.lanqiao.cn/problems/2218/learning/)\n\n![image-20231118203219627](https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311182102200.png)\n\n思路：将这个区间中的每一个数都根据唯一分解定理进行拆分，统计有多少个数的拆分结果为12\n\n```java\nimport java.util.Scanner;\n\npublic class 数数 {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint ans = 0;\n\t\tfor(int i=2333333;i<=23333333;i++)\n\t\t\tif(num(i)==12)\n\t\t\t\tans++;\n\t\tSystem.out.println(ans);\n\t}\n\tstatic int num(int n) {\n\t\tint ans = 0;\n\t\tfor(int i=2;i<=n/i;i++) {\n\t\t\twhile(n%i==0) {\n\t\t\t\tn/=i;\n\t\t\t\tans++;\n\t\t\t}\n\t\t}\n\t\tif(n>1)\n\t\t\tans++;\n\t\treturn ans;\n\t}\n}\n\n```\n\n\n\n#### 例题：求阶乘\n\n题目链接：[求阶乘 - 蓝桥云课 (lanqiao.cn)](https://www.lanqiao.cn/problems/2145/learning/)\n\n![image-20231118203313070](https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311182102201.png)\n\n思路：\n\n​\t\t1.根据唯一分解定理可知：每一个数都可以写为 n 个素数的乘积；\n\n​\t\t2.如果一个数的结尾有 0 的存在，那么这个数分解后一定有 2 和 5 （素数中，只有2 * 5才能使结尾产生 0 ）； \n\n​\t\t3.从 1 ~ N ，将每一个数都分解后，2 的数量一定比 5 多（ 2 每隔两个数就会最少出现一个，5 每隔5个数，最少出现一个），那么，N！末尾 0 的数量，就是将 1 ~ N 中每个数分解后，5 的数量；\n\n​\t\t4.如果用一个循环从 5 开始，每次 +5 ，判断这些数可以拆分出几个 5 ，然后去找结尾有 k 个 0 的最小的 N 是多少，这个方法结果正确，但是时间复杂度会比较高，所以借助二分，去找到结尾有 k 个 0 的最小的 N 是多少；\n\n​\t\t5.用二分去查找，就必须做到：已知 N ，求出 1 ~ N 中可以拆分出多少个 5 ，以 125 为例，因为每五个数才拆分出 5 ，所以，如果 1~125 都只拆一个 5 ，则可以拆分出 125 / 5 共 25 个 5 ，拆分后的结果为 1 ~ 25 ，然后继续拆分 5 ，1 ~ 25 可以拆分出 25 / 5 个 5 ，拆分后结果为 1 ~ 5 ，1 ~ 5 可以拆分出 5 / 5 个 5 ，最后剩余 1 ，1 无法继续拆分出 5 ，所以 125 可以拆分出 25 + 5 + 1 = 31 个 5 ；\n\n​\t\t6.二分：如果mid拆分出的 5 的数量 >= k，那么可以 right = mid ，反之left = mid + 1，二分结果后，还需要判断它是否确实能拆分出 k 个 5 ，因为存在一个 N!  能恰好末尾有 k 个 0 ；\n\n```java\nimport java.util.Scanner;\n\npublic class 求阶乘 {\n\tpublic static long find(long x) {//求x能拆分出多少个5\n\t\tlong res = 0;\n\t\twhile(x != 0) {\n\t\t\tres = res + x / 5;\n\t\t\tx/=5;\n\t\t}\n\t\treturn res;\n\t}\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tlong k = sc.nextLong();\n\t\tlong l = 0,r = 100000;//防止溢出\n\t\twhile(l < r) {\n\t\t\tlong mid = (l + r) / 2;\n\t\t\tif(k <= find(mid)) {\n\t\t\t\tr = mid;\n\t\t\t}else {\n\t\t\t\tl = mid + 1;\n\t\t\t}\n\t\t}\n\t\tif(find(r) != k) {//确保有解\n\t\t\tSystem.out.println(-1);\n\t\t}else {\n\t\t\tSystem.out.println(r);\n\t\t}\n\t}\n}\n```\n\n\n\n# 第二章 字符串基础\n\n## 常用API\n\n```java\nString m = \"abcde\";\n\nchar ch = m.charAt(String n);//获取字符串m的第(n+1)个字符\nint length = m.length();//获取字符串m的长度\nboolean flag = m.equals(String n);//判断字符串m和n是否相等,严格区分大小写\nboolean flag = m.equalsIgnoreCase(String n);//判断字符串m和n是否相等,不区分大小写\nint len = m.index(String s);//返回字符串s在m中第一次出现的位置\nint compare = m.compareTo(String anotherString);//按字典序比较两个字符串,若compare>0,m大,若compare<0,m小\nString s = m.concat(n);//将字符串n拼接到字符串m的结尾\nboolean flag = m.contains(String n);//判断字符串m是否包含字符串n\nboolean flag = m.endsWith(String s);//判断字符串m是否以字符串s结尾\nString[] s = m.split(\" \");//根据正则表达式拆分字符串m\nString s = m.trim();//删除字符串m的前导空格和尾部空格\nString s = m.subString(int i,int j);//截取字符串m中下标为i至下标为j-1的部分,即[i,j);\n...\n```\n\n## 周期串\n\n思路：从 1 开始枚举周期 T 的大小，然后判断每个周期内的对应字符是否相同，如果不同，则直接判断下一个 T 。\n\n```java\npublic static int cycle(String s){\n    char[] ch = s.toCharArray();\n    int T;\n    for(T=1;T<=ch.length;T++){\n        if(ch.length%T==0){//周期串的长度一定是周期T的倍数\n            boolean flag = true;\n            for(int start = T;start<ch.length;start++){\n                if(ch[start]!=ch[start%T]){\n                    flag = false;\n                    break;\n                }\n            }\n            if(flag){\n                break;\n            }\n        }\n    }\n    return T;\n}\n```\n\n思路：pos 表示第二行的字符串向右移动的格数，如果移动后，第二行的字符串与第一行字符串对应位置的字符全部相同，则 pos 就是这个字符串的周期。\n\n![image-20231118203417476](https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311182102202.png)\n\n```java\npublic static int cycle(String s){\n\tString m = s+s;\n    int pos;\n    for(pos=1;pos<=s.length();pos++){\n        if(s.length()%pos!=0)\n            continue;\n        String x = m.substring(pos,pos+s.length());\n        if(x.equals(s))\n            break;\n    }\n    return pos;\n}\n```\n\n思路：如果一个字符串 sub 是字符串 s 的周期，那么将字符串 s 中所有的 sub 全部替换为空字符串之后，字符串的长度如果为 0 ，就表示字符串 sub 是字符串 s 的周期。\n\n```java\npublic static int cycle(String s){\n    for(int i=1;i<=s.length();i++){\n        if(s.length()%i==0){\n            String sub = s.substring(0,i);\n            if(s.replace(sub,\"\").length()==0)\n                return i;\n        }\n        \n    }\n    return 0;\n}\n```\n\n#### 例题：重复字符串\n\n题目链接：[重复字符串 - 蓝桥云课 (lanqiao.cn)](https://www.lanqiao.cn/problems/1049/learning/)\n\n![image-20231118203511964](https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311182102203.png)\n\n思路：已知重复次数为 K ，那么周期就是 S.length() / K ，然后只需要求出每一个周期的第 i 个字符，出现次数最多的字符是哪个，然后将其余字符全部改为它，那么就将 S 改为了重复 K 次的字符串，此时修改次数也是最少的。以abdcbbcaabca ， 重复 3 次为例：\n\n​\t\t将此字符串拆分为三个部分后，每个周期写在一行，结果为：\n\n​\t \t\tabdc\n​\t \t\tbbca\n​\t \t\tabca\n\n​\t\t只需要求出每一个竖列出现次数最多的字符出现的次数，然后将其余字符全部改为它，那么这一列修改次数为（K - max），然后将每一列的结果加起来，即为答案。\n\n```java\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\n\npublic class 重复字符串 {\n\n\tstatic BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\tstatic PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));\n\tpublic static void main(String[] args) throws IOException {\n\t\tint n = Integer.parseInt(in.readLine());\n\t\tString a = in.readLine();\n\t\tif(a.length()%n!=0 || n>a.length()) {\n\t\t\tSystem.out.println(-1);\n\t\t\treturn;\n\t\t}\n\t\tint t = a.length() / n;\n\t\tint index = 0;\n\t\tchar[][] ch = new char[n][t];\n\t\tfor(int i=0;i<n;i++) \n\t\t\tfor(int j=0;j<t;j++)\n\t\t\t\tch[i][j] = a.charAt(index++);\n\t\tint ans = 0;\n\t\tfor(int i=0;i<t;i++) {\n\t\t\tint[] num = new int[26];\n\t\t\tint max = 0;\n\t\t\tfor(int j=0;j<n;j++) {\n\t\t\t\tnum[ch[j][i]-'a']++;\n\t\t\t\tif(max<num[ch[j][i]-'a']) {\n\t\t\t\t\tmax = num[ch[j][i]-'a'];\n\t\t\t\t}\n\t\t\t}\n\t\t\tans = ans + (n-max);\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n}\n```\n\n# 第三章 排序\n\n## 冒泡排序\n\n思路：每一次循环将最大值 / 最小值放于向后移动。\n\n```jAVA\npublic static int[] sort(int[] a){\n    for(int i=0;i<a.length-1;i++){\n        for(int j=0;j<a.length-1-i;j++){\n            if(a[j]>a[j+1]){\n                int temp = a[j+1];\n                a[j+1] = a[j];\n                a[j] = temp;\n            }\n        }\n    }\n    return a;\n}\n```\n\n## 插入排序\n\n思路：第 i 趟，把第 i 个元素放到前 i - 1 个有序的序列中 。\n\n```java\npublic static int[] InsertSort(int[] a){\n    for(int i=1;i<a.length;i++){\n        int temp = a[i];//处理第i个元素\n        int j = i-1;\n        for(;j>=0 && a[j]>temp;j--){\n            a[j+1] = a[j];//大的元素往后移\n        }\n        a[j+1] = temp;\n    }\n    return a;\n}\n```\n\n## 选择排序\n\n思路：第 i 趟把从 i ~ 结尾最小的元素找到，放到 i 位置。\n\n```java\npublic static int[] SelectedSort(int[] a){\n    for(int i=0;i<a.length;i++){\n        int min = i;//存放i+1到最后最小的元素所在的下标\n     \tfor(int j=i+1;j<a.length;j++){\n            if(a[j]<a[min])\n                min = j;\n        }\n        int temp = a[i];\n        a[i] = a[min];\n        a[min] = temp;\n    }\n    return a;\n}\n```\n\n## 希尔排序\n\n思路：将排序的区间分成若干个有跨度的子区间，对每一个子区间，进行插入排序，跨度不断 / 2 ，最终当跨度为 1 的时候，进行一个插入排序。\n\n```java\npublic static int[] shell(int[] a){\n    for(int gap = a.length/2;gap>0;gap/=2){\n        //对每一分组进行直接插入排序\n        for(int i=gap;i<a.length;i++){\n            int j = i;\n            while(j-gap>=0 && a[j-gap]>a[j]){//大的往后移动\n                int temp = a[j];\n                a[j] = a[j-gap];\n                a[j-gap] = temp;\n                j = j-gap;//下一次继续从分组的前一个位置开始\n            }\n        }\n    }\n    return a;\n}\n```\n\n## 计数排序\n\n思路：找出数组中的最大值和最小值，每个数都是在 min 和 max 之间，用一个长度为（max - min + 1）的数组 c 来存储每一个数出现的次数，然后将数组 c 转换为前缀和数组，则 c[ i ]，就表示不大于（i+min）的元素的个数，按照 c 数组还原排序结果。\n\n```java\npublic static void countSort(int[] a){\n\tint[] b = new int[a.length];\n    int max = a[0];min = a[0];\n    for(int i=0;i<a.length;i++){\n        if(a[i]>max) max = a[i];\n        if(a[i]<min) min = a[i];\n    }\n    int dis = max - min + ;\n    int[] c = new int[dis];\n    for(int i=0;i<a.length;i++)\n        c[a[i]-min]++;\n    for(int i=1;i<c.length;i++)\n        c[i] = c[i] + c[i-1];\n    for(int i=a.length-1;i>=0;i--){\n        b[c[a[i]-min]-1] = a[i];\n        c[a[i]-min]--;\n    }\n    System.out.println(Arrays.toString(b));\n}\n```\n\n# 第四章 数据结构基础\n\n## 链表\n\n#### 为什么要用链表\n\n数组作为一个顺序储存方式的数据结构，可是有大作为的，它的灵活使用为我们的程序设计带来了大量的便利；但是，数组最大的缺点就是我们的插入和删除时需要移动大量的元素，所以呢，大量的消耗时间，以及冗余度难以接收。\n\n链表可以灵活地去解决这个问题，插入删除操作只需要修改指向的对象就可以了，不需要进行大量的数据移动操作。\n\n#### 单链表\n\n###### \t\t初始化\t\n\n```java\nstatic class Node{//定义结点类\n    int value;//本身的值\n    Node next;//指向下一个结点\n    public Node(int value, Node next) {\n        this.value = value;\n        this.next = next;\n    }\n}\n```\n\n```java\nNode head = new Node(-1,null);//头结点\nNode end = new Node(-1, null);//尾结点\nNode per = head;\nfor(int i=1;i<=10;i++) {\n    per.next = new Node(i, null);\n    per = per.next;\n}\nper.next = end;\n```\n\n###### \t\t插入\n\n​\t\t插入前：\n\n![image-20231118203551162](https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311182102205.png)\n\n​\t\t\t插入后：\n\n![image-20231118203544620](https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311182102206.png)\n\n```java\nNode now;//待插入结点\nnow.next = head.next;//此节点的next为插入位置上一个结点的下一个结点\nhead.next = now;//此节点位置的上一个结点的下一个结点为now\n```\n\n###### \t\t删除\n\n​\t\t删除前：\n\n![image-20231118203608364](https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311182102207.png)\n\n​\t\t删除后：\t\n\n![image-20231118203627478](https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311182102208.png)\t\t\n\n```java\nNode now;//待删除结点\nhead.next = now.next;\n```\n\n#### 双链表\n\n###### \t初始化\n\n```java\nstatic class N{\n    N last;\n    int value;\n    N next;\n    public N(N last, int value, N next) {\n        this.last = last;\n        this.value = value;\n        this.next = next;\n    }\n}\n```\n\n```java\nNode first = new Node(null,-1,null);//头结点\nNode end = new Node(null,-1, null);//尾节点\nNode per = first;\nfor(int i=1;i<=10;i++) {\n    per.next = new N(per,i, null);\n    per = per.next;\n}\nend.last = per;\nper.next = end;\n```\n\n###### \t插入\n\n​\t\t插入前：\n\n![image-20231118203704325](https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311182102209.png)\n\n​\t \t插入后：\n\n![image-20231118203719212](https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311182102210.png)\n\n```java\nNode now;//待插入结点\nnow.next = first.next;\nfirst.next.last = now;\nfirst.next = now;\nnow.last = first;\n```\n\n###### \t\t删除\n\n​\t\t删除前：\n\n![image-20231118203733885](https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311182102211.png)\n\n​\t\t删除后：\n\n![image-20231118203744884](https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311182102212.png)\n\n```java\nNode now;//待删除结点\nnow.last.next = now.next;\nnow.next.last = now.last;\n```\n\n#### 例题：左移右移（双链表解法）\n\n题目链接：[左移右移 - 蓝桥云课 (lanqiao.cn)](https://www.lanqiao.cn/problems/2219/learning/)\n\n![image-20231118203759075](https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311182102213.png)\n\n思路：\n\n​\t\t1.创建双链表并完成初始化，初始元素为 1 ~ n；\n\n​\t\t2.无论 x 左移或右移，都要先将 x 从原位置删除，为了便于获取 x 对应的 Node 结点，用 Map 存储 x 和 value 为 x 的结点；\n\n​\t\t3.如果 x 为左移，就将 x 对应的 Node 结点插入到头结点后；\n\n​\t\t4.如果 x 为右移，就将 x 对应的 Node 结点插入到尾节点前；\n\n```java\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class 左移右移_双链表 {\n\tstatic class Node{\n\t\tNode up;\n\t\tint value;\n\t\tNode down;\n\t\tpublic Node(Node up, int value, Node down) {\n\t\t\tthis.up = up;\n\t\t\tthis.value = value;\n\t\t\tthis.down = down;\n\t\t}\n\t}\n\tpublic static void main(String[] args) throws IOException{\n        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n        PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));\n        String[] s = in.readLine().split(\" \");\n        int n = Integer.parseInt(s[0]);\n        int m = Integer.parseInt(s[1]);\n        Map<Integer, Node> map = new HashMap<>();\n        Node first = new Node(null, -1, null);\n        Node last = new Node(null, -1, null);\n        Node no = first;\n        for(int i=1;i<=n;i++) {\n        \tno.down = new Node(no, i, null);\n        \tno = no.down;\n        \tmap.put(i, no);\n        }\n        last.up = no;\n        no.down = last;\n        for(int i=0;i<m;i++) {\n        \ts = in.readLine().split(\" \");\n        \tchar ch = s[0].charAt(0);\n        \tint x = Integer.parseInt(s[1]);\n        \tNode node = map.get(x);\n        \tnode.up.down = node.down;\n        \tnode.down.up = node.up;\n        \tif(ch=='L') {\n        \t\tnode.down = first.down;\n        \t\tfirst.down.up = node;\n        \t\tfirst.down = node;\n        \t\tnode.up = first;\n        \t}else {\n        \t\tnode.up = last.up;\n        \t\tlast.up.down = node;\n        \t\tnode.down = last;\n        \t\tlast.up = node;\n        \t}\n        }\n        no = first.down;\n        while(no!=last) {\n        \tSystem.out.print(no.value+\" \");\n        \tno = no.down; \n        }\n\t}\n}\n```\n\n## 栈\n\n#### 栈\n\n栈（Stack）：是只允许在一端进行插入或删除的线性表。首先栈是一种线性表，但限定这种线性表只能在某一端进行插入和删除操作。\n\n栈顶（Top）：线性表允许进行插入删除的那一端。\n\n栈底（Bottom）：固定的，不允许进行插入和删除的另一端。\n\n![image-20231118203841538](https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311182102214.png)\n\n#### 常用方法\n\n```java\nStack<Integer> stack = new Stack();\nboolean is = stack.isEmpty();//判断此栈是否为空\nint n = stack.peek();//获取栈顶的元素，但不删除\nint m = stacl.pop();//获取并删除栈顶的元素\nstack.push(10);//将10压入栈中\nstack.clear();//清空栈\n```\n\n#### 判断括号序列是否合法\n\n```java\npublic static boolean check(String s){\n    Stack<Character> stack = new Stack();\n    char[] ch = s.toCharArray();\n    for(int i=0;i<ch.length;i++){\n        if(ch[i]=='(')\n            stack.push(ch[i]);\n        else if(stack.isEmpty())\n            return false;\n        else\n            stack.pop();\n    }\n    return stack.isEmpty();\n}\n```\n\n\n\n## 队列\n\n#### 队列\n\n队列（queue）是一种先进先出的、操作受限的线性表。\n\n![image-20231118203904215](https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311182102215.png)\n\n队列这种数据结构非常容易理解，就像我们平时去超市买东西，在收银台结账的时候需要排队，先去排队的就先结账出去，排在后面的就后结账，有其他人再要过来结账，必须排在队尾不能在队中间插队。\n\n#### 常用方法\n\n```java\nQueue<Integer> queue = new LinkedList<>();\nqueue.peek();//获取队头元素，但不删除\nqueue.poll();//获取并删除队头元素\nqueue.clear();//清空队列\nqueue.push(11);//将11存放到队列中\n```\n\n#### 例题：左移右移（栈 + 队列解法）\n\n题目链接：[左移右移 - 蓝桥云课 (lanqiao.cn)](https://www.lanqiao.cn/problems/2219/learning/)\n\n![image-20231118203920958](https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311182102217.png)\n\n思路：\n\n​\t\t1.如果一个数先移动到最左边，再移动到最右边，那么最后输出的时候这个数一定是在最右边，也就是一个数最终出现在哪里，以他最后一次出现为准；\n\n​\t\t2.为了避免一个数重复判断，而且要以他最后一次出现时的 L 和 R 操作为最终操作，所以可以先将全部输入分别存放到 char 类型数组和 int 类型数组中，然后逆序判断，并且用一个数组来表示这个 x 有没有出现过；\n\n​\t\t3.因为要对输入做逆序操作，所以，逆序时最后出现的 L 对应的 x 在输出的最前面，然后之后出现的 L 对应的 x 依次输出，即先入先出，可以用队列来存储进行 L 操作的 x ；\n\n​\t\t4.逆序时最后出现的 R 对应的 x 在输出的最后面，然后之后出现的 R 对应的 x 依次在前，即后入先出，可以用栈来存储进行 R 操作的 x ；\n\n​\t\t5.输出时，先输出队列中的元素，然后将 1 ~ n 中没有出现过的值按序输出，最后输出栈中的元素；\n\n```java\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Stack;\n\npublic class 左移右移_栈_队列 {\n\n\tpublic static void main(String[] args) throws IOException{\n        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n        PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));\n        String[] s = in.readLine().split(\" \");\n        int n = Integer.parseInt(s[0]);\n        int m = Integer.parseInt(s[1]);\n        int[] a = new int[n+1];\n        char[] c = new char[m];\n        int[] x = new int[m];\n        for(int i=0;i<m;i++) {\n        \ts = in.readLine().split(\" \");\n            c[i] = s[0].charAt(0);\n            x[i] = Integer.parseInt(s[1]);\n        }\n        Stack<Integer> r = new Stack<>();\n        Queue<Integer> l = new LinkedList<>();\n        for(int i=m-1;i>=0;i--) {\n        \tif(a[x[i]]==0) {//判断x[i]是否出现过\n        \t\ta[x[i]] = 1;//若x[i]没有出现过\n        \t\tif(c[i]=='L')\n        \t\t\tl.add(x[i]);\n        \t\telse\n        \t\t\tr.push(x[i]);\n        \t}\n        }\n        while(l.size()!=0) //输出队列中元素\n        \tSystem.out.print(l.poll()+\" \");\n        for(int i=1;i<=n;i++) \n        \tif(a[i]==0) //a[i]为0，表示i没有出现过\n        \t\tSystem.out.print(i+\" \");\n        while(r.size()!=0) //输出栈中元素\n        \tSystem.out.print(r.pop()+\" \");\n\t}\n}\n```\n\n# 第五章 分治算法\n\n## 归并排序\n\n思路：先把数组从中间分成前后两部分，然后分别对前后两部分进行排序，再将排好序的两部分数据合并在一起\n\n```java\npublic static void mergeSort(int[] a,int left,int right){//待排序数组，要排序的范围[left,right]\n    int mid = (left+right)>>1;\n    if(left<right){\n        mergeSort(a,left,mid);\n        mergeSort(a,mid+1,right);\n        merge(a,left,mid,right);\n    }\n}\npublic static void merge(int[] a,int left,int mid,int right){\n    int[] temp = new int[right-left+1];//临时数组，用来归并\n    int i=left,j=mid+1,k=0;//左半段用i指向，右半段用j指向，temp数组用k指向\n    while(i<=mid && j<=right){\n        if(a[i]<a[j])\n            temp[k++] = a[i++];\n        else\n            temp[k++] = a[j++];   \n    }\n    while(i<=mid) temp[k++] = a[i++];\n    while(j<=right) temp[k++] = a[j++];\n    for(int x=0;x<temp.length;x++){\n        a[left+x] = temp[x];\n    }\n}\n```\n\n## 快速排序\n\n思路：\n\n(1)首先设定一个分界值，通过该分界值将数组分成左右两部分。 \n\n(2)将大于或等于分界值的数据集中到数组右边，小于分界值的数据集中到数组的左边。此时，左边部分中各元素都小于分界值，而右边部分中各元素都大于或等于分界值。 \n\n(3)然后，左边和右边的数据可以独立排序。对于左侧的数组数据，又可以取一个分界值，将该部分数据分成左右两部分，同样在左边放置较小值，右边放置较大值。右侧的数组数据也可以做类似处理。 \n\n(4)重复上述过程，可以看出，这是一个递归定义。通过递归将左侧部分排好序后，再递归排好右侧部分的顺序。当左、右两个部分各数据排序完成后，整个数组的排序也就完成了。\n\n```java\npublic static void quickSort(int[] a,int left,int right){\n    if(left>right) return;//区间擦肩而过，无效，不需要进行递归\n    int i=left,j=right,temp = a[left];//a[left]作为基准点\n    while(i!=j){\n        while(a[j]>=a[temp] && j>i)\n            j--;//只要a[j]大于基准点继续往前移动j\n        if(j>i)\n            a[i++] = a[j];\n        while(a[i]<=a[temp] && i<j)\n            i++;\n        if(i<j)\n            a[j--] = a[i];\n    }\n    a[i] = temp;//基准点元素放到最终位置\n    quickSort(a,left,i-1);\n    quickSort(a,i+1,right);\n}\n```\n\n\n\n## 快速幂\n\n思路：每一步都把指数分成两半，而相应的底数做平方运算。这样不仅能把非常大的指数给不断变小，所需要执行的循环次数也变小，而最后表示的结果却一直不会变。\n\n例：3^10^ = 3\\*3\\*3\\*3\\*3\\*3\\*3\\*3\\*3\\*3 ，尽量想办法把指数变小来，这里的指数为10。\n\n3^10^=(3\\*3)\\(3\\*3)(3\\*3)(3\\*3)(3\\*3)\n\n3^10^=(3*3)^5^\n\n3^10^=9^5^\n\n此时指数由10缩减一半变成了5，而底数变成了原来的平方，求3^10^原本需要执行10次循环操作，求9^5^却只需要执行5次循环操作，但是3^10^却等于9^5^,用一次（底数做平方操作）的操作减少了原本一半的循环量，特别是在幂特别大的时候效果非常好，例如2^10000^=4^5000^,底数只是做了一个小小的平方操作，而指数就从10000变成了5000，减少了5000次的循环操作。\n\n现在问题是如何把指数5变成原来的一半，5是一个奇数，5的一半是2.5，但是指数不能为小数，因此不能简单粗暴地直接执行5/2，然而，这里还有另一种方法能表示9^5^，9^5^=9^4^*9^1^\n\n此时抽出了一个底数的一次方，这里即为9^1^，这个9^1^先单独移出来,剩下的9^4^又能够在执行“缩指数”操作了，把指数缩小一半，底数执行平方操作。9^5^=81^2^*9^1^\n\n把指数缩小一半，底数执行平方操作，9^5^=6561^1^\\*9^1^\n\n此时，发现指数又变成了一个奇数1，按照上面对指数为奇数的操作方法，应该抽出了一个底数的一次方，这里即为6561^1^，这个6561^1^先单独移出来，但是此时指数却变成了0，也就意味着我们无法再进行“缩指数”操作了。\n\n9^5^=（6561^0^)(9^1^)(6561^1^)=1(9^1^)(6561^1^)=(9^1^)(6561^1^)=9*6561=59049\n\n能够发现，最后的结果是9*6561。所以能发现一个规律：最后求出的幂结果实际上就是在变化过程中所有当指数为奇数时底数的乘积。\n\n继续优化：\n\nb%2==1可以用更快的“位运算”来代替，例如：b&1。因为如果b为偶数，则其二进制表示的最后一位一定是0；如果b是奇数，则其二进制表示的最后一位一定是1。将他们分别与1的二进制做“与”运算，得到的就是b二进制最后一位的数字了，是0则为偶数，是1则为奇数。例如9是奇数，则9&1=1；而8是偶数，则8&1=0；因此奇偶数的判断就可以用“位运算”来替换了。\n\nm = m / 2也可以用更快的移位操作来代替，例如：6的四位二进制为0110，而6/2=3,3的四位二进制为0011，可以发现，a的一半，结果为a的二进制码向右移一位，即m >>=1。\n\n```java\npublic static long num(long n, long m, long p) {\n    long result = 1;\n    while (m > 0) {\n        if ((m & 1 ) == 1) {\n            result = result * n % p;\n        }\n        m >>= 1;\n        n = (n * n) % p;\n    }\n    return result;\n}\n```\n\n# 第六章 搜索\n\n## 全排列\n\n#### DFS解法\n\n思路：将此过程看做一棵树，每一个结点下都会有 n 个结点表示下一个数，首先先将全部 n^n^ 个结果全部得出，然后剪枝，减去有重复数字出现的情况。\n\n```java\npublic static void dfs(int depth,String ans,int n){//当前深搜的层数，目前的结果，目标层数\n    if(depth==n){//当前深搜层数=目标层数\n        System.out.println(ans);\n        return;\n    }\n    for(int i=1;i<=n;i++){\n    \tif(!ans.contains(i+\"\"))//只有当还没有用过i的时候，才会在现在的基础上继续往下拓展\n\t\t\tdfs(depth+1,ans+i;n);//进入下一层，ans记录为进入下一层的值，n不变\n    }\n}\n```\n\n#### BFS解法\n\n思路：先将有重复数字的结果得出，每一个数后都可以跟 n 中可能，那么将这 n 中可能存入队列中，然后重复此过程，直到字符串的长度为 n 时，得到结果；剪枝，如果这个数字已经用过了，就直接只用下一个数字。\n\n```java\npublic static void bfs(int n){\n    Queue<String> queue = new LinkedList<>();\n    for(int i=1;i<=n;i++)\n        queue.offer(i+\"\");\n    while(!queue.isEmpty()){\n        String now = queue.poll();\n        for(int i=1;i<=n;i++){//每个结点都向下产生n个结果\n            if(now.contains(i+\"\"))//i已经使用过了\n                continue;\n            String son = head + i;\n            if(son.length()==n)\n                System.out.println(son);\n            else\n                queue.offer(son);\n        }\n    }\n}\n```\n\n## 整数划分\n\n思路：对 n 进行划分后， n 可以被不超过 n 个数累加得到，进行累加的每一个数，也可以被不超过它本身个数累加得到。\n\n```java\npublic static void dfs(int n,int nowget,int max,String ans){//要划分的数，现在已经得到的值，目前划分已经用到的最大值，具体拆分方法\n    if(nowget==n){\n        ans = ans.substring(0,ans.length()-1);\n        System.out.println(n+\"=\"+ans);\n        return;\n    }\n    for(int i=1;i<=n-nowget;i++){//从nowget累加到n\n        if(i>=max)//只有当下一个数不小于我之前用过的最大值时，才能保证整个结果为非递减\n            dfs(n,nowget+i,i,ans+i+\"+\");\n    }\n}\n```\n\n## 例题\n\n#### 例题：路径之谜\n\n题目链接：[路径之谜 - 蓝桥云课 (lanqiao.cn)](https://www.lanqiao.cn/problems/89/learning/)\n\n![image-20231118204002349](https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311182102218.png)\n\n思路：\n\n​\t\t1.从入口点开始，到达每一个点都将对应位置北墙和西墙的箭靶数减一，每一个点，都可以继续向四个方向继续前进（前提是这个点没有走过，在城堡范围内，且这个点对应的两个箭靶的数字不为 0 ）。\n\n​\t\t2.如果已经到了终点，就要判断现在每一个箭靶上的数字是否都已经变为 0 ，如果是，那么此时走的路径就是正确解，否则就需要回溯，考虑其他的行走路线。\n\n​\t\t3.回溯：因为要从已经走过的点退回来，所以在已经走过的点上射的箭要收回，箭靶数加一，并且标记此点为还没有走过。\n\n```java\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\n\npublic class 路径之谜 {\n\tstatic int[] path;//记录最终路径，因为底面为n*n，所以走出需要2*n步\n\tstatic int n;\n\tstatic int[] cntx;//存储北墙箭靶数字\n\tstatic int[] cnty;//存储西墙箭靶数字\n\tstatic boolean[][] visited;//判断此点有没有走过\n\tstatic int dx[] = {1, 0, -1, 0};//到下一个点x坐标的变化量\n\tstatic int dy[] = {0, 1, 0, -1};//到下一个点y坐标的变化量\n\tstatic BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\tstatic PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));\n\tpublic static void main(String[] args) throws IOException {\n    \tn = Integer.parseInt(in.readLine());\n    \tcntx = new int[n];\n    \tcnty = new int[n];\n    \tpath = new int[n * n];\n    \tvisited = new boolean[n][n];\n    \tString[] s = in.readLine().split(\" \");\n    \tfor (int i = 0; i < n; i++) {\n    \t\tcntx[i] = Integer.parseInt(s[i]);\n    \t}\n    \ts = in.readLine().split(\" \");\n    \tfor (int i = 0; i < n; i++) {\n    \t\tcnty[i] = Integer.parseInt(s[i]);\n    \t}\n    \tdfs(0, 0, 0);//从0,0位置开始走,目前走了0步\n  }\n\tprivate static void dfs(int x, int y, int step) {\n\t\tpath[step] = y * n + x; //将该点编号记录到路径中\n\t\tvisited[x][y] = true;//将该点标记为已经走过的状态\n\t\tcntx[x]--;//拔掉对应北墙的箭\n\t\tcnty[y]--;//拔掉对应西墙的箭\n\t\tif (x == n - 1 && y == n - 1 && check()){//判断是否到达终点\n\t\t\tfor (int i = 0; i <= step; i++){//输出答案\n\t\t\t\tSystem.out.print(path[i]+\" \");\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tfor (int i = 0; i < 4; i++){//上下左右四个方向搜索下一步\n\t\t\tint xx = x + dx[i], yy = y + dy[i];\n             //下一步(xx,yy)未走过且在地图范围内\n\t\t\tif (0 <= xx && xx <= n-1 && yy >= 0 && yy <= n-1&& !visited[xx][yy] ){\n\t\t\t\tif (cntx[xx] > 0 && cnty[yy] > 0){//该点对应箭靶上有箭，说明该点可以走\n\t\t\t\t\tdfs(xx, yy, step + 1);//搜索下一步\n                    //要从xx,yy点回来,在xx,yy点射的箭要复原，并重新标记xx,yy点没有走过\n\t\t\t\t\tvisited[xx][yy] = false;\n\t\t\t\t\tcntx[xx]++;\n\t\t\t\t\tcnty[yy]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprivate static boolean check() {//判断到达终点时,是否箭靶数都已经归零\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (cntx[i] != 0 || cnty[i] != 0)\n\t\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n}\n```\n\n#### 例题：迷宫\n\n题目链接：[迷宫 - 蓝桥云课 (lanqiao.cn)](https://www.lanqiao.cn/problems/602/learning/)\n\n![image-20231118204041308](https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311182102219.png)\n\n思路：从起点开始，将从此点能到达的点存储到队列中，每次获取并删除队列中的第一个元素，并将其能到达且还未到达过的点（若此点已经到达过，则表示当前处理的这条路径不是最短路径）存储到队列中，若已经到达终点，则此路径为最短路径。如果队列中已经没有元素，但仍未到达迷宫终点，则表示此迷宫无解\n\n```java\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.util.LinkedList;\nimport java.util.Queue;\n\npublic class 迷宫 {\n\tstatic int num;//存储迷宫最短路径所需要的步数\n\tstatic int xsize = 30;//迷宫大小30行50列\n\tstatic int ysize = 50;\n\tstatic char[][] arr = new char[xsize][ysize];//存储迷宫：0表示路，1表示墙\n\tstatic boolean[][] help = new boolean[xsize][ysize];//判断此点是否已经做过\n\tstatic int[][] dir = {{1,0},{0,-1},{0,1},{-1,0}};//四个方向横纵坐标的变化量\n\tstatic char[] sign = {'D','L','R','U'};//表示四个方向\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\t\tPrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));\n\t\tfor(int i=0;i<xsize;i++){\n\t\t\tarr[i] = in.readLine().toCharArray();\n\t\t}\n\t\tout.println(bfs());\n\t\tout.print(num);//额外输出最短路径需要多少步\n\t\tout.flush();\n\t}\n\tprivate static String bfs() {\n\t\tQueue<Node> list = new LinkedList<>();//队列\n\t\tint x = 0;\n\t\tint y = 0;\n\t\tint runnum = 0;\n\t\tlist.add(new Node(x,y,\"\",runnum));//将起点存储到队列中\n\t\twhile(!list.isEmpty()){//判断队列是否为空，若为空，则此迷宫没有通路\n\t\t\tNode now = list.poll();//获取队列中的第一个元素并删除\n\t\t\thelp[now.x][now.y] = true;//将此点标记为已经走过\n\t\t\tfor(int i=0;i<4;i++){//循环四次，对四个方向进行处理\n\t\t\t\tint xx = now.x + dir[i][0];//移动后的x坐标\n\t\t\t\tint yy = now.y + dir[i][1];//移动后的y坐标\n                  //此点在迷宫范围内，未走过，不是墙\n\t\t\t\tif(check(xx,yy) && help[xx][yy]==false && arr[xx][yy]=='0'){\n\t\t\t\t\tlist.add(new Node(xx,yy,now.num + sign[i],now.runnum + 1));//将此点存入队列中\n\t\t\t\t\tif(xx==xsize-1 && yy==ysize-1){//如果已经到了迷宫终点\n\t\t\t\t\t\tnum = now.runnum + 1;//所需步数+1（now.runnum是到达迷宫终点前一步所需要的步数）\n\t\t\t\t\t\treturn now.num + sign[i];//返回通过迷宫的方式\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn \"\";//空字符串，表示此迷宫无通路\n\t}\n\tprivate static boolean check(int xx, int yy) {//判断此点是否在迷宫范围内\n\t\treturn xx>=0 && yy>=0 && xx<xsize && yy<ysize;\n\t}\n\tstatic class Node{\n\t\tint x;//x坐标\n\t\tint y;//y坐标\n\t\tint runnum;//到达此点最短步数\n\t\tString num;//到达此点的方式\n\t\tpublic Node(int x, int y,String num ,int runnum) {\n\t\t\tsuper();\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.num = num;\n\t\t\tthis.runnum = runnum;\n\t\t}\n\t}\n}\n```\n\n# 第七章 贪心\n\n## 基本概念\n\n所谓贪心算法是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，它所做出的仅仅是在某种意义上的局部最优解。\n贪心算法没有固定的算法框架，算法设计的关键是贪心策略的选择。必须注意的是，贪心算法不是对所有问题都能得到整体最优解，选择的贪心策略必须具备无后效性（即某个状态以后的过程不会影响以前的状态，只与当前状态有关。\n\n## 例题\n\n#### 例题：合并果子\n\n题目链接：[合并果子 - 蓝桥云课 (lanqiao.cn)](https://www.lanqiao.cn/problems/741/learning/)\n\n![image-20231118204125650](https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311182102220.png)\n\n思路：\n\n​\t\t1.要保证最终耗费的体力最小，那么就可以每次合并都把目前数量最少的两堆果子合并，耗费的体力就是这两堆果子树木的和，然后合并后又可以作为新的一堆果子继续去判断，直到最终只剩一堆。\n\n​\t\t2.可以借助PriorityQueue优先队列，队列中第一个元素就是最小值，即可每次获取队列中前两个元素，然后将他们的和再次添加至队列中，直到最终队列中只剩一个元素。\n\n​\t\t3.以题目样例为例：对于数组{pi}={1, 2, 9}，Huffman树的构造过程如下：\n\n​\t\t\t3.1找到{1, 2, 9}中最小的两个数，分别是 1 和 2 ，\n\n​\t\t\t3.2从{pi}中删除它们并将和 3 加入，得到{3, 9}，体力消耗为 3 。\n\n​\t\t\t3.3找到{3， 9}中最小的两个数，分别是 3 和 9 ，\n\n​\t\t\t3.4从{pi}中删除它们并将和 12 加入，得到{12}，费用为 12 。\n\n​\t\t\t3.5现在，数组中只剩下一个数12，构造过程结束，总费用为3 + 12 = 15。\n\n```java\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\nimport java.util.Spliterator;\n\npublic class Main {\n\n    public static void main(String[] args) throws IOException{\n        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n        PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));\n        int n = Integer.parseInt(in.readLine());\n        long sum = 0;\n        PriorityQueue<Long> queue = new PriorityQueue<>();\n        String[] s = in.readLine().split(\" \");\n        for(int i=0;i<s.length;i++) {\n            queue.add(Long.parseLong(s[i]));\n        }\n        long number = 0;\n        while(queue.size()!=1) {\n            long a = queue.poll();//获取最小的一堆\n            long b = queue.poll();//获取最小的一堆\n            number = number + ( a + b );//合并这两堆耗费的体力\n            queue.add((a+b));//将合并后的结果放回优先队列中\n        }\n        System.out.println(number);\n    }\n}\n```\n\n# 第八章 树\n\n## 树的相关概念\n\n#### 什么是树\n\n树(Tree)是 n ( n ≧ 0 )个结点的有限集。n=0时称为空树。在任意一颗非空树中：有且仅有一个特定的称为根的结点。当n>1时，其余结点可分为 m ( m > 0 ) 个互不相交的有限集T1、T2、T3……、Tm，其中每个集合本身又是一棵树，并且称为根的子树。\n\n#### 树的基本概念\n\n![image-20231118204210164](https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311182102221.png)\n\n## 二叉树\n\n#### 什么是二叉树\n\n二叉树是n(n>=0)个结点的有限集合，该集合或者为空集（空二叉树）、或者由一个根结点和两颗互不相交的、分别称为根结点的左子树和右子树的二叉树组成。\n\n#### 二叉树的特点\n\n​\t\t1.二叉树中每个结点最多有两颗子树，度没有超过2的。\n\n​\t\t2.左子树和右子树是有顺序的，不能颠倒。\n\n#### 满二叉树\n\n在二叉树中，所有的分支节点都有左子树和右子树，并且所有的叶子都在同一层。\n\n#### 完全二叉树\n\n​\t\t1.叶子结点只能出现在最下面两层。\n\n​\t\t2.最下层的叶子一定集中在左部连续位置。\n\n​\t\t3.倒数第二层，若有叶子结点，一定在右部连续位置。\n\n​\t\t4.如果结点度为1，则该结点只有左孩子。\n\n​\t\t5.同样结点的二叉树，完全二叉树的深度最小。\n\n## 二叉树的创建和嵌套打印\n\n```java\n//结点类\npublic class TreeNode{\n    int data;//结点存放的数据\n    TreeNode left;//左孩子\n    TreeNode right;//右孩子\n    public TreeNode(int data,TreeNode left,TreeNOde right){\n        this.data = data;\n        this.left = left;\n        this.right = right;\n    }\n}\n```\n\n```java\nimport java.util.Scanner;\npublic class Tree{\n    TreeNode root;//整棵树的根节点\n    Scanner sc = new Scanner(System.in);\n    public Tree(){\n        root = null;\n    }\n    public TreeNode createBinaryTree(){//树的创建\n        TreeNode t;//当前树的根节点\n        int x = sc.nextInt();\n        if(x==0) t=null;\n        else{\n            t = new TreeNode();\n            t.data = x;\n            t.left = createBinaryTree();\n            t.right = createBinaryTree();\n        }\n        return t;\n    }\n    public void printTree(TreeNode t){//树的打印\n        if(t!=null){\n            System.out.print(t.data);\n            if(t.left!=null || t.right!=null){\n                System.out.print(\"(\");\n                printTree(t.left);\n                if(t.right!=null) System.out.print(\",\");\n                printTree(t.left);\n                System.out.print(\")\");\n            }\n        }\n    }\n}\n```\n\n## 前中后序层次遍历\n\n#### 前序遍历\n\n思路：对于每个结点，优先处理结点本身，再处理它的左孩子，最后处理它的右孩子。\n\n```java\npublic void preOrder(TreeNode root){\n    if(root!=null){\n        System.out.print(root.data+\" \");\n        preOrder(root.left);\n        preOrder(root.right);\n    }\n}\n```\n\n#### 中序遍历\n\n思路：对于每个结点，优先处理它的左孩子，再处理它本身，最后处理它的右孩子。\n\n```java\npublic void midOrder(TreeNode root){\n    if(root!=null){\n        midOrder(root.left);\n        System.out.print(root.data+\" \");\n        midOrder(root.right);\n    }\n}\n```\n\n#### 后序遍历\n\n思路：对于每个结点，优先处理它的左节点，再处理它的右节点，最后处理它本身。\n\n```java\npublic void postOrder(TreeNode root){\n    if(root!=null){\n        postOrder(root.left);\n       \tpostOrder(root.right);\n        System.out.print(root.data+\" \");\n    }\n}\n```\n\n#### 层次遍历\n\n思路：广度优先搜索；处理根节点的每一个子结点，再处理子结点的每一个子结点......直至结束。\n\n```java\npublic void levelOrder(TreeNode t){\n    Queue<TreeNode> queue = new LinkedList<>();\n    if(t==null) return;\n    queue.offer(t);\n    while(!queue.isEmpty()){\n        TreeNode head = queue.poll();\n        System.out.print(head.data);\n        if(head.left!=null)\n        \tqueue.offer(head.left);\n        if(head.right!=null)\n        \tqueue.offer(head.right);\n    }\n}\n```\n\n## 求二叉树深度\n\n```java\npublic int treeDepth(TreeNode root){\n    if(root==null) return 0;//此结点不存在\n    return Math.max(treeDepth(root.left),treeDepth(root.right))+1;\n}\n```\n\n## 求二叉树叶子结点个数\n\n```java\npublic int TreeLeaf(TreeNode root){\n    if(root==null) return 0;\n    if(root.left==null && root.right==null) return 1;//此结点没有孩子，表示此结点为叶子结点\n    else return treeLeaf(root.left) + treeLeaf(root.right);\n}\n```\n\n## 重建二叉树\n\n思路：\n\n​\t\t1.前序遍历为：根，{左子树}，{右子树}；可得，前序遍历的第一个结点为根结点；\n\n​\t\t2.中序遍历为：{左子树}，根，{右子树}；可得，结点的左侧为它的左孩子树，右侧为它的右孩子树；\n\n​\t\t3.重复此过程，重建此二叉树；\n\n```java\npublic static String f(String pre,String mid){//前序遍历结果，中序遍历结果\n    if(pre.length()==0) return \"\";\n    else if(pre.length==1) return pre;\n    else{\n        int pos = mid.indexOf(pre.charAt(0));\n        String left = f(pre.substring(1,pos+1),mid.substring(0,pos));\n        String right = f(pre.substring(pos+1),mid.substring(pos+1));\n        return left+right+pre.charAt(0);\n    }\n}\n```\n\n# 第九章 图\n\n# 第十章 动态规划\n\n#### LCS 最长公共子序列\n\n思路：\n\n​\t\t1.用一个数组 dp\\[ i ]\\[ j ] 表示 S 字符串中前 i 个字符与 T 字符串中前 j 个字符的最长上升子序列，那么 dp\\[ i+1 ]\\[ j+1 ] 就是S 字符串中前 i+1 个字符与 T 字符串中前 j+1 个字符的最长上升子序列；\n\n​\t\t2.如果此时 S 中的第 i+1 个字符与 T 中的第 j+1 个字符相同，那么 dp\\[ i+1 ]\\[ j+1 ] = dp\\[ i ]\\[ j ] + 1;\n\n​\t\t3.如果此时 S 中的第 i+1 个字符与 T 中的第 j+1 个字符不同，那么 dp\\[ i+1 ]\\[ j+1 ] = Math.max ( dp\\[ i+1 ]\\[ j ] , dp\\[ i ]\\[ j+1 ] );\n\n```java\npublic static int LCS(String s,String t){\n    int[][] dp=new int[s.length()+1][t.length()+1];\n    for(int i=1;i<=s.length();i++){\n        for(int j=1;j<=t.length();j++){\n            if(s.charAt(i-1)==t.charAt(j-1))\n                dp[i][j]=dp[i-1][j-1]+1;\n            else\n                dp[i][j]=Math.max(dp[i][j-1],dp[i-1][j]);\n        }\n    }\n    return dp[len1][len2];\n}\n```\n\n","source":"_posts/MyLanqiaoNote.md","raw":"---\ntitle: 蓝桥杯\nindex_img: https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311151627636.png\nbanner_img: https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311151627628.png\ncategories:\n  - 算法\ntags:\n  - 蓝桥杯\nabbrlink: 48363\ndate: 2023-05-11 12:23:11\n---\n\n# 第一章 基础数学思维与技巧\n\n## \t最大公约数\n\n#### 求最大公约数----欧几里得辗转相除法\n\n``` java\npublic static int gcd(int a,int b){\n   \twhile(b>0){\n        int temp = a%b;\n        a=b;\n        b=temp;\n    }\n    return a;\n}\n```\n\n```java\npublic static int gcd(int a,int b){\n    return b==0?a:gcd(b,a%b);\n}\n```\n\n## 最小公倍数\n\n#### 求最大公倍数\n\n``` java\npublic static int lcm(int a,int b){\n    return a * b / gcd(a,b);\n}\n```\n\n## 进制转换\n\n``` java\nString s = Integer.toString(a,m);//10进制a数转m进制数,结果为字符串\n\nint a = Integer.parseInt(s,m);//把字符串s当做m进制数,将结果转为10进制数\n\nBigInteger biginteger = new BigInteger(s,m);//把m进制的字符串s转换成10进制数后封装成大数对象\n```\n\n## 位运算\n\n### \t与 & (全1为1,有0为0)\n\n#### 判断奇偶数\n\n奇数-二进制最后一位一定为1\n偶数-二进制最后一位一定为0\n\n``` java\npublic static boolean check(int m){\n    return (m&1)==1;\n}\n```\n\n#### \t\t判断m是否为2的x次方\n\n若m为2的x次方:m的二进制只有最高位为1,其余全为0,(m-1)的二进制除最高位都为1.\n\n``` java\npublic static boolean check(int m){\n    return m&(m-1)==0;\n}\n```\n\n### \t异或 ^ (相同为0,不同为1)\n\n#### 找到数组中只出现了一次的数\n\n按位异或：相同为0，不同为1\n\n```java\nx^x=0;\n0^x=x;\na^b^c=a^c^b;\n\npublic static int num(int[] s){\n    int ans = 0;\n    for(int i=0;i<s.length;i++){\n        ans = ans ^ s[i];\n    }\n    return ans;\n}\n```\n\n\n\n### \t移位 >> 和<< \n\n```java\n8>>1 == 4\n4>>1 == 2\n    \n2<<1 == 4\n4<<1 == 8\n\nn >> m == n / (2 ^ m)\nn << m == n * (2 ^ m)\n```\n\n## 素数\n\n#### 判断素数\n\n素数:只有1和它本身是因数 。\n\n首先，0和1不是素数，然后 i 从 2 开始判断 i 是不是 n 的因数，如果是因数，则直接返回 n 不是素数，否则，判断 i+1是不是 n 的因数，直到 i=√n 的时候，如果 i 仍然不是 n 的因数，那么 n 就是素数。\n\n注：如果一个数 a 能够整除 i ，那么 i 和 a/i 一定满足：假设 i<=a/i , 那么 i<=√n , && a/i>= √n 。\n\n```java\npublic static boolean isprime(int n){\n    if(n==0 || n==1)\n        return false;\n    for(int i=2;i<=n/i;i++){\n        if(n%i==0)\n            return false;\n    }\n    return true;\n}\n```\n\n#### 求1~n中的所有素数----埃氏筛法\n\n思路：如果一个数不是素数，那么这个数一定是 n 个素数的乘积（0和1除外），同理，素数的 k 倍数一定是合数（k>=2）。\n\n```java\npublic static void isprime(int n){\n    boolean[] isprime = new boolean[n+1];//false表示素数，true表示合数\n    for(int i=2;i*i<=n;i++) \n        if(!isprime[i]) //i是质数\n            for(int j=2;j*i<=n;j++)//将i的倍数全部标记为合数\n                isprime[i*j] = true;\n    for(int i=2;i<=n;i++)\n        if(!isprime[i])\n            System.out.println(i);\n}\n```\n\n#### 求1~n中的所有素数----欧拉筛法\n\n思路：每个合数，只被他最小的质因子筛一次。\n\n注：与埃氏筛法不同，埃氏筛法是将素数的倍数，标记为合数；欧拉筛法是将目前已经找到的每一个素数的 i 倍标记为合数，无论 i 是否是素数，同时，如果 i 本身就是素数的倍数，那么就去执行下一个 i 。 \n\n```java\npublic static void isprime(int n){\n    boolean[] isprime = new boolean[n+1];\n    int[] prime = new int[n];//存储素数\n    int count = 0;//统计目前素数个数\n    for(int i=2;i<=n;i++) {\n        if(!isprime[i])  //i是质数\n            prime[count++] = i;//把当前素数存储到数组中count位置\n        for(int j=0;j<count && i*prime[j]<=n;j++){//将i的倍数全部标记为合数\n            isprime[i*prime[j]] = true;\n            if(i%prime[j]==0) break;//欧拉筛法精髓\n        }\n    }\n    for(int i=0;i<count;i++)\n        System.out.println(prime[i]);\n}\n```\n\n#### 例题：最小质因子之和\n\n题目链接：[最小质因子之和(Easy Version) - 蓝桥云课 (lanqiao.cn)](https://www.lanqiao.cn/problems/1151/learning/)\n\n![最小质因子之和题目描述](https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311182102197.png)\n\n思路：因为题目输入为T组数据，如果单独计算每组数据，则会有部分区间的数据被重复计算，所以先通过埃氏筛法，求出每一个数的最小质因子，将结果存放在 ans 数组中，然后将 ans 数组表示为前缀和数组，此时 ans 数组中的结果就为2~n的质因子之和，此时，题目若输入 15 ，则直接输出 ans[15] 即可。\n\n```java\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\n\npublic class 最小质因子之和 {\n\tstatic boolean[] isprime  = new boolean[3000001];//是否是素数\n\tstatic long[] ans = new long[3000001];//存储最小质因子 i的最小质因子为ans[i]，例：ans[4] = 2\n\tstatic BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\tstatic PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));\n\t\n\tpublic static void main(String[] args) throws IOException{\n\t\tget(3000000);//题目数据范围，N最大值为3*10^6，将2~3*10^6中每一个数的最小质因子全部求出\n\t\tfor(int i=2;i<=3000000;i++) {\n\t\t\tans[i] = ans[i] + ans[i-1];//求前缀和，此时ans[i]中存放的数就是2~i中每一个数的最小质因子的和\n\t\t}\n\t\tint n = Integer.parseInt(in.readLine());\n\t\twhile(n-->0) {\n\t\t\tout.println(ans[Integer.parseInt(in.readLine())]);\n\t\t}\n\t\tout.flush();\n\t}\n\t\n\t//找出每个数的质因子\n\tstatic void get(int n) {\n\t\tfor(int i=2;i<=n;i++) {\n\t\t\tif(isprime[i])//i不是质数直接跳过,不考虑,i不能作为筛除条件\n\t\t\t\tcontinue;\n\t\t\tans[i] = i;//i为素数，素数的最小质因子就是其本身\n\t\t\tfor(int j=2;j<=n/i;j++) {//j为倍数，将素数i的j倍数标记为合数，并将此数的最小质因子标记为i\n\t\t\t\tif(!isprime[j*i]) {//判断是否已经被标记过\n\t\t\t\t\tisprime[j*i] = true;//将i*j标记为合数\n\t\t\t\t\tans[j*i] = i;//j*i的最小质因子是i\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n```\n\n## 回文数\n\n#### 判断回文数\n\n思路：将数字转换为字符串类型后，将此字符串倒转后，判断与原字符串是否相同\n\n```java\npublic static boolean check(int m){\n    return Integer.toString(m).equals(new StringBuffer(Integer.toString(m)).reverse().toString());\n}\n```\n\n## 判断数组中元素是否相同\n\n思路：若数组中元素全部相同，则数组中的最大值应当==最小值。\n\n```java\npublic static boolean check(int[] n){\n    Arrays.sort(n);\n    return n[0]==n[n.length-1];\n}\n```\n\n思路：利用Set集合自动去重，将数组中所有元素全部添加到集合中后，如果集合中只有一个元素，则表示数组中所有元素全部相同。\n\n```java\npublic static boolean check(int[] n){\n    Set<Integer> set = new HashSet<>();\n    for(int i=0;i<n.length;i++) {\n        set.add(n[i]);\n    }\n    return set.size()==1;\n}\n```\n\n## 日期+星期模拟\n\n```java\npublic static Main{\n    static int[] date = {0,31,28,31,30,31,30,31,31,30,31,30,31};//存储每月天数\n    static int y = 2001,m = 1;d = 1,week = 1;//初始年,月,日,星期(根据题意选择是否需要)\n    //week==0,表示周日,week==1,表示周一 ... week==6,表示周六\n    public static void main(String[] args){\n        int ans = 0;//计数\n        while(y!=9999 || m!=12|| d!=31){//设置日期判断范围\n            //判断闰年(满足其一即可):\n            //1.可以整除400\n            //2.可以整除4但不能整除100\n            if(y%400==0 || (y%4==0&& y%100!=0) date[2] = 29;\n            else date[2] = 28;\n            if(check()) ans++;//满足条件,计数器++;\n            d++;\n            week++;\n            week%=7;\n            if(d>date[m]){\n                d = 1;\n                m++;\n            }\n            if(m>12){\n                m = 1;\n                y++;\n            }\n        }\n        if(check()) ans++;//之前结束日期并未判断,判断结束日期\n        System.out.println(ans);\n    }\n    public static boolean check(){}//根据题目要求完成\n}\n```\n\n## 约数\n\n#### 唯一分解定理\n\n![image-20231118203136873](https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311182102199.png)\n\n#### n的质因数个数----唯一分解定理\n\n```java\npublic static int num(long n){   \n    int ans = 0;    \n    for(int i=2;i<=n/i;i++){        \n        while(n%i==0){            \n            ans++;              \n            n/=i;        \n        }    \n    }    \n    if(n>1)        \n        ans++;    \n    return ans;\n}\n```\n\n#### n的约数个数----唯一分解定理\n\n```java\npublic static int num(int n){\n    int cnt = 1;//乘法初始值为1\n    int bak = n;//备份n\n    for(int i=2;i*i<=n;i++){\n        int sum = 0;\n        while(bak%i==0){\n            sum++;\n            bak = bak / i;\n        }\n        cnt = cnt * (sum + 1);\n    }\n    if(bak>1) cnt*=2;\n    return cnt;\n}\n```\n\n#### 求n!的约数个数----唯一分解定理\n\n```java\npublic static long num(int n){\n    int[] prime = new int[n+1];//prime[i]表示素数i这个因子出现的次数\n    for(int i=2;i<=n;i++){\n        int bak = i;\n        for(int j=2;j*j<=bak;j++){\n            int sum = 0;\n            while(bak%j==0){\n                prime[j]++;\n                bak = bak / j;\n            }\n    \t}\n    \tif(bak>1) prime[bak]++;\n    }\n    long ans = 1;\n    for(int i=2;i<=n;i++){\n        if(prime[i]>1)\n            ans = ans * (prime[i]+1);\n    }\n    return ans;\t\n}\n```\n\n#### 例题：数数\n\n题目链接：[数数 - 蓝桥云课 (lanqiao.cn)](https://www.lanqiao.cn/problems/2218/learning/)\n\n![image-20231118203219627](https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311182102200.png)\n\n思路：将这个区间中的每一个数都根据唯一分解定理进行拆分，统计有多少个数的拆分结果为12\n\n```java\nimport java.util.Scanner;\n\npublic class 数数 {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint ans = 0;\n\t\tfor(int i=2333333;i<=23333333;i++)\n\t\t\tif(num(i)==12)\n\t\t\t\tans++;\n\t\tSystem.out.println(ans);\n\t}\n\tstatic int num(int n) {\n\t\tint ans = 0;\n\t\tfor(int i=2;i<=n/i;i++) {\n\t\t\twhile(n%i==0) {\n\t\t\t\tn/=i;\n\t\t\t\tans++;\n\t\t\t}\n\t\t}\n\t\tif(n>1)\n\t\t\tans++;\n\t\treturn ans;\n\t}\n}\n\n```\n\n\n\n#### 例题：求阶乘\n\n题目链接：[求阶乘 - 蓝桥云课 (lanqiao.cn)](https://www.lanqiao.cn/problems/2145/learning/)\n\n![image-20231118203313070](https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311182102201.png)\n\n思路：\n\n​\t\t1.根据唯一分解定理可知：每一个数都可以写为 n 个素数的乘积；\n\n​\t\t2.如果一个数的结尾有 0 的存在，那么这个数分解后一定有 2 和 5 （素数中，只有2 * 5才能使结尾产生 0 ）； \n\n​\t\t3.从 1 ~ N ，将每一个数都分解后，2 的数量一定比 5 多（ 2 每隔两个数就会最少出现一个，5 每隔5个数，最少出现一个），那么，N！末尾 0 的数量，就是将 1 ~ N 中每个数分解后，5 的数量；\n\n​\t\t4.如果用一个循环从 5 开始，每次 +5 ，判断这些数可以拆分出几个 5 ，然后去找结尾有 k 个 0 的最小的 N 是多少，这个方法结果正确，但是时间复杂度会比较高，所以借助二分，去找到结尾有 k 个 0 的最小的 N 是多少；\n\n​\t\t5.用二分去查找，就必须做到：已知 N ，求出 1 ~ N 中可以拆分出多少个 5 ，以 125 为例，因为每五个数才拆分出 5 ，所以，如果 1~125 都只拆一个 5 ，则可以拆分出 125 / 5 共 25 个 5 ，拆分后的结果为 1 ~ 25 ，然后继续拆分 5 ，1 ~ 25 可以拆分出 25 / 5 个 5 ，拆分后结果为 1 ~ 5 ，1 ~ 5 可以拆分出 5 / 5 个 5 ，最后剩余 1 ，1 无法继续拆分出 5 ，所以 125 可以拆分出 25 + 5 + 1 = 31 个 5 ；\n\n​\t\t6.二分：如果mid拆分出的 5 的数量 >= k，那么可以 right = mid ，反之left = mid + 1，二分结果后，还需要判断它是否确实能拆分出 k 个 5 ，因为存在一个 N!  能恰好末尾有 k 个 0 ；\n\n```java\nimport java.util.Scanner;\n\npublic class 求阶乘 {\n\tpublic static long find(long x) {//求x能拆分出多少个5\n\t\tlong res = 0;\n\t\twhile(x != 0) {\n\t\t\tres = res + x / 5;\n\t\t\tx/=5;\n\t\t}\n\t\treturn res;\n\t}\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tlong k = sc.nextLong();\n\t\tlong l = 0,r = 100000;//防止溢出\n\t\twhile(l < r) {\n\t\t\tlong mid = (l + r) / 2;\n\t\t\tif(k <= find(mid)) {\n\t\t\t\tr = mid;\n\t\t\t}else {\n\t\t\t\tl = mid + 1;\n\t\t\t}\n\t\t}\n\t\tif(find(r) != k) {//确保有解\n\t\t\tSystem.out.println(-1);\n\t\t}else {\n\t\t\tSystem.out.println(r);\n\t\t}\n\t}\n}\n```\n\n\n\n# 第二章 字符串基础\n\n## 常用API\n\n```java\nString m = \"abcde\";\n\nchar ch = m.charAt(String n);//获取字符串m的第(n+1)个字符\nint length = m.length();//获取字符串m的长度\nboolean flag = m.equals(String n);//判断字符串m和n是否相等,严格区分大小写\nboolean flag = m.equalsIgnoreCase(String n);//判断字符串m和n是否相等,不区分大小写\nint len = m.index(String s);//返回字符串s在m中第一次出现的位置\nint compare = m.compareTo(String anotherString);//按字典序比较两个字符串,若compare>0,m大,若compare<0,m小\nString s = m.concat(n);//将字符串n拼接到字符串m的结尾\nboolean flag = m.contains(String n);//判断字符串m是否包含字符串n\nboolean flag = m.endsWith(String s);//判断字符串m是否以字符串s结尾\nString[] s = m.split(\" \");//根据正则表达式拆分字符串m\nString s = m.trim();//删除字符串m的前导空格和尾部空格\nString s = m.subString(int i,int j);//截取字符串m中下标为i至下标为j-1的部分,即[i,j);\n...\n```\n\n## 周期串\n\n思路：从 1 开始枚举周期 T 的大小，然后判断每个周期内的对应字符是否相同，如果不同，则直接判断下一个 T 。\n\n```java\npublic static int cycle(String s){\n    char[] ch = s.toCharArray();\n    int T;\n    for(T=1;T<=ch.length;T++){\n        if(ch.length%T==0){//周期串的长度一定是周期T的倍数\n            boolean flag = true;\n            for(int start = T;start<ch.length;start++){\n                if(ch[start]!=ch[start%T]){\n                    flag = false;\n                    break;\n                }\n            }\n            if(flag){\n                break;\n            }\n        }\n    }\n    return T;\n}\n```\n\n思路：pos 表示第二行的字符串向右移动的格数，如果移动后，第二行的字符串与第一行字符串对应位置的字符全部相同，则 pos 就是这个字符串的周期。\n\n![image-20231118203417476](https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311182102202.png)\n\n```java\npublic static int cycle(String s){\n\tString m = s+s;\n    int pos;\n    for(pos=1;pos<=s.length();pos++){\n        if(s.length()%pos!=0)\n            continue;\n        String x = m.substring(pos,pos+s.length());\n        if(x.equals(s))\n            break;\n    }\n    return pos;\n}\n```\n\n思路：如果一个字符串 sub 是字符串 s 的周期，那么将字符串 s 中所有的 sub 全部替换为空字符串之后，字符串的长度如果为 0 ，就表示字符串 sub 是字符串 s 的周期。\n\n```java\npublic static int cycle(String s){\n    for(int i=1;i<=s.length();i++){\n        if(s.length()%i==0){\n            String sub = s.substring(0,i);\n            if(s.replace(sub,\"\").length()==0)\n                return i;\n        }\n        \n    }\n    return 0;\n}\n```\n\n#### 例题：重复字符串\n\n题目链接：[重复字符串 - 蓝桥云课 (lanqiao.cn)](https://www.lanqiao.cn/problems/1049/learning/)\n\n![image-20231118203511964](https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311182102203.png)\n\n思路：已知重复次数为 K ，那么周期就是 S.length() / K ，然后只需要求出每一个周期的第 i 个字符，出现次数最多的字符是哪个，然后将其余字符全部改为它，那么就将 S 改为了重复 K 次的字符串，此时修改次数也是最少的。以abdcbbcaabca ， 重复 3 次为例：\n\n​\t\t将此字符串拆分为三个部分后，每个周期写在一行，结果为：\n\n​\t \t\tabdc\n​\t \t\tbbca\n​\t \t\tabca\n\n​\t\t只需要求出每一个竖列出现次数最多的字符出现的次数，然后将其余字符全部改为它，那么这一列修改次数为（K - max），然后将每一列的结果加起来，即为答案。\n\n```java\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\n\npublic class 重复字符串 {\n\n\tstatic BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\tstatic PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));\n\tpublic static void main(String[] args) throws IOException {\n\t\tint n = Integer.parseInt(in.readLine());\n\t\tString a = in.readLine();\n\t\tif(a.length()%n!=0 || n>a.length()) {\n\t\t\tSystem.out.println(-1);\n\t\t\treturn;\n\t\t}\n\t\tint t = a.length() / n;\n\t\tint index = 0;\n\t\tchar[][] ch = new char[n][t];\n\t\tfor(int i=0;i<n;i++) \n\t\t\tfor(int j=0;j<t;j++)\n\t\t\t\tch[i][j] = a.charAt(index++);\n\t\tint ans = 0;\n\t\tfor(int i=0;i<t;i++) {\n\t\t\tint[] num = new int[26];\n\t\t\tint max = 0;\n\t\t\tfor(int j=0;j<n;j++) {\n\t\t\t\tnum[ch[j][i]-'a']++;\n\t\t\t\tif(max<num[ch[j][i]-'a']) {\n\t\t\t\t\tmax = num[ch[j][i]-'a'];\n\t\t\t\t}\n\t\t\t}\n\t\t\tans = ans + (n-max);\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n}\n```\n\n# 第三章 排序\n\n## 冒泡排序\n\n思路：每一次循环将最大值 / 最小值放于向后移动。\n\n```jAVA\npublic static int[] sort(int[] a){\n    for(int i=0;i<a.length-1;i++){\n        for(int j=0;j<a.length-1-i;j++){\n            if(a[j]>a[j+1]){\n                int temp = a[j+1];\n                a[j+1] = a[j];\n                a[j] = temp;\n            }\n        }\n    }\n    return a;\n}\n```\n\n## 插入排序\n\n思路：第 i 趟，把第 i 个元素放到前 i - 1 个有序的序列中 。\n\n```java\npublic static int[] InsertSort(int[] a){\n    for(int i=1;i<a.length;i++){\n        int temp = a[i];//处理第i个元素\n        int j = i-1;\n        for(;j>=0 && a[j]>temp;j--){\n            a[j+1] = a[j];//大的元素往后移\n        }\n        a[j+1] = temp;\n    }\n    return a;\n}\n```\n\n## 选择排序\n\n思路：第 i 趟把从 i ~ 结尾最小的元素找到，放到 i 位置。\n\n```java\npublic static int[] SelectedSort(int[] a){\n    for(int i=0;i<a.length;i++){\n        int min = i;//存放i+1到最后最小的元素所在的下标\n     \tfor(int j=i+1;j<a.length;j++){\n            if(a[j]<a[min])\n                min = j;\n        }\n        int temp = a[i];\n        a[i] = a[min];\n        a[min] = temp;\n    }\n    return a;\n}\n```\n\n## 希尔排序\n\n思路：将排序的区间分成若干个有跨度的子区间，对每一个子区间，进行插入排序，跨度不断 / 2 ，最终当跨度为 1 的时候，进行一个插入排序。\n\n```java\npublic static int[] shell(int[] a){\n    for(int gap = a.length/2;gap>0;gap/=2){\n        //对每一分组进行直接插入排序\n        for(int i=gap;i<a.length;i++){\n            int j = i;\n            while(j-gap>=0 && a[j-gap]>a[j]){//大的往后移动\n                int temp = a[j];\n                a[j] = a[j-gap];\n                a[j-gap] = temp;\n                j = j-gap;//下一次继续从分组的前一个位置开始\n            }\n        }\n    }\n    return a;\n}\n```\n\n## 计数排序\n\n思路：找出数组中的最大值和最小值，每个数都是在 min 和 max 之间，用一个长度为（max - min + 1）的数组 c 来存储每一个数出现的次数，然后将数组 c 转换为前缀和数组，则 c[ i ]，就表示不大于（i+min）的元素的个数，按照 c 数组还原排序结果。\n\n```java\npublic static void countSort(int[] a){\n\tint[] b = new int[a.length];\n    int max = a[0];min = a[0];\n    for(int i=0;i<a.length;i++){\n        if(a[i]>max) max = a[i];\n        if(a[i]<min) min = a[i];\n    }\n    int dis = max - min + ;\n    int[] c = new int[dis];\n    for(int i=0;i<a.length;i++)\n        c[a[i]-min]++;\n    for(int i=1;i<c.length;i++)\n        c[i] = c[i] + c[i-1];\n    for(int i=a.length-1;i>=0;i--){\n        b[c[a[i]-min]-1] = a[i];\n        c[a[i]-min]--;\n    }\n    System.out.println(Arrays.toString(b));\n}\n```\n\n# 第四章 数据结构基础\n\n## 链表\n\n#### 为什么要用链表\n\n数组作为一个顺序储存方式的数据结构，可是有大作为的，它的灵活使用为我们的程序设计带来了大量的便利；但是，数组最大的缺点就是我们的插入和删除时需要移动大量的元素，所以呢，大量的消耗时间，以及冗余度难以接收。\n\n链表可以灵活地去解决这个问题，插入删除操作只需要修改指向的对象就可以了，不需要进行大量的数据移动操作。\n\n#### 单链表\n\n###### \t\t初始化\t\n\n```java\nstatic class Node{//定义结点类\n    int value;//本身的值\n    Node next;//指向下一个结点\n    public Node(int value, Node next) {\n        this.value = value;\n        this.next = next;\n    }\n}\n```\n\n```java\nNode head = new Node(-1,null);//头结点\nNode end = new Node(-1, null);//尾结点\nNode per = head;\nfor(int i=1;i<=10;i++) {\n    per.next = new Node(i, null);\n    per = per.next;\n}\nper.next = end;\n```\n\n###### \t\t插入\n\n​\t\t插入前：\n\n![image-20231118203551162](https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311182102205.png)\n\n​\t\t\t插入后：\n\n![image-20231118203544620](https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311182102206.png)\n\n```java\nNode now;//待插入结点\nnow.next = head.next;//此节点的next为插入位置上一个结点的下一个结点\nhead.next = now;//此节点位置的上一个结点的下一个结点为now\n```\n\n###### \t\t删除\n\n​\t\t删除前：\n\n![image-20231118203608364](https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311182102207.png)\n\n​\t\t删除后：\t\n\n![image-20231118203627478](https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311182102208.png)\t\t\n\n```java\nNode now;//待删除结点\nhead.next = now.next;\n```\n\n#### 双链表\n\n###### \t初始化\n\n```java\nstatic class N{\n    N last;\n    int value;\n    N next;\n    public N(N last, int value, N next) {\n        this.last = last;\n        this.value = value;\n        this.next = next;\n    }\n}\n```\n\n```java\nNode first = new Node(null,-1,null);//头结点\nNode end = new Node(null,-1, null);//尾节点\nNode per = first;\nfor(int i=1;i<=10;i++) {\n    per.next = new N(per,i, null);\n    per = per.next;\n}\nend.last = per;\nper.next = end;\n```\n\n###### \t插入\n\n​\t\t插入前：\n\n![image-20231118203704325](https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311182102209.png)\n\n​\t \t插入后：\n\n![image-20231118203719212](https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311182102210.png)\n\n```java\nNode now;//待插入结点\nnow.next = first.next;\nfirst.next.last = now;\nfirst.next = now;\nnow.last = first;\n```\n\n###### \t\t删除\n\n​\t\t删除前：\n\n![image-20231118203733885](https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311182102211.png)\n\n​\t\t删除后：\n\n![image-20231118203744884](https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311182102212.png)\n\n```java\nNode now;//待删除结点\nnow.last.next = now.next;\nnow.next.last = now.last;\n```\n\n#### 例题：左移右移（双链表解法）\n\n题目链接：[左移右移 - 蓝桥云课 (lanqiao.cn)](https://www.lanqiao.cn/problems/2219/learning/)\n\n![image-20231118203759075](https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311182102213.png)\n\n思路：\n\n​\t\t1.创建双链表并完成初始化，初始元素为 1 ~ n；\n\n​\t\t2.无论 x 左移或右移，都要先将 x 从原位置删除，为了便于获取 x 对应的 Node 结点，用 Map 存储 x 和 value 为 x 的结点；\n\n​\t\t3.如果 x 为左移，就将 x 对应的 Node 结点插入到头结点后；\n\n​\t\t4.如果 x 为右移，就将 x 对应的 Node 结点插入到尾节点前；\n\n```java\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class 左移右移_双链表 {\n\tstatic class Node{\n\t\tNode up;\n\t\tint value;\n\t\tNode down;\n\t\tpublic Node(Node up, int value, Node down) {\n\t\t\tthis.up = up;\n\t\t\tthis.value = value;\n\t\t\tthis.down = down;\n\t\t}\n\t}\n\tpublic static void main(String[] args) throws IOException{\n        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n        PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));\n        String[] s = in.readLine().split(\" \");\n        int n = Integer.parseInt(s[0]);\n        int m = Integer.parseInt(s[1]);\n        Map<Integer, Node> map = new HashMap<>();\n        Node first = new Node(null, -1, null);\n        Node last = new Node(null, -1, null);\n        Node no = first;\n        for(int i=1;i<=n;i++) {\n        \tno.down = new Node(no, i, null);\n        \tno = no.down;\n        \tmap.put(i, no);\n        }\n        last.up = no;\n        no.down = last;\n        for(int i=0;i<m;i++) {\n        \ts = in.readLine().split(\" \");\n        \tchar ch = s[0].charAt(0);\n        \tint x = Integer.parseInt(s[1]);\n        \tNode node = map.get(x);\n        \tnode.up.down = node.down;\n        \tnode.down.up = node.up;\n        \tif(ch=='L') {\n        \t\tnode.down = first.down;\n        \t\tfirst.down.up = node;\n        \t\tfirst.down = node;\n        \t\tnode.up = first;\n        \t}else {\n        \t\tnode.up = last.up;\n        \t\tlast.up.down = node;\n        \t\tnode.down = last;\n        \t\tlast.up = node;\n        \t}\n        }\n        no = first.down;\n        while(no!=last) {\n        \tSystem.out.print(no.value+\" \");\n        \tno = no.down; \n        }\n\t}\n}\n```\n\n## 栈\n\n#### 栈\n\n栈（Stack）：是只允许在一端进行插入或删除的线性表。首先栈是一种线性表，但限定这种线性表只能在某一端进行插入和删除操作。\n\n栈顶（Top）：线性表允许进行插入删除的那一端。\n\n栈底（Bottom）：固定的，不允许进行插入和删除的另一端。\n\n![image-20231118203841538](https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311182102214.png)\n\n#### 常用方法\n\n```java\nStack<Integer> stack = new Stack();\nboolean is = stack.isEmpty();//判断此栈是否为空\nint n = stack.peek();//获取栈顶的元素，但不删除\nint m = stacl.pop();//获取并删除栈顶的元素\nstack.push(10);//将10压入栈中\nstack.clear();//清空栈\n```\n\n#### 判断括号序列是否合法\n\n```java\npublic static boolean check(String s){\n    Stack<Character> stack = new Stack();\n    char[] ch = s.toCharArray();\n    for(int i=0;i<ch.length;i++){\n        if(ch[i]=='(')\n            stack.push(ch[i]);\n        else if(stack.isEmpty())\n            return false;\n        else\n            stack.pop();\n    }\n    return stack.isEmpty();\n}\n```\n\n\n\n## 队列\n\n#### 队列\n\n队列（queue）是一种先进先出的、操作受限的线性表。\n\n![image-20231118203904215](https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311182102215.png)\n\n队列这种数据结构非常容易理解，就像我们平时去超市买东西，在收银台结账的时候需要排队，先去排队的就先结账出去，排在后面的就后结账，有其他人再要过来结账，必须排在队尾不能在队中间插队。\n\n#### 常用方法\n\n```java\nQueue<Integer> queue = new LinkedList<>();\nqueue.peek();//获取队头元素，但不删除\nqueue.poll();//获取并删除队头元素\nqueue.clear();//清空队列\nqueue.push(11);//将11存放到队列中\n```\n\n#### 例题：左移右移（栈 + 队列解法）\n\n题目链接：[左移右移 - 蓝桥云课 (lanqiao.cn)](https://www.lanqiao.cn/problems/2219/learning/)\n\n![image-20231118203920958](https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311182102217.png)\n\n思路：\n\n​\t\t1.如果一个数先移动到最左边，再移动到最右边，那么最后输出的时候这个数一定是在最右边，也就是一个数最终出现在哪里，以他最后一次出现为准；\n\n​\t\t2.为了避免一个数重复判断，而且要以他最后一次出现时的 L 和 R 操作为最终操作，所以可以先将全部输入分别存放到 char 类型数组和 int 类型数组中，然后逆序判断，并且用一个数组来表示这个 x 有没有出现过；\n\n​\t\t3.因为要对输入做逆序操作，所以，逆序时最后出现的 L 对应的 x 在输出的最前面，然后之后出现的 L 对应的 x 依次输出，即先入先出，可以用队列来存储进行 L 操作的 x ；\n\n​\t\t4.逆序时最后出现的 R 对应的 x 在输出的最后面，然后之后出现的 R 对应的 x 依次在前，即后入先出，可以用栈来存储进行 R 操作的 x ；\n\n​\t\t5.输出时，先输出队列中的元素，然后将 1 ~ n 中没有出现过的值按序输出，最后输出栈中的元素；\n\n```java\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Stack;\n\npublic class 左移右移_栈_队列 {\n\n\tpublic static void main(String[] args) throws IOException{\n        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n        PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));\n        String[] s = in.readLine().split(\" \");\n        int n = Integer.parseInt(s[0]);\n        int m = Integer.parseInt(s[1]);\n        int[] a = new int[n+1];\n        char[] c = new char[m];\n        int[] x = new int[m];\n        for(int i=0;i<m;i++) {\n        \ts = in.readLine().split(\" \");\n            c[i] = s[0].charAt(0);\n            x[i] = Integer.parseInt(s[1]);\n        }\n        Stack<Integer> r = new Stack<>();\n        Queue<Integer> l = new LinkedList<>();\n        for(int i=m-1;i>=0;i--) {\n        \tif(a[x[i]]==0) {//判断x[i]是否出现过\n        \t\ta[x[i]] = 1;//若x[i]没有出现过\n        \t\tif(c[i]=='L')\n        \t\t\tl.add(x[i]);\n        \t\telse\n        \t\t\tr.push(x[i]);\n        \t}\n        }\n        while(l.size()!=0) //输出队列中元素\n        \tSystem.out.print(l.poll()+\" \");\n        for(int i=1;i<=n;i++) \n        \tif(a[i]==0) //a[i]为0，表示i没有出现过\n        \t\tSystem.out.print(i+\" \");\n        while(r.size()!=0) //输出栈中元素\n        \tSystem.out.print(r.pop()+\" \");\n\t}\n}\n```\n\n# 第五章 分治算法\n\n## 归并排序\n\n思路：先把数组从中间分成前后两部分，然后分别对前后两部分进行排序，再将排好序的两部分数据合并在一起\n\n```java\npublic static void mergeSort(int[] a,int left,int right){//待排序数组，要排序的范围[left,right]\n    int mid = (left+right)>>1;\n    if(left<right){\n        mergeSort(a,left,mid);\n        mergeSort(a,mid+1,right);\n        merge(a,left,mid,right);\n    }\n}\npublic static void merge(int[] a,int left,int mid,int right){\n    int[] temp = new int[right-left+1];//临时数组，用来归并\n    int i=left,j=mid+1,k=0;//左半段用i指向，右半段用j指向，temp数组用k指向\n    while(i<=mid && j<=right){\n        if(a[i]<a[j])\n            temp[k++] = a[i++];\n        else\n            temp[k++] = a[j++];   \n    }\n    while(i<=mid) temp[k++] = a[i++];\n    while(j<=right) temp[k++] = a[j++];\n    for(int x=0;x<temp.length;x++){\n        a[left+x] = temp[x];\n    }\n}\n```\n\n## 快速排序\n\n思路：\n\n(1)首先设定一个分界值，通过该分界值将数组分成左右两部分。 \n\n(2)将大于或等于分界值的数据集中到数组右边，小于分界值的数据集中到数组的左边。此时，左边部分中各元素都小于分界值，而右边部分中各元素都大于或等于分界值。 \n\n(3)然后，左边和右边的数据可以独立排序。对于左侧的数组数据，又可以取一个分界值，将该部分数据分成左右两部分，同样在左边放置较小值，右边放置较大值。右侧的数组数据也可以做类似处理。 \n\n(4)重复上述过程，可以看出，这是一个递归定义。通过递归将左侧部分排好序后，再递归排好右侧部分的顺序。当左、右两个部分各数据排序完成后，整个数组的排序也就完成了。\n\n```java\npublic static void quickSort(int[] a,int left,int right){\n    if(left>right) return;//区间擦肩而过，无效，不需要进行递归\n    int i=left,j=right,temp = a[left];//a[left]作为基准点\n    while(i!=j){\n        while(a[j]>=a[temp] && j>i)\n            j--;//只要a[j]大于基准点继续往前移动j\n        if(j>i)\n            a[i++] = a[j];\n        while(a[i]<=a[temp] && i<j)\n            i++;\n        if(i<j)\n            a[j--] = a[i];\n    }\n    a[i] = temp;//基准点元素放到最终位置\n    quickSort(a,left,i-1);\n    quickSort(a,i+1,right);\n}\n```\n\n\n\n## 快速幂\n\n思路：每一步都把指数分成两半，而相应的底数做平方运算。这样不仅能把非常大的指数给不断变小，所需要执行的循环次数也变小，而最后表示的结果却一直不会变。\n\n例：3^10^ = 3\\*3\\*3\\*3\\*3\\*3\\*3\\*3\\*3\\*3 ，尽量想办法把指数变小来，这里的指数为10。\n\n3^10^=(3\\*3)\\(3\\*3)(3\\*3)(3\\*3)(3\\*3)\n\n3^10^=(3*3)^5^\n\n3^10^=9^5^\n\n此时指数由10缩减一半变成了5，而底数变成了原来的平方，求3^10^原本需要执行10次循环操作，求9^5^却只需要执行5次循环操作，但是3^10^却等于9^5^,用一次（底数做平方操作）的操作减少了原本一半的循环量，特别是在幂特别大的时候效果非常好，例如2^10000^=4^5000^,底数只是做了一个小小的平方操作，而指数就从10000变成了5000，减少了5000次的循环操作。\n\n现在问题是如何把指数5变成原来的一半，5是一个奇数，5的一半是2.5，但是指数不能为小数，因此不能简单粗暴地直接执行5/2，然而，这里还有另一种方法能表示9^5^，9^5^=9^4^*9^1^\n\n此时抽出了一个底数的一次方，这里即为9^1^，这个9^1^先单独移出来,剩下的9^4^又能够在执行“缩指数”操作了，把指数缩小一半，底数执行平方操作。9^5^=81^2^*9^1^\n\n把指数缩小一半，底数执行平方操作，9^5^=6561^1^\\*9^1^\n\n此时，发现指数又变成了一个奇数1，按照上面对指数为奇数的操作方法，应该抽出了一个底数的一次方，这里即为6561^1^，这个6561^1^先单独移出来，但是此时指数却变成了0，也就意味着我们无法再进行“缩指数”操作了。\n\n9^5^=（6561^0^)(9^1^)(6561^1^)=1(9^1^)(6561^1^)=(9^1^)(6561^1^)=9*6561=59049\n\n能够发现，最后的结果是9*6561。所以能发现一个规律：最后求出的幂结果实际上就是在变化过程中所有当指数为奇数时底数的乘积。\n\n继续优化：\n\nb%2==1可以用更快的“位运算”来代替，例如：b&1。因为如果b为偶数，则其二进制表示的最后一位一定是0；如果b是奇数，则其二进制表示的最后一位一定是1。将他们分别与1的二进制做“与”运算，得到的就是b二进制最后一位的数字了，是0则为偶数，是1则为奇数。例如9是奇数，则9&1=1；而8是偶数，则8&1=0；因此奇偶数的判断就可以用“位运算”来替换了。\n\nm = m / 2也可以用更快的移位操作来代替，例如：6的四位二进制为0110，而6/2=3,3的四位二进制为0011，可以发现，a的一半，结果为a的二进制码向右移一位，即m >>=1。\n\n```java\npublic static long num(long n, long m, long p) {\n    long result = 1;\n    while (m > 0) {\n        if ((m & 1 ) == 1) {\n            result = result * n % p;\n        }\n        m >>= 1;\n        n = (n * n) % p;\n    }\n    return result;\n}\n```\n\n# 第六章 搜索\n\n## 全排列\n\n#### DFS解法\n\n思路：将此过程看做一棵树，每一个结点下都会有 n 个结点表示下一个数，首先先将全部 n^n^ 个结果全部得出，然后剪枝，减去有重复数字出现的情况。\n\n```java\npublic static void dfs(int depth,String ans,int n){//当前深搜的层数，目前的结果，目标层数\n    if(depth==n){//当前深搜层数=目标层数\n        System.out.println(ans);\n        return;\n    }\n    for(int i=1;i<=n;i++){\n    \tif(!ans.contains(i+\"\"))//只有当还没有用过i的时候，才会在现在的基础上继续往下拓展\n\t\t\tdfs(depth+1,ans+i;n);//进入下一层，ans记录为进入下一层的值，n不变\n    }\n}\n```\n\n#### BFS解法\n\n思路：先将有重复数字的结果得出，每一个数后都可以跟 n 中可能，那么将这 n 中可能存入队列中，然后重复此过程，直到字符串的长度为 n 时，得到结果；剪枝，如果这个数字已经用过了，就直接只用下一个数字。\n\n```java\npublic static void bfs(int n){\n    Queue<String> queue = new LinkedList<>();\n    for(int i=1;i<=n;i++)\n        queue.offer(i+\"\");\n    while(!queue.isEmpty()){\n        String now = queue.poll();\n        for(int i=1;i<=n;i++){//每个结点都向下产生n个结果\n            if(now.contains(i+\"\"))//i已经使用过了\n                continue;\n            String son = head + i;\n            if(son.length()==n)\n                System.out.println(son);\n            else\n                queue.offer(son);\n        }\n    }\n}\n```\n\n## 整数划分\n\n思路：对 n 进行划分后， n 可以被不超过 n 个数累加得到，进行累加的每一个数，也可以被不超过它本身个数累加得到。\n\n```java\npublic static void dfs(int n,int nowget,int max,String ans){//要划分的数，现在已经得到的值，目前划分已经用到的最大值，具体拆分方法\n    if(nowget==n){\n        ans = ans.substring(0,ans.length()-1);\n        System.out.println(n+\"=\"+ans);\n        return;\n    }\n    for(int i=1;i<=n-nowget;i++){//从nowget累加到n\n        if(i>=max)//只有当下一个数不小于我之前用过的最大值时，才能保证整个结果为非递减\n            dfs(n,nowget+i,i,ans+i+\"+\");\n    }\n}\n```\n\n## 例题\n\n#### 例题：路径之谜\n\n题目链接：[路径之谜 - 蓝桥云课 (lanqiao.cn)](https://www.lanqiao.cn/problems/89/learning/)\n\n![image-20231118204002349](https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311182102218.png)\n\n思路：\n\n​\t\t1.从入口点开始，到达每一个点都将对应位置北墙和西墙的箭靶数减一，每一个点，都可以继续向四个方向继续前进（前提是这个点没有走过，在城堡范围内，且这个点对应的两个箭靶的数字不为 0 ）。\n\n​\t\t2.如果已经到了终点，就要判断现在每一个箭靶上的数字是否都已经变为 0 ，如果是，那么此时走的路径就是正确解，否则就需要回溯，考虑其他的行走路线。\n\n​\t\t3.回溯：因为要从已经走过的点退回来，所以在已经走过的点上射的箭要收回，箭靶数加一，并且标记此点为还没有走过。\n\n```java\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\n\npublic class 路径之谜 {\n\tstatic int[] path;//记录最终路径，因为底面为n*n，所以走出需要2*n步\n\tstatic int n;\n\tstatic int[] cntx;//存储北墙箭靶数字\n\tstatic int[] cnty;//存储西墙箭靶数字\n\tstatic boolean[][] visited;//判断此点有没有走过\n\tstatic int dx[] = {1, 0, -1, 0};//到下一个点x坐标的变化量\n\tstatic int dy[] = {0, 1, 0, -1};//到下一个点y坐标的变化量\n\tstatic BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\tstatic PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));\n\tpublic static void main(String[] args) throws IOException {\n    \tn = Integer.parseInt(in.readLine());\n    \tcntx = new int[n];\n    \tcnty = new int[n];\n    \tpath = new int[n * n];\n    \tvisited = new boolean[n][n];\n    \tString[] s = in.readLine().split(\" \");\n    \tfor (int i = 0; i < n; i++) {\n    \t\tcntx[i] = Integer.parseInt(s[i]);\n    \t}\n    \ts = in.readLine().split(\" \");\n    \tfor (int i = 0; i < n; i++) {\n    \t\tcnty[i] = Integer.parseInt(s[i]);\n    \t}\n    \tdfs(0, 0, 0);//从0,0位置开始走,目前走了0步\n  }\n\tprivate static void dfs(int x, int y, int step) {\n\t\tpath[step] = y * n + x; //将该点编号记录到路径中\n\t\tvisited[x][y] = true;//将该点标记为已经走过的状态\n\t\tcntx[x]--;//拔掉对应北墙的箭\n\t\tcnty[y]--;//拔掉对应西墙的箭\n\t\tif (x == n - 1 && y == n - 1 && check()){//判断是否到达终点\n\t\t\tfor (int i = 0; i <= step; i++){//输出答案\n\t\t\t\tSystem.out.print(path[i]+\" \");\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tfor (int i = 0; i < 4; i++){//上下左右四个方向搜索下一步\n\t\t\tint xx = x + dx[i], yy = y + dy[i];\n             //下一步(xx,yy)未走过且在地图范围内\n\t\t\tif (0 <= xx && xx <= n-1 && yy >= 0 && yy <= n-1&& !visited[xx][yy] ){\n\t\t\t\tif (cntx[xx] > 0 && cnty[yy] > 0){//该点对应箭靶上有箭，说明该点可以走\n\t\t\t\t\tdfs(xx, yy, step + 1);//搜索下一步\n                    //要从xx,yy点回来,在xx,yy点射的箭要复原，并重新标记xx,yy点没有走过\n\t\t\t\t\tvisited[xx][yy] = false;\n\t\t\t\t\tcntx[xx]++;\n\t\t\t\t\tcnty[yy]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprivate static boolean check() {//判断到达终点时,是否箭靶数都已经归零\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (cntx[i] != 0 || cnty[i] != 0)\n\t\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n}\n```\n\n#### 例题：迷宫\n\n题目链接：[迷宫 - 蓝桥云课 (lanqiao.cn)](https://www.lanqiao.cn/problems/602/learning/)\n\n![image-20231118204041308](https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311182102219.png)\n\n思路：从起点开始，将从此点能到达的点存储到队列中，每次获取并删除队列中的第一个元素，并将其能到达且还未到达过的点（若此点已经到达过，则表示当前处理的这条路径不是最短路径）存储到队列中，若已经到达终点，则此路径为最短路径。如果队列中已经没有元素，但仍未到达迷宫终点，则表示此迷宫无解\n\n```java\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.util.LinkedList;\nimport java.util.Queue;\n\npublic class 迷宫 {\n\tstatic int num;//存储迷宫最短路径所需要的步数\n\tstatic int xsize = 30;//迷宫大小30行50列\n\tstatic int ysize = 50;\n\tstatic char[][] arr = new char[xsize][ysize];//存储迷宫：0表示路，1表示墙\n\tstatic boolean[][] help = new boolean[xsize][ysize];//判断此点是否已经做过\n\tstatic int[][] dir = {{1,0},{0,-1},{0,1},{-1,0}};//四个方向横纵坐标的变化量\n\tstatic char[] sign = {'D','L','R','U'};//表示四个方向\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\t\tPrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));\n\t\tfor(int i=0;i<xsize;i++){\n\t\t\tarr[i] = in.readLine().toCharArray();\n\t\t}\n\t\tout.println(bfs());\n\t\tout.print(num);//额外输出最短路径需要多少步\n\t\tout.flush();\n\t}\n\tprivate static String bfs() {\n\t\tQueue<Node> list = new LinkedList<>();//队列\n\t\tint x = 0;\n\t\tint y = 0;\n\t\tint runnum = 0;\n\t\tlist.add(new Node(x,y,\"\",runnum));//将起点存储到队列中\n\t\twhile(!list.isEmpty()){//判断队列是否为空，若为空，则此迷宫没有通路\n\t\t\tNode now = list.poll();//获取队列中的第一个元素并删除\n\t\t\thelp[now.x][now.y] = true;//将此点标记为已经走过\n\t\t\tfor(int i=0;i<4;i++){//循环四次，对四个方向进行处理\n\t\t\t\tint xx = now.x + dir[i][0];//移动后的x坐标\n\t\t\t\tint yy = now.y + dir[i][1];//移动后的y坐标\n                  //此点在迷宫范围内，未走过，不是墙\n\t\t\t\tif(check(xx,yy) && help[xx][yy]==false && arr[xx][yy]=='0'){\n\t\t\t\t\tlist.add(new Node(xx,yy,now.num + sign[i],now.runnum + 1));//将此点存入队列中\n\t\t\t\t\tif(xx==xsize-1 && yy==ysize-1){//如果已经到了迷宫终点\n\t\t\t\t\t\tnum = now.runnum + 1;//所需步数+1（now.runnum是到达迷宫终点前一步所需要的步数）\n\t\t\t\t\t\treturn now.num + sign[i];//返回通过迷宫的方式\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn \"\";//空字符串，表示此迷宫无通路\n\t}\n\tprivate static boolean check(int xx, int yy) {//判断此点是否在迷宫范围内\n\t\treturn xx>=0 && yy>=0 && xx<xsize && yy<ysize;\n\t}\n\tstatic class Node{\n\t\tint x;//x坐标\n\t\tint y;//y坐标\n\t\tint runnum;//到达此点最短步数\n\t\tString num;//到达此点的方式\n\t\tpublic Node(int x, int y,String num ,int runnum) {\n\t\t\tsuper();\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.num = num;\n\t\t\tthis.runnum = runnum;\n\t\t}\n\t}\n}\n```\n\n# 第七章 贪心\n\n## 基本概念\n\n所谓贪心算法是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，它所做出的仅仅是在某种意义上的局部最优解。\n贪心算法没有固定的算法框架，算法设计的关键是贪心策略的选择。必须注意的是，贪心算法不是对所有问题都能得到整体最优解，选择的贪心策略必须具备无后效性（即某个状态以后的过程不会影响以前的状态，只与当前状态有关。\n\n## 例题\n\n#### 例题：合并果子\n\n题目链接：[合并果子 - 蓝桥云课 (lanqiao.cn)](https://www.lanqiao.cn/problems/741/learning/)\n\n![image-20231118204125650](https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311182102220.png)\n\n思路：\n\n​\t\t1.要保证最终耗费的体力最小，那么就可以每次合并都把目前数量最少的两堆果子合并，耗费的体力就是这两堆果子树木的和，然后合并后又可以作为新的一堆果子继续去判断，直到最终只剩一堆。\n\n​\t\t2.可以借助PriorityQueue优先队列，队列中第一个元素就是最小值，即可每次获取队列中前两个元素，然后将他们的和再次添加至队列中，直到最终队列中只剩一个元素。\n\n​\t\t3.以题目样例为例：对于数组{pi}={1, 2, 9}，Huffman树的构造过程如下：\n\n​\t\t\t3.1找到{1, 2, 9}中最小的两个数，分别是 1 和 2 ，\n\n​\t\t\t3.2从{pi}中删除它们并将和 3 加入，得到{3, 9}，体力消耗为 3 。\n\n​\t\t\t3.3找到{3， 9}中最小的两个数，分别是 3 和 9 ，\n\n​\t\t\t3.4从{pi}中删除它们并将和 12 加入，得到{12}，费用为 12 。\n\n​\t\t\t3.5现在，数组中只剩下一个数12，构造过程结束，总费用为3 + 12 = 15。\n\n```java\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\nimport java.util.Spliterator;\n\npublic class Main {\n\n    public static void main(String[] args) throws IOException{\n        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n        PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));\n        int n = Integer.parseInt(in.readLine());\n        long sum = 0;\n        PriorityQueue<Long> queue = new PriorityQueue<>();\n        String[] s = in.readLine().split(\" \");\n        for(int i=0;i<s.length;i++) {\n            queue.add(Long.parseLong(s[i]));\n        }\n        long number = 0;\n        while(queue.size()!=1) {\n            long a = queue.poll();//获取最小的一堆\n            long b = queue.poll();//获取最小的一堆\n            number = number + ( a + b );//合并这两堆耗费的体力\n            queue.add((a+b));//将合并后的结果放回优先队列中\n        }\n        System.out.println(number);\n    }\n}\n```\n\n# 第八章 树\n\n## 树的相关概念\n\n#### 什么是树\n\n树(Tree)是 n ( n ≧ 0 )个结点的有限集。n=0时称为空树。在任意一颗非空树中：有且仅有一个特定的称为根的结点。当n>1时，其余结点可分为 m ( m > 0 ) 个互不相交的有限集T1、T2、T3……、Tm，其中每个集合本身又是一棵树，并且称为根的子树。\n\n#### 树的基本概念\n\n![image-20231118204210164](https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311182102221.png)\n\n## 二叉树\n\n#### 什么是二叉树\n\n二叉树是n(n>=0)个结点的有限集合，该集合或者为空集（空二叉树）、或者由一个根结点和两颗互不相交的、分别称为根结点的左子树和右子树的二叉树组成。\n\n#### 二叉树的特点\n\n​\t\t1.二叉树中每个结点最多有两颗子树，度没有超过2的。\n\n​\t\t2.左子树和右子树是有顺序的，不能颠倒。\n\n#### 满二叉树\n\n在二叉树中，所有的分支节点都有左子树和右子树，并且所有的叶子都在同一层。\n\n#### 完全二叉树\n\n​\t\t1.叶子结点只能出现在最下面两层。\n\n​\t\t2.最下层的叶子一定集中在左部连续位置。\n\n​\t\t3.倒数第二层，若有叶子结点，一定在右部连续位置。\n\n​\t\t4.如果结点度为1，则该结点只有左孩子。\n\n​\t\t5.同样结点的二叉树，完全二叉树的深度最小。\n\n## 二叉树的创建和嵌套打印\n\n```java\n//结点类\npublic class TreeNode{\n    int data;//结点存放的数据\n    TreeNode left;//左孩子\n    TreeNode right;//右孩子\n    public TreeNode(int data,TreeNode left,TreeNOde right){\n        this.data = data;\n        this.left = left;\n        this.right = right;\n    }\n}\n```\n\n```java\nimport java.util.Scanner;\npublic class Tree{\n    TreeNode root;//整棵树的根节点\n    Scanner sc = new Scanner(System.in);\n    public Tree(){\n        root = null;\n    }\n    public TreeNode createBinaryTree(){//树的创建\n        TreeNode t;//当前树的根节点\n        int x = sc.nextInt();\n        if(x==0) t=null;\n        else{\n            t = new TreeNode();\n            t.data = x;\n            t.left = createBinaryTree();\n            t.right = createBinaryTree();\n        }\n        return t;\n    }\n    public void printTree(TreeNode t){//树的打印\n        if(t!=null){\n            System.out.print(t.data);\n            if(t.left!=null || t.right!=null){\n                System.out.print(\"(\");\n                printTree(t.left);\n                if(t.right!=null) System.out.print(\",\");\n                printTree(t.left);\n                System.out.print(\")\");\n            }\n        }\n    }\n}\n```\n\n## 前中后序层次遍历\n\n#### 前序遍历\n\n思路：对于每个结点，优先处理结点本身，再处理它的左孩子，最后处理它的右孩子。\n\n```java\npublic void preOrder(TreeNode root){\n    if(root!=null){\n        System.out.print(root.data+\" \");\n        preOrder(root.left);\n        preOrder(root.right);\n    }\n}\n```\n\n#### 中序遍历\n\n思路：对于每个结点，优先处理它的左孩子，再处理它本身，最后处理它的右孩子。\n\n```java\npublic void midOrder(TreeNode root){\n    if(root!=null){\n        midOrder(root.left);\n        System.out.print(root.data+\" \");\n        midOrder(root.right);\n    }\n}\n```\n\n#### 后序遍历\n\n思路：对于每个结点，优先处理它的左节点，再处理它的右节点，最后处理它本身。\n\n```java\npublic void postOrder(TreeNode root){\n    if(root!=null){\n        postOrder(root.left);\n       \tpostOrder(root.right);\n        System.out.print(root.data+\" \");\n    }\n}\n```\n\n#### 层次遍历\n\n思路：广度优先搜索；处理根节点的每一个子结点，再处理子结点的每一个子结点......直至结束。\n\n```java\npublic void levelOrder(TreeNode t){\n    Queue<TreeNode> queue = new LinkedList<>();\n    if(t==null) return;\n    queue.offer(t);\n    while(!queue.isEmpty()){\n        TreeNode head = queue.poll();\n        System.out.print(head.data);\n        if(head.left!=null)\n        \tqueue.offer(head.left);\n        if(head.right!=null)\n        \tqueue.offer(head.right);\n    }\n}\n```\n\n## 求二叉树深度\n\n```java\npublic int treeDepth(TreeNode root){\n    if(root==null) return 0;//此结点不存在\n    return Math.max(treeDepth(root.left),treeDepth(root.right))+1;\n}\n```\n\n## 求二叉树叶子结点个数\n\n```java\npublic int TreeLeaf(TreeNode root){\n    if(root==null) return 0;\n    if(root.left==null && root.right==null) return 1;//此结点没有孩子，表示此结点为叶子结点\n    else return treeLeaf(root.left) + treeLeaf(root.right);\n}\n```\n\n## 重建二叉树\n\n思路：\n\n​\t\t1.前序遍历为：根，{左子树}，{右子树}；可得，前序遍历的第一个结点为根结点；\n\n​\t\t2.中序遍历为：{左子树}，根，{右子树}；可得，结点的左侧为它的左孩子树，右侧为它的右孩子树；\n\n​\t\t3.重复此过程，重建此二叉树；\n\n```java\npublic static String f(String pre,String mid){//前序遍历结果，中序遍历结果\n    if(pre.length()==0) return \"\";\n    else if(pre.length==1) return pre;\n    else{\n        int pos = mid.indexOf(pre.charAt(0));\n        String left = f(pre.substring(1,pos+1),mid.substring(0,pos));\n        String right = f(pre.substring(pos+1),mid.substring(pos+1));\n        return left+right+pre.charAt(0);\n    }\n}\n```\n\n# 第九章 图\n\n# 第十章 动态规划\n\n#### LCS 最长公共子序列\n\n思路：\n\n​\t\t1.用一个数组 dp\\[ i ]\\[ j ] 表示 S 字符串中前 i 个字符与 T 字符串中前 j 个字符的最长上升子序列，那么 dp\\[ i+1 ]\\[ j+1 ] 就是S 字符串中前 i+1 个字符与 T 字符串中前 j+1 个字符的最长上升子序列；\n\n​\t\t2.如果此时 S 中的第 i+1 个字符与 T 中的第 j+1 个字符相同，那么 dp\\[ i+1 ]\\[ j+1 ] = dp\\[ i ]\\[ j ] + 1;\n\n​\t\t3.如果此时 S 中的第 i+1 个字符与 T 中的第 j+1 个字符不同，那么 dp\\[ i+1 ]\\[ j+1 ] = Math.max ( dp\\[ i+1 ]\\[ j ] , dp\\[ i ]\\[ j+1 ] );\n\n```java\npublic static int LCS(String s,String t){\n    int[][] dp=new int[s.length()+1][t.length()+1];\n    for(int i=1;i<=s.length();i++){\n        for(int j=1;j<=t.length();j++){\n            if(s.charAt(i-1)==t.charAt(j-1))\n                dp[i][j]=dp[i-1][j-1]+1;\n            else\n                dp[i][j]=Math.max(dp[i][j-1],dp[i-1][j]);\n        }\n    }\n    return dp[len1][len2];\n}\n```\n\n","slug":"MyLanqiaoNote","published":1,"updated":"2023-11-18T13:02:44.094Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clpkicziu0015fkfo6w396mvj","content":"<h1 id=\"第一章-基础数学思维与技巧\"><a href=\"#第一章-基础数学思维与技巧\" class=\"headerlink\" title=\"第一章 基础数学思维与技巧\"></a>第一章 基础数学思维与技巧</h1><h2 id=\"最大公约数\"><a href=\"#最大公约数\" class=\"headerlink\" title=\"最大公约数\"></a>最大公约数</h2><h4 id=\"求最大公约数—-欧几里得辗转相除法\"><a href=\"#求最大公约数—-欧几里得辗转相除法\" class=\"headerlink\" title=\"求最大公约数—-欧几里得辗转相除法\"></a>求最大公约数—-欧几里得辗转相除法</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">gcd</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> a,<span class=\"hljs-type\">int</span> b)</span>&#123;<br>   \t<span class=\"hljs-keyword\">while</span>(b&gt;<span class=\"hljs-number\">0</span>)&#123;<br>        <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">temp</span> <span class=\"hljs-operator\">=</span> a%b;<br>        a=b;<br>        b=temp;<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> a;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">gcd</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> a,<span class=\"hljs-type\">int</span> b)</span>&#123;<br>    <span class=\"hljs-keyword\">return</span> b==<span class=\"hljs-number\">0</span>?a:gcd(b,a%b);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"最小公倍数\"><a href=\"#最小公倍数\" class=\"headerlink\" title=\"最小公倍数\"></a>最小公倍数</h2><h4 id=\"求最大公倍数\"><a href=\"#求最大公倍数\" class=\"headerlink\" title=\"求最大公倍数\"></a>求最大公倍数</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">lcm</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> a,<span class=\"hljs-type\">int</span> b)</span>&#123;<br>    <span class=\"hljs-keyword\">return</span> a * b / gcd(a,b);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"进制转换\"><a href=\"#进制转换\" class=\"headerlink\" title=\"进制转换\"></a>进制转换</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">s</span> <span class=\"hljs-operator\">=</span> Integer.toString(a,m);<span class=\"hljs-comment\">//10进制a数转m进制数,结果为字符串</span><br><br><span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">a</span> <span class=\"hljs-operator\">=</span> Integer.parseInt(s,m);<span class=\"hljs-comment\">//把字符串s当做m进制数,将结果转为10进制数</span><br><br><span class=\"hljs-type\">BigInteger</span> <span class=\"hljs-variable\">biginteger</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">BigInteger</span>(s,m);<span class=\"hljs-comment\">//把m进制的字符串s转换成10进制数后封装成大数对象</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"位运算\"><a href=\"#位运算\" class=\"headerlink\" title=\"位运算\"></a>位运算</h2><h3 id=\"与-amp-全1为1-有0为0\"><a href=\"#与-amp-全1为1-有0为0\" class=\"headerlink\" title=\"与 &amp; (全1为1,有0为0)\"></a>与 &amp; (全1为1,有0为0)</h3><h4 id=\"判断奇偶数\"><a href=\"#判断奇偶数\" class=\"headerlink\" title=\"判断奇偶数\"></a>判断奇偶数</h4><p>奇数-二进制最后一位一定为1<br>偶数-二进制最后一位一定为0</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">boolean</span> <span class=\"hljs-title function_\">check</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> m)</span>&#123;<br>    <span class=\"hljs-keyword\">return</span> (m&amp;<span class=\"hljs-number\">1</span>)==<span class=\"hljs-number\">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"判断m是否为2的x次方\"><a href=\"#判断m是否为2的x次方\" class=\"headerlink\" title=\"判断m是否为2的x次方\"></a>判断m是否为2的x次方</h4><p>若m为2的x次方:m的二进制只有最高位为1,其余全为0,(m-1)的二进制除最高位都为1.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">boolean</span> <span class=\"hljs-title function_\">check</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> m)</span>&#123;<br>    <span class=\"hljs-keyword\">return</span> m&amp;(m-<span class=\"hljs-number\">1</span>)==<span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"异或-相同为0-不同为1\"><a href=\"#异或-相同为0-不同为1\" class=\"headerlink\" title=\"异或 ^ (相同为0,不同为1)\"></a>异或 ^ (相同为0,不同为1)</h3><h4 id=\"找到数组中只出现了一次的数\"><a href=\"#找到数组中只出现了一次的数\" class=\"headerlink\" title=\"找到数组中只出现了一次的数\"></a>找到数组中只出现了一次的数</h4><p>按位异或：相同为0，不同为1</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">x^x=<span class=\"hljs-number\">0</span>;<br><span class=\"hljs-number\">0</span>^x=x;<br>a^b^c=a^c^b;<br><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">num</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span>[] s)</span>&#123;<br>    <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">ans</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;s.length;i++)&#123;<br>        ans = ans ^ s[i];<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"移位-gt-gt-和-lt-lt\"><a href=\"#移位-gt-gt-和-lt-lt\" class=\"headerlink\" title=\"移位 &gt;&gt; 和&lt;&lt;\"></a>移位 &gt;&gt; 和&lt;&lt;</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-number\">8</span>&gt;&gt;<span class=\"hljs-number\">1</span> == <span class=\"hljs-number\">4</span><br><span class=\"hljs-number\">4</span>&gt;&gt;<span class=\"hljs-number\">1</span> == <span class=\"hljs-number\">2</span><br>    <br><span class=\"hljs-number\">2</span>&lt;&lt;<span class=\"hljs-number\">1</span> == <span class=\"hljs-number\">4</span><br><span class=\"hljs-number\">4</span>&lt;&lt;<span class=\"hljs-number\">1</span> == <span class=\"hljs-number\">8</span><br><br>n &gt;&gt; m == n / (<span class=\"hljs-number\">2</span> ^ m)<br>n &lt;&lt; m == n * (<span class=\"hljs-number\">2</span> ^ m)<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"素数\"><a href=\"#素数\" class=\"headerlink\" title=\"素数\"></a>素数</h2><h4 id=\"判断素数\"><a href=\"#判断素数\" class=\"headerlink\" title=\"判断素数\"></a>判断素数</h4><p>素数:只有1和它本身是因数 。</p>\n<p>首先，0和1不是素数，然后 i 从 2 开始判断 i 是不是 n 的因数，如果是因数，则直接返回 n 不是素数，否则，判断 i+1是不是 n 的因数，直到 i=√n 的时候，如果 i 仍然不是 n 的因数，那么 n 就是素数。</p>\n<p>注：如果一个数 a 能够整除 i ，那么 i 和 a/i 一定满足：假设 i&lt;=a/i , 那么 i&lt;=√n , &amp;&amp; a/i&gt;= √n 。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">boolean</span> <span class=\"hljs-title function_\">isprime</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> n)</span>&#123;<br>    <span class=\"hljs-keyword\">if</span>(n==<span class=\"hljs-number\">0</span> || n==<span class=\"hljs-number\">1</span>)<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">2</span>;i&lt;=n/i;i++)&#123;<br>        <span class=\"hljs-keyword\">if</span>(n%i==<span class=\"hljs-number\">0</span>)<br>            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"求1-n中的所有素数—-埃氏筛法\"><a href=\"#求1-n中的所有素数—-埃氏筛法\" class=\"headerlink\" title=\"求1~n中的所有素数—-埃氏筛法\"></a>求1~n中的所有素数—-埃氏筛法</h4><p>思路：如果一个数不是素数，那么这个数一定是 n 个素数的乘积（0和1除外），同理，素数的 k 倍数一定是合数（k&gt;=2）。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">isprime</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> n)</span>&#123;<br>    <span class=\"hljs-type\">boolean</span>[] isprime = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">boolean</span>[n+<span class=\"hljs-number\">1</span>];<span class=\"hljs-comment\">//false表示素数，true表示合数</span><br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">2</span>;i*i&lt;=n;i++) <br>        <span class=\"hljs-keyword\">if</span>(!isprime[i]) <span class=\"hljs-comment\">//i是质数</span><br>            <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> j=<span class=\"hljs-number\">2</span>;j*i&lt;=n;j++)<span class=\"hljs-comment\">//将i的倍数全部标记为合数</span><br>                isprime[i*j] = <span class=\"hljs-literal\">true</span>;<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">2</span>;i&lt;=n;i++)<br>        <span class=\"hljs-keyword\">if</span>(!isprime[i])<br>            System.out.println(i);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"求1-n中的所有素数—-欧拉筛法\"><a href=\"#求1-n中的所有素数—-欧拉筛法\" class=\"headerlink\" title=\"求1~n中的所有素数—-欧拉筛法\"></a>求1~n中的所有素数—-欧拉筛法</h4><p>思路：每个合数，只被他最小的质因子筛一次。</p>\n<p>注：与埃氏筛法不同，埃氏筛法是将素数的倍数，标记为合数；欧拉筛法是将目前已经找到的每一个素数的 i 倍标记为合数，无论 i 是否是素数，同时，如果 i 本身就是素数的倍数，那么就去执行下一个 i 。 </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">isprime</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> n)</span>&#123;<br>    <span class=\"hljs-type\">boolean</span>[] isprime = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">boolean</span>[n+<span class=\"hljs-number\">1</span>];<br>    <span class=\"hljs-type\">int</span>[] prime = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">int</span>[n];<span class=\"hljs-comment\">//存储素数</span><br>    <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">count</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span>;<span class=\"hljs-comment\">//统计目前素数个数</span><br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">2</span>;i&lt;=n;i++) &#123;<br>        <span class=\"hljs-keyword\">if</span>(!isprime[i])  <span class=\"hljs-comment\">//i是质数</span><br>            prime[count++] = i;<span class=\"hljs-comment\">//把当前素数存储到数组中count位置</span><br>        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> j=<span class=\"hljs-number\">0</span>;j&lt;count &amp;&amp; i*prime[j]&lt;=n;j++)&#123;<span class=\"hljs-comment\">//将i的倍数全部标记为合数</span><br>            isprime[i*prime[j]] = <span class=\"hljs-literal\">true</span>;<br>            <span class=\"hljs-keyword\">if</span>(i%prime[j]==<span class=\"hljs-number\">0</span>) <span class=\"hljs-keyword\">break</span>;<span class=\"hljs-comment\">//欧拉筛法精髓</span><br>        &#125;<br>    &#125;<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;count;i++)<br>        System.out.println(prime[i]);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"例题：最小质因子之和\"><a href=\"#例题：最小质因子之和\" class=\"headerlink\" title=\"例题：最小质因子之和\"></a>例题：最小质因子之和</h4><p>题目链接：<a href=\"https://www.lanqiao.cn/problems/1151/learning/\">最小质因子之和(Easy Version) - 蓝桥云课 (lanqiao.cn)</a></p>\n<p><img src=\"https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311182102197.png\" alt=\"最小质因子之和题目描述\"></p>\n<p>思路：因为题目输入为T组数据，如果单独计算每组数据，则会有部分区间的数据被重复计算，所以先通过埃氏筛法，求出每一个数的最小质因子，将结果存放在 ans 数组中，然后将 ans 数组表示为前缀和数组，此时 ans 数组中的结果就为2~n的质因子之和，此时，题目若输入 15 ，则直接输出 ans[15] 即可。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">import</span> java.io.BufferedReader;<br><span class=\"hljs-keyword\">import</span> java.io.IOException;<br><span class=\"hljs-keyword\">import</span> java.io.InputStreamReader;<br><span class=\"hljs-keyword\">import</span> java.io.OutputStreamWriter;<br><span class=\"hljs-keyword\">import</span> java.io.PrintWriter;<br><br><span class=\"hljs-keyword\">public</span> class 最小质因子之和 &#123;<br>\t<span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">boolean</span>[] isprime  = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">boolean</span>[<span class=\"hljs-number\">3000001</span>];<span class=\"hljs-comment\">//是否是素数</span><br>\t<span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">long</span>[] ans = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">long</span>[<span class=\"hljs-number\">3000001</span>];<span class=\"hljs-comment\">//存储最小质因子 i的最小质因子为ans[i]，例：ans[4] = 2</span><br>\t<span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">BufferedReader</span> <span class=\"hljs-variable\">in</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">BufferedReader</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">InputStreamReader</span>(System.in));<br>\t<span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">PrintWriter</span> <span class=\"hljs-variable\">out</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">PrintWriter</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">OutputStreamWriter</span>(System.out));<br>\t<br>\t<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> <span class=\"hljs-keyword\">throws</span> IOException&#123;<br>\t\tget(<span class=\"hljs-number\">3000000</span>);<span class=\"hljs-comment\">//题目数据范围，N最大值为3*10^6，将2~3*10^6中每一个数的最小质因子全部求出</span><br>\t\t<span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">2</span>;i&lt;=<span class=\"hljs-number\">3000000</span>;i++) &#123;<br>\t\t\tans[i] = ans[i] + ans[i-<span class=\"hljs-number\">1</span>];<span class=\"hljs-comment\">//求前缀和，此时ans[i]中存放的数就是2~i中每一个数的最小质因子的和</span><br>\t\t&#125;<br>\t\t<span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">n</span> <span class=\"hljs-operator\">=</span> Integer.parseInt(in.readLine());<br>\t\t<span class=\"hljs-keyword\">while</span>(n--&gt;<span class=\"hljs-number\">0</span>) &#123;<br>\t\t\tout.println(ans[Integer.parseInt(in.readLine())]);<br>\t\t&#125;<br>\t\tout.flush();<br>\t&#125;<br>\t<br>\t<span class=\"hljs-comment\">//找出每个数的质因子</span><br>\t<span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">get</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> n)</span> &#123;<br>\t\t<span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">2</span>;i&lt;=n;i++) &#123;<br>\t\t\t<span class=\"hljs-keyword\">if</span>(isprime[i])<span class=\"hljs-comment\">//i不是质数直接跳过,不考虑,i不能作为筛除条件</span><br>\t\t\t\t<span class=\"hljs-keyword\">continue</span>;<br>\t\t\tans[i] = i;<span class=\"hljs-comment\">//i为素数，素数的最小质因子就是其本身</span><br>\t\t\t<span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> j=<span class=\"hljs-number\">2</span>;j&lt;=n/i;j++) &#123;<span class=\"hljs-comment\">//j为倍数，将素数i的j倍数标记为合数，并将此数的最小质因子标记为i</span><br>\t\t\t\t<span class=\"hljs-keyword\">if</span>(!isprime[j*i]) &#123;<span class=\"hljs-comment\">//判断是否已经被标记过</span><br>\t\t\t\t\tisprime[j*i] = <span class=\"hljs-literal\">true</span>;<span class=\"hljs-comment\">//将i*j标记为合数</span><br>\t\t\t\t\tans[j*i] = i;<span class=\"hljs-comment\">//j*i的最小质因子是i</span><br>\t\t\t\t&#125;<br>\t\t\t&#125;<br>\t\t&#125;<br>\t&#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"回文数\"><a href=\"#回文数\" class=\"headerlink\" title=\"回文数\"></a>回文数</h2><h4 id=\"判断回文数\"><a href=\"#判断回文数\" class=\"headerlink\" title=\"判断回文数\"></a>判断回文数</h4><p>思路：将数字转换为字符串类型后，将此字符串倒转后，判断与原字符串是否相同</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">boolean</span> <span class=\"hljs-title function_\">check</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> m)</span>&#123;<br>    <span class=\"hljs-keyword\">return</span> Integer.toString(m).equals(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">StringBuffer</span>(Integer.toString(m)).reverse().toString());<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"判断数组中元素是否相同\"><a href=\"#判断数组中元素是否相同\" class=\"headerlink\" title=\"判断数组中元素是否相同\"></a>判断数组中元素是否相同</h2><p>思路：若数组中元素全部相同，则数组中的最大值应当==最小值。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">boolean</span> <span class=\"hljs-title function_\">check</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span>[] n)</span>&#123;<br>    Arrays.sort(n);<br>    <span class=\"hljs-keyword\">return</span> n[<span class=\"hljs-number\">0</span>]==n[n.length-<span class=\"hljs-number\">1</span>];<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>思路：利用Set集合自动去重，将数组中所有元素全部添加到集合中后，如果集合中只有一个元素，则表示数组中所有元素全部相同。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">boolean</span> <span class=\"hljs-title function_\">check</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span>[] n)</span>&#123;<br>    Set&lt;Integer&gt; set = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">HashSet</span>&lt;&gt;();<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;n.length;i++) &#123;<br>        set.add(n[i]);<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> set.size()==<span class=\"hljs-number\">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"日期-星期模拟\"><a href=\"#日期-星期模拟\" class=\"headerlink\" title=\"日期+星期模拟\"></a>日期+星期模拟</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> Main&#123;<br>    <span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">int</span>[] date = &#123;<span class=\"hljs-number\">0</span>,<span class=\"hljs-number\">31</span>,<span class=\"hljs-number\">28</span>,<span class=\"hljs-number\">31</span>,<span class=\"hljs-number\">30</span>,<span class=\"hljs-number\">31</span>,<span class=\"hljs-number\">30</span>,<span class=\"hljs-number\">31</span>,<span class=\"hljs-number\">31</span>,<span class=\"hljs-number\">30</span>,<span class=\"hljs-number\">31</span>,<span class=\"hljs-number\">30</span>,<span class=\"hljs-number\">31</span>&#125;;<span class=\"hljs-comment\">//存储每月天数</span><br>    <span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">y</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">2001</span>,m = <span class=\"hljs-number\">1</span>;d = <span class=\"hljs-number\">1</span>,week = <span class=\"hljs-number\">1</span>;<span class=\"hljs-comment\">//初始年,月,日,星期(根据题意选择是否需要)</span><br>    <span class=\"hljs-comment\">//week==0,表示周日,week==1,表示周一 ... week==6,表示周六</span><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span>&#123;<br>        <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">ans</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span>;<span class=\"hljs-comment\">//计数</span><br>        <span class=\"hljs-keyword\">while</span>(y!=<span class=\"hljs-number\">9999</span> || m!=<span class=\"hljs-number\">12</span>|| d!=<span class=\"hljs-number\">31</span>)&#123;<span class=\"hljs-comment\">//设置日期判断范围</span><br>            <span class=\"hljs-comment\">//判断闰年(满足其一即可):</span><br>            <span class=\"hljs-comment\">//1.可以整除400</span><br>            <span class=\"hljs-comment\">//2.可以整除4但不能整除100</span><br>            <span class=\"hljs-keyword\">if</span>(y%<span class=\"hljs-number\">400</span>==<span class=\"hljs-number\">0</span> || (y%<span class=\"hljs-number\">4</span>==<span class=\"hljs-number\">0</span>&amp;&amp; y%<span class=\"hljs-number\">100</span>!=<span class=\"hljs-number\">0</span>) date[<span class=\"hljs-number\">2</span>] = <span class=\"hljs-number\">29</span>;<br>            <span class=\"hljs-keyword\">else</span> date[<span class=\"hljs-number\">2</span>] = <span class=\"hljs-number\">28</span>;<br>            <span class=\"hljs-keyword\">if</span>(check()) ans++;<span class=\"hljs-comment\">//满足条件,计数器++;</span><br>            d++;<br>            week++;<br>            week%=<span class=\"hljs-number\">7</span>;<br>            <span class=\"hljs-keyword\">if</span>(d&gt;date[m])&#123;<br>                d = <span class=\"hljs-number\">1</span>;<br>                m++;<br>            &#125;<br>            <span class=\"hljs-keyword\">if</span>(m&gt;<span class=\"hljs-number\">12</span>)&#123;<br>                m = <span class=\"hljs-number\">1</span>;<br>                y++;<br>            &#125;<br>        &#125;<br>        <span class=\"hljs-keyword\">if</span>(check()) ans++;<span class=\"hljs-comment\">//之前结束日期并未判断,判断结束日期</span><br>        System.out.println(ans);<br>    &#125;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">boolean</span> <span class=\"hljs-title function_\">check</span><span class=\"hljs-params\">()</span>&#123;&#125;<span class=\"hljs-comment\">//根据题目要求完成</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"约数\"><a href=\"#约数\" class=\"headerlink\" title=\"约数\"></a>约数</h2><h4 id=\"唯一分解定理\"><a href=\"#唯一分解定理\" class=\"headerlink\" title=\"唯一分解定理\"></a>唯一分解定理</h4><p><img src=\"https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311182102199.png\" alt=\"image-20231118203136873\"></p>\n<h4 id=\"n的质因数个数—-唯一分解定理\"><a href=\"#n的质因数个数—-唯一分解定理\" class=\"headerlink\" title=\"n的质因数个数—-唯一分解定理\"></a>n的质因数个数—-唯一分解定理</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">num</span><span class=\"hljs-params\">(<span class=\"hljs-type\">long</span> n)</span>&#123;   <br>    <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">ans</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span>;    <br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">2</span>;i&lt;=n/i;i++)&#123;        <br>        <span class=\"hljs-keyword\">while</span>(n%i==<span class=\"hljs-number\">0</span>)&#123;            <br>            ans++;              <br>            n/=i;        <br>        &#125;    <br>    &#125;    <br>    <span class=\"hljs-keyword\">if</span>(n&gt;<span class=\"hljs-number\">1</span>)        <br>        ans++;    <br>    <span class=\"hljs-keyword\">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"n的约数个数—-唯一分解定理\"><a href=\"#n的约数个数—-唯一分解定理\" class=\"headerlink\" title=\"n的约数个数—-唯一分解定理\"></a>n的约数个数—-唯一分解定理</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">num</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> n)</span>&#123;<br>    <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">cnt</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">1</span>;<span class=\"hljs-comment\">//乘法初始值为1</span><br>    <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">bak</span> <span class=\"hljs-operator\">=</span> n;<span class=\"hljs-comment\">//备份n</span><br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">2</span>;i*i&lt;=n;i++)&#123;<br>        <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">sum</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span>;<br>        <span class=\"hljs-keyword\">while</span>(bak%i==<span class=\"hljs-number\">0</span>)&#123;<br>            sum++;<br>            bak = bak / i;<br>        &#125;<br>        cnt = cnt * (sum + <span class=\"hljs-number\">1</span>);<br>    &#125;<br>    <span class=\"hljs-keyword\">if</span>(bak&gt;<span class=\"hljs-number\">1</span>) cnt*=<span class=\"hljs-number\">2</span>;<br>    <span class=\"hljs-keyword\">return</span> cnt;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"求n-的约数个数—-唯一分解定理\"><a href=\"#求n-的约数个数—-唯一分解定理\" class=\"headerlink\" title=\"求n!的约数个数—-唯一分解定理\"></a>求n!的约数个数—-唯一分解定理</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">long</span> <span class=\"hljs-title function_\">num</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> n)</span>&#123;<br>    <span class=\"hljs-type\">int</span>[] prime = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">int</span>[n+<span class=\"hljs-number\">1</span>];<span class=\"hljs-comment\">//prime[i]表示素数i这个因子出现的次数</span><br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">2</span>;i&lt;=n;i++)&#123;<br>        <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">bak</span> <span class=\"hljs-operator\">=</span> i;<br>        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> j=<span class=\"hljs-number\">2</span>;j*j&lt;=bak;j++)&#123;<br>            <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">sum</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span>;<br>            <span class=\"hljs-keyword\">while</span>(bak%j==<span class=\"hljs-number\">0</span>)&#123;<br>                prime[j]++;<br>                bak = bak / j;<br>            &#125;<br>    \t&#125;<br>    \t<span class=\"hljs-keyword\">if</span>(bak&gt;<span class=\"hljs-number\">1</span>) prime[bak]++;<br>    &#125;<br>    <span class=\"hljs-type\">long</span> <span class=\"hljs-variable\">ans</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">1</span>;<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">2</span>;i&lt;=n;i++)&#123;<br>        <span class=\"hljs-keyword\">if</span>(prime[i]&gt;<span class=\"hljs-number\">1</span>)<br>            ans = ans * (prime[i]+<span class=\"hljs-number\">1</span>);<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> ans;\t<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"例题：数数\"><a href=\"#例题：数数\" class=\"headerlink\" title=\"例题：数数\"></a>例题：数数</h4><p>题目链接：<a href=\"https://www.lanqiao.cn/problems/2218/learning/\">数数 - 蓝桥云课 (lanqiao.cn)</a></p>\n<p><img src=\"https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311182102200.png\" alt=\"image-20231118203219627\"></p>\n<p>思路：将这个区间中的每一个数都根据唯一分解定理进行拆分，统计有多少个数的拆分结果为12</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">import</span> java.util.Scanner;<br><br><span class=\"hljs-keyword\">public</span> class 数数 &#123;<br><br>\t<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> &#123;<br>\t\t<span class=\"hljs-type\">Scanner</span> <span class=\"hljs-variable\">sc</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Scanner</span>(System.in);<br>\t\t<span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">ans</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span>;<br>\t\t<span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">2333333</span>;i&lt;=<span class=\"hljs-number\">23333333</span>;i++)<br>\t\t\t<span class=\"hljs-keyword\">if</span>(num(i)==<span class=\"hljs-number\">12</span>)<br>\t\t\t\tans++;<br>\t\tSystem.out.println(ans);<br>\t&#125;<br>\t<span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">num</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> n)</span> &#123;<br>\t\t<span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">ans</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span>;<br>\t\t<span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">2</span>;i&lt;=n/i;i++) &#123;<br>\t\t\t<span class=\"hljs-keyword\">while</span>(n%i==<span class=\"hljs-number\">0</span>) &#123;<br>\t\t\t\tn/=i;<br>\t\t\t\tans++;<br>\t\t\t&#125;<br>\t\t&#125;<br>\t\t<span class=\"hljs-keyword\">if</span>(n&gt;<span class=\"hljs-number\">1</span>)<br>\t\t\tans++;<br>\t\t<span class=\"hljs-keyword\">return</span> ans;<br>\t&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"例题：求阶乘\"><a href=\"#例题：求阶乘\" class=\"headerlink\" title=\"例题：求阶乘\"></a>例题：求阶乘</h4><p>题目链接：<a href=\"https://www.lanqiao.cn/problems/2145/learning/\">求阶乘 - 蓝桥云课 (lanqiao.cn)</a></p>\n<p><img src=\"https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311182102201.png\" alt=\"image-20231118203313070\"></p>\n<p>思路：</p>\n<p>​        1.根据唯一分解定理可知：每一个数都可以写为 n 个素数的乘积；</p>\n<p>​        2.如果一个数的结尾有 0 的存在，那么这个数分解后一定有 2 和 5 （素数中，只有2 * 5才能使结尾产生 0 ）； </p>\n<p>​        3.从 1 ~ N ，将每一个数都分解后，2 的数量一定比 5 多（ 2 每隔两个数就会最少出现一个，5 每隔5个数，最少出现一个），那么，N！末尾 0 的数量，就是将 1 ~ N 中每个数分解后，5 的数量；</p>\n<p>​        4.如果用一个循环从 5 开始，每次 +5 ，判断这些数可以拆分出几个 5 ，然后去找结尾有 k 个 0 的最小的 N 是多少，这个方法结果正确，但是时间复杂度会比较高，所以借助二分，去找到结尾有 k 个 0 的最小的 N 是多少；</p>\n<p>​        5.用二分去查找，就必须做到：已知 N ，求出 1 ~ N 中可以拆分出多少个 5 ，以 125 为例，因为每五个数才拆分出 5 ，所以，如果 1~125 都只拆一个 5 ，则可以拆分出 125 / 5 共 25 个 5 ，拆分后的结果为 1 ~ 25 ，然后继续拆分 5 ，1 ~ 25 可以拆分出 25 / 5 个 5 ，拆分后结果为 1 ~ 5 ，1 ~ 5 可以拆分出 5 / 5 个 5 ，最后剩余 1 ，1 无法继续拆分出 5 ，所以 125 可以拆分出 25 + 5 + 1 = 31 个 5 ；</p>\n<p>​        6.二分：如果mid拆分出的 5 的数量 &gt;= k，那么可以 right = mid ，反之left = mid + 1，二分结果后，还需要判断它是否确实能拆分出 k 个 5 ，因为存在一个 N!  能恰好末尾有 k 个 0 ；</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">import</span> java.util.Scanner;<br><br><span class=\"hljs-keyword\">public</span> class 求阶乘 &#123;<br>\t<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">long</span> <span class=\"hljs-title function_\">find</span><span class=\"hljs-params\">(<span class=\"hljs-type\">long</span> x)</span> &#123;<span class=\"hljs-comment\">//求x能拆分出多少个5</span><br>\t\t<span class=\"hljs-type\">long</span> <span class=\"hljs-variable\">res</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span>;<br>\t\t<span class=\"hljs-keyword\">while</span>(x != <span class=\"hljs-number\">0</span>) &#123;<br>\t\t\tres = res + x / <span class=\"hljs-number\">5</span>;<br>\t\t\tx/=<span class=\"hljs-number\">5</span>;<br>\t\t&#125;<br>\t\t<span class=\"hljs-keyword\">return</span> res;<br>\t&#125;<br>\t<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> &#123;<br>\t\t<span class=\"hljs-type\">Scanner</span> <span class=\"hljs-variable\">sc</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Scanner</span>(System.in);<br>\t\t<span class=\"hljs-type\">long</span> <span class=\"hljs-variable\">k</span> <span class=\"hljs-operator\">=</span> sc.nextLong();<br>\t\t<span class=\"hljs-type\">long</span> <span class=\"hljs-variable\">l</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span>,r = <span class=\"hljs-number\">100000</span>;<span class=\"hljs-comment\">//防止溢出</span><br>\t\t<span class=\"hljs-keyword\">while</span>(l &lt; r) &#123;<br>\t\t\t<span class=\"hljs-type\">long</span> <span class=\"hljs-variable\">mid</span> <span class=\"hljs-operator\">=</span> (l + r) / <span class=\"hljs-number\">2</span>;<br>\t\t\t<span class=\"hljs-keyword\">if</span>(k &lt;= find(mid)) &#123;<br>\t\t\t\tr = mid;<br>\t\t\t&#125;<span class=\"hljs-keyword\">else</span> &#123;<br>\t\t\t\tl = mid + <span class=\"hljs-number\">1</span>;<br>\t\t\t&#125;<br>\t\t&#125;<br>\t\t<span class=\"hljs-keyword\">if</span>(find(r) != k) &#123;<span class=\"hljs-comment\">//确保有解</span><br>\t\t\tSystem.out.println(-<span class=\"hljs-number\">1</span>);<br>\t\t&#125;<span class=\"hljs-keyword\">else</span> &#123;<br>\t\t\tSystem.out.println(r);<br>\t\t&#125;<br>\t&#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"第二章-字符串基础\"><a href=\"#第二章-字符串基础\" class=\"headerlink\" title=\"第二章 字符串基础\"></a>第二章 字符串基础</h1><h2 id=\"常用API\"><a href=\"#常用API\" class=\"headerlink\" title=\"常用API\"></a>常用API</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">m</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;abcde&quot;</span>;<br><br><span class=\"hljs-type\">char</span> <span class=\"hljs-variable\">ch</span> <span class=\"hljs-operator\">=</span> m.charAt(String n);<span class=\"hljs-comment\">//获取字符串m的第(n+1)个字符</span><br><span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">length</span> <span class=\"hljs-operator\">=</span> m.length();<span class=\"hljs-comment\">//获取字符串m的长度</span><br><span class=\"hljs-type\">boolean</span> <span class=\"hljs-variable\">flag</span> <span class=\"hljs-operator\">=</span> m.equals(String n);<span class=\"hljs-comment\">//判断字符串m和n是否相等,严格区分大小写</span><br><span class=\"hljs-type\">boolean</span> <span class=\"hljs-variable\">flag</span> <span class=\"hljs-operator\">=</span> m.equalsIgnoreCase(String n);<span class=\"hljs-comment\">//判断字符串m和n是否相等,不区分大小写</span><br><span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">len</span> <span class=\"hljs-operator\">=</span> m.index(String s);<span class=\"hljs-comment\">//返回字符串s在m中第一次出现的位置</span><br><span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">compare</span> <span class=\"hljs-operator\">=</span> m.compareTo(String anotherString);<span class=\"hljs-comment\">//按字典序比较两个字符串,若compare&gt;0,m大,若compare&lt;0,m小</span><br><span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">s</span> <span class=\"hljs-operator\">=</span> m.concat(n);<span class=\"hljs-comment\">//将字符串n拼接到字符串m的结尾</span><br><span class=\"hljs-type\">boolean</span> <span class=\"hljs-variable\">flag</span> <span class=\"hljs-operator\">=</span> m.contains(String n);<span class=\"hljs-comment\">//判断字符串m是否包含字符串n</span><br><span class=\"hljs-type\">boolean</span> <span class=\"hljs-variable\">flag</span> <span class=\"hljs-operator\">=</span> m.endsWith(String s);<span class=\"hljs-comment\">//判断字符串m是否以字符串s结尾</span><br>String[] s = m.split(<span class=\"hljs-string\">&quot; &quot;</span>);<span class=\"hljs-comment\">//根据正则表达式拆分字符串m</span><br><span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">s</span> <span class=\"hljs-operator\">=</span> m.trim();<span class=\"hljs-comment\">//删除字符串m的前导空格和尾部空格</span><br><span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">s</span> <span class=\"hljs-operator\">=</span> m.subString(<span class=\"hljs-type\">int</span> i,<span class=\"hljs-type\">int</span> j);<span class=\"hljs-comment\">//截取字符串m中下标为i至下标为j-1的部分,即[i,j);</span><br>...<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"周期串\"><a href=\"#周期串\" class=\"headerlink\" title=\"周期串\"></a>周期串</h2><p>思路：从 1 开始枚举周期 T 的大小，然后判断每个周期内的对应字符是否相同，如果不同，则直接判断下一个 T 。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">cycle</span><span class=\"hljs-params\">(String s)</span>&#123;<br>    <span class=\"hljs-type\">char</span>[] ch = s.toCharArray();<br>    <span class=\"hljs-type\">int</span> T;<br>    <span class=\"hljs-keyword\">for</span>(T=<span class=\"hljs-number\">1</span>;T&lt;=ch.length;T++)&#123;<br>        <span class=\"hljs-keyword\">if</span>(ch.length%T==<span class=\"hljs-number\">0</span>)&#123;<span class=\"hljs-comment\">//周期串的长度一定是周期T的倍数</span><br>            <span class=\"hljs-type\">boolean</span> <span class=\"hljs-variable\">flag</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-literal\">true</span>;<br>            <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">start</span> <span class=\"hljs-operator\">=</span> T;start&lt;ch.length;start++)&#123;<br>                <span class=\"hljs-keyword\">if</span>(ch[start]!=ch[start%T])&#123;<br>                    flag = <span class=\"hljs-literal\">false</span>;<br>                    <span class=\"hljs-keyword\">break</span>;<br>                &#125;<br>            &#125;<br>            <span class=\"hljs-keyword\">if</span>(flag)&#123;<br>                <span class=\"hljs-keyword\">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> T;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>思路：pos 表示第二行的字符串向右移动的格数，如果移动后，第二行的字符串与第一行字符串对应位置的字符全部相同，则 pos 就是这个字符串的周期。</p>\n<p><img src=\"https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311182102202.png\" alt=\"image-20231118203417476\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">cycle</span><span class=\"hljs-params\">(String s)</span>&#123;<br>\t<span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">m</span> <span class=\"hljs-operator\">=</span> s+s;<br>    <span class=\"hljs-type\">int</span> pos;<br>    <span class=\"hljs-keyword\">for</span>(pos=<span class=\"hljs-number\">1</span>;pos&lt;=s.length();pos++)&#123;<br>        <span class=\"hljs-keyword\">if</span>(s.length()%pos!=<span class=\"hljs-number\">0</span>)<br>            <span class=\"hljs-keyword\">continue</span>;<br>        <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">x</span> <span class=\"hljs-operator\">=</span> m.substring(pos,pos+s.length());<br>        <span class=\"hljs-keyword\">if</span>(x.equals(s))<br>            <span class=\"hljs-keyword\">break</span>;<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> pos;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>思路：如果一个字符串 sub 是字符串 s 的周期，那么将字符串 s 中所有的 sub 全部替换为空字符串之后，字符串的长度如果为 0 ，就表示字符串 sub 是字符串 s 的周期。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">cycle</span><span class=\"hljs-params\">(String s)</span>&#123;<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">1</span>;i&lt;=s.length();i++)&#123;<br>        <span class=\"hljs-keyword\">if</span>(s.length()%i==<span class=\"hljs-number\">0</span>)&#123;<br>            <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">sub</span> <span class=\"hljs-operator\">=</span> s.substring(<span class=\"hljs-number\">0</span>,i);<br>            <span class=\"hljs-keyword\">if</span>(s.replace(sub,<span class=\"hljs-string\">&quot;&quot;</span>).length()==<span class=\"hljs-number\">0</span>)<br>                <span class=\"hljs-keyword\">return</span> i;<br>        &#125;<br>        <br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"例题：重复字符串\"><a href=\"#例题：重复字符串\" class=\"headerlink\" title=\"例题：重复字符串\"></a>例题：重复字符串</h4><p>题目链接：<a href=\"https://www.lanqiao.cn/problems/1049/learning/\">重复字符串 - 蓝桥云课 (lanqiao.cn)</a></p>\n<p><img src=\"https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311182102203.png\" alt=\"image-20231118203511964\"></p>\n<p>思路：已知重复次数为 K ，那么周期就是 S.length() / K ，然后只需要求出每一个周期的第 i 个字符，出现次数最多的字符是哪个，然后将其余字符全部改为它，那么就将 S 改为了重复 K 次的字符串，此时修改次数也是最少的。以abdcbbcaabca ， 重复 3 次为例：</p>\n<p>​        将此字符串拆分为三个部分后，每个周期写在一行，结果为：</p>\n<p>​             abdc<br>​             bbca<br>​             abca</p>\n<p>​        只需要求出每一个竖列出现次数最多的字符出现的次数，然后将其余字符全部改为它，那么这一列修改次数为（K - max），然后将每一列的结果加起来，即为答案。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">import</span> java.io.BufferedReader;<br><span class=\"hljs-keyword\">import</span> java.io.IOException;<br><span class=\"hljs-keyword\">import</span> java.io.InputStreamReader;<br><span class=\"hljs-keyword\">import</span> java.io.OutputStreamWriter;<br><span class=\"hljs-keyword\">import</span> java.io.PrintWriter;<br><br><span class=\"hljs-keyword\">public</span> class 重复字符串 &#123;<br><br>\t<span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">BufferedReader</span> <span class=\"hljs-variable\">in</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">BufferedReader</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">InputStreamReader</span>(System.in));<br>\t<span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">PrintWriter</span> <span class=\"hljs-variable\">out</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">PrintWriter</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">OutputStreamWriter</span>(System.out));<br>\t<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> <span class=\"hljs-keyword\">throws</span> IOException &#123;<br>\t\t<span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">n</span> <span class=\"hljs-operator\">=</span> Integer.parseInt(in.readLine());<br>\t\t<span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">a</span> <span class=\"hljs-operator\">=</span> in.readLine();<br>\t\t<span class=\"hljs-keyword\">if</span>(a.length()%n!=<span class=\"hljs-number\">0</span> || n&gt;a.length()) &#123;<br>\t\t\tSystem.out.println(-<span class=\"hljs-number\">1</span>);<br>\t\t\t<span class=\"hljs-keyword\">return</span>;<br>\t\t&#125;<br>\t\t<span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">t</span> <span class=\"hljs-operator\">=</span> a.length() / n;<br>\t\t<span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">index</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span>;<br>\t\t<span class=\"hljs-type\">char</span>[][] ch = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">char</span>[n][t];<br>\t\t<span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;n;i++) <br>\t\t\t<span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> j=<span class=\"hljs-number\">0</span>;j&lt;t;j++)<br>\t\t\t\tch[i][j] = a.charAt(index++);<br>\t\t<span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">ans</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span>;<br>\t\t<span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;t;i++) &#123;<br>\t\t\t<span class=\"hljs-type\">int</span>[] num = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">int</span>[<span class=\"hljs-number\">26</span>];<br>\t\t\t<span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">max</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span>;<br>\t\t\t<span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> j=<span class=\"hljs-number\">0</span>;j&lt;n;j++) &#123;<br>\t\t\t\tnum[ch[j][i]-<span class=\"hljs-string\">&#x27;a&#x27;</span>]++;<br>\t\t\t\t<span class=\"hljs-keyword\">if</span>(max&lt;num[ch[j][i]-<span class=\"hljs-string\">&#x27;a&#x27;</span>]) &#123;<br>\t\t\t\t\tmax = num[ch[j][i]-<span class=\"hljs-string\">&#x27;a&#x27;</span>];<br>\t\t\t\t&#125;<br>\t\t\t&#125;<br>\t\t\tans = ans + (n-max);<br>\t\t&#125;<br>\t\tSystem.out.println(ans);<br>\t&#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h1 id=\"第三章-排序\"><a href=\"#第三章-排序\" class=\"headerlink\" title=\"第三章 排序\"></a>第三章 排序</h1><h2 id=\"冒泡排序\"><a href=\"#冒泡排序\" class=\"headerlink\" title=\"冒泡排序\"></a>冒泡排序</h2><p>思路：每一次循环将最大值 / 最小值放于向后移动。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs jAVA\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">int</span>[] sort(<span class=\"hljs-type\">int</span>[] a)&#123;<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;a.length-<span class=\"hljs-number\">1</span>;i++)&#123;<br>        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> j=<span class=\"hljs-number\">0</span>;j&lt;a.length-<span class=\"hljs-number\">1</span>-i;j++)&#123;<br>            <span class=\"hljs-keyword\">if</span>(a[j]&gt;a[j+<span class=\"hljs-number\">1</span>])&#123;<br>                <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">temp</span> <span class=\"hljs-operator\">=</span> a[j+<span class=\"hljs-number\">1</span>];<br>                a[j+<span class=\"hljs-number\">1</span>] = a[j];<br>                a[j] = temp;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> a;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"插入排序\"><a href=\"#插入排序\" class=\"headerlink\" title=\"插入排序\"></a>插入排序</h2><p>思路：第 i 趟，把第 i 个元素放到前 i - 1 个有序的序列中 。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">int</span>[] InsertSort(<span class=\"hljs-type\">int</span>[] a)&#123;<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">1</span>;i&lt;a.length;i++)&#123;<br>        <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">temp</span> <span class=\"hljs-operator\">=</span> a[i];<span class=\"hljs-comment\">//处理第i个元素</span><br>        <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">j</span> <span class=\"hljs-operator\">=</span> i-<span class=\"hljs-number\">1</span>;<br>        <span class=\"hljs-keyword\">for</span>(;j&gt;=<span class=\"hljs-number\">0</span> &amp;&amp; a[j]&gt;temp;j--)&#123;<br>            a[j+<span class=\"hljs-number\">1</span>] = a[j];<span class=\"hljs-comment\">//大的元素往后移</span><br>        &#125;<br>        a[j+<span class=\"hljs-number\">1</span>] = temp;<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> a;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"选择排序\"><a href=\"#选择排序\" class=\"headerlink\" title=\"选择排序\"></a>选择排序</h2><p>思路：第 i 趟把从 i ~ 结尾最小的元素找到，放到 i 位置。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">int</span>[] SelectedSort(<span class=\"hljs-type\">int</span>[] a)&#123;<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;a.length;i++)&#123;<br>        <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">min</span> <span class=\"hljs-operator\">=</span> i;<span class=\"hljs-comment\">//存放i+1到最后最小的元素所在的下标</span><br>     \t<span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> j=i+<span class=\"hljs-number\">1</span>;j&lt;a.length;j++)&#123;<br>            <span class=\"hljs-keyword\">if</span>(a[j]&lt;a[min])<br>                min = j;<br>        &#125;<br>        <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">temp</span> <span class=\"hljs-operator\">=</span> a[i];<br>        a[i] = a[min];<br>        a[min] = temp;<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> a;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"希尔排序\"><a href=\"#希尔排序\" class=\"headerlink\" title=\"希尔排序\"></a>希尔排序</h2><p>思路：将排序的区间分成若干个有跨度的子区间，对每一个子区间，进行插入排序，跨度不断 / 2 ，最终当跨度为 1 的时候，进行一个插入排序。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">int</span>[] shell(<span class=\"hljs-type\">int</span>[] a)&#123;<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">gap</span> <span class=\"hljs-operator\">=</span> a.length/<span class=\"hljs-number\">2</span>;gap&gt;<span class=\"hljs-number\">0</span>;gap/=<span class=\"hljs-number\">2</span>)&#123;<br>        <span class=\"hljs-comment\">//对每一分组进行直接插入排序</span><br>        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i=gap;i&lt;a.length;i++)&#123;<br>            <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">j</span> <span class=\"hljs-operator\">=</span> i;<br>            <span class=\"hljs-keyword\">while</span>(j-gap&gt;=<span class=\"hljs-number\">0</span> &amp;&amp; a[j-gap]&gt;a[j])&#123;<span class=\"hljs-comment\">//大的往后移动</span><br>                <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">temp</span> <span class=\"hljs-operator\">=</span> a[j];<br>                a[j] = a[j-gap];<br>                a[j-gap] = temp;<br>                j = j-gap;<span class=\"hljs-comment\">//下一次继续从分组的前一个位置开始</span><br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> a;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"计数排序\"><a href=\"#计数排序\" class=\"headerlink\" title=\"计数排序\"></a>计数排序</h2><p>思路：找出数组中的最大值和最小值，每个数都是在 min 和 max 之间，用一个长度为（max - min + 1）的数组 c 来存储每一个数出现的次数，然后将数组 c 转换为前缀和数组，则 c[ i ]，就表示不大于（i+min）的元素的个数，按照 c 数组还原排序结果。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">countSort</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span>[] a)</span>&#123;<br>\t<span class=\"hljs-type\">int</span>[] b = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">int</span>[a.length];<br>    <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">max</span> <span class=\"hljs-operator\">=</span> a[<span class=\"hljs-number\">0</span>];min = a[<span class=\"hljs-number\">0</span>];<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;a.length;i++)&#123;<br>        <span class=\"hljs-keyword\">if</span>(a[i]&gt;max) max = a[i];<br>        <span class=\"hljs-keyword\">if</span>(a[i]&lt;min) min = a[i];<br>    &#125;<br>    <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">dis</span> <span class=\"hljs-operator\">=</span> max - min + ;<br>    <span class=\"hljs-type\">int</span>[] c = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">int</span>[dis];<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;a.length;i++)<br>        c[a[i]-min]++;<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">1</span>;i&lt;c.length;i++)<br>        c[i] = c[i] + c[i-<span class=\"hljs-number\">1</span>];<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i=a.length-<span class=\"hljs-number\">1</span>;i&gt;=<span class=\"hljs-number\">0</span>;i--)&#123;<br>        b[c[a[i]-min]-<span class=\"hljs-number\">1</span>] = a[i];<br>        c[a[i]-min]--;<br>    &#125;<br>    System.out.println(Arrays.toString(b));<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h1 id=\"第四章-数据结构基础\"><a href=\"#第四章-数据结构基础\" class=\"headerlink\" title=\"第四章 数据结构基础\"></a>第四章 数据结构基础</h1><h2 id=\"链表\"><a href=\"#链表\" class=\"headerlink\" title=\"链表\"></a>链表</h2><h4 id=\"为什么要用链表\"><a href=\"#为什么要用链表\" class=\"headerlink\" title=\"为什么要用链表\"></a>为什么要用链表</h4><p>数组作为一个顺序储存方式的数据结构，可是有大作为的，它的灵活使用为我们的程序设计带来了大量的便利；但是，数组最大的缺点就是我们的插入和删除时需要移动大量的元素，所以呢，大量的消耗时间，以及冗余度难以接收。</p>\n<p>链表可以灵活地去解决这个问题，插入删除操作只需要修改指向的对象就可以了，不需要进行大量的数据移动操作。</p>\n<h4 id=\"单链表\"><a href=\"#单链表\" class=\"headerlink\" title=\"单链表\"></a>单链表</h4><h6 id=\"初始化\"><a href=\"#初始化\" class=\"headerlink\" title=\"初始化\"></a>初始化</h6><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Node</span>&#123;<span class=\"hljs-comment\">//定义结点类</span><br>    <span class=\"hljs-type\">int</span> value;<span class=\"hljs-comment\">//本身的值</span><br>    Node next;<span class=\"hljs-comment\">//指向下一个结点</span><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-title function_\">Node</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> value, Node next)</span> &#123;<br>        <span class=\"hljs-built_in\">this</span>.value = value;<br>        <span class=\"hljs-built_in\">this</span>.next = next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-type\">Node</span> <span class=\"hljs-variable\">head</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Node</span>(-<span class=\"hljs-number\">1</span>,<span class=\"hljs-literal\">null</span>);<span class=\"hljs-comment\">//头结点</span><br><span class=\"hljs-type\">Node</span> <span class=\"hljs-variable\">end</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Node</span>(-<span class=\"hljs-number\">1</span>, <span class=\"hljs-literal\">null</span>);<span class=\"hljs-comment\">//尾结点</span><br><span class=\"hljs-type\">Node</span> <span class=\"hljs-variable\">per</span> <span class=\"hljs-operator\">=</span> head;<br><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">1</span>;i&lt;=<span class=\"hljs-number\">10</span>;i++) &#123;<br>    per.next = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Node</span>(i, <span class=\"hljs-literal\">null</span>);<br>    per = per.next;<br>&#125;<br>per.next = end;<br></code></pre></td></tr></table></figure>\n\n<h6 id=\"插入\"><a href=\"#插入\" class=\"headerlink\" title=\"插入\"></a>插入</h6><p>​        插入前：</p>\n<p><img src=\"https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311182102205.png\" alt=\"image-20231118203551162\"></p>\n<p>​            插入后：</p>\n<p><img src=\"https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311182102206.png\" alt=\"image-20231118203544620\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">Node now;<span class=\"hljs-comment\">//待插入结点</span><br>now.next = head.next;<span class=\"hljs-comment\">//此节点的next为插入位置上一个结点的下一个结点</span><br>head.next = now;<span class=\"hljs-comment\">//此节点位置的上一个结点的下一个结点为now</span><br></code></pre></td></tr></table></figure>\n\n<h6 id=\"删除\"><a href=\"#删除\" class=\"headerlink\" title=\"删除\"></a>删除</h6><p>​        删除前：</p>\n<p><img src=\"https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311182102207.png\" alt=\"image-20231118203608364\"></p>\n<p>​        删除后：    </p>\n<p><img src=\"https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311182102208.png\" alt=\"image-20231118203627478\">        </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">Node now;<span class=\"hljs-comment\">//待删除结点</span><br>head.next = now.next;<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"双链表\"><a href=\"#双链表\" class=\"headerlink\" title=\"双链表\"></a>双链表</h4><h6 id=\"初始化-1\"><a href=\"#初始化-1\" class=\"headerlink\" title=\"初始化\"></a>初始化</h6><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">N</span>&#123;<br>    N last;<br>    <span class=\"hljs-type\">int</span> value;<br>    N next;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-title function_\">N</span><span class=\"hljs-params\">(N last, <span class=\"hljs-type\">int</span> value, N next)</span> &#123;<br>        <span class=\"hljs-built_in\">this</span>.last = last;<br>        <span class=\"hljs-built_in\">this</span>.value = value;<br>        <span class=\"hljs-built_in\">this</span>.next = next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-type\">Node</span> <span class=\"hljs-variable\">first</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Node</span>(<span class=\"hljs-literal\">null</span>,-<span class=\"hljs-number\">1</span>,<span class=\"hljs-literal\">null</span>);<span class=\"hljs-comment\">//头结点</span><br><span class=\"hljs-type\">Node</span> <span class=\"hljs-variable\">end</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Node</span>(<span class=\"hljs-literal\">null</span>,-<span class=\"hljs-number\">1</span>, <span class=\"hljs-literal\">null</span>);<span class=\"hljs-comment\">//尾节点</span><br><span class=\"hljs-type\">Node</span> <span class=\"hljs-variable\">per</span> <span class=\"hljs-operator\">=</span> first;<br><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">1</span>;i&lt;=<span class=\"hljs-number\">10</span>;i++) &#123;<br>    per.next = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">N</span>(per,i, <span class=\"hljs-literal\">null</span>);<br>    per = per.next;<br>&#125;<br>end.last = per;<br>per.next = end;<br></code></pre></td></tr></table></figure>\n\n<h6 id=\"插入-1\"><a href=\"#插入-1\" class=\"headerlink\" title=\"插入\"></a>插入</h6><p>​        插入前：</p>\n<p><img src=\"https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311182102209.png\" alt=\"image-20231118203704325\"></p>\n<p>​         插入后：</p>\n<p><img src=\"https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311182102210.png\" alt=\"image-20231118203719212\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">Node now;<span class=\"hljs-comment\">//待插入结点</span><br>now.next = first.next;<br>first.next.last = now;<br>first.next = now;<br>now.last = first;<br></code></pre></td></tr></table></figure>\n\n<h6 id=\"删除-1\"><a href=\"#删除-1\" class=\"headerlink\" title=\"删除\"></a>删除</h6><p>​        删除前：</p>\n<p><img src=\"https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311182102211.png\" alt=\"image-20231118203733885\"></p>\n<p>​        删除后：</p>\n<p><img src=\"https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311182102212.png\" alt=\"image-20231118203744884\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">Node now;<span class=\"hljs-comment\">//待删除结点</span><br>now.last.next = now.next;<br>now.next.last = now.last;<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"例题：左移右移（双链表解法）\"><a href=\"#例题：左移右移（双链表解法）\" class=\"headerlink\" title=\"例题：左移右移（双链表解法）\"></a>例题：左移右移（双链表解法）</h4><p>题目链接：<a href=\"https://www.lanqiao.cn/problems/2219/learning/\">左移右移 - 蓝桥云课 (lanqiao.cn)</a></p>\n<p><img src=\"https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311182102213.png\" alt=\"image-20231118203759075\"></p>\n<p>思路：</p>\n<p>​        1.创建双链表并完成初始化，初始元素为 1 ~ n；</p>\n<p>​        2.无论 x 左移或右移，都要先将 x 从原位置删除，为了便于获取 x 对应的 Node 结点，用 Map 存储 x 和 value 为 x 的结点；</p>\n<p>​        3.如果 x 为左移，就将 x 对应的 Node 结点插入到头结点后；</p>\n<p>​        4.如果 x 为右移，就将 x 对应的 Node 结点插入到尾节点前；</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">import</span> java.io.BufferedReader;<br><span class=\"hljs-keyword\">import</span> java.io.IOException;<br><span class=\"hljs-keyword\">import</span> java.io.InputStreamReader;<br><span class=\"hljs-keyword\">import</span> java.io.OutputStreamWriter;<br><span class=\"hljs-keyword\">import</span> java.io.PrintWriter;<br><span class=\"hljs-keyword\">import</span> java.util.HashMap;<br><span class=\"hljs-keyword\">import</span> java.util.Map;<br><br><span class=\"hljs-keyword\">public</span> class 左移右移_双链表 &#123;<br>\t<span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Node</span>&#123;<br>\t\tNode up;<br>\t\t<span class=\"hljs-type\">int</span> value;<br>\t\tNode down;<br>\t\t<span class=\"hljs-keyword\">public</span> <span class=\"hljs-title function_\">Node</span><span class=\"hljs-params\">(Node up, <span class=\"hljs-type\">int</span> value, Node down)</span> &#123;<br>\t\t\t<span class=\"hljs-built_in\">this</span>.up = up;<br>\t\t\t<span class=\"hljs-built_in\">this</span>.value = value;<br>\t\t\t<span class=\"hljs-built_in\">this</span>.down = down;<br>\t\t&#125;<br>\t&#125;<br>\t<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> <span class=\"hljs-keyword\">throws</span> IOException&#123;<br>        <span class=\"hljs-type\">BufferedReader</span> <span class=\"hljs-variable\">in</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">BufferedReader</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">InputStreamReader</span>(System.in));<br>        <span class=\"hljs-type\">PrintWriter</span> <span class=\"hljs-variable\">out</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">PrintWriter</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">OutputStreamWriter</span>(System.out));<br>        String[] s = in.readLine().split(<span class=\"hljs-string\">&quot; &quot;</span>);<br>        <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">n</span> <span class=\"hljs-operator\">=</span> Integer.parseInt(s[<span class=\"hljs-number\">0</span>]);<br>        <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">m</span> <span class=\"hljs-operator\">=</span> Integer.parseInt(s[<span class=\"hljs-number\">1</span>]);<br>        Map&lt;Integer, Node&gt; map = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">HashMap</span>&lt;&gt;();<br>        <span class=\"hljs-type\">Node</span> <span class=\"hljs-variable\">first</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Node</span>(<span class=\"hljs-literal\">null</span>, -<span class=\"hljs-number\">1</span>, <span class=\"hljs-literal\">null</span>);<br>        <span class=\"hljs-type\">Node</span> <span class=\"hljs-variable\">last</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Node</span>(<span class=\"hljs-literal\">null</span>, -<span class=\"hljs-number\">1</span>, <span class=\"hljs-literal\">null</span>);<br>        <span class=\"hljs-type\">Node</span> <span class=\"hljs-variable\">no</span> <span class=\"hljs-operator\">=</span> first;<br>        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">1</span>;i&lt;=n;i++) &#123;<br>        \tno.down = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Node</span>(no, i, <span class=\"hljs-literal\">null</span>);<br>        \tno = no.down;<br>        \tmap.put(i, no);<br>        &#125;<br>        last.up = no;<br>        no.down = last;<br>        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;m;i++) &#123;<br>        \ts = in.readLine().split(<span class=\"hljs-string\">&quot; &quot;</span>);<br>        \t<span class=\"hljs-type\">char</span> <span class=\"hljs-variable\">ch</span> <span class=\"hljs-operator\">=</span> s[<span class=\"hljs-number\">0</span>].charAt(<span class=\"hljs-number\">0</span>);<br>        \t<span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">x</span> <span class=\"hljs-operator\">=</span> Integer.parseInt(s[<span class=\"hljs-number\">1</span>]);<br>        \t<span class=\"hljs-type\">Node</span> <span class=\"hljs-variable\">node</span> <span class=\"hljs-operator\">=</span> map.get(x);<br>        \tnode.up.down = node.down;<br>        \tnode.down.up = node.up;<br>        \t<span class=\"hljs-keyword\">if</span>(ch==<span class=\"hljs-string\">&#x27;L&#x27;</span>) &#123;<br>        \t\tnode.down = first.down;<br>        \t\tfirst.down.up = node;<br>        \t\tfirst.down = node;<br>        \t\tnode.up = first;<br>        \t&#125;<span class=\"hljs-keyword\">else</span> &#123;<br>        \t\tnode.up = last.up;<br>        \t\tlast.up.down = node;<br>        \t\tnode.down = last;<br>        \t\tlast.up = node;<br>        \t&#125;<br>        &#125;<br>        no = first.down;<br>        <span class=\"hljs-keyword\">while</span>(no!=last) &#123;<br>        \tSystem.out.print(no.value+<span class=\"hljs-string\">&quot; &quot;</span>);<br>        \tno = no.down; <br>        &#125;<br>\t&#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"栈\"><a href=\"#栈\" class=\"headerlink\" title=\"栈\"></a>栈</h2><h4 id=\"栈-1\"><a href=\"#栈-1\" class=\"headerlink\" title=\"栈\"></a>栈</h4><p>栈（Stack）：是只允许在一端进行插入或删除的线性表。首先栈是一种线性表，但限定这种线性表只能在某一端进行插入和删除操作。</p>\n<p>栈顶（Top）：线性表允许进行插入删除的那一端。</p>\n<p>栈底（Bottom）：固定的，不允许进行插入和删除的另一端。</p>\n<p><img src=\"https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311182102214.png\" alt=\"image-20231118203841538\"></p>\n<h4 id=\"常用方法\"><a href=\"#常用方法\" class=\"headerlink\" title=\"常用方法\"></a>常用方法</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">Stack&lt;Integer&gt; stack = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Stack</span>();<br><span class=\"hljs-type\">boolean</span> <span class=\"hljs-variable\">is</span> <span class=\"hljs-operator\">=</span> stack.isEmpty();<span class=\"hljs-comment\">//判断此栈是否为空</span><br><span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">n</span> <span class=\"hljs-operator\">=</span> stack.peek();<span class=\"hljs-comment\">//获取栈顶的元素，但不删除</span><br><span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">m</span> <span class=\"hljs-operator\">=</span> stacl.pop();<span class=\"hljs-comment\">//获取并删除栈顶的元素</span><br>stack.push(<span class=\"hljs-number\">10</span>);<span class=\"hljs-comment\">//将10压入栈中</span><br>stack.clear();<span class=\"hljs-comment\">//清空栈</span><br></code></pre></td></tr></table></figure>\n\n<h4 id=\"判断括号序列是否合法\"><a href=\"#判断括号序列是否合法\" class=\"headerlink\" title=\"判断括号序列是否合法\"></a>判断括号序列是否合法</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">boolean</span> <span class=\"hljs-title function_\">check</span><span class=\"hljs-params\">(String s)</span>&#123;<br>    Stack&lt;Character&gt; stack = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Stack</span>();<br>    <span class=\"hljs-type\">char</span>[] ch = s.toCharArray();<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;ch.length;i++)&#123;<br>        <span class=\"hljs-keyword\">if</span>(ch[i]==<span class=\"hljs-string\">&#x27;(&#x27;</span>)<br>            stack.push(ch[i]);<br>        <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(stack.isEmpty())<br>            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;<br>        <span class=\"hljs-keyword\">else</span><br>            stack.pop();<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> stack.isEmpty();<br>&#125;<br></code></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"队列\"><a href=\"#队列\" class=\"headerlink\" title=\"队列\"></a>队列</h2><h4 id=\"队列-1\"><a href=\"#队列-1\" class=\"headerlink\" title=\"队列\"></a>队列</h4><p>队列（queue）是一种先进先出的、操作受限的线性表。</p>\n<p><img src=\"https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311182102215.png\" alt=\"image-20231118203904215\"></p>\n<p>队列这种数据结构非常容易理解，就像我们平时去超市买东西，在收银台结账的时候需要排队，先去排队的就先结账出去，排在后面的就后结账，有其他人再要过来结账，必须排在队尾不能在队中间插队。</p>\n<h4 id=\"常用方法-1\"><a href=\"#常用方法-1\" class=\"headerlink\" title=\"常用方法\"></a>常用方法</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">Queue&lt;Integer&gt; queue = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">LinkedList</span>&lt;&gt;();<br>queue.peek();<span class=\"hljs-comment\">//获取队头元素，但不删除</span><br>queue.poll();<span class=\"hljs-comment\">//获取并删除队头元素</span><br>queue.clear();<span class=\"hljs-comment\">//清空队列</span><br>queue.push(<span class=\"hljs-number\">11</span>);<span class=\"hljs-comment\">//将11存放到队列中</span><br></code></pre></td></tr></table></figure>\n\n<h4 id=\"例题：左移右移（栈-队列解法）\"><a href=\"#例题：左移右移（栈-队列解法）\" class=\"headerlink\" title=\"例题：左移右移（栈 + 队列解法）\"></a>例题：左移右移（栈 + 队列解法）</h4><p>题目链接：<a href=\"https://www.lanqiao.cn/problems/2219/learning/\">左移右移 - 蓝桥云课 (lanqiao.cn)</a></p>\n<p><img src=\"https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311182102217.png\" alt=\"image-20231118203920958\"></p>\n<p>思路：</p>\n<p>​        1.如果一个数先移动到最左边，再移动到最右边，那么最后输出的时候这个数一定是在最右边，也就是一个数最终出现在哪里，以他最后一次出现为准；</p>\n<p>​        2.为了避免一个数重复判断，而且要以他最后一次出现时的 L 和 R 操作为最终操作，所以可以先将全部输入分别存放到 char 类型数组和 int 类型数组中，然后逆序判断，并且用一个数组来表示这个 x 有没有出现过；</p>\n<p>​        3.因为要对输入做逆序操作，所以，逆序时最后出现的 L 对应的 x 在输出的最前面，然后之后出现的 L 对应的 x 依次输出，即先入先出，可以用队列来存储进行 L 操作的 x ；</p>\n<p>​        4.逆序时最后出现的 R 对应的 x 在输出的最后面，然后之后出现的 R 对应的 x 依次在前，即后入先出，可以用栈来存储进行 R 操作的 x ；</p>\n<p>​        5.输出时，先输出队列中的元素，然后将 1 ~ n 中没有出现过的值按序输出，最后输出栈中的元素；</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">import</span> java.io.BufferedReader;<br><span class=\"hljs-keyword\">import</span> java.io.IOException;<br><span class=\"hljs-keyword\">import</span> java.io.InputStreamReader;<br><span class=\"hljs-keyword\">import</span> java.io.OutputStreamWriter;<br><span class=\"hljs-keyword\">import</span> java.io.PrintWriter;<br><span class=\"hljs-keyword\">import</span> java.util.LinkedList;<br><span class=\"hljs-keyword\">import</span> java.util.Queue;<br><span class=\"hljs-keyword\">import</span> java.util.Stack;<br><br><span class=\"hljs-keyword\">public</span> class 左移右移_栈_队列 &#123;<br><br>\t<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> <span class=\"hljs-keyword\">throws</span> IOException&#123;<br>        <span class=\"hljs-type\">BufferedReader</span> <span class=\"hljs-variable\">in</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">BufferedReader</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">InputStreamReader</span>(System.in));<br>        <span class=\"hljs-type\">PrintWriter</span> <span class=\"hljs-variable\">out</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">PrintWriter</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">OutputStreamWriter</span>(System.out));<br>        String[] s = in.readLine().split(<span class=\"hljs-string\">&quot; &quot;</span>);<br>        <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">n</span> <span class=\"hljs-operator\">=</span> Integer.parseInt(s[<span class=\"hljs-number\">0</span>]);<br>        <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">m</span> <span class=\"hljs-operator\">=</span> Integer.parseInt(s[<span class=\"hljs-number\">1</span>]);<br>        <span class=\"hljs-type\">int</span>[] a = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">int</span>[n+<span class=\"hljs-number\">1</span>];<br>        <span class=\"hljs-type\">char</span>[] c = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">char</span>[m];<br>        <span class=\"hljs-type\">int</span>[] x = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">int</span>[m];<br>        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;m;i++) &#123;<br>        \ts = in.readLine().split(<span class=\"hljs-string\">&quot; &quot;</span>);<br>            c[i] = s[<span class=\"hljs-number\">0</span>].charAt(<span class=\"hljs-number\">0</span>);<br>            x[i] = Integer.parseInt(s[<span class=\"hljs-number\">1</span>]);<br>        &#125;<br>        Stack&lt;Integer&gt; r = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Stack</span>&lt;&gt;();<br>        Queue&lt;Integer&gt; l = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">LinkedList</span>&lt;&gt;();<br>        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i=m-<span class=\"hljs-number\">1</span>;i&gt;=<span class=\"hljs-number\">0</span>;i--) &#123;<br>        \t<span class=\"hljs-keyword\">if</span>(a[x[i]]==<span class=\"hljs-number\">0</span>) &#123;<span class=\"hljs-comment\">//判断x[i]是否出现过</span><br>        \t\ta[x[i]] = <span class=\"hljs-number\">1</span>;<span class=\"hljs-comment\">//若x[i]没有出现过</span><br>        \t\t<span class=\"hljs-keyword\">if</span>(c[i]==<span class=\"hljs-string\">&#x27;L&#x27;</span>)<br>        \t\t\tl.add(x[i]);<br>        \t\t<span class=\"hljs-keyword\">else</span><br>        \t\t\tr.push(x[i]);<br>        \t&#125;<br>        &#125;<br>        <span class=\"hljs-keyword\">while</span>(l.size()!=<span class=\"hljs-number\">0</span>) <span class=\"hljs-comment\">//输出队列中元素</span><br>        \tSystem.out.print(l.poll()+<span class=\"hljs-string\">&quot; &quot;</span>);<br>        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">1</span>;i&lt;=n;i++) <br>        \t<span class=\"hljs-keyword\">if</span>(a[i]==<span class=\"hljs-number\">0</span>) <span class=\"hljs-comment\">//a[i]为0，表示i没有出现过</span><br>        \t\tSystem.out.print(i+<span class=\"hljs-string\">&quot; &quot;</span>);<br>        <span class=\"hljs-keyword\">while</span>(r.size()!=<span class=\"hljs-number\">0</span>) <span class=\"hljs-comment\">//输出栈中元素</span><br>        \tSystem.out.print(r.pop()+<span class=\"hljs-string\">&quot; &quot;</span>);<br>\t&#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h1 id=\"第五章-分治算法\"><a href=\"#第五章-分治算法\" class=\"headerlink\" title=\"第五章 分治算法\"></a>第五章 分治算法</h1><h2 id=\"归并排序\"><a href=\"#归并排序\" class=\"headerlink\" title=\"归并排序\"></a>归并排序</h2><p>思路：先把数组从中间分成前后两部分，然后分别对前后两部分进行排序，再将排好序的两部分数据合并在一起</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">mergeSort</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span>[] a,<span class=\"hljs-type\">int</span> left,<span class=\"hljs-type\">int</span> right)</span>&#123;<span class=\"hljs-comment\">//待排序数组，要排序的范围[left,right]</span><br>    <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">mid</span> <span class=\"hljs-operator\">=</span> (left+right)&gt;&gt;<span class=\"hljs-number\">1</span>;<br>    <span class=\"hljs-keyword\">if</span>(left&lt;right)&#123;<br>        mergeSort(a,left,mid);<br>        mergeSort(a,mid+<span class=\"hljs-number\">1</span>,right);<br>        merge(a,left,mid,right);<br>    &#125;<br>&#125;<br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">merge</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span>[] a,<span class=\"hljs-type\">int</span> left,<span class=\"hljs-type\">int</span> mid,<span class=\"hljs-type\">int</span> right)</span>&#123;<br>    <span class=\"hljs-type\">int</span>[] temp = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">int</span>[right-left+<span class=\"hljs-number\">1</span>];<span class=\"hljs-comment\">//临时数组，用来归并</span><br>    <span class=\"hljs-type\">int</span> i=left,j=mid+<span class=\"hljs-number\">1</span>,k=<span class=\"hljs-number\">0</span>;<span class=\"hljs-comment\">//左半段用i指向，右半段用j指向，temp数组用k指向</span><br>    <span class=\"hljs-keyword\">while</span>(i&lt;=mid &amp;&amp; j&lt;=right)&#123;<br>        <span class=\"hljs-keyword\">if</span>(a[i]&lt;a[j])<br>            temp[k++] = a[i++];<br>        <span class=\"hljs-keyword\">else</span><br>            temp[k++] = a[j++];   <br>    &#125;<br>    <span class=\"hljs-keyword\">while</span>(i&lt;=mid) temp[k++] = a[i++];<br>    <span class=\"hljs-keyword\">while</span>(j&lt;=right) temp[k++] = a[j++];<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> x=<span class=\"hljs-number\">0</span>;x&lt;temp.length;x++)&#123;<br>        a[left+x] = temp[x];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"快速排序\"><a href=\"#快速排序\" class=\"headerlink\" title=\"快速排序\"></a>快速排序</h2><p>思路：</p>\n<p>(1)首先设定一个分界值，通过该分界值将数组分成左右两部分。 </p>\n<p>(2)将大于或等于分界值的数据集中到数组右边，小于分界值的数据集中到数组的左边。此时，左边部分中各元素都小于分界值，而右边部分中各元素都大于或等于分界值。 </p>\n<p>(3)然后，左边和右边的数据可以独立排序。对于左侧的数组数据，又可以取一个分界值，将该部分数据分成左右两部分，同样在左边放置较小值，右边放置较大值。右侧的数组数据也可以做类似处理。 </p>\n<p>(4)重复上述过程，可以看出，这是一个递归定义。通过递归将左侧部分排好序后，再递归排好右侧部分的顺序。当左、右两个部分各数据排序完成后，整个数组的排序也就完成了。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">quickSort</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span>[] a,<span class=\"hljs-type\">int</span> left,<span class=\"hljs-type\">int</span> right)</span>&#123;<br>    <span class=\"hljs-keyword\">if</span>(left&gt;right) <span class=\"hljs-keyword\">return</span>;<span class=\"hljs-comment\">//区间擦肩而过，无效，不需要进行递归</span><br>    <span class=\"hljs-type\">int</span> i=left,j=right,temp = a[left];<span class=\"hljs-comment\">//a[left]作为基准点</span><br>    <span class=\"hljs-keyword\">while</span>(i!=j)&#123;<br>        <span class=\"hljs-keyword\">while</span>(a[j]&gt;=a[temp] &amp;&amp; j&gt;i)<br>            j--;<span class=\"hljs-comment\">//只要a[j]大于基准点继续往前移动j</span><br>        <span class=\"hljs-keyword\">if</span>(j&gt;i)<br>            a[i++] = a[j];<br>        <span class=\"hljs-keyword\">while</span>(a[i]&lt;=a[temp] &amp;&amp; i&lt;j)<br>            i++;<br>        <span class=\"hljs-keyword\">if</span>(i&lt;j)<br>            a[j--] = a[i];<br>    &#125;<br>    a[i] = temp;<span class=\"hljs-comment\">//基准点元素放到最终位置</span><br>    quickSort(a,left,i-<span class=\"hljs-number\">1</span>);<br>    quickSort(a,i+<span class=\"hljs-number\">1</span>,right);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"快速幂\"><a href=\"#快速幂\" class=\"headerlink\" title=\"快速幂\"></a>快速幂</h2><p>思路：每一步都把指数分成两半，而相应的底数做平方运算。这样不仅能把非常大的指数给不断变小，所需要执行的循环次数也变小，而最后表示的结果却一直不会变。</p>\n<p>例：3^10^ = 3*3*3*3*3*3*3*3*3*3 ，尽量想办法把指数变小来，这里的指数为10。</p>\n<p>3^10^=(3*3)(3*3)(3*3)(3*3)(3*3)</p>\n<p>3^10^=(3*3)^5^</p>\n<p>3^10^=9^5^</p>\n<p>此时指数由10缩减一半变成了5，而底数变成了原来的平方，求3^10^原本需要执行10次循环操作，求9^5^却只需要执行5次循环操作，但是3^10^却等于9^5^,用一次（底数做平方操作）的操作减少了原本一半的循环量，特别是在幂特别大的时候效果非常好，例如2^10000^=4^5000^,底数只是做了一个小小的平方操作，而指数就从10000变成了5000，减少了5000次的循环操作。</p>\n<p>现在问题是如何把指数5变成原来的一半，5是一个奇数，5的一半是2.5，但是指数不能为小数，因此不能简单粗暴地直接执行5/2，然而，这里还有另一种方法能表示9^5^，9^5^=9^4^*9^1^</p>\n<p>此时抽出了一个底数的一次方，这里即为9^1^，这个9^1^先单独移出来,剩下的9^4^又能够在执行“缩指数”操作了，把指数缩小一半，底数执行平方操作。9^5^=81^2^*9^1^</p>\n<p>把指数缩小一半，底数执行平方操作，9^5^=6561^1^*9^1^</p>\n<p>此时，发现指数又变成了一个奇数1，按照上面对指数为奇数的操作方法，应该抽出了一个底数的一次方，这里即为6561^1^，这个6561^1^先单独移出来，但是此时指数却变成了0，也就意味着我们无法再进行“缩指数”操作了。</p>\n<p>9^5^=（6561^0^)(9^1^)(6561^1^)=1(9^1^)(6561^1^)=(9^1^)(6561^1^)=9*6561=59049</p>\n<p>能够发现，最后的结果是9*6561。所以能发现一个规律：最后求出的幂结果实际上就是在变化过程中所有当指数为奇数时底数的乘积。</p>\n<p>继续优化：</p>\n<p>b%2==1可以用更快的“位运算”来代替，例如：b&amp;1。因为如果b为偶数，则其二进制表示的最后一位一定是0；如果b是奇数，则其二进制表示的最后一位一定是1。将他们分别与1的二进制做“与”运算，得到的就是b二进制最后一位的数字了，是0则为偶数，是1则为奇数。例如9是奇数，则9&amp;1=1；而8是偶数，则8&amp;1=0；因此奇偶数的判断就可以用“位运算”来替换了。</p>\n<p>m = m / 2也可以用更快的移位操作来代替，例如：6的四位二进制为0110，而6/2=3,3的四位二进制为0011，可以发现，a的一半，结果为a的二进制码向右移一位，即m &gt;&gt;=1。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">long</span> <span class=\"hljs-title function_\">num</span><span class=\"hljs-params\">(<span class=\"hljs-type\">long</span> n, <span class=\"hljs-type\">long</span> m, <span class=\"hljs-type\">long</span> p)</span> &#123;<br>    <span class=\"hljs-type\">long</span> <span class=\"hljs-variable\">result</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">1</span>;<br>    <span class=\"hljs-keyword\">while</span> (m &gt; <span class=\"hljs-number\">0</span>) &#123;<br>        <span class=\"hljs-keyword\">if</span> ((m &amp; <span class=\"hljs-number\">1</span> ) == <span class=\"hljs-number\">1</span>) &#123;<br>            result = result * n % p;<br>        &#125;<br>        m &gt;&gt;= <span class=\"hljs-number\">1</span>;<br>        n = (n * n) % p;<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h1 id=\"第六章-搜索\"><a href=\"#第六章-搜索\" class=\"headerlink\" title=\"第六章 搜索\"></a>第六章 搜索</h1><h2 id=\"全排列\"><a href=\"#全排列\" class=\"headerlink\" title=\"全排列\"></a>全排列</h2><h4 id=\"DFS解法\"><a href=\"#DFS解法\" class=\"headerlink\" title=\"DFS解法\"></a>DFS解法</h4><p>思路：将此过程看做一棵树，每一个结点下都会有 n 个结点表示下一个数，首先先将全部 n^n^ 个结果全部得出，然后剪枝，减去有重复数字出现的情况。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">dfs</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> depth,String ans,<span class=\"hljs-type\">int</span> n)</span>&#123;<span class=\"hljs-comment\">//当前深搜的层数，目前的结果，目标层数</span><br>    <span class=\"hljs-keyword\">if</span>(depth==n)&#123;<span class=\"hljs-comment\">//当前深搜层数=目标层数</span><br>        System.out.println(ans);<br>        <span class=\"hljs-keyword\">return</span>;<br>    &#125;<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">1</span>;i&lt;=n;i++)&#123;<br>    \t<span class=\"hljs-keyword\">if</span>(!ans.contains(i+<span class=\"hljs-string\">&quot;&quot;</span>))<span class=\"hljs-comment\">//只有当还没有用过i的时候，才会在现在的基础上继续往下拓展</span><br>\t\t\tdfs(depth+<span class=\"hljs-number\">1</span>,ans+i;n);<span class=\"hljs-comment\">//进入下一层，ans记录为进入下一层的值，n不变</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"BFS解法\"><a href=\"#BFS解法\" class=\"headerlink\" title=\"BFS解法\"></a>BFS解法</h4><p>思路：先将有重复数字的结果得出，每一个数后都可以跟 n 中可能，那么将这 n 中可能存入队列中，然后重复此过程，直到字符串的长度为 n 时，得到结果；剪枝，如果这个数字已经用过了，就直接只用下一个数字。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">bfs</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> n)</span>&#123;<br>    Queue&lt;String&gt; queue = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">LinkedList</span>&lt;&gt;();<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">1</span>;i&lt;=n;i++)<br>        queue.offer(i+<span class=\"hljs-string\">&quot;&quot;</span>);<br>    <span class=\"hljs-keyword\">while</span>(!queue.isEmpty())&#123;<br>        <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">now</span> <span class=\"hljs-operator\">=</span> queue.poll();<br>        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">1</span>;i&lt;=n;i++)&#123;<span class=\"hljs-comment\">//每个结点都向下产生n个结果</span><br>            <span class=\"hljs-keyword\">if</span>(now.contains(i+<span class=\"hljs-string\">&quot;&quot;</span>))<span class=\"hljs-comment\">//i已经使用过了</span><br>                <span class=\"hljs-keyword\">continue</span>;<br>            <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">son</span> <span class=\"hljs-operator\">=</span> head + i;<br>            <span class=\"hljs-keyword\">if</span>(son.length()==n)<br>                System.out.println(son);<br>            <span class=\"hljs-keyword\">else</span><br>                queue.offer(son);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"整数划分\"><a href=\"#整数划分\" class=\"headerlink\" title=\"整数划分\"></a>整数划分</h2><p>思路：对 n 进行划分后， n 可以被不超过 n 个数累加得到，进行累加的每一个数，也可以被不超过它本身个数累加得到。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">dfs</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> n,<span class=\"hljs-type\">int</span> nowget,<span class=\"hljs-type\">int</span> max,String ans)</span>&#123;<span class=\"hljs-comment\">//要划分的数，现在已经得到的值，目前划分已经用到的最大值，具体拆分方法</span><br>    <span class=\"hljs-keyword\">if</span>(nowget==n)&#123;<br>        ans = ans.substring(<span class=\"hljs-number\">0</span>,ans.length()-<span class=\"hljs-number\">1</span>);<br>        System.out.println(n+<span class=\"hljs-string\">&quot;=&quot;</span>+ans);<br>        <span class=\"hljs-keyword\">return</span>;<br>    &#125;<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">1</span>;i&lt;=n-nowget;i++)&#123;<span class=\"hljs-comment\">//从nowget累加到n</span><br>        <span class=\"hljs-keyword\">if</span>(i&gt;=max)<span class=\"hljs-comment\">//只有当下一个数不小于我之前用过的最大值时，才能保证整个结果为非递减</span><br>            dfs(n,nowget+i,i,ans+i+<span class=\"hljs-string\">&quot;+&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"例题\"><a href=\"#例题\" class=\"headerlink\" title=\"例题\"></a>例题</h2><h4 id=\"例题：路径之谜\"><a href=\"#例题：路径之谜\" class=\"headerlink\" title=\"例题：路径之谜\"></a>例题：路径之谜</h4><p>题目链接：<a href=\"https://www.lanqiao.cn/problems/89/learning/\">路径之谜 - 蓝桥云课 (lanqiao.cn)</a></p>\n<p><img src=\"https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311182102218.png\" alt=\"image-20231118204002349\"></p>\n<p>思路：</p>\n<p>​        1.从入口点开始，到达每一个点都将对应位置北墙和西墙的箭靶数减一，每一个点，都可以继续向四个方向继续前进（前提是这个点没有走过，在城堡范围内，且这个点对应的两个箭靶的数字不为 0 ）。</p>\n<p>​        2.如果已经到了终点，就要判断现在每一个箭靶上的数字是否都已经变为 0 ，如果是，那么此时走的路径就是正确解，否则就需要回溯，考虑其他的行走路线。</p>\n<p>​        3.回溯：因为要从已经走过的点退回来，所以在已经走过的点上射的箭要收回，箭靶数加一，并且标记此点为还没有走过。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">import</span> java.io.BufferedReader;<br><span class=\"hljs-keyword\">import</span> java.io.IOException;<br><span class=\"hljs-keyword\">import</span> java.io.InputStreamReader;<br><span class=\"hljs-keyword\">import</span> java.io.OutputStreamWriter;<br><span class=\"hljs-keyword\">import</span> java.io.PrintWriter;<br><br><span class=\"hljs-keyword\">public</span> class 路径之谜 &#123;<br>\t<span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">int</span>[] path;<span class=\"hljs-comment\">//记录最终路径，因为底面为n*n，所以走出需要2*n步</span><br>\t<span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">int</span> n;<br>\t<span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">int</span>[] cntx;<span class=\"hljs-comment\">//存储北墙箭靶数字</span><br>\t<span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">int</span>[] cnty;<span class=\"hljs-comment\">//存储西墙箭靶数字</span><br>\t<span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">boolean</span>[][] visited;<span class=\"hljs-comment\">//判断此点有没有走过</span><br>\t<span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">int</span> dx[] = &#123;<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">0</span>, -<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">0</span>&#125;;<span class=\"hljs-comment\">//到下一个点x坐标的变化量</span><br>\t<span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">int</span> dy[] = &#123;<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">0</span>, -<span class=\"hljs-number\">1</span>&#125;;<span class=\"hljs-comment\">//到下一个点y坐标的变化量</span><br>\t<span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">BufferedReader</span> <span class=\"hljs-variable\">in</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">BufferedReader</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">InputStreamReader</span>(System.in));<br>\t<span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">PrintWriter</span> <span class=\"hljs-variable\">out</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">PrintWriter</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">OutputStreamWriter</span>(System.out));<br>\t<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> <span class=\"hljs-keyword\">throws</span> IOException &#123;<br>    \tn = Integer.parseInt(in.readLine());<br>    \tcntx = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">int</span>[n];<br>    \tcnty = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">int</span>[n];<br>    \tpath = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">int</span>[n * n];<br>    \tvisited = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">boolean</span>[n][n];<br>    \tString[] s = in.readLine().split(<span class=\"hljs-string\">&quot; &quot;</span>);<br>    \t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">i</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span>; i &lt; n; i++) &#123;<br>    \t\tcntx[i] = Integer.parseInt(s[i]);<br>    \t&#125;<br>    \ts = in.readLine().split(<span class=\"hljs-string\">&quot; &quot;</span>);<br>    \t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">i</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span>; i &lt; n; i++) &#123;<br>    \t\tcnty[i] = Integer.parseInt(s[i]);<br>    \t&#125;<br>    \tdfs(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>);<span class=\"hljs-comment\">//从0,0位置开始走,目前走了0步</span><br>  &#125;<br>\t<span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">dfs</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> x, <span class=\"hljs-type\">int</span> y, <span class=\"hljs-type\">int</span> step)</span> &#123;<br>\t\tpath[step] = y * n + x; <span class=\"hljs-comment\">//将该点编号记录到路径中</span><br>\t\tvisited[x][y] = <span class=\"hljs-literal\">true</span>;<span class=\"hljs-comment\">//将该点标记为已经走过的状态</span><br>\t\tcntx[x]--;<span class=\"hljs-comment\">//拔掉对应北墙的箭</span><br>\t\tcnty[y]--;<span class=\"hljs-comment\">//拔掉对应西墙的箭</span><br>\t\t<span class=\"hljs-keyword\">if</span> (x == n - <span class=\"hljs-number\">1</span> &amp;&amp; y == n - <span class=\"hljs-number\">1</span> &amp;&amp; check())&#123;<span class=\"hljs-comment\">//判断是否到达终点</span><br>\t\t\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">i</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span>; i &lt;= step; i++)&#123;<span class=\"hljs-comment\">//输出答案</span><br>\t\t\t\tSystem.out.print(path[i]+<span class=\"hljs-string\">&quot; &quot;</span>);<br>\t\t\t&#125;<br>\t\t\t<span class=\"hljs-keyword\">return</span>;<br>\t\t&#125;<br>\t\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">i</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">4</span>; i++)&#123;<span class=\"hljs-comment\">//上下左右四个方向搜索下一步</span><br>\t\t\t<span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">xx</span> <span class=\"hljs-operator\">=</span> x + dx[i], yy = y + dy[i];<br>             <span class=\"hljs-comment\">//下一步(xx,yy)未走过且在地图范围内</span><br>\t\t\t<span class=\"hljs-keyword\">if</span> (<span class=\"hljs-number\">0</span> &lt;= xx &amp;&amp; xx &lt;= n-<span class=\"hljs-number\">1</span> &amp;&amp; yy &gt;= <span class=\"hljs-number\">0</span> &amp;&amp; yy &lt;= n-<span class=\"hljs-number\">1</span>&amp;&amp; !visited[xx][yy] )&#123;<br>\t\t\t\t<span class=\"hljs-keyword\">if</span> (cntx[xx] &gt; <span class=\"hljs-number\">0</span> &amp;&amp; cnty[yy] &gt; <span class=\"hljs-number\">0</span>)&#123;<span class=\"hljs-comment\">//该点对应箭靶上有箭，说明该点可以走</span><br>\t\t\t\t\tdfs(xx, yy, step + <span class=\"hljs-number\">1</span>);<span class=\"hljs-comment\">//搜索下一步</span><br>                    <span class=\"hljs-comment\">//要从xx,yy点回来,在xx,yy点射的箭要复原，并重新标记xx,yy点没有走过</span><br>\t\t\t\t\tvisited[xx][yy] = <span class=\"hljs-literal\">false</span>;<br>\t\t\t\t\tcntx[xx]++;<br>\t\t\t\t\tcnty[yy]++;<br>\t\t\t\t&#125;<br>\t\t\t&#125;<br>\t\t&#125;<br>\t&#125;<br>\t<span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">boolean</span> <span class=\"hljs-title function_\">check</span><span class=\"hljs-params\">()</span> &#123;<span class=\"hljs-comment\">//判断到达终点时,是否箭靶数都已经归零</span><br>\t\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">i</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span>; i &lt; n; i++) &#123;<br>\t\t\t<span class=\"hljs-keyword\">if</span> (cntx[i] != <span class=\"hljs-number\">0</span> || cnty[i] != <span class=\"hljs-number\">0</span>)<br>\t\t\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;<br>\t\t&#125;<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;<br>\t&#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"例题：迷宫\"><a href=\"#例题：迷宫\" class=\"headerlink\" title=\"例题：迷宫\"></a>例题：迷宫</h4><p>题目链接：<a href=\"https://www.lanqiao.cn/problems/602/learning/\">迷宫 - 蓝桥云课 (lanqiao.cn)</a></p>\n<p><img src=\"https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311182102219.png\" alt=\"image-20231118204041308\"></p>\n<p>思路：从起点开始，将从此点能到达的点存储到队列中，每次获取并删除队列中的第一个元素，并将其能到达且还未到达过的点（若此点已经到达过，则表示当前处理的这条路径不是最短路径）存储到队列中，若已经到达终点，则此路径为最短路径。如果队列中已经没有元素，但仍未到达迷宫终点，则表示此迷宫无解</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">import</span> java.io.BufferedReader;<br><span class=\"hljs-keyword\">import</span> java.io.IOException;<br><span class=\"hljs-keyword\">import</span> java.io.InputStreamReader;<br><span class=\"hljs-keyword\">import</span> java.io.OutputStreamWriter;<br><span class=\"hljs-keyword\">import</span> java.io.PrintWriter;<br><span class=\"hljs-keyword\">import</span> java.util.LinkedList;<br><span class=\"hljs-keyword\">import</span> java.util.Queue;<br><br><span class=\"hljs-keyword\">public</span> class 迷宫 &#123;<br>\t<span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">int</span> num;<span class=\"hljs-comment\">//存储迷宫最短路径所需要的步数</span><br>\t<span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">xsize</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">30</span>;<span class=\"hljs-comment\">//迷宫大小30行50列</span><br>\t<span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">ysize</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">50</span>;<br>\t<span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">char</span>[][] arr = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">char</span>[xsize][ysize];<span class=\"hljs-comment\">//存储迷宫：0表示路，1表示墙</span><br>\t<span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">boolean</span>[][] help = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">boolean</span>[xsize][ysize];<span class=\"hljs-comment\">//判断此点是否已经做过</span><br>\t<span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">int</span>[][] dir = &#123;&#123;<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">0</span>&#125;,&#123;<span class=\"hljs-number\">0</span>,-<span class=\"hljs-number\">1</span>&#125;,&#123;<span class=\"hljs-number\">0</span>,<span class=\"hljs-number\">1</span>&#125;,&#123;-<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">0</span>&#125;&#125;;<span class=\"hljs-comment\">//四个方向横纵坐标的变化量</span><br>\t<span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">char</span>[] sign = &#123;<span class=\"hljs-string\">&#x27;D&#x27;</span>,<span class=\"hljs-string\">&#x27;L&#x27;</span>,<span class=\"hljs-string\">&#x27;R&#x27;</span>,<span class=\"hljs-string\">&#x27;U&#x27;</span>&#125;;<span class=\"hljs-comment\">//表示四个方向</span><br>\t<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> <span class=\"hljs-keyword\">throws</span> IOException &#123;<br>\t\t<span class=\"hljs-type\">BufferedReader</span> <span class=\"hljs-variable\">in</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">BufferedReader</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">InputStreamReader</span>(System.in));<br>\t\t<span class=\"hljs-type\">PrintWriter</span> <span class=\"hljs-variable\">out</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">PrintWriter</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">OutputStreamWriter</span>(System.out));<br>\t\t<span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;xsize;i++)&#123;<br>\t\t\tarr[i] = in.readLine().toCharArray();<br>\t\t&#125;<br>\t\tout.println(bfs());<br>\t\tout.print(num);<span class=\"hljs-comment\">//额外输出最短路径需要多少步</span><br>\t\tout.flush();<br>\t&#125;<br>\t<span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> String <span class=\"hljs-title function_\">bfs</span><span class=\"hljs-params\">()</span> &#123;<br>\t\tQueue&lt;Node&gt; list = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">LinkedList</span>&lt;&gt;();<span class=\"hljs-comment\">//队列</span><br>\t\t<span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">x</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span>;<br>\t\t<span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">y</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span>;<br>\t\t<span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">runnum</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span>;<br>\t\tlist.add(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Node</span>(x,y,<span class=\"hljs-string\">&quot;&quot;</span>,runnum));<span class=\"hljs-comment\">//将起点存储到队列中</span><br>\t\t<span class=\"hljs-keyword\">while</span>(!list.isEmpty())&#123;<span class=\"hljs-comment\">//判断队列是否为空，若为空，则此迷宫没有通路</span><br>\t\t\t<span class=\"hljs-type\">Node</span> <span class=\"hljs-variable\">now</span> <span class=\"hljs-operator\">=</span> list.poll();<span class=\"hljs-comment\">//获取队列中的第一个元素并删除</span><br>\t\t\thelp[now.x][now.y] = <span class=\"hljs-literal\">true</span>;<span class=\"hljs-comment\">//将此点标记为已经走过</span><br>\t\t\t<span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;<span class=\"hljs-number\">4</span>;i++)&#123;<span class=\"hljs-comment\">//循环四次，对四个方向进行处理</span><br>\t\t\t\t<span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">xx</span> <span class=\"hljs-operator\">=</span> now.x + dir[i][<span class=\"hljs-number\">0</span>];<span class=\"hljs-comment\">//移动后的x坐标</span><br>\t\t\t\t<span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">yy</span> <span class=\"hljs-operator\">=</span> now.y + dir[i][<span class=\"hljs-number\">1</span>];<span class=\"hljs-comment\">//移动后的y坐标</span><br>                  <span class=\"hljs-comment\">//此点在迷宫范围内，未走过，不是墙</span><br>\t\t\t\t<span class=\"hljs-keyword\">if</span>(check(xx,yy) &amp;&amp; help[xx][yy]==<span class=\"hljs-literal\">false</span> &amp;&amp; arr[xx][yy]==<span class=\"hljs-string\">&#x27;0&#x27;</span>)&#123;<br>\t\t\t\t\tlist.add(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Node</span>(xx,yy,now.num + sign[i],now.runnum + <span class=\"hljs-number\">1</span>));<span class=\"hljs-comment\">//将此点存入队列中</span><br>\t\t\t\t\t<span class=\"hljs-keyword\">if</span>(xx==xsize-<span class=\"hljs-number\">1</span> &amp;&amp; yy==ysize-<span class=\"hljs-number\">1</span>)&#123;<span class=\"hljs-comment\">//如果已经到了迷宫终点</span><br>\t\t\t\t\t\tnum = now.runnum + <span class=\"hljs-number\">1</span>;<span class=\"hljs-comment\">//所需步数+1（now.runnum是到达迷宫终点前一步所需要的步数）</span><br>\t\t\t\t\t\t<span class=\"hljs-keyword\">return</span> now.num + sign[i];<span class=\"hljs-comment\">//返回通过迷宫的方式</span><br>\t\t\t\t\t&#125;<br>\t\t\t\t&#125;<br>\t\t\t&#125;<br>\t\t&#125;<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&quot;&quot;</span>;<span class=\"hljs-comment\">//空字符串，表示此迷宫无通路</span><br>\t&#125;<br>\t<span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">boolean</span> <span class=\"hljs-title function_\">check</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> xx, <span class=\"hljs-type\">int</span> yy)</span> &#123;<span class=\"hljs-comment\">//判断此点是否在迷宫范围内</span><br>\t\t<span class=\"hljs-keyword\">return</span> xx&gt;=<span class=\"hljs-number\">0</span> &amp;&amp; yy&gt;=<span class=\"hljs-number\">0</span> &amp;&amp; xx&lt;xsize &amp;&amp; yy&lt;ysize;<br>\t&#125;<br>\t<span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Node</span>&#123;<br>\t\t<span class=\"hljs-type\">int</span> x;<span class=\"hljs-comment\">//x坐标</span><br>\t\t<span class=\"hljs-type\">int</span> y;<span class=\"hljs-comment\">//y坐标</span><br>\t\t<span class=\"hljs-type\">int</span> runnum;<span class=\"hljs-comment\">//到达此点最短步数</span><br>\t\tString num;<span class=\"hljs-comment\">//到达此点的方式</span><br>\t\t<span class=\"hljs-keyword\">public</span> <span class=\"hljs-title function_\">Node</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> x, <span class=\"hljs-type\">int</span> y,String num ,<span class=\"hljs-type\">int</span> runnum)</span> &#123;<br>\t\t\t<span class=\"hljs-built_in\">super</span>();<br>\t\t\t<span class=\"hljs-built_in\">this</span>.x = x;<br>\t\t\t<span class=\"hljs-built_in\">this</span>.y = y;<br>\t\t\t<span class=\"hljs-built_in\">this</span>.num = num;<br>\t\t\t<span class=\"hljs-built_in\">this</span>.runnum = runnum;<br>\t\t&#125;<br>\t&#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h1 id=\"第七章-贪心\"><a href=\"#第七章-贪心\" class=\"headerlink\" title=\"第七章 贪心\"></a>第七章 贪心</h1><h2 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h2><p>所谓贪心算法是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，它所做出的仅仅是在某种意义上的局部最优解。<br>贪心算法没有固定的算法框架，算法设计的关键是贪心策略的选择。必须注意的是，贪心算法不是对所有问题都能得到整体最优解，选择的贪心策略必须具备无后效性（即某个状态以后的过程不会影响以前的状态，只与当前状态有关。</p>\n<h2 id=\"例题-1\"><a href=\"#例题-1\" class=\"headerlink\" title=\"例题\"></a>例题</h2><h4 id=\"例题：合并果子\"><a href=\"#例题：合并果子\" class=\"headerlink\" title=\"例题：合并果子\"></a>例题：合并果子</h4><p>题目链接：<a href=\"https://www.lanqiao.cn/problems/741/learning/\">合并果子 - 蓝桥云课 (lanqiao.cn)</a></p>\n<p><img src=\"https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311182102220.png\" alt=\"image-20231118204125650\"></p>\n<p>思路：</p>\n<p>​        1.要保证最终耗费的体力最小，那么就可以每次合并都把目前数量最少的两堆果子合并，耗费的体力就是这两堆果子树木的和，然后合并后又可以作为新的一堆果子继续去判断，直到最终只剩一堆。</p>\n<p>​        2.可以借助PriorityQueue优先队列，队列中第一个元素就是最小值，即可每次获取队列中前两个元素，然后将他们的和再次添加至队列中，直到最终队列中只剩一个元素。</p>\n<p>​        3.以题目样例为例：对于数组{pi}={1, 2, 9}，Huffman树的构造过程如下：</p>\n<p>​            3.1找到{1, 2, 9}中最小的两个数，分别是 1 和 2 ，</p>\n<p>​            3.2从{pi}中删除它们并将和 3 加入，得到{3, 9}，体力消耗为 3 。</p>\n<p>​            3.3找到{3， 9}中最小的两个数，分别是 3 和 9 ，</p>\n<p>​            3.4从{pi}中删除它们并将和 12 加入，得到{12}，费用为 12 。</p>\n<p>​            3.5现在，数组中只剩下一个数12，构造过程结束，总费用为3 + 12 = 15。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">import</span> java.io.BufferedReader;<br><span class=\"hljs-keyword\">import</span> java.io.IOException;<br><span class=\"hljs-keyword\">import</span> java.io.InputStreamReader;<br><span class=\"hljs-keyword\">import</span> java.io.OutputStreamWriter;<br><span class=\"hljs-keyword\">import</span> java.io.PrintWriter;<br><span class=\"hljs-keyword\">import</span> java.util.PriorityQueue;<br><span class=\"hljs-keyword\">import</span> java.util.Scanner;<br><span class=\"hljs-keyword\">import</span> java.util.Spliterator;<br><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Main</span> &#123;<br><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> <span class=\"hljs-keyword\">throws</span> IOException&#123;<br>        <span class=\"hljs-type\">BufferedReader</span> <span class=\"hljs-variable\">in</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">BufferedReader</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">InputStreamReader</span>(System.in));<br>        <span class=\"hljs-type\">PrintWriter</span> <span class=\"hljs-variable\">out</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">PrintWriter</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">OutputStreamWriter</span>(System.out));<br>        <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">n</span> <span class=\"hljs-operator\">=</span> Integer.parseInt(in.readLine());<br>        <span class=\"hljs-type\">long</span> <span class=\"hljs-variable\">sum</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span>;<br>        PriorityQueue&lt;Long&gt; queue = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">PriorityQueue</span>&lt;&gt;();<br>        String[] s = in.readLine().split(<span class=\"hljs-string\">&quot; &quot;</span>);<br>        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;s.length;i++) &#123;<br>            queue.add(Long.parseLong(s[i]));<br>        &#125;<br>        <span class=\"hljs-type\">long</span> <span class=\"hljs-variable\">number</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span>;<br>        <span class=\"hljs-keyword\">while</span>(queue.size()!=<span class=\"hljs-number\">1</span>) &#123;<br>            <span class=\"hljs-type\">long</span> <span class=\"hljs-variable\">a</span> <span class=\"hljs-operator\">=</span> queue.poll();<span class=\"hljs-comment\">//获取最小的一堆</span><br>            <span class=\"hljs-type\">long</span> <span class=\"hljs-variable\">b</span> <span class=\"hljs-operator\">=</span> queue.poll();<span class=\"hljs-comment\">//获取最小的一堆</span><br>            number = number + ( a + b );<span class=\"hljs-comment\">//合并这两堆耗费的体力</span><br>            queue.add((a+b));<span class=\"hljs-comment\">//将合并后的结果放回优先队列中</span><br>        &#125;<br>        System.out.println(number);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h1 id=\"第八章-树\"><a href=\"#第八章-树\" class=\"headerlink\" title=\"第八章 树\"></a>第八章 树</h1><h2 id=\"树的相关概念\"><a href=\"#树的相关概念\" class=\"headerlink\" title=\"树的相关概念\"></a>树的相关概念</h2><h4 id=\"什么是树\"><a href=\"#什么是树\" class=\"headerlink\" title=\"什么是树\"></a>什么是树</h4><p>树(Tree)是 n ( n ≧ 0 )个结点的有限集。n=0时称为空树。在任意一颗非空树中：有且仅有一个特定的称为根的结点。当n&gt;1时，其余结点可分为 m ( m &gt; 0 ) 个互不相交的有限集T1、T2、T3……、Tm，其中每个集合本身又是一棵树，并且称为根的子树。</p>\n<h4 id=\"树的基本概念\"><a href=\"#树的基本概念\" class=\"headerlink\" title=\"树的基本概念\"></a>树的基本概念</h4><p><img src=\"https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311182102221.png\" alt=\"image-20231118204210164\"></p>\n<h2 id=\"二叉树\"><a href=\"#二叉树\" class=\"headerlink\" title=\"二叉树\"></a>二叉树</h2><h4 id=\"什么是二叉树\"><a href=\"#什么是二叉树\" class=\"headerlink\" title=\"什么是二叉树\"></a>什么是二叉树</h4><p>二叉树是n(n&gt;=0)个结点的有限集合，该集合或者为空集（空二叉树）、或者由一个根结点和两颗互不相交的、分别称为根结点的左子树和右子树的二叉树组成。</p>\n<h4 id=\"二叉树的特点\"><a href=\"#二叉树的特点\" class=\"headerlink\" title=\"二叉树的特点\"></a>二叉树的特点</h4><p>​        1.二叉树中每个结点最多有两颗子树，度没有超过2的。</p>\n<p>​        2.左子树和右子树是有顺序的，不能颠倒。</p>\n<h4 id=\"满二叉树\"><a href=\"#满二叉树\" class=\"headerlink\" title=\"满二叉树\"></a>满二叉树</h4><p>在二叉树中，所有的分支节点都有左子树和右子树，并且所有的叶子都在同一层。</p>\n<h4 id=\"完全二叉树\"><a href=\"#完全二叉树\" class=\"headerlink\" title=\"完全二叉树\"></a>完全二叉树</h4><p>​        1.叶子结点只能出现在最下面两层。</p>\n<p>​        2.最下层的叶子一定集中在左部连续位置。</p>\n<p>​        3.倒数第二层，若有叶子结点，一定在右部连续位置。</p>\n<p>​        4.如果结点度为1，则该结点只有左孩子。</p>\n<p>​        5.同样结点的二叉树，完全二叉树的深度最小。</p>\n<h2 id=\"二叉树的创建和嵌套打印\"><a href=\"#二叉树的创建和嵌套打印\" class=\"headerlink\" title=\"二叉树的创建和嵌套打印\"></a>二叉树的创建和嵌套打印</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">//结点类</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">TreeNode</span>&#123;<br>    <span class=\"hljs-type\">int</span> data;<span class=\"hljs-comment\">//结点存放的数据</span><br>    TreeNode left;<span class=\"hljs-comment\">//左孩子</span><br>    TreeNode right;<span class=\"hljs-comment\">//右孩子</span><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-title function_\">TreeNode</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> data,TreeNode left,TreeNOde right)</span>&#123;<br>        <span class=\"hljs-built_in\">this</span>.data = data;<br>        <span class=\"hljs-built_in\">this</span>.left = left;<br>        <span class=\"hljs-built_in\">this</span>.right = right;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">import</span> java.util.Scanner;<br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Tree</span>&#123;<br>    TreeNode root;<span class=\"hljs-comment\">//整棵树的根节点</span><br>    <span class=\"hljs-type\">Scanner</span> <span class=\"hljs-variable\">sc</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Scanner</span>(System.in);<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-title function_\">Tree</span><span class=\"hljs-params\">()</span>&#123;<br>        root = <span class=\"hljs-literal\">null</span>;<br>    &#125;<br>    <span class=\"hljs-keyword\">public</span> TreeNode <span class=\"hljs-title function_\">createBinaryTree</span><span class=\"hljs-params\">()</span>&#123;<span class=\"hljs-comment\">//树的创建</span><br>        TreeNode t;<span class=\"hljs-comment\">//当前树的根节点</span><br>        <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">x</span> <span class=\"hljs-operator\">=</span> sc.nextInt();<br>        <span class=\"hljs-keyword\">if</span>(x==<span class=\"hljs-number\">0</span>) t=<span class=\"hljs-literal\">null</span>;<br>        <span class=\"hljs-keyword\">else</span>&#123;<br>            t = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">TreeNode</span>();<br>            t.data = x;<br>            t.left = createBinaryTree();<br>            t.right = createBinaryTree();<br>        &#125;<br>        <span class=\"hljs-keyword\">return</span> t;<br>    &#125;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">printTree</span><span class=\"hljs-params\">(TreeNode t)</span>&#123;<span class=\"hljs-comment\">//树的打印</span><br>        <span class=\"hljs-keyword\">if</span>(t!=<span class=\"hljs-literal\">null</span>)&#123;<br>            System.out.print(t.data);<br>            <span class=\"hljs-keyword\">if</span>(t.left!=<span class=\"hljs-literal\">null</span> || t.right!=<span class=\"hljs-literal\">null</span>)&#123;<br>                System.out.print(<span class=\"hljs-string\">&quot;(&quot;</span>);<br>                printTree(t.left);<br>                <span class=\"hljs-keyword\">if</span>(t.right!=<span class=\"hljs-literal\">null</span>) System.out.print(<span class=\"hljs-string\">&quot;,&quot;</span>);<br>                printTree(t.left);<br>                System.out.print(<span class=\"hljs-string\">&quot;)&quot;</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"前中后序层次遍历\"><a href=\"#前中后序层次遍历\" class=\"headerlink\" title=\"前中后序层次遍历\"></a>前中后序层次遍历</h2><h4 id=\"前序遍历\"><a href=\"#前序遍历\" class=\"headerlink\" title=\"前序遍历\"></a>前序遍历</h4><p>思路：对于每个结点，优先处理结点本身，再处理它的左孩子，最后处理它的右孩子。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">preOrder</span><span class=\"hljs-params\">(TreeNode root)</span>&#123;<br>    <span class=\"hljs-keyword\">if</span>(root!=<span class=\"hljs-literal\">null</span>)&#123;<br>        System.out.print(root.data+<span class=\"hljs-string\">&quot; &quot;</span>);<br>        preOrder(root.left);<br>        preOrder(root.right);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"中序遍历\"><a href=\"#中序遍历\" class=\"headerlink\" title=\"中序遍历\"></a>中序遍历</h4><p>思路：对于每个结点，优先处理它的左孩子，再处理它本身，最后处理它的右孩子。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">midOrder</span><span class=\"hljs-params\">(TreeNode root)</span>&#123;<br>    <span class=\"hljs-keyword\">if</span>(root!=<span class=\"hljs-literal\">null</span>)&#123;<br>        midOrder(root.left);<br>        System.out.print(root.data+<span class=\"hljs-string\">&quot; &quot;</span>);<br>        midOrder(root.right);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"后序遍历\"><a href=\"#后序遍历\" class=\"headerlink\" title=\"后序遍历\"></a>后序遍历</h4><p>思路：对于每个结点，优先处理它的左节点，再处理它的右节点，最后处理它本身。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">postOrder</span><span class=\"hljs-params\">(TreeNode root)</span>&#123;<br>    <span class=\"hljs-keyword\">if</span>(root!=<span class=\"hljs-literal\">null</span>)&#123;<br>        postOrder(root.left);<br>       \tpostOrder(root.right);<br>        System.out.print(root.data+<span class=\"hljs-string\">&quot; &quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"层次遍历\"><a href=\"#层次遍历\" class=\"headerlink\" title=\"层次遍历\"></a>层次遍历</h4><p>思路：广度优先搜索；处理根节点的每一个子结点，再处理子结点的每一个子结点……直至结束。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">levelOrder</span><span class=\"hljs-params\">(TreeNode t)</span>&#123;<br>    Queue&lt;TreeNode&gt; queue = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">LinkedList</span>&lt;&gt;();<br>    <span class=\"hljs-keyword\">if</span>(t==<span class=\"hljs-literal\">null</span>) <span class=\"hljs-keyword\">return</span>;<br>    queue.offer(t);<br>    <span class=\"hljs-keyword\">while</span>(!queue.isEmpty())&#123;<br>        <span class=\"hljs-type\">TreeNode</span> <span class=\"hljs-variable\">head</span> <span class=\"hljs-operator\">=</span> queue.poll();<br>        System.out.print(head.data);<br>        <span class=\"hljs-keyword\">if</span>(head.left!=<span class=\"hljs-literal\">null</span>)<br>        \tqueue.offer(head.left);<br>        <span class=\"hljs-keyword\">if</span>(head.right!=<span class=\"hljs-literal\">null</span>)<br>        \tqueue.offer(head.right);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"求二叉树深度\"><a href=\"#求二叉树深度\" class=\"headerlink\" title=\"求二叉树深度\"></a>求二叉树深度</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">treeDepth</span><span class=\"hljs-params\">(TreeNode root)</span>&#123;<br>    <span class=\"hljs-keyword\">if</span>(root==<span class=\"hljs-literal\">null</span>) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<span class=\"hljs-comment\">//此结点不存在</span><br>    <span class=\"hljs-keyword\">return</span> Math.max(treeDepth(root.left),treeDepth(root.right))+<span class=\"hljs-number\">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"求二叉树叶子结点个数\"><a href=\"#求二叉树叶子结点个数\" class=\"headerlink\" title=\"求二叉树叶子结点个数\"></a>求二叉树叶子结点个数</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">TreeLeaf</span><span class=\"hljs-params\">(TreeNode root)</span>&#123;<br>    <span class=\"hljs-keyword\">if</span>(root==<span class=\"hljs-literal\">null</span>) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-keyword\">if</span>(root.left==<span class=\"hljs-literal\">null</span> &amp;&amp; root.right==<span class=\"hljs-literal\">null</span>) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1</span>;<span class=\"hljs-comment\">//此结点没有孩子，表示此结点为叶子结点</span><br>    <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">return</span> treeLeaf(root.left) + treeLeaf(root.right);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"重建二叉树\"><a href=\"#重建二叉树\" class=\"headerlink\" title=\"重建二叉树\"></a>重建二叉树</h2><p>思路：</p>\n<p>​        1.前序遍历为：根，{左子树}，{右子树}；可得，前序遍历的第一个结点为根结点；</p>\n<p>​        2.中序遍历为：{左子树}，根，{右子树}；可得，结点的左侧为它的左孩子树，右侧为它的右孩子树；</p>\n<p>​        3.重复此过程，重建此二叉树；</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> String <span class=\"hljs-title function_\">f</span><span class=\"hljs-params\">(String pre,String mid)</span>&#123;<span class=\"hljs-comment\">//前序遍历结果，中序遍历结果</span><br>    <span class=\"hljs-keyword\">if</span>(pre.length()==<span class=\"hljs-number\">0</span>) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&quot;&quot;</span>;<br>    <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(pre.length==<span class=\"hljs-number\">1</span>) <span class=\"hljs-keyword\">return</span> pre;<br>    <span class=\"hljs-keyword\">else</span>&#123;<br>        <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">pos</span> <span class=\"hljs-operator\">=</span> mid.indexOf(pre.charAt(<span class=\"hljs-number\">0</span>));<br>        <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">left</span> <span class=\"hljs-operator\">=</span> f(pre.substring(<span class=\"hljs-number\">1</span>,pos+<span class=\"hljs-number\">1</span>),mid.substring(<span class=\"hljs-number\">0</span>,pos));<br>        <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">right</span> <span class=\"hljs-operator\">=</span> f(pre.substring(pos+<span class=\"hljs-number\">1</span>),mid.substring(pos+<span class=\"hljs-number\">1</span>));<br>        <span class=\"hljs-keyword\">return</span> left+right+pre.charAt(<span class=\"hljs-number\">0</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h1 id=\"第九章-图\"><a href=\"#第九章-图\" class=\"headerlink\" title=\"第九章 图\"></a>第九章 图</h1><h1 id=\"第十章-动态规划\"><a href=\"#第十章-动态规划\" class=\"headerlink\" title=\"第十章 动态规划\"></a>第十章 动态规划</h1><h4 id=\"LCS-最长公共子序列\"><a href=\"#LCS-最长公共子序列\" class=\"headerlink\" title=\"LCS 最长公共子序列\"></a>LCS 最长公共子序列</h4><p>思路：</p>\n<p>​        1.用一个数组 dp[ i ][ j ] 表示 S 字符串中前 i 个字符与 T 字符串中前 j 个字符的最长上升子序列，那么 dp[ i+1 ][ j+1 ] 就是S 字符串中前 i+1 个字符与 T 字符串中前 j+1 个字符的最长上升子序列；</p>\n<p>​        2.如果此时 S 中的第 i+1 个字符与 T 中的第 j+1 个字符相同，那么 dp[ i+1 ][ j+1 ] = dp[ i ][ j ] + 1;</p>\n<p>​        3.如果此时 S 中的第 i+1 个字符与 T 中的第 j+1 个字符不同，那么 dp[ i+1 ][ j+1 ] = Math.max ( dp[ i+1 ][ j ] , dp[ i ][ j+1 ] );</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">LCS</span><span class=\"hljs-params\">(String s,String t)</span>&#123;<br>    <span class=\"hljs-type\">int</span>[][] dp=<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">int</span>[s.length()+<span class=\"hljs-number\">1</span>][t.length()+<span class=\"hljs-number\">1</span>];<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">1</span>;i&lt;=s.length();i++)&#123;<br>        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> j=<span class=\"hljs-number\">1</span>;j&lt;=t.length();j++)&#123;<br>            <span class=\"hljs-keyword\">if</span>(s.charAt(i-<span class=\"hljs-number\">1</span>)==t.charAt(j-<span class=\"hljs-number\">1</span>))<br>                dp[i][j]=dp[i-<span class=\"hljs-number\">1</span>][j-<span class=\"hljs-number\">1</span>]+<span class=\"hljs-number\">1</span>;<br>            <span class=\"hljs-keyword\">else</span><br>                dp[i][j]=Math.max(dp[i][j-<span class=\"hljs-number\">1</span>],dp[i-<span class=\"hljs-number\">1</span>][j]);<br>        &#125;<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> dp[len1][len2];<br>&#125;<br></code></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"第一章-基础数学思维与技巧\"><a href=\"#第一章-基础数学思维与技巧\" class=\"headerlink\" title=\"第一章 基础数学思维与技巧\"></a>第一章 基础数学思维与技巧</h1><h2 id=\"最大公约数\"><a href=\"#最大公约数\" class=\"headerlink\" title=\"最大公约数\"></a>最大公约数</h2><h4 id=\"求最大公约数—-欧几里得辗转相除法\"><a href=\"#求最大公约数—-欧几里得辗转相除法\" class=\"headerlink\" title=\"求最大公约数—-欧几里得辗转相除法\"></a>求最大公约数—-欧几里得辗转相除法</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">gcd</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> a,<span class=\"hljs-type\">int</span> b)</span>&#123;<br>   \t<span class=\"hljs-keyword\">while</span>(b&gt;<span class=\"hljs-number\">0</span>)&#123;<br>        <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">temp</span> <span class=\"hljs-operator\">=</span> a%b;<br>        a=b;<br>        b=temp;<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> a;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">gcd</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> a,<span class=\"hljs-type\">int</span> b)</span>&#123;<br>    <span class=\"hljs-keyword\">return</span> b==<span class=\"hljs-number\">0</span>?a:gcd(b,a%b);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"最小公倍数\"><a href=\"#最小公倍数\" class=\"headerlink\" title=\"最小公倍数\"></a>最小公倍数</h2><h4 id=\"求最大公倍数\"><a href=\"#求最大公倍数\" class=\"headerlink\" title=\"求最大公倍数\"></a>求最大公倍数</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">lcm</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> a,<span class=\"hljs-type\">int</span> b)</span>&#123;<br>    <span class=\"hljs-keyword\">return</span> a * b / gcd(a,b);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"进制转换\"><a href=\"#进制转换\" class=\"headerlink\" title=\"进制转换\"></a>进制转换</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">s</span> <span class=\"hljs-operator\">=</span> Integer.toString(a,m);<span class=\"hljs-comment\">//10进制a数转m进制数,结果为字符串</span><br><br><span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">a</span> <span class=\"hljs-operator\">=</span> Integer.parseInt(s,m);<span class=\"hljs-comment\">//把字符串s当做m进制数,将结果转为10进制数</span><br><br><span class=\"hljs-type\">BigInteger</span> <span class=\"hljs-variable\">biginteger</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">BigInteger</span>(s,m);<span class=\"hljs-comment\">//把m进制的字符串s转换成10进制数后封装成大数对象</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"位运算\"><a href=\"#位运算\" class=\"headerlink\" title=\"位运算\"></a>位运算</h2><h3 id=\"与-amp-全1为1-有0为0\"><a href=\"#与-amp-全1为1-有0为0\" class=\"headerlink\" title=\"与 &amp; (全1为1,有0为0)\"></a>与 &amp; (全1为1,有0为0)</h3><h4 id=\"判断奇偶数\"><a href=\"#判断奇偶数\" class=\"headerlink\" title=\"判断奇偶数\"></a>判断奇偶数</h4><p>奇数-二进制最后一位一定为1<br>偶数-二进制最后一位一定为0</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">boolean</span> <span class=\"hljs-title function_\">check</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> m)</span>&#123;<br>    <span class=\"hljs-keyword\">return</span> (m&amp;<span class=\"hljs-number\">1</span>)==<span class=\"hljs-number\">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"判断m是否为2的x次方\"><a href=\"#判断m是否为2的x次方\" class=\"headerlink\" title=\"判断m是否为2的x次方\"></a>判断m是否为2的x次方</h4><p>若m为2的x次方:m的二进制只有最高位为1,其余全为0,(m-1)的二进制除最高位都为1.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">boolean</span> <span class=\"hljs-title function_\">check</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> m)</span>&#123;<br>    <span class=\"hljs-keyword\">return</span> m&amp;(m-<span class=\"hljs-number\">1</span>)==<span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"异或-相同为0-不同为1\"><a href=\"#异或-相同为0-不同为1\" class=\"headerlink\" title=\"异或 ^ (相同为0,不同为1)\"></a>异或 ^ (相同为0,不同为1)</h3><h4 id=\"找到数组中只出现了一次的数\"><a href=\"#找到数组中只出现了一次的数\" class=\"headerlink\" title=\"找到数组中只出现了一次的数\"></a>找到数组中只出现了一次的数</h4><p>按位异或：相同为0，不同为1</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">x^x=<span class=\"hljs-number\">0</span>;<br><span class=\"hljs-number\">0</span>^x=x;<br>a^b^c=a^c^b;<br><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">num</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span>[] s)</span>&#123;<br>    <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">ans</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;s.length;i++)&#123;<br>        ans = ans ^ s[i];<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"移位-gt-gt-和-lt-lt\"><a href=\"#移位-gt-gt-和-lt-lt\" class=\"headerlink\" title=\"移位 &gt;&gt; 和&lt;&lt;\"></a>移位 &gt;&gt; 和&lt;&lt;</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-number\">8</span>&gt;&gt;<span class=\"hljs-number\">1</span> == <span class=\"hljs-number\">4</span><br><span class=\"hljs-number\">4</span>&gt;&gt;<span class=\"hljs-number\">1</span> == <span class=\"hljs-number\">2</span><br>    <br><span class=\"hljs-number\">2</span>&lt;&lt;<span class=\"hljs-number\">1</span> == <span class=\"hljs-number\">4</span><br><span class=\"hljs-number\">4</span>&lt;&lt;<span class=\"hljs-number\">1</span> == <span class=\"hljs-number\">8</span><br><br>n &gt;&gt; m == n / (<span class=\"hljs-number\">2</span> ^ m)<br>n &lt;&lt; m == n * (<span class=\"hljs-number\">2</span> ^ m)<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"素数\"><a href=\"#素数\" class=\"headerlink\" title=\"素数\"></a>素数</h2><h4 id=\"判断素数\"><a href=\"#判断素数\" class=\"headerlink\" title=\"判断素数\"></a>判断素数</h4><p>素数:只有1和它本身是因数 。</p>\n<p>首先，0和1不是素数，然后 i 从 2 开始判断 i 是不是 n 的因数，如果是因数，则直接返回 n 不是素数，否则，判断 i+1是不是 n 的因数，直到 i=√n 的时候，如果 i 仍然不是 n 的因数，那么 n 就是素数。</p>\n<p>注：如果一个数 a 能够整除 i ，那么 i 和 a/i 一定满足：假设 i&lt;=a/i , 那么 i&lt;=√n , &amp;&amp; a/i&gt;= √n 。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">boolean</span> <span class=\"hljs-title function_\">isprime</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> n)</span>&#123;<br>    <span class=\"hljs-keyword\">if</span>(n==<span class=\"hljs-number\">0</span> || n==<span class=\"hljs-number\">1</span>)<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">2</span>;i&lt;=n/i;i++)&#123;<br>        <span class=\"hljs-keyword\">if</span>(n%i==<span class=\"hljs-number\">0</span>)<br>            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"求1-n中的所有素数—-埃氏筛法\"><a href=\"#求1-n中的所有素数—-埃氏筛法\" class=\"headerlink\" title=\"求1~n中的所有素数—-埃氏筛法\"></a>求1~n中的所有素数—-埃氏筛法</h4><p>思路：如果一个数不是素数，那么这个数一定是 n 个素数的乘积（0和1除外），同理，素数的 k 倍数一定是合数（k&gt;=2）。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">isprime</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> n)</span>&#123;<br>    <span class=\"hljs-type\">boolean</span>[] isprime = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">boolean</span>[n+<span class=\"hljs-number\">1</span>];<span class=\"hljs-comment\">//false表示素数，true表示合数</span><br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">2</span>;i*i&lt;=n;i++) <br>        <span class=\"hljs-keyword\">if</span>(!isprime[i]) <span class=\"hljs-comment\">//i是质数</span><br>            <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> j=<span class=\"hljs-number\">2</span>;j*i&lt;=n;j++)<span class=\"hljs-comment\">//将i的倍数全部标记为合数</span><br>                isprime[i*j] = <span class=\"hljs-literal\">true</span>;<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">2</span>;i&lt;=n;i++)<br>        <span class=\"hljs-keyword\">if</span>(!isprime[i])<br>            System.out.println(i);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"求1-n中的所有素数—-欧拉筛法\"><a href=\"#求1-n中的所有素数—-欧拉筛法\" class=\"headerlink\" title=\"求1~n中的所有素数—-欧拉筛法\"></a>求1~n中的所有素数—-欧拉筛法</h4><p>思路：每个合数，只被他最小的质因子筛一次。</p>\n<p>注：与埃氏筛法不同，埃氏筛法是将素数的倍数，标记为合数；欧拉筛法是将目前已经找到的每一个素数的 i 倍标记为合数，无论 i 是否是素数，同时，如果 i 本身就是素数的倍数，那么就去执行下一个 i 。 </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">isprime</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> n)</span>&#123;<br>    <span class=\"hljs-type\">boolean</span>[] isprime = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">boolean</span>[n+<span class=\"hljs-number\">1</span>];<br>    <span class=\"hljs-type\">int</span>[] prime = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">int</span>[n];<span class=\"hljs-comment\">//存储素数</span><br>    <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">count</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span>;<span class=\"hljs-comment\">//统计目前素数个数</span><br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">2</span>;i&lt;=n;i++) &#123;<br>        <span class=\"hljs-keyword\">if</span>(!isprime[i])  <span class=\"hljs-comment\">//i是质数</span><br>            prime[count++] = i;<span class=\"hljs-comment\">//把当前素数存储到数组中count位置</span><br>        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> j=<span class=\"hljs-number\">0</span>;j&lt;count &amp;&amp; i*prime[j]&lt;=n;j++)&#123;<span class=\"hljs-comment\">//将i的倍数全部标记为合数</span><br>            isprime[i*prime[j]] = <span class=\"hljs-literal\">true</span>;<br>            <span class=\"hljs-keyword\">if</span>(i%prime[j]==<span class=\"hljs-number\">0</span>) <span class=\"hljs-keyword\">break</span>;<span class=\"hljs-comment\">//欧拉筛法精髓</span><br>        &#125;<br>    &#125;<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;count;i++)<br>        System.out.println(prime[i]);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"例题：最小质因子之和\"><a href=\"#例题：最小质因子之和\" class=\"headerlink\" title=\"例题：最小质因子之和\"></a>例题：最小质因子之和</h4><p>题目链接：<a href=\"https://www.lanqiao.cn/problems/1151/learning/\">最小质因子之和(Easy Version) - 蓝桥云课 (lanqiao.cn)</a></p>\n<p><img src=\"https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311182102197.png\" alt=\"最小质因子之和题目描述\"></p>\n<p>思路：因为题目输入为T组数据，如果单独计算每组数据，则会有部分区间的数据被重复计算，所以先通过埃氏筛法，求出每一个数的最小质因子，将结果存放在 ans 数组中，然后将 ans 数组表示为前缀和数组，此时 ans 数组中的结果就为2~n的质因子之和，此时，题目若输入 15 ，则直接输出 ans[15] 即可。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">import</span> java.io.BufferedReader;<br><span class=\"hljs-keyword\">import</span> java.io.IOException;<br><span class=\"hljs-keyword\">import</span> java.io.InputStreamReader;<br><span class=\"hljs-keyword\">import</span> java.io.OutputStreamWriter;<br><span class=\"hljs-keyword\">import</span> java.io.PrintWriter;<br><br><span class=\"hljs-keyword\">public</span> class 最小质因子之和 &#123;<br>\t<span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">boolean</span>[] isprime  = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">boolean</span>[<span class=\"hljs-number\">3000001</span>];<span class=\"hljs-comment\">//是否是素数</span><br>\t<span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">long</span>[] ans = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">long</span>[<span class=\"hljs-number\">3000001</span>];<span class=\"hljs-comment\">//存储最小质因子 i的最小质因子为ans[i]，例：ans[4] = 2</span><br>\t<span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">BufferedReader</span> <span class=\"hljs-variable\">in</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">BufferedReader</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">InputStreamReader</span>(System.in));<br>\t<span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">PrintWriter</span> <span class=\"hljs-variable\">out</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">PrintWriter</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">OutputStreamWriter</span>(System.out));<br>\t<br>\t<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> <span class=\"hljs-keyword\">throws</span> IOException&#123;<br>\t\tget(<span class=\"hljs-number\">3000000</span>);<span class=\"hljs-comment\">//题目数据范围，N最大值为3*10^6，将2~3*10^6中每一个数的最小质因子全部求出</span><br>\t\t<span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">2</span>;i&lt;=<span class=\"hljs-number\">3000000</span>;i++) &#123;<br>\t\t\tans[i] = ans[i] + ans[i-<span class=\"hljs-number\">1</span>];<span class=\"hljs-comment\">//求前缀和，此时ans[i]中存放的数就是2~i中每一个数的最小质因子的和</span><br>\t\t&#125;<br>\t\t<span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">n</span> <span class=\"hljs-operator\">=</span> Integer.parseInt(in.readLine());<br>\t\t<span class=\"hljs-keyword\">while</span>(n--&gt;<span class=\"hljs-number\">0</span>) &#123;<br>\t\t\tout.println(ans[Integer.parseInt(in.readLine())]);<br>\t\t&#125;<br>\t\tout.flush();<br>\t&#125;<br>\t<br>\t<span class=\"hljs-comment\">//找出每个数的质因子</span><br>\t<span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">get</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> n)</span> &#123;<br>\t\t<span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">2</span>;i&lt;=n;i++) &#123;<br>\t\t\t<span class=\"hljs-keyword\">if</span>(isprime[i])<span class=\"hljs-comment\">//i不是质数直接跳过,不考虑,i不能作为筛除条件</span><br>\t\t\t\t<span class=\"hljs-keyword\">continue</span>;<br>\t\t\tans[i] = i;<span class=\"hljs-comment\">//i为素数，素数的最小质因子就是其本身</span><br>\t\t\t<span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> j=<span class=\"hljs-number\">2</span>;j&lt;=n/i;j++) &#123;<span class=\"hljs-comment\">//j为倍数，将素数i的j倍数标记为合数，并将此数的最小质因子标记为i</span><br>\t\t\t\t<span class=\"hljs-keyword\">if</span>(!isprime[j*i]) &#123;<span class=\"hljs-comment\">//判断是否已经被标记过</span><br>\t\t\t\t\tisprime[j*i] = <span class=\"hljs-literal\">true</span>;<span class=\"hljs-comment\">//将i*j标记为合数</span><br>\t\t\t\t\tans[j*i] = i;<span class=\"hljs-comment\">//j*i的最小质因子是i</span><br>\t\t\t\t&#125;<br>\t\t\t&#125;<br>\t\t&#125;<br>\t&#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"回文数\"><a href=\"#回文数\" class=\"headerlink\" title=\"回文数\"></a>回文数</h2><h4 id=\"判断回文数\"><a href=\"#判断回文数\" class=\"headerlink\" title=\"判断回文数\"></a>判断回文数</h4><p>思路：将数字转换为字符串类型后，将此字符串倒转后，判断与原字符串是否相同</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">boolean</span> <span class=\"hljs-title function_\">check</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> m)</span>&#123;<br>    <span class=\"hljs-keyword\">return</span> Integer.toString(m).equals(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">StringBuffer</span>(Integer.toString(m)).reverse().toString());<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"判断数组中元素是否相同\"><a href=\"#判断数组中元素是否相同\" class=\"headerlink\" title=\"判断数组中元素是否相同\"></a>判断数组中元素是否相同</h2><p>思路：若数组中元素全部相同，则数组中的最大值应当==最小值。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">boolean</span> <span class=\"hljs-title function_\">check</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span>[] n)</span>&#123;<br>    Arrays.sort(n);<br>    <span class=\"hljs-keyword\">return</span> n[<span class=\"hljs-number\">0</span>]==n[n.length-<span class=\"hljs-number\">1</span>];<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>思路：利用Set集合自动去重，将数组中所有元素全部添加到集合中后，如果集合中只有一个元素，则表示数组中所有元素全部相同。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">boolean</span> <span class=\"hljs-title function_\">check</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span>[] n)</span>&#123;<br>    Set&lt;Integer&gt; set = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">HashSet</span>&lt;&gt;();<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;n.length;i++) &#123;<br>        set.add(n[i]);<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> set.size()==<span class=\"hljs-number\">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"日期-星期模拟\"><a href=\"#日期-星期模拟\" class=\"headerlink\" title=\"日期+星期模拟\"></a>日期+星期模拟</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> Main&#123;<br>    <span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">int</span>[] date = &#123;<span class=\"hljs-number\">0</span>,<span class=\"hljs-number\">31</span>,<span class=\"hljs-number\">28</span>,<span class=\"hljs-number\">31</span>,<span class=\"hljs-number\">30</span>,<span class=\"hljs-number\">31</span>,<span class=\"hljs-number\">30</span>,<span class=\"hljs-number\">31</span>,<span class=\"hljs-number\">31</span>,<span class=\"hljs-number\">30</span>,<span class=\"hljs-number\">31</span>,<span class=\"hljs-number\">30</span>,<span class=\"hljs-number\">31</span>&#125;;<span class=\"hljs-comment\">//存储每月天数</span><br>    <span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">y</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">2001</span>,m = <span class=\"hljs-number\">1</span>;d = <span class=\"hljs-number\">1</span>,week = <span class=\"hljs-number\">1</span>;<span class=\"hljs-comment\">//初始年,月,日,星期(根据题意选择是否需要)</span><br>    <span class=\"hljs-comment\">//week==0,表示周日,week==1,表示周一 ... week==6,表示周六</span><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span>&#123;<br>        <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">ans</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span>;<span class=\"hljs-comment\">//计数</span><br>        <span class=\"hljs-keyword\">while</span>(y!=<span class=\"hljs-number\">9999</span> || m!=<span class=\"hljs-number\">12</span>|| d!=<span class=\"hljs-number\">31</span>)&#123;<span class=\"hljs-comment\">//设置日期判断范围</span><br>            <span class=\"hljs-comment\">//判断闰年(满足其一即可):</span><br>            <span class=\"hljs-comment\">//1.可以整除400</span><br>            <span class=\"hljs-comment\">//2.可以整除4但不能整除100</span><br>            <span class=\"hljs-keyword\">if</span>(y%<span class=\"hljs-number\">400</span>==<span class=\"hljs-number\">0</span> || (y%<span class=\"hljs-number\">4</span>==<span class=\"hljs-number\">0</span>&amp;&amp; y%<span class=\"hljs-number\">100</span>!=<span class=\"hljs-number\">0</span>) date[<span class=\"hljs-number\">2</span>] = <span class=\"hljs-number\">29</span>;<br>            <span class=\"hljs-keyword\">else</span> date[<span class=\"hljs-number\">2</span>] = <span class=\"hljs-number\">28</span>;<br>            <span class=\"hljs-keyword\">if</span>(check()) ans++;<span class=\"hljs-comment\">//满足条件,计数器++;</span><br>            d++;<br>            week++;<br>            week%=<span class=\"hljs-number\">7</span>;<br>            <span class=\"hljs-keyword\">if</span>(d&gt;date[m])&#123;<br>                d = <span class=\"hljs-number\">1</span>;<br>                m++;<br>            &#125;<br>            <span class=\"hljs-keyword\">if</span>(m&gt;<span class=\"hljs-number\">12</span>)&#123;<br>                m = <span class=\"hljs-number\">1</span>;<br>                y++;<br>            &#125;<br>        &#125;<br>        <span class=\"hljs-keyword\">if</span>(check()) ans++;<span class=\"hljs-comment\">//之前结束日期并未判断,判断结束日期</span><br>        System.out.println(ans);<br>    &#125;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">boolean</span> <span class=\"hljs-title function_\">check</span><span class=\"hljs-params\">()</span>&#123;&#125;<span class=\"hljs-comment\">//根据题目要求完成</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"约数\"><a href=\"#约数\" class=\"headerlink\" title=\"约数\"></a>约数</h2><h4 id=\"唯一分解定理\"><a href=\"#唯一分解定理\" class=\"headerlink\" title=\"唯一分解定理\"></a>唯一分解定理</h4><p><img src=\"https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311182102199.png\" alt=\"image-20231118203136873\"></p>\n<h4 id=\"n的质因数个数—-唯一分解定理\"><a href=\"#n的质因数个数—-唯一分解定理\" class=\"headerlink\" title=\"n的质因数个数—-唯一分解定理\"></a>n的质因数个数—-唯一分解定理</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">num</span><span class=\"hljs-params\">(<span class=\"hljs-type\">long</span> n)</span>&#123;   <br>    <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">ans</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span>;    <br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">2</span>;i&lt;=n/i;i++)&#123;        <br>        <span class=\"hljs-keyword\">while</span>(n%i==<span class=\"hljs-number\">0</span>)&#123;            <br>            ans++;              <br>            n/=i;        <br>        &#125;    <br>    &#125;    <br>    <span class=\"hljs-keyword\">if</span>(n&gt;<span class=\"hljs-number\">1</span>)        <br>        ans++;    <br>    <span class=\"hljs-keyword\">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"n的约数个数—-唯一分解定理\"><a href=\"#n的约数个数—-唯一分解定理\" class=\"headerlink\" title=\"n的约数个数—-唯一分解定理\"></a>n的约数个数—-唯一分解定理</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">num</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> n)</span>&#123;<br>    <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">cnt</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">1</span>;<span class=\"hljs-comment\">//乘法初始值为1</span><br>    <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">bak</span> <span class=\"hljs-operator\">=</span> n;<span class=\"hljs-comment\">//备份n</span><br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">2</span>;i*i&lt;=n;i++)&#123;<br>        <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">sum</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span>;<br>        <span class=\"hljs-keyword\">while</span>(bak%i==<span class=\"hljs-number\">0</span>)&#123;<br>            sum++;<br>            bak = bak / i;<br>        &#125;<br>        cnt = cnt * (sum + <span class=\"hljs-number\">1</span>);<br>    &#125;<br>    <span class=\"hljs-keyword\">if</span>(bak&gt;<span class=\"hljs-number\">1</span>) cnt*=<span class=\"hljs-number\">2</span>;<br>    <span class=\"hljs-keyword\">return</span> cnt;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"求n-的约数个数—-唯一分解定理\"><a href=\"#求n-的约数个数—-唯一分解定理\" class=\"headerlink\" title=\"求n!的约数个数—-唯一分解定理\"></a>求n!的约数个数—-唯一分解定理</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">long</span> <span class=\"hljs-title function_\">num</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> n)</span>&#123;<br>    <span class=\"hljs-type\">int</span>[] prime = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">int</span>[n+<span class=\"hljs-number\">1</span>];<span class=\"hljs-comment\">//prime[i]表示素数i这个因子出现的次数</span><br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">2</span>;i&lt;=n;i++)&#123;<br>        <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">bak</span> <span class=\"hljs-operator\">=</span> i;<br>        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> j=<span class=\"hljs-number\">2</span>;j*j&lt;=bak;j++)&#123;<br>            <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">sum</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span>;<br>            <span class=\"hljs-keyword\">while</span>(bak%j==<span class=\"hljs-number\">0</span>)&#123;<br>                prime[j]++;<br>                bak = bak / j;<br>            &#125;<br>    \t&#125;<br>    \t<span class=\"hljs-keyword\">if</span>(bak&gt;<span class=\"hljs-number\">1</span>) prime[bak]++;<br>    &#125;<br>    <span class=\"hljs-type\">long</span> <span class=\"hljs-variable\">ans</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">1</span>;<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">2</span>;i&lt;=n;i++)&#123;<br>        <span class=\"hljs-keyword\">if</span>(prime[i]&gt;<span class=\"hljs-number\">1</span>)<br>            ans = ans * (prime[i]+<span class=\"hljs-number\">1</span>);<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> ans;\t<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"例题：数数\"><a href=\"#例题：数数\" class=\"headerlink\" title=\"例题：数数\"></a>例题：数数</h4><p>题目链接：<a href=\"https://www.lanqiao.cn/problems/2218/learning/\">数数 - 蓝桥云课 (lanqiao.cn)</a></p>\n<p><img src=\"https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311182102200.png\" alt=\"image-20231118203219627\"></p>\n<p>思路：将这个区间中的每一个数都根据唯一分解定理进行拆分，统计有多少个数的拆分结果为12</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">import</span> java.util.Scanner;<br><br><span class=\"hljs-keyword\">public</span> class 数数 &#123;<br><br>\t<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> &#123;<br>\t\t<span class=\"hljs-type\">Scanner</span> <span class=\"hljs-variable\">sc</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Scanner</span>(System.in);<br>\t\t<span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">ans</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span>;<br>\t\t<span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">2333333</span>;i&lt;=<span class=\"hljs-number\">23333333</span>;i++)<br>\t\t\t<span class=\"hljs-keyword\">if</span>(num(i)==<span class=\"hljs-number\">12</span>)<br>\t\t\t\tans++;<br>\t\tSystem.out.println(ans);<br>\t&#125;<br>\t<span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">num</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> n)</span> &#123;<br>\t\t<span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">ans</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span>;<br>\t\t<span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">2</span>;i&lt;=n/i;i++) &#123;<br>\t\t\t<span class=\"hljs-keyword\">while</span>(n%i==<span class=\"hljs-number\">0</span>) &#123;<br>\t\t\t\tn/=i;<br>\t\t\t\tans++;<br>\t\t\t&#125;<br>\t\t&#125;<br>\t\t<span class=\"hljs-keyword\">if</span>(n&gt;<span class=\"hljs-number\">1</span>)<br>\t\t\tans++;<br>\t\t<span class=\"hljs-keyword\">return</span> ans;<br>\t&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"例题：求阶乘\"><a href=\"#例题：求阶乘\" class=\"headerlink\" title=\"例题：求阶乘\"></a>例题：求阶乘</h4><p>题目链接：<a href=\"https://www.lanqiao.cn/problems/2145/learning/\">求阶乘 - 蓝桥云课 (lanqiao.cn)</a></p>\n<p><img src=\"https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311182102201.png\" alt=\"image-20231118203313070\"></p>\n<p>思路：</p>\n<p>​        1.根据唯一分解定理可知：每一个数都可以写为 n 个素数的乘积；</p>\n<p>​        2.如果一个数的结尾有 0 的存在，那么这个数分解后一定有 2 和 5 （素数中，只有2 * 5才能使结尾产生 0 ）； </p>\n<p>​        3.从 1 ~ N ，将每一个数都分解后，2 的数量一定比 5 多（ 2 每隔两个数就会最少出现一个，5 每隔5个数，最少出现一个），那么，N！末尾 0 的数量，就是将 1 ~ N 中每个数分解后，5 的数量；</p>\n<p>​        4.如果用一个循环从 5 开始，每次 +5 ，判断这些数可以拆分出几个 5 ，然后去找结尾有 k 个 0 的最小的 N 是多少，这个方法结果正确，但是时间复杂度会比较高，所以借助二分，去找到结尾有 k 个 0 的最小的 N 是多少；</p>\n<p>​        5.用二分去查找，就必须做到：已知 N ，求出 1 ~ N 中可以拆分出多少个 5 ，以 125 为例，因为每五个数才拆分出 5 ，所以，如果 1~125 都只拆一个 5 ，则可以拆分出 125 / 5 共 25 个 5 ，拆分后的结果为 1 ~ 25 ，然后继续拆分 5 ，1 ~ 25 可以拆分出 25 / 5 个 5 ，拆分后结果为 1 ~ 5 ，1 ~ 5 可以拆分出 5 / 5 个 5 ，最后剩余 1 ，1 无法继续拆分出 5 ，所以 125 可以拆分出 25 + 5 + 1 = 31 个 5 ；</p>\n<p>​        6.二分：如果mid拆分出的 5 的数量 &gt;= k，那么可以 right = mid ，反之left = mid + 1，二分结果后，还需要判断它是否确实能拆分出 k 个 5 ，因为存在一个 N!  能恰好末尾有 k 个 0 ；</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">import</span> java.util.Scanner;<br><br><span class=\"hljs-keyword\">public</span> class 求阶乘 &#123;<br>\t<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">long</span> <span class=\"hljs-title function_\">find</span><span class=\"hljs-params\">(<span class=\"hljs-type\">long</span> x)</span> &#123;<span class=\"hljs-comment\">//求x能拆分出多少个5</span><br>\t\t<span class=\"hljs-type\">long</span> <span class=\"hljs-variable\">res</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span>;<br>\t\t<span class=\"hljs-keyword\">while</span>(x != <span class=\"hljs-number\">0</span>) &#123;<br>\t\t\tres = res + x / <span class=\"hljs-number\">5</span>;<br>\t\t\tx/=<span class=\"hljs-number\">5</span>;<br>\t\t&#125;<br>\t\t<span class=\"hljs-keyword\">return</span> res;<br>\t&#125;<br>\t<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> &#123;<br>\t\t<span class=\"hljs-type\">Scanner</span> <span class=\"hljs-variable\">sc</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Scanner</span>(System.in);<br>\t\t<span class=\"hljs-type\">long</span> <span class=\"hljs-variable\">k</span> <span class=\"hljs-operator\">=</span> sc.nextLong();<br>\t\t<span class=\"hljs-type\">long</span> <span class=\"hljs-variable\">l</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span>,r = <span class=\"hljs-number\">100000</span>;<span class=\"hljs-comment\">//防止溢出</span><br>\t\t<span class=\"hljs-keyword\">while</span>(l &lt; r) &#123;<br>\t\t\t<span class=\"hljs-type\">long</span> <span class=\"hljs-variable\">mid</span> <span class=\"hljs-operator\">=</span> (l + r) / <span class=\"hljs-number\">2</span>;<br>\t\t\t<span class=\"hljs-keyword\">if</span>(k &lt;= find(mid)) &#123;<br>\t\t\t\tr = mid;<br>\t\t\t&#125;<span class=\"hljs-keyword\">else</span> &#123;<br>\t\t\t\tl = mid + <span class=\"hljs-number\">1</span>;<br>\t\t\t&#125;<br>\t\t&#125;<br>\t\t<span class=\"hljs-keyword\">if</span>(find(r) != k) &#123;<span class=\"hljs-comment\">//确保有解</span><br>\t\t\tSystem.out.println(-<span class=\"hljs-number\">1</span>);<br>\t\t&#125;<span class=\"hljs-keyword\">else</span> &#123;<br>\t\t\tSystem.out.println(r);<br>\t\t&#125;<br>\t&#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"第二章-字符串基础\"><a href=\"#第二章-字符串基础\" class=\"headerlink\" title=\"第二章 字符串基础\"></a>第二章 字符串基础</h1><h2 id=\"常用API\"><a href=\"#常用API\" class=\"headerlink\" title=\"常用API\"></a>常用API</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">m</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;abcde&quot;</span>;<br><br><span class=\"hljs-type\">char</span> <span class=\"hljs-variable\">ch</span> <span class=\"hljs-operator\">=</span> m.charAt(String n);<span class=\"hljs-comment\">//获取字符串m的第(n+1)个字符</span><br><span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">length</span> <span class=\"hljs-operator\">=</span> m.length();<span class=\"hljs-comment\">//获取字符串m的长度</span><br><span class=\"hljs-type\">boolean</span> <span class=\"hljs-variable\">flag</span> <span class=\"hljs-operator\">=</span> m.equals(String n);<span class=\"hljs-comment\">//判断字符串m和n是否相等,严格区分大小写</span><br><span class=\"hljs-type\">boolean</span> <span class=\"hljs-variable\">flag</span> <span class=\"hljs-operator\">=</span> m.equalsIgnoreCase(String n);<span class=\"hljs-comment\">//判断字符串m和n是否相等,不区分大小写</span><br><span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">len</span> <span class=\"hljs-operator\">=</span> m.index(String s);<span class=\"hljs-comment\">//返回字符串s在m中第一次出现的位置</span><br><span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">compare</span> <span class=\"hljs-operator\">=</span> m.compareTo(String anotherString);<span class=\"hljs-comment\">//按字典序比较两个字符串,若compare&gt;0,m大,若compare&lt;0,m小</span><br><span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">s</span> <span class=\"hljs-operator\">=</span> m.concat(n);<span class=\"hljs-comment\">//将字符串n拼接到字符串m的结尾</span><br><span class=\"hljs-type\">boolean</span> <span class=\"hljs-variable\">flag</span> <span class=\"hljs-operator\">=</span> m.contains(String n);<span class=\"hljs-comment\">//判断字符串m是否包含字符串n</span><br><span class=\"hljs-type\">boolean</span> <span class=\"hljs-variable\">flag</span> <span class=\"hljs-operator\">=</span> m.endsWith(String s);<span class=\"hljs-comment\">//判断字符串m是否以字符串s结尾</span><br>String[] s = m.split(<span class=\"hljs-string\">&quot; &quot;</span>);<span class=\"hljs-comment\">//根据正则表达式拆分字符串m</span><br><span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">s</span> <span class=\"hljs-operator\">=</span> m.trim();<span class=\"hljs-comment\">//删除字符串m的前导空格和尾部空格</span><br><span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">s</span> <span class=\"hljs-operator\">=</span> m.subString(<span class=\"hljs-type\">int</span> i,<span class=\"hljs-type\">int</span> j);<span class=\"hljs-comment\">//截取字符串m中下标为i至下标为j-1的部分,即[i,j);</span><br>...<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"周期串\"><a href=\"#周期串\" class=\"headerlink\" title=\"周期串\"></a>周期串</h2><p>思路：从 1 开始枚举周期 T 的大小，然后判断每个周期内的对应字符是否相同，如果不同，则直接判断下一个 T 。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">cycle</span><span class=\"hljs-params\">(String s)</span>&#123;<br>    <span class=\"hljs-type\">char</span>[] ch = s.toCharArray();<br>    <span class=\"hljs-type\">int</span> T;<br>    <span class=\"hljs-keyword\">for</span>(T=<span class=\"hljs-number\">1</span>;T&lt;=ch.length;T++)&#123;<br>        <span class=\"hljs-keyword\">if</span>(ch.length%T==<span class=\"hljs-number\">0</span>)&#123;<span class=\"hljs-comment\">//周期串的长度一定是周期T的倍数</span><br>            <span class=\"hljs-type\">boolean</span> <span class=\"hljs-variable\">flag</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-literal\">true</span>;<br>            <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">start</span> <span class=\"hljs-operator\">=</span> T;start&lt;ch.length;start++)&#123;<br>                <span class=\"hljs-keyword\">if</span>(ch[start]!=ch[start%T])&#123;<br>                    flag = <span class=\"hljs-literal\">false</span>;<br>                    <span class=\"hljs-keyword\">break</span>;<br>                &#125;<br>            &#125;<br>            <span class=\"hljs-keyword\">if</span>(flag)&#123;<br>                <span class=\"hljs-keyword\">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> T;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>思路：pos 表示第二行的字符串向右移动的格数，如果移动后，第二行的字符串与第一行字符串对应位置的字符全部相同，则 pos 就是这个字符串的周期。</p>\n<p><img src=\"https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311182102202.png\" alt=\"image-20231118203417476\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">cycle</span><span class=\"hljs-params\">(String s)</span>&#123;<br>\t<span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">m</span> <span class=\"hljs-operator\">=</span> s+s;<br>    <span class=\"hljs-type\">int</span> pos;<br>    <span class=\"hljs-keyword\">for</span>(pos=<span class=\"hljs-number\">1</span>;pos&lt;=s.length();pos++)&#123;<br>        <span class=\"hljs-keyword\">if</span>(s.length()%pos!=<span class=\"hljs-number\">0</span>)<br>            <span class=\"hljs-keyword\">continue</span>;<br>        <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">x</span> <span class=\"hljs-operator\">=</span> m.substring(pos,pos+s.length());<br>        <span class=\"hljs-keyword\">if</span>(x.equals(s))<br>            <span class=\"hljs-keyword\">break</span>;<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> pos;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>思路：如果一个字符串 sub 是字符串 s 的周期，那么将字符串 s 中所有的 sub 全部替换为空字符串之后，字符串的长度如果为 0 ，就表示字符串 sub 是字符串 s 的周期。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">cycle</span><span class=\"hljs-params\">(String s)</span>&#123;<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">1</span>;i&lt;=s.length();i++)&#123;<br>        <span class=\"hljs-keyword\">if</span>(s.length()%i==<span class=\"hljs-number\">0</span>)&#123;<br>            <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">sub</span> <span class=\"hljs-operator\">=</span> s.substring(<span class=\"hljs-number\">0</span>,i);<br>            <span class=\"hljs-keyword\">if</span>(s.replace(sub,<span class=\"hljs-string\">&quot;&quot;</span>).length()==<span class=\"hljs-number\">0</span>)<br>                <span class=\"hljs-keyword\">return</span> i;<br>        &#125;<br>        <br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"例题：重复字符串\"><a href=\"#例题：重复字符串\" class=\"headerlink\" title=\"例题：重复字符串\"></a>例题：重复字符串</h4><p>题目链接：<a href=\"https://www.lanqiao.cn/problems/1049/learning/\">重复字符串 - 蓝桥云课 (lanqiao.cn)</a></p>\n<p><img src=\"https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311182102203.png\" alt=\"image-20231118203511964\"></p>\n<p>思路：已知重复次数为 K ，那么周期就是 S.length() / K ，然后只需要求出每一个周期的第 i 个字符，出现次数最多的字符是哪个，然后将其余字符全部改为它，那么就将 S 改为了重复 K 次的字符串，此时修改次数也是最少的。以abdcbbcaabca ， 重复 3 次为例：</p>\n<p>​        将此字符串拆分为三个部分后，每个周期写在一行，结果为：</p>\n<p>​             abdc<br>​             bbca<br>​             abca</p>\n<p>​        只需要求出每一个竖列出现次数最多的字符出现的次数，然后将其余字符全部改为它，那么这一列修改次数为（K - max），然后将每一列的结果加起来，即为答案。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">import</span> java.io.BufferedReader;<br><span class=\"hljs-keyword\">import</span> java.io.IOException;<br><span class=\"hljs-keyword\">import</span> java.io.InputStreamReader;<br><span class=\"hljs-keyword\">import</span> java.io.OutputStreamWriter;<br><span class=\"hljs-keyword\">import</span> java.io.PrintWriter;<br><br><span class=\"hljs-keyword\">public</span> class 重复字符串 &#123;<br><br>\t<span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">BufferedReader</span> <span class=\"hljs-variable\">in</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">BufferedReader</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">InputStreamReader</span>(System.in));<br>\t<span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">PrintWriter</span> <span class=\"hljs-variable\">out</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">PrintWriter</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">OutputStreamWriter</span>(System.out));<br>\t<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> <span class=\"hljs-keyword\">throws</span> IOException &#123;<br>\t\t<span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">n</span> <span class=\"hljs-operator\">=</span> Integer.parseInt(in.readLine());<br>\t\t<span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">a</span> <span class=\"hljs-operator\">=</span> in.readLine();<br>\t\t<span class=\"hljs-keyword\">if</span>(a.length()%n!=<span class=\"hljs-number\">0</span> || n&gt;a.length()) &#123;<br>\t\t\tSystem.out.println(-<span class=\"hljs-number\">1</span>);<br>\t\t\t<span class=\"hljs-keyword\">return</span>;<br>\t\t&#125;<br>\t\t<span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">t</span> <span class=\"hljs-operator\">=</span> a.length() / n;<br>\t\t<span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">index</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span>;<br>\t\t<span class=\"hljs-type\">char</span>[][] ch = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">char</span>[n][t];<br>\t\t<span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;n;i++) <br>\t\t\t<span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> j=<span class=\"hljs-number\">0</span>;j&lt;t;j++)<br>\t\t\t\tch[i][j] = a.charAt(index++);<br>\t\t<span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">ans</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span>;<br>\t\t<span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;t;i++) &#123;<br>\t\t\t<span class=\"hljs-type\">int</span>[] num = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">int</span>[<span class=\"hljs-number\">26</span>];<br>\t\t\t<span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">max</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span>;<br>\t\t\t<span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> j=<span class=\"hljs-number\">0</span>;j&lt;n;j++) &#123;<br>\t\t\t\tnum[ch[j][i]-<span class=\"hljs-string\">&#x27;a&#x27;</span>]++;<br>\t\t\t\t<span class=\"hljs-keyword\">if</span>(max&lt;num[ch[j][i]-<span class=\"hljs-string\">&#x27;a&#x27;</span>]) &#123;<br>\t\t\t\t\tmax = num[ch[j][i]-<span class=\"hljs-string\">&#x27;a&#x27;</span>];<br>\t\t\t\t&#125;<br>\t\t\t&#125;<br>\t\t\tans = ans + (n-max);<br>\t\t&#125;<br>\t\tSystem.out.println(ans);<br>\t&#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h1 id=\"第三章-排序\"><a href=\"#第三章-排序\" class=\"headerlink\" title=\"第三章 排序\"></a>第三章 排序</h1><h2 id=\"冒泡排序\"><a href=\"#冒泡排序\" class=\"headerlink\" title=\"冒泡排序\"></a>冒泡排序</h2><p>思路：每一次循环将最大值 / 最小值放于向后移动。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs jAVA\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">int</span>[] sort(<span class=\"hljs-type\">int</span>[] a)&#123;<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;a.length-<span class=\"hljs-number\">1</span>;i++)&#123;<br>        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> j=<span class=\"hljs-number\">0</span>;j&lt;a.length-<span class=\"hljs-number\">1</span>-i;j++)&#123;<br>            <span class=\"hljs-keyword\">if</span>(a[j]&gt;a[j+<span class=\"hljs-number\">1</span>])&#123;<br>                <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">temp</span> <span class=\"hljs-operator\">=</span> a[j+<span class=\"hljs-number\">1</span>];<br>                a[j+<span class=\"hljs-number\">1</span>] = a[j];<br>                a[j] = temp;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> a;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"插入排序\"><a href=\"#插入排序\" class=\"headerlink\" title=\"插入排序\"></a>插入排序</h2><p>思路：第 i 趟，把第 i 个元素放到前 i - 1 个有序的序列中 。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">int</span>[] InsertSort(<span class=\"hljs-type\">int</span>[] a)&#123;<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">1</span>;i&lt;a.length;i++)&#123;<br>        <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">temp</span> <span class=\"hljs-operator\">=</span> a[i];<span class=\"hljs-comment\">//处理第i个元素</span><br>        <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">j</span> <span class=\"hljs-operator\">=</span> i-<span class=\"hljs-number\">1</span>;<br>        <span class=\"hljs-keyword\">for</span>(;j&gt;=<span class=\"hljs-number\">0</span> &amp;&amp; a[j]&gt;temp;j--)&#123;<br>            a[j+<span class=\"hljs-number\">1</span>] = a[j];<span class=\"hljs-comment\">//大的元素往后移</span><br>        &#125;<br>        a[j+<span class=\"hljs-number\">1</span>] = temp;<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> a;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"选择排序\"><a href=\"#选择排序\" class=\"headerlink\" title=\"选择排序\"></a>选择排序</h2><p>思路：第 i 趟把从 i ~ 结尾最小的元素找到，放到 i 位置。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">int</span>[] SelectedSort(<span class=\"hljs-type\">int</span>[] a)&#123;<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;a.length;i++)&#123;<br>        <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">min</span> <span class=\"hljs-operator\">=</span> i;<span class=\"hljs-comment\">//存放i+1到最后最小的元素所在的下标</span><br>     \t<span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> j=i+<span class=\"hljs-number\">1</span>;j&lt;a.length;j++)&#123;<br>            <span class=\"hljs-keyword\">if</span>(a[j]&lt;a[min])<br>                min = j;<br>        &#125;<br>        <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">temp</span> <span class=\"hljs-operator\">=</span> a[i];<br>        a[i] = a[min];<br>        a[min] = temp;<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> a;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"希尔排序\"><a href=\"#希尔排序\" class=\"headerlink\" title=\"希尔排序\"></a>希尔排序</h2><p>思路：将排序的区间分成若干个有跨度的子区间，对每一个子区间，进行插入排序，跨度不断 / 2 ，最终当跨度为 1 的时候，进行一个插入排序。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">int</span>[] shell(<span class=\"hljs-type\">int</span>[] a)&#123;<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">gap</span> <span class=\"hljs-operator\">=</span> a.length/<span class=\"hljs-number\">2</span>;gap&gt;<span class=\"hljs-number\">0</span>;gap/=<span class=\"hljs-number\">2</span>)&#123;<br>        <span class=\"hljs-comment\">//对每一分组进行直接插入排序</span><br>        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i=gap;i&lt;a.length;i++)&#123;<br>            <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">j</span> <span class=\"hljs-operator\">=</span> i;<br>            <span class=\"hljs-keyword\">while</span>(j-gap&gt;=<span class=\"hljs-number\">0</span> &amp;&amp; a[j-gap]&gt;a[j])&#123;<span class=\"hljs-comment\">//大的往后移动</span><br>                <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">temp</span> <span class=\"hljs-operator\">=</span> a[j];<br>                a[j] = a[j-gap];<br>                a[j-gap] = temp;<br>                j = j-gap;<span class=\"hljs-comment\">//下一次继续从分组的前一个位置开始</span><br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> a;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"计数排序\"><a href=\"#计数排序\" class=\"headerlink\" title=\"计数排序\"></a>计数排序</h2><p>思路：找出数组中的最大值和最小值，每个数都是在 min 和 max 之间，用一个长度为（max - min + 1）的数组 c 来存储每一个数出现的次数，然后将数组 c 转换为前缀和数组，则 c[ i ]，就表示不大于（i+min）的元素的个数，按照 c 数组还原排序结果。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">countSort</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span>[] a)</span>&#123;<br>\t<span class=\"hljs-type\">int</span>[] b = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">int</span>[a.length];<br>    <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">max</span> <span class=\"hljs-operator\">=</span> a[<span class=\"hljs-number\">0</span>];min = a[<span class=\"hljs-number\">0</span>];<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;a.length;i++)&#123;<br>        <span class=\"hljs-keyword\">if</span>(a[i]&gt;max) max = a[i];<br>        <span class=\"hljs-keyword\">if</span>(a[i]&lt;min) min = a[i];<br>    &#125;<br>    <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">dis</span> <span class=\"hljs-operator\">=</span> max - min + ;<br>    <span class=\"hljs-type\">int</span>[] c = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">int</span>[dis];<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;a.length;i++)<br>        c[a[i]-min]++;<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">1</span>;i&lt;c.length;i++)<br>        c[i] = c[i] + c[i-<span class=\"hljs-number\">1</span>];<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i=a.length-<span class=\"hljs-number\">1</span>;i&gt;=<span class=\"hljs-number\">0</span>;i--)&#123;<br>        b[c[a[i]-min]-<span class=\"hljs-number\">1</span>] = a[i];<br>        c[a[i]-min]--;<br>    &#125;<br>    System.out.println(Arrays.toString(b));<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h1 id=\"第四章-数据结构基础\"><a href=\"#第四章-数据结构基础\" class=\"headerlink\" title=\"第四章 数据结构基础\"></a>第四章 数据结构基础</h1><h2 id=\"链表\"><a href=\"#链表\" class=\"headerlink\" title=\"链表\"></a>链表</h2><h4 id=\"为什么要用链表\"><a href=\"#为什么要用链表\" class=\"headerlink\" title=\"为什么要用链表\"></a>为什么要用链表</h4><p>数组作为一个顺序储存方式的数据结构，可是有大作为的，它的灵活使用为我们的程序设计带来了大量的便利；但是，数组最大的缺点就是我们的插入和删除时需要移动大量的元素，所以呢，大量的消耗时间，以及冗余度难以接收。</p>\n<p>链表可以灵活地去解决这个问题，插入删除操作只需要修改指向的对象就可以了，不需要进行大量的数据移动操作。</p>\n<h4 id=\"单链表\"><a href=\"#单链表\" class=\"headerlink\" title=\"单链表\"></a>单链表</h4><h6 id=\"初始化\"><a href=\"#初始化\" class=\"headerlink\" title=\"初始化\"></a>初始化</h6><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Node</span>&#123;<span class=\"hljs-comment\">//定义结点类</span><br>    <span class=\"hljs-type\">int</span> value;<span class=\"hljs-comment\">//本身的值</span><br>    Node next;<span class=\"hljs-comment\">//指向下一个结点</span><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-title function_\">Node</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> value, Node next)</span> &#123;<br>        <span class=\"hljs-built_in\">this</span>.value = value;<br>        <span class=\"hljs-built_in\">this</span>.next = next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-type\">Node</span> <span class=\"hljs-variable\">head</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Node</span>(-<span class=\"hljs-number\">1</span>,<span class=\"hljs-literal\">null</span>);<span class=\"hljs-comment\">//头结点</span><br><span class=\"hljs-type\">Node</span> <span class=\"hljs-variable\">end</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Node</span>(-<span class=\"hljs-number\">1</span>, <span class=\"hljs-literal\">null</span>);<span class=\"hljs-comment\">//尾结点</span><br><span class=\"hljs-type\">Node</span> <span class=\"hljs-variable\">per</span> <span class=\"hljs-operator\">=</span> head;<br><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">1</span>;i&lt;=<span class=\"hljs-number\">10</span>;i++) &#123;<br>    per.next = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Node</span>(i, <span class=\"hljs-literal\">null</span>);<br>    per = per.next;<br>&#125;<br>per.next = end;<br></code></pre></td></tr></table></figure>\n\n<h6 id=\"插入\"><a href=\"#插入\" class=\"headerlink\" title=\"插入\"></a>插入</h6><p>​        插入前：</p>\n<p><img src=\"https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311182102205.png\" alt=\"image-20231118203551162\"></p>\n<p>​            插入后：</p>\n<p><img src=\"https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311182102206.png\" alt=\"image-20231118203544620\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">Node now;<span class=\"hljs-comment\">//待插入结点</span><br>now.next = head.next;<span class=\"hljs-comment\">//此节点的next为插入位置上一个结点的下一个结点</span><br>head.next = now;<span class=\"hljs-comment\">//此节点位置的上一个结点的下一个结点为now</span><br></code></pre></td></tr></table></figure>\n\n<h6 id=\"删除\"><a href=\"#删除\" class=\"headerlink\" title=\"删除\"></a>删除</h6><p>​        删除前：</p>\n<p><img src=\"https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311182102207.png\" alt=\"image-20231118203608364\"></p>\n<p>​        删除后：    </p>\n<p><img src=\"https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311182102208.png\" alt=\"image-20231118203627478\">        </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">Node now;<span class=\"hljs-comment\">//待删除结点</span><br>head.next = now.next;<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"双链表\"><a href=\"#双链表\" class=\"headerlink\" title=\"双链表\"></a>双链表</h4><h6 id=\"初始化-1\"><a href=\"#初始化-1\" class=\"headerlink\" title=\"初始化\"></a>初始化</h6><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">N</span>&#123;<br>    N last;<br>    <span class=\"hljs-type\">int</span> value;<br>    N next;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-title function_\">N</span><span class=\"hljs-params\">(N last, <span class=\"hljs-type\">int</span> value, N next)</span> &#123;<br>        <span class=\"hljs-built_in\">this</span>.last = last;<br>        <span class=\"hljs-built_in\">this</span>.value = value;<br>        <span class=\"hljs-built_in\">this</span>.next = next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-type\">Node</span> <span class=\"hljs-variable\">first</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Node</span>(<span class=\"hljs-literal\">null</span>,-<span class=\"hljs-number\">1</span>,<span class=\"hljs-literal\">null</span>);<span class=\"hljs-comment\">//头结点</span><br><span class=\"hljs-type\">Node</span> <span class=\"hljs-variable\">end</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Node</span>(<span class=\"hljs-literal\">null</span>,-<span class=\"hljs-number\">1</span>, <span class=\"hljs-literal\">null</span>);<span class=\"hljs-comment\">//尾节点</span><br><span class=\"hljs-type\">Node</span> <span class=\"hljs-variable\">per</span> <span class=\"hljs-operator\">=</span> first;<br><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">1</span>;i&lt;=<span class=\"hljs-number\">10</span>;i++) &#123;<br>    per.next = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">N</span>(per,i, <span class=\"hljs-literal\">null</span>);<br>    per = per.next;<br>&#125;<br>end.last = per;<br>per.next = end;<br></code></pre></td></tr></table></figure>\n\n<h6 id=\"插入-1\"><a href=\"#插入-1\" class=\"headerlink\" title=\"插入\"></a>插入</h6><p>​        插入前：</p>\n<p><img src=\"https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311182102209.png\" alt=\"image-20231118203704325\"></p>\n<p>​         插入后：</p>\n<p><img src=\"https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311182102210.png\" alt=\"image-20231118203719212\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">Node now;<span class=\"hljs-comment\">//待插入结点</span><br>now.next = first.next;<br>first.next.last = now;<br>first.next = now;<br>now.last = first;<br></code></pre></td></tr></table></figure>\n\n<h6 id=\"删除-1\"><a href=\"#删除-1\" class=\"headerlink\" title=\"删除\"></a>删除</h6><p>​        删除前：</p>\n<p><img src=\"https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311182102211.png\" alt=\"image-20231118203733885\"></p>\n<p>​        删除后：</p>\n<p><img src=\"https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311182102212.png\" alt=\"image-20231118203744884\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">Node now;<span class=\"hljs-comment\">//待删除结点</span><br>now.last.next = now.next;<br>now.next.last = now.last;<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"例题：左移右移（双链表解法）\"><a href=\"#例题：左移右移（双链表解法）\" class=\"headerlink\" title=\"例题：左移右移（双链表解法）\"></a>例题：左移右移（双链表解法）</h4><p>题目链接：<a href=\"https://www.lanqiao.cn/problems/2219/learning/\">左移右移 - 蓝桥云课 (lanqiao.cn)</a></p>\n<p><img src=\"https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311182102213.png\" alt=\"image-20231118203759075\"></p>\n<p>思路：</p>\n<p>​        1.创建双链表并完成初始化，初始元素为 1 ~ n；</p>\n<p>​        2.无论 x 左移或右移，都要先将 x 从原位置删除，为了便于获取 x 对应的 Node 结点，用 Map 存储 x 和 value 为 x 的结点；</p>\n<p>​        3.如果 x 为左移，就将 x 对应的 Node 结点插入到头结点后；</p>\n<p>​        4.如果 x 为右移，就将 x 对应的 Node 结点插入到尾节点前；</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">import</span> java.io.BufferedReader;<br><span class=\"hljs-keyword\">import</span> java.io.IOException;<br><span class=\"hljs-keyword\">import</span> java.io.InputStreamReader;<br><span class=\"hljs-keyword\">import</span> java.io.OutputStreamWriter;<br><span class=\"hljs-keyword\">import</span> java.io.PrintWriter;<br><span class=\"hljs-keyword\">import</span> java.util.HashMap;<br><span class=\"hljs-keyword\">import</span> java.util.Map;<br><br><span class=\"hljs-keyword\">public</span> class 左移右移_双链表 &#123;<br>\t<span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Node</span>&#123;<br>\t\tNode up;<br>\t\t<span class=\"hljs-type\">int</span> value;<br>\t\tNode down;<br>\t\t<span class=\"hljs-keyword\">public</span> <span class=\"hljs-title function_\">Node</span><span class=\"hljs-params\">(Node up, <span class=\"hljs-type\">int</span> value, Node down)</span> &#123;<br>\t\t\t<span class=\"hljs-built_in\">this</span>.up = up;<br>\t\t\t<span class=\"hljs-built_in\">this</span>.value = value;<br>\t\t\t<span class=\"hljs-built_in\">this</span>.down = down;<br>\t\t&#125;<br>\t&#125;<br>\t<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> <span class=\"hljs-keyword\">throws</span> IOException&#123;<br>        <span class=\"hljs-type\">BufferedReader</span> <span class=\"hljs-variable\">in</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">BufferedReader</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">InputStreamReader</span>(System.in));<br>        <span class=\"hljs-type\">PrintWriter</span> <span class=\"hljs-variable\">out</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">PrintWriter</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">OutputStreamWriter</span>(System.out));<br>        String[] s = in.readLine().split(<span class=\"hljs-string\">&quot; &quot;</span>);<br>        <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">n</span> <span class=\"hljs-operator\">=</span> Integer.parseInt(s[<span class=\"hljs-number\">0</span>]);<br>        <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">m</span> <span class=\"hljs-operator\">=</span> Integer.parseInt(s[<span class=\"hljs-number\">1</span>]);<br>        Map&lt;Integer, Node&gt; map = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">HashMap</span>&lt;&gt;();<br>        <span class=\"hljs-type\">Node</span> <span class=\"hljs-variable\">first</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Node</span>(<span class=\"hljs-literal\">null</span>, -<span class=\"hljs-number\">1</span>, <span class=\"hljs-literal\">null</span>);<br>        <span class=\"hljs-type\">Node</span> <span class=\"hljs-variable\">last</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Node</span>(<span class=\"hljs-literal\">null</span>, -<span class=\"hljs-number\">1</span>, <span class=\"hljs-literal\">null</span>);<br>        <span class=\"hljs-type\">Node</span> <span class=\"hljs-variable\">no</span> <span class=\"hljs-operator\">=</span> first;<br>        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">1</span>;i&lt;=n;i++) &#123;<br>        \tno.down = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Node</span>(no, i, <span class=\"hljs-literal\">null</span>);<br>        \tno = no.down;<br>        \tmap.put(i, no);<br>        &#125;<br>        last.up = no;<br>        no.down = last;<br>        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;m;i++) &#123;<br>        \ts = in.readLine().split(<span class=\"hljs-string\">&quot; &quot;</span>);<br>        \t<span class=\"hljs-type\">char</span> <span class=\"hljs-variable\">ch</span> <span class=\"hljs-operator\">=</span> s[<span class=\"hljs-number\">0</span>].charAt(<span class=\"hljs-number\">0</span>);<br>        \t<span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">x</span> <span class=\"hljs-operator\">=</span> Integer.parseInt(s[<span class=\"hljs-number\">1</span>]);<br>        \t<span class=\"hljs-type\">Node</span> <span class=\"hljs-variable\">node</span> <span class=\"hljs-operator\">=</span> map.get(x);<br>        \tnode.up.down = node.down;<br>        \tnode.down.up = node.up;<br>        \t<span class=\"hljs-keyword\">if</span>(ch==<span class=\"hljs-string\">&#x27;L&#x27;</span>) &#123;<br>        \t\tnode.down = first.down;<br>        \t\tfirst.down.up = node;<br>        \t\tfirst.down = node;<br>        \t\tnode.up = first;<br>        \t&#125;<span class=\"hljs-keyword\">else</span> &#123;<br>        \t\tnode.up = last.up;<br>        \t\tlast.up.down = node;<br>        \t\tnode.down = last;<br>        \t\tlast.up = node;<br>        \t&#125;<br>        &#125;<br>        no = first.down;<br>        <span class=\"hljs-keyword\">while</span>(no!=last) &#123;<br>        \tSystem.out.print(no.value+<span class=\"hljs-string\">&quot; &quot;</span>);<br>        \tno = no.down; <br>        &#125;<br>\t&#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"栈\"><a href=\"#栈\" class=\"headerlink\" title=\"栈\"></a>栈</h2><h4 id=\"栈-1\"><a href=\"#栈-1\" class=\"headerlink\" title=\"栈\"></a>栈</h4><p>栈（Stack）：是只允许在一端进行插入或删除的线性表。首先栈是一种线性表，但限定这种线性表只能在某一端进行插入和删除操作。</p>\n<p>栈顶（Top）：线性表允许进行插入删除的那一端。</p>\n<p>栈底（Bottom）：固定的，不允许进行插入和删除的另一端。</p>\n<p><img src=\"https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311182102214.png\" alt=\"image-20231118203841538\"></p>\n<h4 id=\"常用方法\"><a href=\"#常用方法\" class=\"headerlink\" title=\"常用方法\"></a>常用方法</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">Stack&lt;Integer&gt; stack = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Stack</span>();<br><span class=\"hljs-type\">boolean</span> <span class=\"hljs-variable\">is</span> <span class=\"hljs-operator\">=</span> stack.isEmpty();<span class=\"hljs-comment\">//判断此栈是否为空</span><br><span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">n</span> <span class=\"hljs-operator\">=</span> stack.peek();<span class=\"hljs-comment\">//获取栈顶的元素，但不删除</span><br><span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">m</span> <span class=\"hljs-operator\">=</span> stacl.pop();<span class=\"hljs-comment\">//获取并删除栈顶的元素</span><br>stack.push(<span class=\"hljs-number\">10</span>);<span class=\"hljs-comment\">//将10压入栈中</span><br>stack.clear();<span class=\"hljs-comment\">//清空栈</span><br></code></pre></td></tr></table></figure>\n\n<h4 id=\"判断括号序列是否合法\"><a href=\"#判断括号序列是否合法\" class=\"headerlink\" title=\"判断括号序列是否合法\"></a>判断括号序列是否合法</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">boolean</span> <span class=\"hljs-title function_\">check</span><span class=\"hljs-params\">(String s)</span>&#123;<br>    Stack&lt;Character&gt; stack = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Stack</span>();<br>    <span class=\"hljs-type\">char</span>[] ch = s.toCharArray();<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;ch.length;i++)&#123;<br>        <span class=\"hljs-keyword\">if</span>(ch[i]==<span class=\"hljs-string\">&#x27;(&#x27;</span>)<br>            stack.push(ch[i]);<br>        <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(stack.isEmpty())<br>            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;<br>        <span class=\"hljs-keyword\">else</span><br>            stack.pop();<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> stack.isEmpty();<br>&#125;<br></code></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"队列\"><a href=\"#队列\" class=\"headerlink\" title=\"队列\"></a>队列</h2><h4 id=\"队列-1\"><a href=\"#队列-1\" class=\"headerlink\" title=\"队列\"></a>队列</h4><p>队列（queue）是一种先进先出的、操作受限的线性表。</p>\n<p><img src=\"https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311182102215.png\" alt=\"image-20231118203904215\"></p>\n<p>队列这种数据结构非常容易理解，就像我们平时去超市买东西，在收银台结账的时候需要排队，先去排队的就先结账出去，排在后面的就后结账，有其他人再要过来结账，必须排在队尾不能在队中间插队。</p>\n<h4 id=\"常用方法-1\"><a href=\"#常用方法-1\" class=\"headerlink\" title=\"常用方法\"></a>常用方法</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">Queue&lt;Integer&gt; queue = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">LinkedList</span>&lt;&gt;();<br>queue.peek();<span class=\"hljs-comment\">//获取队头元素，但不删除</span><br>queue.poll();<span class=\"hljs-comment\">//获取并删除队头元素</span><br>queue.clear();<span class=\"hljs-comment\">//清空队列</span><br>queue.push(<span class=\"hljs-number\">11</span>);<span class=\"hljs-comment\">//将11存放到队列中</span><br></code></pre></td></tr></table></figure>\n\n<h4 id=\"例题：左移右移（栈-队列解法）\"><a href=\"#例题：左移右移（栈-队列解法）\" class=\"headerlink\" title=\"例题：左移右移（栈 + 队列解法）\"></a>例题：左移右移（栈 + 队列解法）</h4><p>题目链接：<a href=\"https://www.lanqiao.cn/problems/2219/learning/\">左移右移 - 蓝桥云课 (lanqiao.cn)</a></p>\n<p><img src=\"https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311182102217.png\" alt=\"image-20231118203920958\"></p>\n<p>思路：</p>\n<p>​        1.如果一个数先移动到最左边，再移动到最右边，那么最后输出的时候这个数一定是在最右边，也就是一个数最终出现在哪里，以他最后一次出现为准；</p>\n<p>​        2.为了避免一个数重复判断，而且要以他最后一次出现时的 L 和 R 操作为最终操作，所以可以先将全部输入分别存放到 char 类型数组和 int 类型数组中，然后逆序判断，并且用一个数组来表示这个 x 有没有出现过；</p>\n<p>​        3.因为要对输入做逆序操作，所以，逆序时最后出现的 L 对应的 x 在输出的最前面，然后之后出现的 L 对应的 x 依次输出，即先入先出，可以用队列来存储进行 L 操作的 x ；</p>\n<p>​        4.逆序时最后出现的 R 对应的 x 在输出的最后面，然后之后出现的 R 对应的 x 依次在前，即后入先出，可以用栈来存储进行 R 操作的 x ；</p>\n<p>​        5.输出时，先输出队列中的元素，然后将 1 ~ n 中没有出现过的值按序输出，最后输出栈中的元素；</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">import</span> java.io.BufferedReader;<br><span class=\"hljs-keyword\">import</span> java.io.IOException;<br><span class=\"hljs-keyword\">import</span> java.io.InputStreamReader;<br><span class=\"hljs-keyword\">import</span> java.io.OutputStreamWriter;<br><span class=\"hljs-keyword\">import</span> java.io.PrintWriter;<br><span class=\"hljs-keyword\">import</span> java.util.LinkedList;<br><span class=\"hljs-keyword\">import</span> java.util.Queue;<br><span class=\"hljs-keyword\">import</span> java.util.Stack;<br><br><span class=\"hljs-keyword\">public</span> class 左移右移_栈_队列 &#123;<br><br>\t<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> <span class=\"hljs-keyword\">throws</span> IOException&#123;<br>        <span class=\"hljs-type\">BufferedReader</span> <span class=\"hljs-variable\">in</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">BufferedReader</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">InputStreamReader</span>(System.in));<br>        <span class=\"hljs-type\">PrintWriter</span> <span class=\"hljs-variable\">out</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">PrintWriter</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">OutputStreamWriter</span>(System.out));<br>        String[] s = in.readLine().split(<span class=\"hljs-string\">&quot; &quot;</span>);<br>        <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">n</span> <span class=\"hljs-operator\">=</span> Integer.parseInt(s[<span class=\"hljs-number\">0</span>]);<br>        <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">m</span> <span class=\"hljs-operator\">=</span> Integer.parseInt(s[<span class=\"hljs-number\">1</span>]);<br>        <span class=\"hljs-type\">int</span>[] a = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">int</span>[n+<span class=\"hljs-number\">1</span>];<br>        <span class=\"hljs-type\">char</span>[] c = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">char</span>[m];<br>        <span class=\"hljs-type\">int</span>[] x = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">int</span>[m];<br>        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;m;i++) &#123;<br>        \ts = in.readLine().split(<span class=\"hljs-string\">&quot; &quot;</span>);<br>            c[i] = s[<span class=\"hljs-number\">0</span>].charAt(<span class=\"hljs-number\">0</span>);<br>            x[i] = Integer.parseInt(s[<span class=\"hljs-number\">1</span>]);<br>        &#125;<br>        Stack&lt;Integer&gt; r = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Stack</span>&lt;&gt;();<br>        Queue&lt;Integer&gt; l = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">LinkedList</span>&lt;&gt;();<br>        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i=m-<span class=\"hljs-number\">1</span>;i&gt;=<span class=\"hljs-number\">0</span>;i--) &#123;<br>        \t<span class=\"hljs-keyword\">if</span>(a[x[i]]==<span class=\"hljs-number\">0</span>) &#123;<span class=\"hljs-comment\">//判断x[i]是否出现过</span><br>        \t\ta[x[i]] = <span class=\"hljs-number\">1</span>;<span class=\"hljs-comment\">//若x[i]没有出现过</span><br>        \t\t<span class=\"hljs-keyword\">if</span>(c[i]==<span class=\"hljs-string\">&#x27;L&#x27;</span>)<br>        \t\t\tl.add(x[i]);<br>        \t\t<span class=\"hljs-keyword\">else</span><br>        \t\t\tr.push(x[i]);<br>        \t&#125;<br>        &#125;<br>        <span class=\"hljs-keyword\">while</span>(l.size()!=<span class=\"hljs-number\">0</span>) <span class=\"hljs-comment\">//输出队列中元素</span><br>        \tSystem.out.print(l.poll()+<span class=\"hljs-string\">&quot; &quot;</span>);<br>        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">1</span>;i&lt;=n;i++) <br>        \t<span class=\"hljs-keyword\">if</span>(a[i]==<span class=\"hljs-number\">0</span>) <span class=\"hljs-comment\">//a[i]为0，表示i没有出现过</span><br>        \t\tSystem.out.print(i+<span class=\"hljs-string\">&quot; &quot;</span>);<br>        <span class=\"hljs-keyword\">while</span>(r.size()!=<span class=\"hljs-number\">0</span>) <span class=\"hljs-comment\">//输出栈中元素</span><br>        \tSystem.out.print(r.pop()+<span class=\"hljs-string\">&quot; &quot;</span>);<br>\t&#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h1 id=\"第五章-分治算法\"><a href=\"#第五章-分治算法\" class=\"headerlink\" title=\"第五章 分治算法\"></a>第五章 分治算法</h1><h2 id=\"归并排序\"><a href=\"#归并排序\" class=\"headerlink\" title=\"归并排序\"></a>归并排序</h2><p>思路：先把数组从中间分成前后两部分，然后分别对前后两部分进行排序，再将排好序的两部分数据合并在一起</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">mergeSort</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span>[] a,<span class=\"hljs-type\">int</span> left,<span class=\"hljs-type\">int</span> right)</span>&#123;<span class=\"hljs-comment\">//待排序数组，要排序的范围[left,right]</span><br>    <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">mid</span> <span class=\"hljs-operator\">=</span> (left+right)&gt;&gt;<span class=\"hljs-number\">1</span>;<br>    <span class=\"hljs-keyword\">if</span>(left&lt;right)&#123;<br>        mergeSort(a,left,mid);<br>        mergeSort(a,mid+<span class=\"hljs-number\">1</span>,right);<br>        merge(a,left,mid,right);<br>    &#125;<br>&#125;<br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">merge</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span>[] a,<span class=\"hljs-type\">int</span> left,<span class=\"hljs-type\">int</span> mid,<span class=\"hljs-type\">int</span> right)</span>&#123;<br>    <span class=\"hljs-type\">int</span>[] temp = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">int</span>[right-left+<span class=\"hljs-number\">1</span>];<span class=\"hljs-comment\">//临时数组，用来归并</span><br>    <span class=\"hljs-type\">int</span> i=left,j=mid+<span class=\"hljs-number\">1</span>,k=<span class=\"hljs-number\">0</span>;<span class=\"hljs-comment\">//左半段用i指向，右半段用j指向，temp数组用k指向</span><br>    <span class=\"hljs-keyword\">while</span>(i&lt;=mid &amp;&amp; j&lt;=right)&#123;<br>        <span class=\"hljs-keyword\">if</span>(a[i]&lt;a[j])<br>            temp[k++] = a[i++];<br>        <span class=\"hljs-keyword\">else</span><br>            temp[k++] = a[j++];   <br>    &#125;<br>    <span class=\"hljs-keyword\">while</span>(i&lt;=mid) temp[k++] = a[i++];<br>    <span class=\"hljs-keyword\">while</span>(j&lt;=right) temp[k++] = a[j++];<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> x=<span class=\"hljs-number\">0</span>;x&lt;temp.length;x++)&#123;<br>        a[left+x] = temp[x];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"快速排序\"><a href=\"#快速排序\" class=\"headerlink\" title=\"快速排序\"></a>快速排序</h2><p>思路：</p>\n<p>(1)首先设定一个分界值，通过该分界值将数组分成左右两部分。 </p>\n<p>(2)将大于或等于分界值的数据集中到数组右边，小于分界值的数据集中到数组的左边。此时，左边部分中各元素都小于分界值，而右边部分中各元素都大于或等于分界值。 </p>\n<p>(3)然后，左边和右边的数据可以独立排序。对于左侧的数组数据，又可以取一个分界值，将该部分数据分成左右两部分，同样在左边放置较小值，右边放置较大值。右侧的数组数据也可以做类似处理。 </p>\n<p>(4)重复上述过程，可以看出，这是一个递归定义。通过递归将左侧部分排好序后，再递归排好右侧部分的顺序。当左、右两个部分各数据排序完成后，整个数组的排序也就完成了。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">quickSort</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span>[] a,<span class=\"hljs-type\">int</span> left,<span class=\"hljs-type\">int</span> right)</span>&#123;<br>    <span class=\"hljs-keyword\">if</span>(left&gt;right) <span class=\"hljs-keyword\">return</span>;<span class=\"hljs-comment\">//区间擦肩而过，无效，不需要进行递归</span><br>    <span class=\"hljs-type\">int</span> i=left,j=right,temp = a[left];<span class=\"hljs-comment\">//a[left]作为基准点</span><br>    <span class=\"hljs-keyword\">while</span>(i!=j)&#123;<br>        <span class=\"hljs-keyword\">while</span>(a[j]&gt;=a[temp] &amp;&amp; j&gt;i)<br>            j--;<span class=\"hljs-comment\">//只要a[j]大于基准点继续往前移动j</span><br>        <span class=\"hljs-keyword\">if</span>(j&gt;i)<br>            a[i++] = a[j];<br>        <span class=\"hljs-keyword\">while</span>(a[i]&lt;=a[temp] &amp;&amp; i&lt;j)<br>            i++;<br>        <span class=\"hljs-keyword\">if</span>(i&lt;j)<br>            a[j--] = a[i];<br>    &#125;<br>    a[i] = temp;<span class=\"hljs-comment\">//基准点元素放到最终位置</span><br>    quickSort(a,left,i-<span class=\"hljs-number\">1</span>);<br>    quickSort(a,i+<span class=\"hljs-number\">1</span>,right);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"快速幂\"><a href=\"#快速幂\" class=\"headerlink\" title=\"快速幂\"></a>快速幂</h2><p>思路：每一步都把指数分成两半，而相应的底数做平方运算。这样不仅能把非常大的指数给不断变小，所需要执行的循环次数也变小，而最后表示的结果却一直不会变。</p>\n<p>例：3^10^ = 3*3*3*3*3*3*3*3*3*3 ，尽量想办法把指数变小来，这里的指数为10。</p>\n<p>3^10^=(3*3)(3*3)(3*3)(3*3)(3*3)</p>\n<p>3^10^=(3*3)^5^</p>\n<p>3^10^=9^5^</p>\n<p>此时指数由10缩减一半变成了5，而底数变成了原来的平方，求3^10^原本需要执行10次循环操作，求9^5^却只需要执行5次循环操作，但是3^10^却等于9^5^,用一次（底数做平方操作）的操作减少了原本一半的循环量，特别是在幂特别大的时候效果非常好，例如2^10000^=4^5000^,底数只是做了一个小小的平方操作，而指数就从10000变成了5000，减少了5000次的循环操作。</p>\n<p>现在问题是如何把指数5变成原来的一半，5是一个奇数，5的一半是2.5，但是指数不能为小数，因此不能简单粗暴地直接执行5/2，然而，这里还有另一种方法能表示9^5^，9^5^=9^4^*9^1^</p>\n<p>此时抽出了一个底数的一次方，这里即为9^1^，这个9^1^先单独移出来,剩下的9^4^又能够在执行“缩指数”操作了，把指数缩小一半，底数执行平方操作。9^5^=81^2^*9^1^</p>\n<p>把指数缩小一半，底数执行平方操作，9^5^=6561^1^*9^1^</p>\n<p>此时，发现指数又变成了一个奇数1，按照上面对指数为奇数的操作方法，应该抽出了一个底数的一次方，这里即为6561^1^，这个6561^1^先单独移出来，但是此时指数却变成了0，也就意味着我们无法再进行“缩指数”操作了。</p>\n<p>9^5^=（6561^0^)(9^1^)(6561^1^)=1(9^1^)(6561^1^)=(9^1^)(6561^1^)=9*6561=59049</p>\n<p>能够发现，最后的结果是9*6561。所以能发现一个规律：最后求出的幂结果实际上就是在变化过程中所有当指数为奇数时底数的乘积。</p>\n<p>继续优化：</p>\n<p>b%2==1可以用更快的“位运算”来代替，例如：b&amp;1。因为如果b为偶数，则其二进制表示的最后一位一定是0；如果b是奇数，则其二进制表示的最后一位一定是1。将他们分别与1的二进制做“与”运算，得到的就是b二进制最后一位的数字了，是0则为偶数，是1则为奇数。例如9是奇数，则9&amp;1=1；而8是偶数，则8&amp;1=0；因此奇偶数的判断就可以用“位运算”来替换了。</p>\n<p>m = m / 2也可以用更快的移位操作来代替，例如：6的四位二进制为0110，而6/2=3,3的四位二进制为0011，可以发现，a的一半，结果为a的二进制码向右移一位，即m &gt;&gt;=1。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">long</span> <span class=\"hljs-title function_\">num</span><span class=\"hljs-params\">(<span class=\"hljs-type\">long</span> n, <span class=\"hljs-type\">long</span> m, <span class=\"hljs-type\">long</span> p)</span> &#123;<br>    <span class=\"hljs-type\">long</span> <span class=\"hljs-variable\">result</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">1</span>;<br>    <span class=\"hljs-keyword\">while</span> (m &gt; <span class=\"hljs-number\">0</span>) &#123;<br>        <span class=\"hljs-keyword\">if</span> ((m &amp; <span class=\"hljs-number\">1</span> ) == <span class=\"hljs-number\">1</span>) &#123;<br>            result = result * n % p;<br>        &#125;<br>        m &gt;&gt;= <span class=\"hljs-number\">1</span>;<br>        n = (n * n) % p;<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h1 id=\"第六章-搜索\"><a href=\"#第六章-搜索\" class=\"headerlink\" title=\"第六章 搜索\"></a>第六章 搜索</h1><h2 id=\"全排列\"><a href=\"#全排列\" class=\"headerlink\" title=\"全排列\"></a>全排列</h2><h4 id=\"DFS解法\"><a href=\"#DFS解法\" class=\"headerlink\" title=\"DFS解法\"></a>DFS解法</h4><p>思路：将此过程看做一棵树，每一个结点下都会有 n 个结点表示下一个数，首先先将全部 n^n^ 个结果全部得出，然后剪枝，减去有重复数字出现的情况。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">dfs</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> depth,String ans,<span class=\"hljs-type\">int</span> n)</span>&#123;<span class=\"hljs-comment\">//当前深搜的层数，目前的结果，目标层数</span><br>    <span class=\"hljs-keyword\">if</span>(depth==n)&#123;<span class=\"hljs-comment\">//当前深搜层数=目标层数</span><br>        System.out.println(ans);<br>        <span class=\"hljs-keyword\">return</span>;<br>    &#125;<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">1</span>;i&lt;=n;i++)&#123;<br>    \t<span class=\"hljs-keyword\">if</span>(!ans.contains(i+<span class=\"hljs-string\">&quot;&quot;</span>))<span class=\"hljs-comment\">//只有当还没有用过i的时候，才会在现在的基础上继续往下拓展</span><br>\t\t\tdfs(depth+<span class=\"hljs-number\">1</span>,ans+i;n);<span class=\"hljs-comment\">//进入下一层，ans记录为进入下一层的值，n不变</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"BFS解法\"><a href=\"#BFS解法\" class=\"headerlink\" title=\"BFS解法\"></a>BFS解法</h4><p>思路：先将有重复数字的结果得出，每一个数后都可以跟 n 中可能，那么将这 n 中可能存入队列中，然后重复此过程，直到字符串的长度为 n 时，得到结果；剪枝，如果这个数字已经用过了，就直接只用下一个数字。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">bfs</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> n)</span>&#123;<br>    Queue&lt;String&gt; queue = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">LinkedList</span>&lt;&gt;();<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">1</span>;i&lt;=n;i++)<br>        queue.offer(i+<span class=\"hljs-string\">&quot;&quot;</span>);<br>    <span class=\"hljs-keyword\">while</span>(!queue.isEmpty())&#123;<br>        <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">now</span> <span class=\"hljs-operator\">=</span> queue.poll();<br>        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">1</span>;i&lt;=n;i++)&#123;<span class=\"hljs-comment\">//每个结点都向下产生n个结果</span><br>            <span class=\"hljs-keyword\">if</span>(now.contains(i+<span class=\"hljs-string\">&quot;&quot;</span>))<span class=\"hljs-comment\">//i已经使用过了</span><br>                <span class=\"hljs-keyword\">continue</span>;<br>            <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">son</span> <span class=\"hljs-operator\">=</span> head + i;<br>            <span class=\"hljs-keyword\">if</span>(son.length()==n)<br>                System.out.println(son);<br>            <span class=\"hljs-keyword\">else</span><br>                queue.offer(son);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"整数划分\"><a href=\"#整数划分\" class=\"headerlink\" title=\"整数划分\"></a>整数划分</h2><p>思路：对 n 进行划分后， n 可以被不超过 n 个数累加得到，进行累加的每一个数，也可以被不超过它本身个数累加得到。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">dfs</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> n,<span class=\"hljs-type\">int</span> nowget,<span class=\"hljs-type\">int</span> max,String ans)</span>&#123;<span class=\"hljs-comment\">//要划分的数，现在已经得到的值，目前划分已经用到的最大值，具体拆分方法</span><br>    <span class=\"hljs-keyword\">if</span>(nowget==n)&#123;<br>        ans = ans.substring(<span class=\"hljs-number\">0</span>,ans.length()-<span class=\"hljs-number\">1</span>);<br>        System.out.println(n+<span class=\"hljs-string\">&quot;=&quot;</span>+ans);<br>        <span class=\"hljs-keyword\">return</span>;<br>    &#125;<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">1</span>;i&lt;=n-nowget;i++)&#123;<span class=\"hljs-comment\">//从nowget累加到n</span><br>        <span class=\"hljs-keyword\">if</span>(i&gt;=max)<span class=\"hljs-comment\">//只有当下一个数不小于我之前用过的最大值时，才能保证整个结果为非递减</span><br>            dfs(n,nowget+i,i,ans+i+<span class=\"hljs-string\">&quot;+&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"例题\"><a href=\"#例题\" class=\"headerlink\" title=\"例题\"></a>例题</h2><h4 id=\"例题：路径之谜\"><a href=\"#例题：路径之谜\" class=\"headerlink\" title=\"例题：路径之谜\"></a>例题：路径之谜</h4><p>题目链接：<a href=\"https://www.lanqiao.cn/problems/89/learning/\">路径之谜 - 蓝桥云课 (lanqiao.cn)</a></p>\n<p><img src=\"https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311182102218.png\" alt=\"image-20231118204002349\"></p>\n<p>思路：</p>\n<p>​        1.从入口点开始，到达每一个点都将对应位置北墙和西墙的箭靶数减一，每一个点，都可以继续向四个方向继续前进（前提是这个点没有走过，在城堡范围内，且这个点对应的两个箭靶的数字不为 0 ）。</p>\n<p>​        2.如果已经到了终点，就要判断现在每一个箭靶上的数字是否都已经变为 0 ，如果是，那么此时走的路径就是正确解，否则就需要回溯，考虑其他的行走路线。</p>\n<p>​        3.回溯：因为要从已经走过的点退回来，所以在已经走过的点上射的箭要收回，箭靶数加一，并且标记此点为还没有走过。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">import</span> java.io.BufferedReader;<br><span class=\"hljs-keyword\">import</span> java.io.IOException;<br><span class=\"hljs-keyword\">import</span> java.io.InputStreamReader;<br><span class=\"hljs-keyword\">import</span> java.io.OutputStreamWriter;<br><span class=\"hljs-keyword\">import</span> java.io.PrintWriter;<br><br><span class=\"hljs-keyword\">public</span> class 路径之谜 &#123;<br>\t<span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">int</span>[] path;<span class=\"hljs-comment\">//记录最终路径，因为底面为n*n，所以走出需要2*n步</span><br>\t<span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">int</span> n;<br>\t<span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">int</span>[] cntx;<span class=\"hljs-comment\">//存储北墙箭靶数字</span><br>\t<span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">int</span>[] cnty;<span class=\"hljs-comment\">//存储西墙箭靶数字</span><br>\t<span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">boolean</span>[][] visited;<span class=\"hljs-comment\">//判断此点有没有走过</span><br>\t<span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">int</span> dx[] = &#123;<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">0</span>, -<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">0</span>&#125;;<span class=\"hljs-comment\">//到下一个点x坐标的变化量</span><br>\t<span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">int</span> dy[] = &#123;<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">0</span>, -<span class=\"hljs-number\">1</span>&#125;;<span class=\"hljs-comment\">//到下一个点y坐标的变化量</span><br>\t<span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">BufferedReader</span> <span class=\"hljs-variable\">in</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">BufferedReader</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">InputStreamReader</span>(System.in));<br>\t<span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">PrintWriter</span> <span class=\"hljs-variable\">out</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">PrintWriter</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">OutputStreamWriter</span>(System.out));<br>\t<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> <span class=\"hljs-keyword\">throws</span> IOException &#123;<br>    \tn = Integer.parseInt(in.readLine());<br>    \tcntx = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">int</span>[n];<br>    \tcnty = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">int</span>[n];<br>    \tpath = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">int</span>[n * n];<br>    \tvisited = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">boolean</span>[n][n];<br>    \tString[] s = in.readLine().split(<span class=\"hljs-string\">&quot; &quot;</span>);<br>    \t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">i</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span>; i &lt; n; i++) &#123;<br>    \t\tcntx[i] = Integer.parseInt(s[i]);<br>    \t&#125;<br>    \ts = in.readLine().split(<span class=\"hljs-string\">&quot; &quot;</span>);<br>    \t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">i</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span>; i &lt; n; i++) &#123;<br>    \t\tcnty[i] = Integer.parseInt(s[i]);<br>    \t&#125;<br>    \tdfs(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>);<span class=\"hljs-comment\">//从0,0位置开始走,目前走了0步</span><br>  &#125;<br>\t<span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">dfs</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> x, <span class=\"hljs-type\">int</span> y, <span class=\"hljs-type\">int</span> step)</span> &#123;<br>\t\tpath[step] = y * n + x; <span class=\"hljs-comment\">//将该点编号记录到路径中</span><br>\t\tvisited[x][y] = <span class=\"hljs-literal\">true</span>;<span class=\"hljs-comment\">//将该点标记为已经走过的状态</span><br>\t\tcntx[x]--;<span class=\"hljs-comment\">//拔掉对应北墙的箭</span><br>\t\tcnty[y]--;<span class=\"hljs-comment\">//拔掉对应西墙的箭</span><br>\t\t<span class=\"hljs-keyword\">if</span> (x == n - <span class=\"hljs-number\">1</span> &amp;&amp; y == n - <span class=\"hljs-number\">1</span> &amp;&amp; check())&#123;<span class=\"hljs-comment\">//判断是否到达终点</span><br>\t\t\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">i</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span>; i &lt;= step; i++)&#123;<span class=\"hljs-comment\">//输出答案</span><br>\t\t\t\tSystem.out.print(path[i]+<span class=\"hljs-string\">&quot; &quot;</span>);<br>\t\t\t&#125;<br>\t\t\t<span class=\"hljs-keyword\">return</span>;<br>\t\t&#125;<br>\t\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">i</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">4</span>; i++)&#123;<span class=\"hljs-comment\">//上下左右四个方向搜索下一步</span><br>\t\t\t<span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">xx</span> <span class=\"hljs-operator\">=</span> x + dx[i], yy = y + dy[i];<br>             <span class=\"hljs-comment\">//下一步(xx,yy)未走过且在地图范围内</span><br>\t\t\t<span class=\"hljs-keyword\">if</span> (<span class=\"hljs-number\">0</span> &lt;= xx &amp;&amp; xx &lt;= n-<span class=\"hljs-number\">1</span> &amp;&amp; yy &gt;= <span class=\"hljs-number\">0</span> &amp;&amp; yy &lt;= n-<span class=\"hljs-number\">1</span>&amp;&amp; !visited[xx][yy] )&#123;<br>\t\t\t\t<span class=\"hljs-keyword\">if</span> (cntx[xx] &gt; <span class=\"hljs-number\">0</span> &amp;&amp; cnty[yy] &gt; <span class=\"hljs-number\">0</span>)&#123;<span class=\"hljs-comment\">//该点对应箭靶上有箭，说明该点可以走</span><br>\t\t\t\t\tdfs(xx, yy, step + <span class=\"hljs-number\">1</span>);<span class=\"hljs-comment\">//搜索下一步</span><br>                    <span class=\"hljs-comment\">//要从xx,yy点回来,在xx,yy点射的箭要复原，并重新标记xx,yy点没有走过</span><br>\t\t\t\t\tvisited[xx][yy] = <span class=\"hljs-literal\">false</span>;<br>\t\t\t\t\tcntx[xx]++;<br>\t\t\t\t\tcnty[yy]++;<br>\t\t\t\t&#125;<br>\t\t\t&#125;<br>\t\t&#125;<br>\t&#125;<br>\t<span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">boolean</span> <span class=\"hljs-title function_\">check</span><span class=\"hljs-params\">()</span> &#123;<span class=\"hljs-comment\">//判断到达终点时,是否箭靶数都已经归零</span><br>\t\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">i</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span>; i &lt; n; i++) &#123;<br>\t\t\t<span class=\"hljs-keyword\">if</span> (cntx[i] != <span class=\"hljs-number\">0</span> || cnty[i] != <span class=\"hljs-number\">0</span>)<br>\t\t\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;<br>\t\t&#125;<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;<br>\t&#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"例题：迷宫\"><a href=\"#例题：迷宫\" class=\"headerlink\" title=\"例题：迷宫\"></a>例题：迷宫</h4><p>题目链接：<a href=\"https://www.lanqiao.cn/problems/602/learning/\">迷宫 - 蓝桥云课 (lanqiao.cn)</a></p>\n<p><img src=\"https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311182102219.png\" alt=\"image-20231118204041308\"></p>\n<p>思路：从起点开始，将从此点能到达的点存储到队列中，每次获取并删除队列中的第一个元素，并将其能到达且还未到达过的点（若此点已经到达过，则表示当前处理的这条路径不是最短路径）存储到队列中，若已经到达终点，则此路径为最短路径。如果队列中已经没有元素，但仍未到达迷宫终点，则表示此迷宫无解</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">import</span> java.io.BufferedReader;<br><span class=\"hljs-keyword\">import</span> java.io.IOException;<br><span class=\"hljs-keyword\">import</span> java.io.InputStreamReader;<br><span class=\"hljs-keyword\">import</span> java.io.OutputStreamWriter;<br><span class=\"hljs-keyword\">import</span> java.io.PrintWriter;<br><span class=\"hljs-keyword\">import</span> java.util.LinkedList;<br><span class=\"hljs-keyword\">import</span> java.util.Queue;<br><br><span class=\"hljs-keyword\">public</span> class 迷宫 &#123;<br>\t<span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">int</span> num;<span class=\"hljs-comment\">//存储迷宫最短路径所需要的步数</span><br>\t<span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">xsize</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">30</span>;<span class=\"hljs-comment\">//迷宫大小30行50列</span><br>\t<span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">ysize</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">50</span>;<br>\t<span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">char</span>[][] arr = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">char</span>[xsize][ysize];<span class=\"hljs-comment\">//存储迷宫：0表示路，1表示墙</span><br>\t<span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">boolean</span>[][] help = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">boolean</span>[xsize][ysize];<span class=\"hljs-comment\">//判断此点是否已经做过</span><br>\t<span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">int</span>[][] dir = &#123;&#123;<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">0</span>&#125;,&#123;<span class=\"hljs-number\">0</span>,-<span class=\"hljs-number\">1</span>&#125;,&#123;<span class=\"hljs-number\">0</span>,<span class=\"hljs-number\">1</span>&#125;,&#123;-<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">0</span>&#125;&#125;;<span class=\"hljs-comment\">//四个方向横纵坐标的变化量</span><br>\t<span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">char</span>[] sign = &#123;<span class=\"hljs-string\">&#x27;D&#x27;</span>,<span class=\"hljs-string\">&#x27;L&#x27;</span>,<span class=\"hljs-string\">&#x27;R&#x27;</span>,<span class=\"hljs-string\">&#x27;U&#x27;</span>&#125;;<span class=\"hljs-comment\">//表示四个方向</span><br>\t<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> <span class=\"hljs-keyword\">throws</span> IOException &#123;<br>\t\t<span class=\"hljs-type\">BufferedReader</span> <span class=\"hljs-variable\">in</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">BufferedReader</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">InputStreamReader</span>(System.in));<br>\t\t<span class=\"hljs-type\">PrintWriter</span> <span class=\"hljs-variable\">out</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">PrintWriter</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">OutputStreamWriter</span>(System.out));<br>\t\t<span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;xsize;i++)&#123;<br>\t\t\tarr[i] = in.readLine().toCharArray();<br>\t\t&#125;<br>\t\tout.println(bfs());<br>\t\tout.print(num);<span class=\"hljs-comment\">//额外输出最短路径需要多少步</span><br>\t\tout.flush();<br>\t&#125;<br>\t<span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> String <span class=\"hljs-title function_\">bfs</span><span class=\"hljs-params\">()</span> &#123;<br>\t\tQueue&lt;Node&gt; list = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">LinkedList</span>&lt;&gt;();<span class=\"hljs-comment\">//队列</span><br>\t\t<span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">x</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span>;<br>\t\t<span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">y</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span>;<br>\t\t<span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">runnum</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span>;<br>\t\tlist.add(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Node</span>(x,y,<span class=\"hljs-string\">&quot;&quot;</span>,runnum));<span class=\"hljs-comment\">//将起点存储到队列中</span><br>\t\t<span class=\"hljs-keyword\">while</span>(!list.isEmpty())&#123;<span class=\"hljs-comment\">//判断队列是否为空，若为空，则此迷宫没有通路</span><br>\t\t\t<span class=\"hljs-type\">Node</span> <span class=\"hljs-variable\">now</span> <span class=\"hljs-operator\">=</span> list.poll();<span class=\"hljs-comment\">//获取队列中的第一个元素并删除</span><br>\t\t\thelp[now.x][now.y] = <span class=\"hljs-literal\">true</span>;<span class=\"hljs-comment\">//将此点标记为已经走过</span><br>\t\t\t<span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;<span class=\"hljs-number\">4</span>;i++)&#123;<span class=\"hljs-comment\">//循环四次，对四个方向进行处理</span><br>\t\t\t\t<span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">xx</span> <span class=\"hljs-operator\">=</span> now.x + dir[i][<span class=\"hljs-number\">0</span>];<span class=\"hljs-comment\">//移动后的x坐标</span><br>\t\t\t\t<span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">yy</span> <span class=\"hljs-operator\">=</span> now.y + dir[i][<span class=\"hljs-number\">1</span>];<span class=\"hljs-comment\">//移动后的y坐标</span><br>                  <span class=\"hljs-comment\">//此点在迷宫范围内，未走过，不是墙</span><br>\t\t\t\t<span class=\"hljs-keyword\">if</span>(check(xx,yy) &amp;&amp; help[xx][yy]==<span class=\"hljs-literal\">false</span> &amp;&amp; arr[xx][yy]==<span class=\"hljs-string\">&#x27;0&#x27;</span>)&#123;<br>\t\t\t\t\tlist.add(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Node</span>(xx,yy,now.num + sign[i],now.runnum + <span class=\"hljs-number\">1</span>));<span class=\"hljs-comment\">//将此点存入队列中</span><br>\t\t\t\t\t<span class=\"hljs-keyword\">if</span>(xx==xsize-<span class=\"hljs-number\">1</span> &amp;&amp; yy==ysize-<span class=\"hljs-number\">1</span>)&#123;<span class=\"hljs-comment\">//如果已经到了迷宫终点</span><br>\t\t\t\t\t\tnum = now.runnum + <span class=\"hljs-number\">1</span>;<span class=\"hljs-comment\">//所需步数+1（now.runnum是到达迷宫终点前一步所需要的步数）</span><br>\t\t\t\t\t\t<span class=\"hljs-keyword\">return</span> now.num + sign[i];<span class=\"hljs-comment\">//返回通过迷宫的方式</span><br>\t\t\t\t\t&#125;<br>\t\t\t\t&#125;<br>\t\t\t&#125;<br>\t\t&#125;<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&quot;&quot;</span>;<span class=\"hljs-comment\">//空字符串，表示此迷宫无通路</span><br>\t&#125;<br>\t<span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">boolean</span> <span class=\"hljs-title function_\">check</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> xx, <span class=\"hljs-type\">int</span> yy)</span> &#123;<span class=\"hljs-comment\">//判断此点是否在迷宫范围内</span><br>\t\t<span class=\"hljs-keyword\">return</span> xx&gt;=<span class=\"hljs-number\">0</span> &amp;&amp; yy&gt;=<span class=\"hljs-number\">0</span> &amp;&amp; xx&lt;xsize &amp;&amp; yy&lt;ysize;<br>\t&#125;<br>\t<span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Node</span>&#123;<br>\t\t<span class=\"hljs-type\">int</span> x;<span class=\"hljs-comment\">//x坐标</span><br>\t\t<span class=\"hljs-type\">int</span> y;<span class=\"hljs-comment\">//y坐标</span><br>\t\t<span class=\"hljs-type\">int</span> runnum;<span class=\"hljs-comment\">//到达此点最短步数</span><br>\t\tString num;<span class=\"hljs-comment\">//到达此点的方式</span><br>\t\t<span class=\"hljs-keyword\">public</span> <span class=\"hljs-title function_\">Node</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> x, <span class=\"hljs-type\">int</span> y,String num ,<span class=\"hljs-type\">int</span> runnum)</span> &#123;<br>\t\t\t<span class=\"hljs-built_in\">super</span>();<br>\t\t\t<span class=\"hljs-built_in\">this</span>.x = x;<br>\t\t\t<span class=\"hljs-built_in\">this</span>.y = y;<br>\t\t\t<span class=\"hljs-built_in\">this</span>.num = num;<br>\t\t\t<span class=\"hljs-built_in\">this</span>.runnum = runnum;<br>\t\t&#125;<br>\t&#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h1 id=\"第七章-贪心\"><a href=\"#第七章-贪心\" class=\"headerlink\" title=\"第七章 贪心\"></a>第七章 贪心</h1><h2 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h2><p>所谓贪心算法是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，它所做出的仅仅是在某种意义上的局部最优解。<br>贪心算法没有固定的算法框架，算法设计的关键是贪心策略的选择。必须注意的是，贪心算法不是对所有问题都能得到整体最优解，选择的贪心策略必须具备无后效性（即某个状态以后的过程不会影响以前的状态，只与当前状态有关。</p>\n<h2 id=\"例题-1\"><a href=\"#例题-1\" class=\"headerlink\" title=\"例题\"></a>例题</h2><h4 id=\"例题：合并果子\"><a href=\"#例题：合并果子\" class=\"headerlink\" title=\"例题：合并果子\"></a>例题：合并果子</h4><p>题目链接：<a href=\"https://www.lanqiao.cn/problems/741/learning/\">合并果子 - 蓝桥云课 (lanqiao.cn)</a></p>\n<p><img src=\"https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311182102220.png\" alt=\"image-20231118204125650\"></p>\n<p>思路：</p>\n<p>​        1.要保证最终耗费的体力最小，那么就可以每次合并都把目前数量最少的两堆果子合并，耗费的体力就是这两堆果子树木的和，然后合并后又可以作为新的一堆果子继续去判断，直到最终只剩一堆。</p>\n<p>​        2.可以借助PriorityQueue优先队列，队列中第一个元素就是最小值，即可每次获取队列中前两个元素，然后将他们的和再次添加至队列中，直到最终队列中只剩一个元素。</p>\n<p>​        3.以题目样例为例：对于数组{pi}={1, 2, 9}，Huffman树的构造过程如下：</p>\n<p>​            3.1找到{1, 2, 9}中最小的两个数，分别是 1 和 2 ，</p>\n<p>​            3.2从{pi}中删除它们并将和 3 加入，得到{3, 9}，体力消耗为 3 。</p>\n<p>​            3.3找到{3， 9}中最小的两个数，分别是 3 和 9 ，</p>\n<p>​            3.4从{pi}中删除它们并将和 12 加入，得到{12}，费用为 12 。</p>\n<p>​            3.5现在，数组中只剩下一个数12，构造过程结束，总费用为3 + 12 = 15。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">import</span> java.io.BufferedReader;<br><span class=\"hljs-keyword\">import</span> java.io.IOException;<br><span class=\"hljs-keyword\">import</span> java.io.InputStreamReader;<br><span class=\"hljs-keyword\">import</span> java.io.OutputStreamWriter;<br><span class=\"hljs-keyword\">import</span> java.io.PrintWriter;<br><span class=\"hljs-keyword\">import</span> java.util.PriorityQueue;<br><span class=\"hljs-keyword\">import</span> java.util.Scanner;<br><span class=\"hljs-keyword\">import</span> java.util.Spliterator;<br><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Main</span> &#123;<br><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> <span class=\"hljs-keyword\">throws</span> IOException&#123;<br>        <span class=\"hljs-type\">BufferedReader</span> <span class=\"hljs-variable\">in</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">BufferedReader</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">InputStreamReader</span>(System.in));<br>        <span class=\"hljs-type\">PrintWriter</span> <span class=\"hljs-variable\">out</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">PrintWriter</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">OutputStreamWriter</span>(System.out));<br>        <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">n</span> <span class=\"hljs-operator\">=</span> Integer.parseInt(in.readLine());<br>        <span class=\"hljs-type\">long</span> <span class=\"hljs-variable\">sum</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span>;<br>        PriorityQueue&lt;Long&gt; queue = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">PriorityQueue</span>&lt;&gt;();<br>        String[] s = in.readLine().split(<span class=\"hljs-string\">&quot; &quot;</span>);<br>        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;s.length;i++) &#123;<br>            queue.add(Long.parseLong(s[i]));<br>        &#125;<br>        <span class=\"hljs-type\">long</span> <span class=\"hljs-variable\">number</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span>;<br>        <span class=\"hljs-keyword\">while</span>(queue.size()!=<span class=\"hljs-number\">1</span>) &#123;<br>            <span class=\"hljs-type\">long</span> <span class=\"hljs-variable\">a</span> <span class=\"hljs-operator\">=</span> queue.poll();<span class=\"hljs-comment\">//获取最小的一堆</span><br>            <span class=\"hljs-type\">long</span> <span class=\"hljs-variable\">b</span> <span class=\"hljs-operator\">=</span> queue.poll();<span class=\"hljs-comment\">//获取最小的一堆</span><br>            number = number + ( a + b );<span class=\"hljs-comment\">//合并这两堆耗费的体力</span><br>            queue.add((a+b));<span class=\"hljs-comment\">//将合并后的结果放回优先队列中</span><br>        &#125;<br>        System.out.println(number);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h1 id=\"第八章-树\"><a href=\"#第八章-树\" class=\"headerlink\" title=\"第八章 树\"></a>第八章 树</h1><h2 id=\"树的相关概念\"><a href=\"#树的相关概念\" class=\"headerlink\" title=\"树的相关概念\"></a>树的相关概念</h2><h4 id=\"什么是树\"><a href=\"#什么是树\" class=\"headerlink\" title=\"什么是树\"></a>什么是树</h4><p>树(Tree)是 n ( n ≧ 0 )个结点的有限集。n=0时称为空树。在任意一颗非空树中：有且仅有一个特定的称为根的结点。当n&gt;1时，其余结点可分为 m ( m &gt; 0 ) 个互不相交的有限集T1、T2、T3……、Tm，其中每个集合本身又是一棵树，并且称为根的子树。</p>\n<h4 id=\"树的基本概念\"><a href=\"#树的基本概念\" class=\"headerlink\" title=\"树的基本概念\"></a>树的基本概念</h4><p><img src=\"https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311182102221.png\" alt=\"image-20231118204210164\"></p>\n<h2 id=\"二叉树\"><a href=\"#二叉树\" class=\"headerlink\" title=\"二叉树\"></a>二叉树</h2><h4 id=\"什么是二叉树\"><a href=\"#什么是二叉树\" class=\"headerlink\" title=\"什么是二叉树\"></a>什么是二叉树</h4><p>二叉树是n(n&gt;=0)个结点的有限集合，该集合或者为空集（空二叉树）、或者由一个根结点和两颗互不相交的、分别称为根结点的左子树和右子树的二叉树组成。</p>\n<h4 id=\"二叉树的特点\"><a href=\"#二叉树的特点\" class=\"headerlink\" title=\"二叉树的特点\"></a>二叉树的特点</h4><p>​        1.二叉树中每个结点最多有两颗子树，度没有超过2的。</p>\n<p>​        2.左子树和右子树是有顺序的，不能颠倒。</p>\n<h4 id=\"满二叉树\"><a href=\"#满二叉树\" class=\"headerlink\" title=\"满二叉树\"></a>满二叉树</h4><p>在二叉树中，所有的分支节点都有左子树和右子树，并且所有的叶子都在同一层。</p>\n<h4 id=\"完全二叉树\"><a href=\"#完全二叉树\" class=\"headerlink\" title=\"完全二叉树\"></a>完全二叉树</h4><p>​        1.叶子结点只能出现在最下面两层。</p>\n<p>​        2.最下层的叶子一定集中在左部连续位置。</p>\n<p>​        3.倒数第二层，若有叶子结点，一定在右部连续位置。</p>\n<p>​        4.如果结点度为1，则该结点只有左孩子。</p>\n<p>​        5.同样结点的二叉树，完全二叉树的深度最小。</p>\n<h2 id=\"二叉树的创建和嵌套打印\"><a href=\"#二叉树的创建和嵌套打印\" class=\"headerlink\" title=\"二叉树的创建和嵌套打印\"></a>二叉树的创建和嵌套打印</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">//结点类</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">TreeNode</span>&#123;<br>    <span class=\"hljs-type\">int</span> data;<span class=\"hljs-comment\">//结点存放的数据</span><br>    TreeNode left;<span class=\"hljs-comment\">//左孩子</span><br>    TreeNode right;<span class=\"hljs-comment\">//右孩子</span><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-title function_\">TreeNode</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> data,TreeNode left,TreeNOde right)</span>&#123;<br>        <span class=\"hljs-built_in\">this</span>.data = data;<br>        <span class=\"hljs-built_in\">this</span>.left = left;<br>        <span class=\"hljs-built_in\">this</span>.right = right;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">import</span> java.util.Scanner;<br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Tree</span>&#123;<br>    TreeNode root;<span class=\"hljs-comment\">//整棵树的根节点</span><br>    <span class=\"hljs-type\">Scanner</span> <span class=\"hljs-variable\">sc</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Scanner</span>(System.in);<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-title function_\">Tree</span><span class=\"hljs-params\">()</span>&#123;<br>        root = <span class=\"hljs-literal\">null</span>;<br>    &#125;<br>    <span class=\"hljs-keyword\">public</span> TreeNode <span class=\"hljs-title function_\">createBinaryTree</span><span class=\"hljs-params\">()</span>&#123;<span class=\"hljs-comment\">//树的创建</span><br>        TreeNode t;<span class=\"hljs-comment\">//当前树的根节点</span><br>        <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">x</span> <span class=\"hljs-operator\">=</span> sc.nextInt();<br>        <span class=\"hljs-keyword\">if</span>(x==<span class=\"hljs-number\">0</span>) t=<span class=\"hljs-literal\">null</span>;<br>        <span class=\"hljs-keyword\">else</span>&#123;<br>            t = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">TreeNode</span>();<br>            t.data = x;<br>            t.left = createBinaryTree();<br>            t.right = createBinaryTree();<br>        &#125;<br>        <span class=\"hljs-keyword\">return</span> t;<br>    &#125;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">printTree</span><span class=\"hljs-params\">(TreeNode t)</span>&#123;<span class=\"hljs-comment\">//树的打印</span><br>        <span class=\"hljs-keyword\">if</span>(t!=<span class=\"hljs-literal\">null</span>)&#123;<br>            System.out.print(t.data);<br>            <span class=\"hljs-keyword\">if</span>(t.left!=<span class=\"hljs-literal\">null</span> || t.right!=<span class=\"hljs-literal\">null</span>)&#123;<br>                System.out.print(<span class=\"hljs-string\">&quot;(&quot;</span>);<br>                printTree(t.left);<br>                <span class=\"hljs-keyword\">if</span>(t.right!=<span class=\"hljs-literal\">null</span>) System.out.print(<span class=\"hljs-string\">&quot;,&quot;</span>);<br>                printTree(t.left);<br>                System.out.print(<span class=\"hljs-string\">&quot;)&quot;</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"前中后序层次遍历\"><a href=\"#前中后序层次遍历\" class=\"headerlink\" title=\"前中后序层次遍历\"></a>前中后序层次遍历</h2><h4 id=\"前序遍历\"><a href=\"#前序遍历\" class=\"headerlink\" title=\"前序遍历\"></a>前序遍历</h4><p>思路：对于每个结点，优先处理结点本身，再处理它的左孩子，最后处理它的右孩子。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">preOrder</span><span class=\"hljs-params\">(TreeNode root)</span>&#123;<br>    <span class=\"hljs-keyword\">if</span>(root!=<span class=\"hljs-literal\">null</span>)&#123;<br>        System.out.print(root.data+<span class=\"hljs-string\">&quot; &quot;</span>);<br>        preOrder(root.left);<br>        preOrder(root.right);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"中序遍历\"><a href=\"#中序遍历\" class=\"headerlink\" title=\"中序遍历\"></a>中序遍历</h4><p>思路：对于每个结点，优先处理它的左孩子，再处理它本身，最后处理它的右孩子。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">midOrder</span><span class=\"hljs-params\">(TreeNode root)</span>&#123;<br>    <span class=\"hljs-keyword\">if</span>(root!=<span class=\"hljs-literal\">null</span>)&#123;<br>        midOrder(root.left);<br>        System.out.print(root.data+<span class=\"hljs-string\">&quot; &quot;</span>);<br>        midOrder(root.right);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"后序遍历\"><a href=\"#后序遍历\" class=\"headerlink\" title=\"后序遍历\"></a>后序遍历</h4><p>思路：对于每个结点，优先处理它的左节点，再处理它的右节点，最后处理它本身。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">postOrder</span><span class=\"hljs-params\">(TreeNode root)</span>&#123;<br>    <span class=\"hljs-keyword\">if</span>(root!=<span class=\"hljs-literal\">null</span>)&#123;<br>        postOrder(root.left);<br>       \tpostOrder(root.right);<br>        System.out.print(root.data+<span class=\"hljs-string\">&quot; &quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"层次遍历\"><a href=\"#层次遍历\" class=\"headerlink\" title=\"层次遍历\"></a>层次遍历</h4><p>思路：广度优先搜索；处理根节点的每一个子结点，再处理子结点的每一个子结点……直至结束。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">levelOrder</span><span class=\"hljs-params\">(TreeNode t)</span>&#123;<br>    Queue&lt;TreeNode&gt; queue = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">LinkedList</span>&lt;&gt;();<br>    <span class=\"hljs-keyword\">if</span>(t==<span class=\"hljs-literal\">null</span>) <span class=\"hljs-keyword\">return</span>;<br>    queue.offer(t);<br>    <span class=\"hljs-keyword\">while</span>(!queue.isEmpty())&#123;<br>        <span class=\"hljs-type\">TreeNode</span> <span class=\"hljs-variable\">head</span> <span class=\"hljs-operator\">=</span> queue.poll();<br>        System.out.print(head.data);<br>        <span class=\"hljs-keyword\">if</span>(head.left!=<span class=\"hljs-literal\">null</span>)<br>        \tqueue.offer(head.left);<br>        <span class=\"hljs-keyword\">if</span>(head.right!=<span class=\"hljs-literal\">null</span>)<br>        \tqueue.offer(head.right);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"求二叉树深度\"><a href=\"#求二叉树深度\" class=\"headerlink\" title=\"求二叉树深度\"></a>求二叉树深度</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">treeDepth</span><span class=\"hljs-params\">(TreeNode root)</span>&#123;<br>    <span class=\"hljs-keyword\">if</span>(root==<span class=\"hljs-literal\">null</span>) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<span class=\"hljs-comment\">//此结点不存在</span><br>    <span class=\"hljs-keyword\">return</span> Math.max(treeDepth(root.left),treeDepth(root.right))+<span class=\"hljs-number\">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"求二叉树叶子结点个数\"><a href=\"#求二叉树叶子结点个数\" class=\"headerlink\" title=\"求二叉树叶子结点个数\"></a>求二叉树叶子结点个数</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">TreeLeaf</span><span class=\"hljs-params\">(TreeNode root)</span>&#123;<br>    <span class=\"hljs-keyword\">if</span>(root==<span class=\"hljs-literal\">null</span>) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-keyword\">if</span>(root.left==<span class=\"hljs-literal\">null</span> &amp;&amp; root.right==<span class=\"hljs-literal\">null</span>) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1</span>;<span class=\"hljs-comment\">//此结点没有孩子，表示此结点为叶子结点</span><br>    <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">return</span> treeLeaf(root.left) + treeLeaf(root.right);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"重建二叉树\"><a href=\"#重建二叉树\" class=\"headerlink\" title=\"重建二叉树\"></a>重建二叉树</h2><p>思路：</p>\n<p>​        1.前序遍历为：根，{左子树}，{右子树}；可得，前序遍历的第一个结点为根结点；</p>\n<p>​        2.中序遍历为：{左子树}，根，{右子树}；可得，结点的左侧为它的左孩子树，右侧为它的右孩子树；</p>\n<p>​        3.重复此过程，重建此二叉树；</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> String <span class=\"hljs-title function_\">f</span><span class=\"hljs-params\">(String pre,String mid)</span>&#123;<span class=\"hljs-comment\">//前序遍历结果，中序遍历结果</span><br>    <span class=\"hljs-keyword\">if</span>(pre.length()==<span class=\"hljs-number\">0</span>) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&quot;&quot;</span>;<br>    <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(pre.length==<span class=\"hljs-number\">1</span>) <span class=\"hljs-keyword\">return</span> pre;<br>    <span class=\"hljs-keyword\">else</span>&#123;<br>        <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">pos</span> <span class=\"hljs-operator\">=</span> mid.indexOf(pre.charAt(<span class=\"hljs-number\">0</span>));<br>        <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">left</span> <span class=\"hljs-operator\">=</span> f(pre.substring(<span class=\"hljs-number\">1</span>,pos+<span class=\"hljs-number\">1</span>),mid.substring(<span class=\"hljs-number\">0</span>,pos));<br>        <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">right</span> <span class=\"hljs-operator\">=</span> f(pre.substring(pos+<span class=\"hljs-number\">1</span>),mid.substring(pos+<span class=\"hljs-number\">1</span>));<br>        <span class=\"hljs-keyword\">return</span> left+right+pre.charAt(<span class=\"hljs-number\">0</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h1 id=\"第九章-图\"><a href=\"#第九章-图\" class=\"headerlink\" title=\"第九章 图\"></a>第九章 图</h1><h1 id=\"第十章-动态规划\"><a href=\"#第十章-动态规划\" class=\"headerlink\" title=\"第十章 动态规划\"></a>第十章 动态规划</h1><h4 id=\"LCS-最长公共子序列\"><a href=\"#LCS-最长公共子序列\" class=\"headerlink\" title=\"LCS 最长公共子序列\"></a>LCS 最长公共子序列</h4><p>思路：</p>\n<p>​        1.用一个数组 dp[ i ][ j ] 表示 S 字符串中前 i 个字符与 T 字符串中前 j 个字符的最长上升子序列，那么 dp[ i+1 ][ j+1 ] 就是S 字符串中前 i+1 个字符与 T 字符串中前 j+1 个字符的最长上升子序列；</p>\n<p>​        2.如果此时 S 中的第 i+1 个字符与 T 中的第 j+1 个字符相同，那么 dp[ i+1 ][ j+1 ] = dp[ i ][ j ] + 1;</p>\n<p>​        3.如果此时 S 中的第 i+1 个字符与 T 中的第 j+1 个字符不同，那么 dp[ i+1 ][ j+1 ] = Math.max ( dp[ i+1 ][ j ] , dp[ i ][ j+1 ] );</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">LCS</span><span class=\"hljs-params\">(String s,String t)</span>&#123;<br>    <span class=\"hljs-type\">int</span>[][] dp=<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">int</span>[s.length()+<span class=\"hljs-number\">1</span>][t.length()+<span class=\"hljs-number\">1</span>];<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">1</span>;i&lt;=s.length();i++)&#123;<br>        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> j=<span class=\"hljs-number\">1</span>;j&lt;=t.length();j++)&#123;<br>            <span class=\"hljs-keyword\">if</span>(s.charAt(i-<span class=\"hljs-number\">1</span>)==t.charAt(j-<span class=\"hljs-number\">1</span>))<br>                dp[i][j]=dp[i-<span class=\"hljs-number\">1</span>][j-<span class=\"hljs-number\">1</span>]+<span class=\"hljs-number\">1</span>;<br>            <span class=\"hljs-keyword\">else</span><br>                dp[i][j]=Math.max(dp[i][j-<span class=\"hljs-number\">1</span>],dp[i-<span class=\"hljs-number\">1</span>][j]);<br>        &#125;<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> dp[len1][len2];<br>&#125;<br></code></pre></td></tr></table></figure>\n\n"},{"title":"Redis学习笔记","index_img":"https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202309111618302.png","abbrlink":30038,"date":"2022-10-27T12:27:45.000Z","_content":"\n> 1. 阅读Redis官方文档：Redis官方文档是学习Redis的最佳资源之一，它提供了全面的介绍和指导，包括数据结构、命令、配置和部署等方面的内容。可以从Redis官方网站上获取最新版本的文档。\n>2. 掌握Redis的基本数据结构：Redis支持多种数据结构，如字符串、哈希、列表、集合和有序集合等。要深入了解Redis，必须掌握这些基本数据结构，以及它们的操作和用途。\n> 3. 实践：阅读Redis文档仅仅是开始，最重要的是实践。使用Redis CLI或者客户端库来执行一些命令，创建一些数据结构，并且观察其行为。尝试使用不同的数据结构和命令，以及探索Redis的一些高级特性，如事务和Lua脚本等。\n> 4. 学习Redis的应用场景：Redis有很多应用场景，如缓存、消息队列、计数器、排行榜等等。学习这些应用场景可以帮助你更好地理解Redis的特性和优势。\n> 5. 学习Redis的高级特性：Redis还有很多高级特性，如发布订阅、Lua脚本、事务、持久化、集群等。学习这些特性可以帮助你更好地利用Redis来构建复杂的应用。\n> 6. 阅读Redis源代码：如果你想深入了解Redis的实现细节，阅读Redis的源代码是一个很好的方式。可以通过GitHub获取Redis的源代码，并尝试阅读和理解其中的实现。\n> 7. 参加Redis社区：Redis社区是一个非常活跃的社区，有很多专家和开发者会在社区中分享他们的经验和见解。参加Redis社区可以帮助你更好地了解Redis，并与其他Redis用户和开发者互动。\n> \n> 总之，要系统和高效地学习Redis，需要全面了解Redis的基本概念和数据结构，掌握Redis的应用场景和高级特性，进行实践和尝试，并参加Redis社区。\n\n# 黑马Redis\n\n## Redis介绍\n\n简介：什么是Redis？Redis是一种基于键值对的非关系型数据库。\n\n优点：\n\n* 满足很多使用场景。Redis数据库比一般的键值对数据库要强大很多，Redis中的value支持多种数据类型与数据结构，例如：String、hash、list、Set、zset（有序集合）、Bitmaps（位图）、HyperLogLog、GEO（地理信息定位）等。![Redis基本数据结构](https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/redis-10434dc7-c7a3-4c1a-b484-de3fb37669ee.png)\n* 基于内存，读写性能出色。同时内存数据可定时通过快照和日志的形式保存到硬盘之上，做到断电不丢失。\n* 还提供了键过期、发布订阅、事物、流水线、Lua脚本等附加功能。\n\n应用领域：\n\n* 缓存：应用最广的地方，很多web应用都会选择使用Redis作为缓存，以降低数据源压力，提高响应速度。![Redis缓存](https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/redis-d44c2397-5994-452f-8b7b-eb85d2b87685.png)\n* 计数器：天然计数功能，可用来记录浏览量、点赞量等\n* 排行榜：借助Redis提供的列表和有序集合数据结构，合理使用数据结构构建排行榜系统\n* 社交网络：点赞与差评、粉丝、共同好友、推送、刷新\n* 消息队列：提供了发布订阅的功能和阻塞队列的功能，可以满足一般消息队列功能\n* 分布式锁：分布式环境下，利用Redis是西安分布式锁\n\n\n\n![Redis数据结构介绍](http://images.rl0206.love/202305021641013.png)\n\nRedis有五种基本数据结构。\n\n**`string`**\n\n字符串最基础的数据结构。字符串类型的值实际可以是字符串（简单的字符串、复杂的字符串（例如JSON、XML））、数字 （整数、浮点数），甚至是二进制（图片、音频、视频），但是值最大不能超过512MB。\n\n字符串主要有以下几个典型使用场景：\n\n- 缓存功能\n- 计数\n- 共享Session\n- 限速\n\n**`hash`**\n\n哈希类型是指键值本身又是一个键值对结构。\n\n哈希主要有以下典型应用场景：\n\n- 缓存用户信息\n- 缓存对象\n\n**`list`**\n\n列表（list）类型是用来存储多个有序的字符串。列表是一种比较灵活的数据结构，它可以充当栈和队列的角色\n\n列表主要有以下几种使用场景：\n\n- 消息队列\n- 文章列表\n\n**`set`**\n\n集合（set）类型也是用来保存多个的字符串元素，但和列表类型不一 样的是，集合中不允许有重复元素，并且集合中的元素是无序的。\n\n集合主要有如下使用场景：\n\n- 标签（tag）\n- 共同关注\n\n**`sorted set`**\n\n有序集合中的元素可以排序。但是它和列表使用索引下标作为排序依据不同的是，它给每个元素设置一个权重（score）作为排序的依据。\n\n有序集合主要应用场景：\n\n- 用户点赞统计\n- 用户排序\n\nRedis为什么快？\n\n> Redis的速度⾮常的快，单机的Redis就可以⽀撑每秒十几万的并发，相对于MySQL来说，性能是MySQL的⼏⼗倍。速度快的原因主要有⼏点：\n\n* 完全基于内存\n* 使用单线程，避免线程切换和竟态产生的消耗\n* 基于非阻塞的IO多路复用机制\n* C语言实现，优化过的数据结构基于几种基本的数据结构，Redis做了大量优化，性能高\n\n怎么理解多路复用？\n\n> 引用知乎上一个高赞的回答来解释什么是I/O多路复用。假设你是一个老师，让30个学生解答一道题目，然后检查学生做的是否正确，你有下面几个选择：\n\n- 第一种选择：按顺序逐个检查，先检查A，然后是B，之后是C、D。。。这中间如果有一个学生卡住，全班都会被耽误。这种模式就好比，你用循环挨个处理socket，根本不具有并发能力。\n- 第二种选择：你创建30个分身，每个分身检查一个学生的答案是否正确。 这种类似于为每一个用户创建一个进程或者- 线程处理连接。\n- 第三种选择，你站在讲台上等，谁解答完谁举手。这时C、D举手，表示他们解答问题完毕，你下去依次检查C、D的答案，然后继续回到讲台上等。此时E、A又举手，然后去处理E和A。\n\n第一种就是阻塞IO模型，第三种就是I/O复用模型。\n\n![I/O模型](http://images.rl0206.love/202305021556308.png)\n\nRedis如何数据持久化？\n\n> Redis是完全基于内存的，要想避免数据断电丢失，就必须把数据持久化，数据持久化的方式有两种：RDB、AOF\n\n* RDB：RDB持久化是把当前进程数据生成快照保存到硬盘的过程，触发RDB持久化过程分为手动触发和自动触发。RDB⽂件是⼀个压缩的⼆进制⽂件，通过它可以还原某个时刻数据库的状态。由于RDB⽂件是保存在硬盘上的，所以即使Redis崩溃或者退出，只要RDB⽂件存在，就可以⽤它来恢复还原数据库的状态。\n\n  * 手动触发分别对应save和bgsave命令: ![save和bgsave](https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/redis-ffe56e32-34c5-453d-8859-c2febbe6a038.png)\n    - save命令：阻塞当前Redis服务器，直到RDB过程完成为止，对于内存比较大的实例会造成长时间阻塞，线上环境不建议使用。\n    - bgsave命令：Redis进程执行fork操作创建子进程，RDB持久化过程由子进程负责，完成后自动结束。阻塞只发生在fork阶段，一般时间很短。\n  * 以下场景会自动触发RDB持久化：\n    * 使用save相关配置，如“save m n”。表示m秒内数据集存在n次修改时，自动触发bgsave。\n    * 如果从节点执行全量复制操作，主节点自动执行bgsave生成RDB文件并发送给从节点\n    * 执行debug reload命令重新加载Redis时，也会自动触发save操作\n    * 默认情况下执行shutdown命令时，如果没有开启AOF持久化功能则自动执行bgsave。\n\n* AOF（append only file）持久化：以独立日志的方式记录每次写命令， 重启时再重新执行AOF文件中的命令达到恢复数据的目的。AOF的主要作用是解决了数据持久化的实时性，目前已经是Redis持久化的主流方式\n\n  * AOF的工作流程操作：命令写入 （append）、文件同步（sync）、文件重写（rewrite）、重启加载 （load） \n\n    ![AOF工作流程](https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/redis-a9fb6202-b1a1-484d-a4fa-fef519090b44.png)\n\n  * 流程如下：\n\n    * 1）所有的写入命令会追加到aof_buf（缓冲区）中。\n    * 2）AOF缓冲区根据对应的策略向硬盘做同步操作。\n    * 3）随着AOF文件越来越大，需要定期对AOF文件进行重写，达到压缩 的目的。\n    * 4）当Redis服务器重启时，可以加载AOF文件进行数据恢复。\n\n\n\n\n\n\n## Redis命令 \n\n[redis帮助文档](https://redis.io/commands/)\n\n![image-20230416091404745](http://images.rl0206.love/202305021641017.png)\n\n![image-20230416092238674](http://images.rl0206.love/202305021641018.png)\n\n![image-20230416093225232](http://images.rl0206.love/202305021641019.png)\n\n![image-20230416094344011](http://images.rl0206.love/202305021641020.png)\n\n![image-20230416100340583](http://images.rl0206.love/202305021641021.png)\n\n![image-20230416100753096](http://images.rl0206.love/202305021641022.png)\n\n![image-20230416101608129](http://images.rl0206.love/202305021641023.png)\n\n![image-20230416101850417](http://images.rl0206.love/202305021641024.png)\n\n![image-20230416102809805](http://images.rl0206.love/202305021641026.png) \n\n![image-20230416103712554](http://images.rl0206.love/202305021641027.png)\n\n![image-20230416105319879](http://images.rl0206.love/202305021641028.png)\n\n注意：所有的排名都是升序，若要降序，则在Z的后面加REV即可。\n\n## Redis进阶\n\n>什么是主从复制？\n\n* **主从复制**，是指将一台 Redis 服务器的数据，复制到其他的 Redis 服务器。前者称为 **主节点(master)**，后者称为 **从节点(slave)**。且数据的复制是 **单向** 的，只能由主节点到从节点。Redis 主从复制支持 **主从同步** 和 **从从同步** 两种，后者是 Redis 后续版本新增的功能，以减轻主节点的同步负担。\n\n![主从复制图](http://images.rl0206.love/202305031511055.png)\n\n>主从复制什么作用？\n\n- **数据冗余：** 主从复制实现了数据的**热备份**，是持久化之外的一种数据冗余方式。\n- **故障恢复：** 当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复 *(实际上是一种服务的冗余)*。\n- **负载均衡：** 在主从复制的基础上，配合读写分离，可以由主节点提供写服务，由从节点提供读服务 *（即写 Redis 数据时应用连接主节点，读 Redis 数据时应用连接从节点）*，分担服务器负载。尤其是在写少读多的场景下，通过多个从节点分担读负载，可以大大提高 Redis 服务器的并发量。\n- **高可用基石：** 除了上述作用以外，主从复制还是哨兵和集群能够实施的 **基础**，因此说主从复制是 Redis 高可用的基础。\n\n> Redis主从有几种常见的拓扑结构？\n\nRedis的复制拓扑结构可以支持单层或多层复制。\n\n根据拓扑结构的复杂性可以分为三种：一主一从、一主多从、树状主从。\n\n* 一主一从结构\n\n  * 一主一从结构是最简单的复制拓扑结构。应用场景：用于主节点出现宕机时从节点提供故障转移支持（故障恢复）\n\n    ![](https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/redis-5d91a67c-dbff-4a8d-bf9d-1fe7602d5a27.png)\n\n* 一主多从\n\n  * 一主多从结构（又称星形拓扑结构）。应用场景：使得应用端可以利用多个从节点实现读写分离，对于读占比较大的场景，可以把读命令发送到从节点来分担主节点压力（负载均衡）。\n\n    ![](https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/redis-71074254-699a-480b-bbb0-c68f364a380b.png)\n\n* 树状主从\n\n  * 树状主从结构（又称树状拓扑结构）。应用场景：使得从节点不但可以复制主节点数据，同时可以作为其他从节点的主节点继续向下层复制。通过引入复制中间层，可以有效降低主节点负载和需要传送给从节点的数据量（负载均衡）。\n\n    ![](https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/redis-dff14203-5e01-4d1b-a775-10ee444ada54.png)\n\n\n\n上面说了什么是？什么用？ 以及常见的拓扑结构，接下来详细说一说主从的基本原理，一起搞懂Redis主从吧！\n\n> Redis主从复制原理？\n\nRedis主从复制的工作流程大概可以分为如下几步：（官方文档翻译后的答案）\n1、保存主节点（master）信息 这一步只是保存主节点信息，保存主节点的ip和port。\n2、主从建立连接 从节点（slave）发现新的主节点后，会尝试和主节点建立网络连接。\n3、发送ping命令 连接建立成功后从节点发送ping请求进行首次通信，主要是检测主从之间网络套接字是否可用、主节点当前是否可接受处理命令。\n4、权限验证 如果主节点要求密码验证，从节点必须正确的密码才能通过验证。\n5、同步数据集 主从复制连接正常通信后，主节点会把持有的数据全部发送给从节点。\n6、命令持续复制 接下来主节点会持续地把写命令发送给从节点，保证主从数据一致性。\n\n![Redis主从复制工作流程](http://images.rl0206.love/202305031556969.png)\n\n```\nRedis主从复制的工作流程如下：（GPT给的2.8以下版本的Redis）\n\n1. 当一个Redis从服务器连接到主服务器时，它会向主服务器发送一个SYNC命令，请求同步数据。\n2. 主服务器接收到SYNC命令后，会开启一个后台线程，将所有写命令记录到一个缓冲区中，同时将缓冲区中的数据发送给从服务器。\n3. 从服务器接收到数据后，将其存储在自己的数据库中，并向主服务器发送一个ACK命令，表示已经接收到数据。\n4. 主服务器接收到ACK命令后，将缓冲区中的数据删除，并继续等待新的写命令。如果从服务器断开连接，主服务器会尝试重新连接。\n5. 当主服务器发生故障或者重启时，从服务器会重新连接到主服务器，并请求同步数据。此时，主服务器会将所有未同步的数据发送给从服务器，并重新开始记录写命令。\n6. 如果主服务器在同步数据时出现错误，从服务器会断开连接，并尝试重新连接到主服务器。如果多次尝试失败，从服务器会成为一个新的主服务器。\n\n总的来说，Redis主从复制的工作流程是基于异步复制的，主服务器不会等待从服务器的响应，而是将数据发送给从服务器后立即返回。这种方式可以提高性能，但也有可能会导致数据不一致的问题。因此，在使用Redis主从复制时，需要注意数据一致性的问题\n```\n\n\n\n> 主从数据同步的方式？\n\nRedis在2.8及以上版本使用psync命令完成主从数据同步，同步过程分为：全量复制和部分复制。\n\n1. **全量复制** 一般用于初次复制场景，Redis早期支持的复制功能只有全量复制，它会把主节点全部数据一次性发送给从节点，当数据量较大时，会对主从节点和网络造成很大的开销。\n\n   全量复制的完整运行流程如下： ![全量复制](https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/redis-aa8d2960-b341-49cc-b04c-201241fd15de.png)\n\n   1. 发送psync命令进行数据同步，由于是第一次进行复制，从节点没有复制偏移量和主节点的运行ID，所以发送psync-1。\n   2. 主节点根据psync-1解析出当前为全量复制，回复+FULLRESYNC响应。\n   3. 从节点接收主节点的响应数据保存运行ID和偏移量offset\n   4. 主节点执行bgsave保存RDB文件到本地\n   5. 主节点发送RDB文件给从节点，从节点把接收的RDB文件保存在本地并直接作为从节点的数据文件\n   6. 对于从节点开始接收RDB快照到接收完成期间，主节点仍然响应读写命令，因此主节点会把这期间写命令数据保存在复制客户端缓冲区内，当从节点加载完RDB文件后，主节点再把缓冲区内的数据发送给从节点，保证主从之间数据一致性。\n   7. 从节点接收完主节点传送来的全部数据后会清空自身旧数据\n   8. 从节点清空数据后开始加载RDB文件\n   9. 从节点成功加载完RDB后，如果当前节点开启了AOF持久化功能， 它会立刻做bgrewriteaof操作，为了保证全量复制后AOF持久化文件立刻可用。\n\n   **部分复制** 部分复制主要是Redis针对全量复制的过高开销做出的一种优化措施， 使用psync{runId}{offset}命令实现。当从节点（slave）正在复制主节点 （master）时，如果出现网络闪断或者命令丢失等异常情况时，从节点会向 主节点要求补发丢失的命令数据，如果主节点的复制积压缓冲区内存在这部分数据则直接发送给从节点，这样就可以保持主从节点复制的一致性。 ![部分复制](https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/redis-87600c72-cc6a-4656-81b2-e71864c97f23.png)\n\n   1. 当主从节点之间网络出现中断时，如果超过repl-timeout时间，主节点会认为从节点故障并中断复制连接\n   2. 主从连接中断期间主节点依然响应命令，但因复制连接中断命令无法发送给从节点，不过主节点内部存在的复制积压缓冲区，依然可以保存最近一段时间的写命令数据，默认最大缓存1MB。\n   3. 当主从节点网络恢复后，从节点会再次连上主节点\n   4. 当主从连接恢复后，由于从节点之前保存了自身已复制的偏移量和主节点的运行ID。因此会把它们当作psync参数发送给主节点，要求进行部分复制操作。\n   5. 主节点接到psync命令后首先核对参数runId是否与自身一致，如果一 致，说明之前复制的是当前主节点；之后根据参数offset在自身复制积压缓冲区查找，如果偏移量之后的数据存在缓冲区中，则对从节点发送+CONTINUE响应，表示可以进行部分复制。\n   6. 主节点根据偏移量把复制积压缓冲区里的数据发送给从节点，保证主从复制进入正常状态。\n\n\n\n> 主从复制存在哪些问题？（主要是高可用和分布式两个方面）\n\n* 一旦主节点出现故障，需要手动将一个从节点设置为主节点，同时还需要修改应用方的主节点的地址，还需要命令之前的从节点去复制新的主节点，整个过程比较麻烦，需要人工进行干预；\n* 主节点的写作能力和存储能力会受到单机的限制\n\n**那么基于以上只从复制存在的问题，我们该如何解决？！这就引入了哨兵的概念（Redis Sentinel）**\n\n> 什么是Redis Sentinel（哨兵）？\n\n鉴于Redis主从复制存在的一些问题就是需要人工的干预，于是Redis设计出了哨兵系统的方案，借助这个方案可以自动完成故障转移。\n\n![Redis Sentinel](http://images.rl0206.love/202305031650481.png)\n\n\n\n\n\n## Redis客户端\n\n![image-20230416111339698](http://images.rl0206.love/202305021641029.png)\n\n![image-20230416111856694](http://images.rl0206.love/202305021641030.png)\n\n Jedis使用的基本步骤：\n\n1.引入依赖\n\n2.创建Jedis对象，建立连接\n\n3.使用Jedis，方法名与Redis命令一致\n\n4.释放资源\n\n\n\n1、引入依赖\n\n```Java\n<dependency>\n    <groupId>redis.clients</groupId>\n    <artifactId>jedis</artifactId>\n    <version>3.7.0</version>\n</dependency>\n```\n\n2、使用Jedis连接池创建连接\n\nJedis本身是线程不安全的，并且频繁的创建和销毁连接会有性能损耗，因此我们推荐大家使用Jedis连接池代替Jedis的直连方式。\n\n```Java\npublic class JedisConnectionFactory {\n   private static final JedisPool jedisPool;\n\n   static {\n     JedisPoolConfig jedisPoolConfig = new JedisPoolConfig();\n     // 最大连接\n     jedisPoolConfig.setMaxTotal(8);\n     // 最大空闲连接\n     jedisPoolConfig.setMaxIdle(8); \n     // 最小空闲连接\n     jedisPoolConfig.setMinIdle(0);\n     // 设置最长等待时间， ms\n     jedisPoolConfig.setMaxWaitMillis(200);\n     jedisPool = new JedisPool(jedisPoolConfig, \"192.168.150.101\", 6379,\n         1000, \"123321\");\n   }\n   // 获取Jedis对象\n   public static Jedis getJedis(){\n     return jedisPool.getResource();\n   }\n }\n```\n\n3、使用Jedis进行单元测试\n\n```java\nprivate Jedis jedis;\n  // 单元测试的注释写法\n  @BeforeEach\n  void setUp() {\n    // 建立连接\n    jedis = JedisConnectionFactory.getJedis();\n    // 设置密码\n    jedis.auth(\"123321\");\n    // 选择库\n    jedis.select(0);\n}\n  @Test\n  void testString() {\n    // 插入数据，方法名称就是redis命令名称，非常简单\n    String result = jedis.set(\"name\", \"张三\");\n    System.out.println(\"result = \" + result); \n    // 获取数据\n    String name = jedis.get(\"name\");\n    System.out.println(\"name = \" + name);\n}\n  @AfterEach\n  void tearDown() {\n    // 释放资源\n    if (jedis != null) {\n      jedis.close();\n    }\n}\n```\n\n## SpringDataRedis\n\n> 打破Redis只接收String，接收Object类，内部通过JDK的序列化工具进行转换。（即传入一个Object对象，会将其序列化，将其“剁碎”，传入Redis，若想不剁碎，就需要重写RedisTemplate的序列化方式）\n\n 那我们如何重写呢？\n\n```Java\n\n```\n\n存：自动化将对象转JSON,\n\n取：JSON反序列化为对象\n\n什么原理呢？\n\n我们会发现，在自动化转JSON时，会在JSON中第一行加入User的CLASS属性（对应的是User类的名称），所以说在反序列化的时候，会将对应的User写进来。巧妙之处就在于JSON串第一行的Class名称记录。\n\n尽管序列化方式可以满足我们的需求，但时仍然存在问题：为了在反序列化时知道对象的类型，JSON选择将类的Class类型写入JSON结果中，存入Redis，因此导致了额外的内存开销。\n\n那么，如何解决？如何节省内存空间？\n\n为了节约内存空间，一般不会使用JSON序列化工具，而会使用String序列化器，但这只能存储String类型的键值对，所以我们的解决方案就是：用的到对象反序列化时，再手动创建对象的序列化和反序列化。\n\n![image-20230419105307964](http://images.rl0206.love/202305021641031.png)\n\nRedis序列化两种方案：\n\n第一种：自定义Templete，修改RedisTemplete的序列化器为GenericJachson2JsonRedisSerializer；\n\n```\npublic class RedisConfig{\n\t@Bean\n\tpublic RedisTemplete<String,Object> redisTemplete(RedisConnectionFactory connectionFactory){\n\t\t\n\t}\n}\n```\n\n第二种：使用RedisRedisTemplete，手动序列化，读取时，手动反序列化。\n\n","source":"_posts/Redis.md","raw":"---\ntitle: Redis学习笔记\nindex_img: >-\n  https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202309111618302.png\ncategories:\n  - Java notes\ntags:\n  - Redis\nabbrlink: 30038\ndate: 2022-10-27 20:27:45\n---\n\n> 1. 阅读Redis官方文档：Redis官方文档是学习Redis的最佳资源之一，它提供了全面的介绍和指导，包括数据结构、命令、配置和部署等方面的内容。可以从Redis官方网站上获取最新版本的文档。\n>2. 掌握Redis的基本数据结构：Redis支持多种数据结构，如字符串、哈希、列表、集合和有序集合等。要深入了解Redis，必须掌握这些基本数据结构，以及它们的操作和用途。\n> 3. 实践：阅读Redis文档仅仅是开始，最重要的是实践。使用Redis CLI或者客户端库来执行一些命令，创建一些数据结构，并且观察其行为。尝试使用不同的数据结构和命令，以及探索Redis的一些高级特性，如事务和Lua脚本等。\n> 4. 学习Redis的应用场景：Redis有很多应用场景，如缓存、消息队列、计数器、排行榜等等。学习这些应用场景可以帮助你更好地理解Redis的特性和优势。\n> 5. 学习Redis的高级特性：Redis还有很多高级特性，如发布订阅、Lua脚本、事务、持久化、集群等。学习这些特性可以帮助你更好地利用Redis来构建复杂的应用。\n> 6. 阅读Redis源代码：如果你想深入了解Redis的实现细节，阅读Redis的源代码是一个很好的方式。可以通过GitHub获取Redis的源代码，并尝试阅读和理解其中的实现。\n> 7. 参加Redis社区：Redis社区是一个非常活跃的社区，有很多专家和开发者会在社区中分享他们的经验和见解。参加Redis社区可以帮助你更好地了解Redis，并与其他Redis用户和开发者互动。\n> \n> 总之，要系统和高效地学习Redis，需要全面了解Redis的基本概念和数据结构，掌握Redis的应用场景和高级特性，进行实践和尝试，并参加Redis社区。\n\n# 黑马Redis\n\n## Redis介绍\n\n简介：什么是Redis？Redis是一种基于键值对的非关系型数据库。\n\n优点：\n\n* 满足很多使用场景。Redis数据库比一般的键值对数据库要强大很多，Redis中的value支持多种数据类型与数据结构，例如：String、hash、list、Set、zset（有序集合）、Bitmaps（位图）、HyperLogLog、GEO（地理信息定位）等。![Redis基本数据结构](https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/redis-10434dc7-c7a3-4c1a-b484-de3fb37669ee.png)\n* 基于内存，读写性能出色。同时内存数据可定时通过快照和日志的形式保存到硬盘之上，做到断电不丢失。\n* 还提供了键过期、发布订阅、事物、流水线、Lua脚本等附加功能。\n\n应用领域：\n\n* 缓存：应用最广的地方，很多web应用都会选择使用Redis作为缓存，以降低数据源压力，提高响应速度。![Redis缓存](https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/redis-d44c2397-5994-452f-8b7b-eb85d2b87685.png)\n* 计数器：天然计数功能，可用来记录浏览量、点赞量等\n* 排行榜：借助Redis提供的列表和有序集合数据结构，合理使用数据结构构建排行榜系统\n* 社交网络：点赞与差评、粉丝、共同好友、推送、刷新\n* 消息队列：提供了发布订阅的功能和阻塞队列的功能，可以满足一般消息队列功能\n* 分布式锁：分布式环境下，利用Redis是西安分布式锁\n\n\n\n![Redis数据结构介绍](http://images.rl0206.love/202305021641013.png)\n\nRedis有五种基本数据结构。\n\n**`string`**\n\n字符串最基础的数据结构。字符串类型的值实际可以是字符串（简单的字符串、复杂的字符串（例如JSON、XML））、数字 （整数、浮点数），甚至是二进制（图片、音频、视频），但是值最大不能超过512MB。\n\n字符串主要有以下几个典型使用场景：\n\n- 缓存功能\n- 计数\n- 共享Session\n- 限速\n\n**`hash`**\n\n哈希类型是指键值本身又是一个键值对结构。\n\n哈希主要有以下典型应用场景：\n\n- 缓存用户信息\n- 缓存对象\n\n**`list`**\n\n列表（list）类型是用来存储多个有序的字符串。列表是一种比较灵活的数据结构，它可以充当栈和队列的角色\n\n列表主要有以下几种使用场景：\n\n- 消息队列\n- 文章列表\n\n**`set`**\n\n集合（set）类型也是用来保存多个的字符串元素，但和列表类型不一 样的是，集合中不允许有重复元素，并且集合中的元素是无序的。\n\n集合主要有如下使用场景：\n\n- 标签（tag）\n- 共同关注\n\n**`sorted set`**\n\n有序集合中的元素可以排序。但是它和列表使用索引下标作为排序依据不同的是，它给每个元素设置一个权重（score）作为排序的依据。\n\n有序集合主要应用场景：\n\n- 用户点赞统计\n- 用户排序\n\nRedis为什么快？\n\n> Redis的速度⾮常的快，单机的Redis就可以⽀撑每秒十几万的并发，相对于MySQL来说，性能是MySQL的⼏⼗倍。速度快的原因主要有⼏点：\n\n* 完全基于内存\n* 使用单线程，避免线程切换和竟态产生的消耗\n* 基于非阻塞的IO多路复用机制\n* C语言实现，优化过的数据结构基于几种基本的数据结构，Redis做了大量优化，性能高\n\n怎么理解多路复用？\n\n> 引用知乎上一个高赞的回答来解释什么是I/O多路复用。假设你是一个老师，让30个学生解答一道题目，然后检查学生做的是否正确，你有下面几个选择：\n\n- 第一种选择：按顺序逐个检查，先检查A，然后是B，之后是C、D。。。这中间如果有一个学生卡住，全班都会被耽误。这种模式就好比，你用循环挨个处理socket，根本不具有并发能力。\n- 第二种选择：你创建30个分身，每个分身检查一个学生的答案是否正确。 这种类似于为每一个用户创建一个进程或者- 线程处理连接。\n- 第三种选择，你站在讲台上等，谁解答完谁举手。这时C、D举手，表示他们解答问题完毕，你下去依次检查C、D的答案，然后继续回到讲台上等。此时E、A又举手，然后去处理E和A。\n\n第一种就是阻塞IO模型，第三种就是I/O复用模型。\n\n![I/O模型](http://images.rl0206.love/202305021556308.png)\n\nRedis如何数据持久化？\n\n> Redis是完全基于内存的，要想避免数据断电丢失，就必须把数据持久化，数据持久化的方式有两种：RDB、AOF\n\n* RDB：RDB持久化是把当前进程数据生成快照保存到硬盘的过程，触发RDB持久化过程分为手动触发和自动触发。RDB⽂件是⼀个压缩的⼆进制⽂件，通过它可以还原某个时刻数据库的状态。由于RDB⽂件是保存在硬盘上的，所以即使Redis崩溃或者退出，只要RDB⽂件存在，就可以⽤它来恢复还原数据库的状态。\n\n  * 手动触发分别对应save和bgsave命令: ![save和bgsave](https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/redis-ffe56e32-34c5-453d-8859-c2febbe6a038.png)\n    - save命令：阻塞当前Redis服务器，直到RDB过程完成为止，对于内存比较大的实例会造成长时间阻塞，线上环境不建议使用。\n    - bgsave命令：Redis进程执行fork操作创建子进程，RDB持久化过程由子进程负责，完成后自动结束。阻塞只发生在fork阶段，一般时间很短。\n  * 以下场景会自动触发RDB持久化：\n    * 使用save相关配置，如“save m n”。表示m秒内数据集存在n次修改时，自动触发bgsave。\n    * 如果从节点执行全量复制操作，主节点自动执行bgsave生成RDB文件并发送给从节点\n    * 执行debug reload命令重新加载Redis时，也会自动触发save操作\n    * 默认情况下执行shutdown命令时，如果没有开启AOF持久化功能则自动执行bgsave。\n\n* AOF（append only file）持久化：以独立日志的方式记录每次写命令， 重启时再重新执行AOF文件中的命令达到恢复数据的目的。AOF的主要作用是解决了数据持久化的实时性，目前已经是Redis持久化的主流方式\n\n  * AOF的工作流程操作：命令写入 （append）、文件同步（sync）、文件重写（rewrite）、重启加载 （load） \n\n    ![AOF工作流程](https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/redis-a9fb6202-b1a1-484d-a4fa-fef519090b44.png)\n\n  * 流程如下：\n\n    * 1）所有的写入命令会追加到aof_buf（缓冲区）中。\n    * 2）AOF缓冲区根据对应的策略向硬盘做同步操作。\n    * 3）随着AOF文件越来越大，需要定期对AOF文件进行重写，达到压缩 的目的。\n    * 4）当Redis服务器重启时，可以加载AOF文件进行数据恢复。\n\n\n\n\n\n\n## Redis命令 \n\n[redis帮助文档](https://redis.io/commands/)\n\n![image-20230416091404745](http://images.rl0206.love/202305021641017.png)\n\n![image-20230416092238674](http://images.rl0206.love/202305021641018.png)\n\n![image-20230416093225232](http://images.rl0206.love/202305021641019.png)\n\n![image-20230416094344011](http://images.rl0206.love/202305021641020.png)\n\n![image-20230416100340583](http://images.rl0206.love/202305021641021.png)\n\n![image-20230416100753096](http://images.rl0206.love/202305021641022.png)\n\n![image-20230416101608129](http://images.rl0206.love/202305021641023.png)\n\n![image-20230416101850417](http://images.rl0206.love/202305021641024.png)\n\n![image-20230416102809805](http://images.rl0206.love/202305021641026.png) \n\n![image-20230416103712554](http://images.rl0206.love/202305021641027.png)\n\n![image-20230416105319879](http://images.rl0206.love/202305021641028.png)\n\n注意：所有的排名都是升序，若要降序，则在Z的后面加REV即可。\n\n## Redis进阶\n\n>什么是主从复制？\n\n* **主从复制**，是指将一台 Redis 服务器的数据，复制到其他的 Redis 服务器。前者称为 **主节点(master)**，后者称为 **从节点(slave)**。且数据的复制是 **单向** 的，只能由主节点到从节点。Redis 主从复制支持 **主从同步** 和 **从从同步** 两种，后者是 Redis 后续版本新增的功能，以减轻主节点的同步负担。\n\n![主从复制图](http://images.rl0206.love/202305031511055.png)\n\n>主从复制什么作用？\n\n- **数据冗余：** 主从复制实现了数据的**热备份**，是持久化之外的一种数据冗余方式。\n- **故障恢复：** 当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复 *(实际上是一种服务的冗余)*。\n- **负载均衡：** 在主从复制的基础上，配合读写分离，可以由主节点提供写服务，由从节点提供读服务 *（即写 Redis 数据时应用连接主节点，读 Redis 数据时应用连接从节点）*，分担服务器负载。尤其是在写少读多的场景下，通过多个从节点分担读负载，可以大大提高 Redis 服务器的并发量。\n- **高可用基石：** 除了上述作用以外，主从复制还是哨兵和集群能够实施的 **基础**，因此说主从复制是 Redis 高可用的基础。\n\n> Redis主从有几种常见的拓扑结构？\n\nRedis的复制拓扑结构可以支持单层或多层复制。\n\n根据拓扑结构的复杂性可以分为三种：一主一从、一主多从、树状主从。\n\n* 一主一从结构\n\n  * 一主一从结构是最简单的复制拓扑结构。应用场景：用于主节点出现宕机时从节点提供故障转移支持（故障恢复）\n\n    ![](https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/redis-5d91a67c-dbff-4a8d-bf9d-1fe7602d5a27.png)\n\n* 一主多从\n\n  * 一主多从结构（又称星形拓扑结构）。应用场景：使得应用端可以利用多个从节点实现读写分离，对于读占比较大的场景，可以把读命令发送到从节点来分担主节点压力（负载均衡）。\n\n    ![](https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/redis-71074254-699a-480b-bbb0-c68f364a380b.png)\n\n* 树状主从\n\n  * 树状主从结构（又称树状拓扑结构）。应用场景：使得从节点不但可以复制主节点数据，同时可以作为其他从节点的主节点继续向下层复制。通过引入复制中间层，可以有效降低主节点负载和需要传送给从节点的数据量（负载均衡）。\n\n    ![](https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/redis-dff14203-5e01-4d1b-a775-10ee444ada54.png)\n\n\n\n上面说了什么是？什么用？ 以及常见的拓扑结构，接下来详细说一说主从的基本原理，一起搞懂Redis主从吧！\n\n> Redis主从复制原理？\n\nRedis主从复制的工作流程大概可以分为如下几步：（官方文档翻译后的答案）\n1、保存主节点（master）信息 这一步只是保存主节点信息，保存主节点的ip和port。\n2、主从建立连接 从节点（slave）发现新的主节点后，会尝试和主节点建立网络连接。\n3、发送ping命令 连接建立成功后从节点发送ping请求进行首次通信，主要是检测主从之间网络套接字是否可用、主节点当前是否可接受处理命令。\n4、权限验证 如果主节点要求密码验证，从节点必须正确的密码才能通过验证。\n5、同步数据集 主从复制连接正常通信后，主节点会把持有的数据全部发送给从节点。\n6、命令持续复制 接下来主节点会持续地把写命令发送给从节点，保证主从数据一致性。\n\n![Redis主从复制工作流程](http://images.rl0206.love/202305031556969.png)\n\n```\nRedis主从复制的工作流程如下：（GPT给的2.8以下版本的Redis）\n\n1. 当一个Redis从服务器连接到主服务器时，它会向主服务器发送一个SYNC命令，请求同步数据。\n2. 主服务器接收到SYNC命令后，会开启一个后台线程，将所有写命令记录到一个缓冲区中，同时将缓冲区中的数据发送给从服务器。\n3. 从服务器接收到数据后，将其存储在自己的数据库中，并向主服务器发送一个ACK命令，表示已经接收到数据。\n4. 主服务器接收到ACK命令后，将缓冲区中的数据删除，并继续等待新的写命令。如果从服务器断开连接，主服务器会尝试重新连接。\n5. 当主服务器发生故障或者重启时，从服务器会重新连接到主服务器，并请求同步数据。此时，主服务器会将所有未同步的数据发送给从服务器，并重新开始记录写命令。\n6. 如果主服务器在同步数据时出现错误，从服务器会断开连接，并尝试重新连接到主服务器。如果多次尝试失败，从服务器会成为一个新的主服务器。\n\n总的来说，Redis主从复制的工作流程是基于异步复制的，主服务器不会等待从服务器的响应，而是将数据发送给从服务器后立即返回。这种方式可以提高性能，但也有可能会导致数据不一致的问题。因此，在使用Redis主从复制时，需要注意数据一致性的问题\n```\n\n\n\n> 主从数据同步的方式？\n\nRedis在2.8及以上版本使用psync命令完成主从数据同步，同步过程分为：全量复制和部分复制。\n\n1. **全量复制** 一般用于初次复制场景，Redis早期支持的复制功能只有全量复制，它会把主节点全部数据一次性发送给从节点，当数据量较大时，会对主从节点和网络造成很大的开销。\n\n   全量复制的完整运行流程如下： ![全量复制](https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/redis-aa8d2960-b341-49cc-b04c-201241fd15de.png)\n\n   1. 发送psync命令进行数据同步，由于是第一次进行复制，从节点没有复制偏移量和主节点的运行ID，所以发送psync-1。\n   2. 主节点根据psync-1解析出当前为全量复制，回复+FULLRESYNC响应。\n   3. 从节点接收主节点的响应数据保存运行ID和偏移量offset\n   4. 主节点执行bgsave保存RDB文件到本地\n   5. 主节点发送RDB文件给从节点，从节点把接收的RDB文件保存在本地并直接作为从节点的数据文件\n   6. 对于从节点开始接收RDB快照到接收完成期间，主节点仍然响应读写命令，因此主节点会把这期间写命令数据保存在复制客户端缓冲区内，当从节点加载完RDB文件后，主节点再把缓冲区内的数据发送给从节点，保证主从之间数据一致性。\n   7. 从节点接收完主节点传送来的全部数据后会清空自身旧数据\n   8. 从节点清空数据后开始加载RDB文件\n   9. 从节点成功加载完RDB后，如果当前节点开启了AOF持久化功能， 它会立刻做bgrewriteaof操作，为了保证全量复制后AOF持久化文件立刻可用。\n\n   **部分复制** 部分复制主要是Redis针对全量复制的过高开销做出的一种优化措施， 使用psync{runId}{offset}命令实现。当从节点（slave）正在复制主节点 （master）时，如果出现网络闪断或者命令丢失等异常情况时，从节点会向 主节点要求补发丢失的命令数据，如果主节点的复制积压缓冲区内存在这部分数据则直接发送给从节点，这样就可以保持主从节点复制的一致性。 ![部分复制](https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/redis-87600c72-cc6a-4656-81b2-e71864c97f23.png)\n\n   1. 当主从节点之间网络出现中断时，如果超过repl-timeout时间，主节点会认为从节点故障并中断复制连接\n   2. 主从连接中断期间主节点依然响应命令，但因复制连接中断命令无法发送给从节点，不过主节点内部存在的复制积压缓冲区，依然可以保存最近一段时间的写命令数据，默认最大缓存1MB。\n   3. 当主从节点网络恢复后，从节点会再次连上主节点\n   4. 当主从连接恢复后，由于从节点之前保存了自身已复制的偏移量和主节点的运行ID。因此会把它们当作psync参数发送给主节点，要求进行部分复制操作。\n   5. 主节点接到psync命令后首先核对参数runId是否与自身一致，如果一 致，说明之前复制的是当前主节点；之后根据参数offset在自身复制积压缓冲区查找，如果偏移量之后的数据存在缓冲区中，则对从节点发送+CONTINUE响应，表示可以进行部分复制。\n   6. 主节点根据偏移量把复制积压缓冲区里的数据发送给从节点，保证主从复制进入正常状态。\n\n\n\n> 主从复制存在哪些问题？（主要是高可用和分布式两个方面）\n\n* 一旦主节点出现故障，需要手动将一个从节点设置为主节点，同时还需要修改应用方的主节点的地址，还需要命令之前的从节点去复制新的主节点，整个过程比较麻烦，需要人工进行干预；\n* 主节点的写作能力和存储能力会受到单机的限制\n\n**那么基于以上只从复制存在的问题，我们该如何解决？！这就引入了哨兵的概念（Redis Sentinel）**\n\n> 什么是Redis Sentinel（哨兵）？\n\n鉴于Redis主从复制存在的一些问题就是需要人工的干预，于是Redis设计出了哨兵系统的方案，借助这个方案可以自动完成故障转移。\n\n![Redis Sentinel](http://images.rl0206.love/202305031650481.png)\n\n\n\n\n\n## Redis客户端\n\n![image-20230416111339698](http://images.rl0206.love/202305021641029.png)\n\n![image-20230416111856694](http://images.rl0206.love/202305021641030.png)\n\n Jedis使用的基本步骤：\n\n1.引入依赖\n\n2.创建Jedis对象，建立连接\n\n3.使用Jedis，方法名与Redis命令一致\n\n4.释放资源\n\n\n\n1、引入依赖\n\n```Java\n<dependency>\n    <groupId>redis.clients</groupId>\n    <artifactId>jedis</artifactId>\n    <version>3.7.0</version>\n</dependency>\n```\n\n2、使用Jedis连接池创建连接\n\nJedis本身是线程不安全的，并且频繁的创建和销毁连接会有性能损耗，因此我们推荐大家使用Jedis连接池代替Jedis的直连方式。\n\n```Java\npublic class JedisConnectionFactory {\n   private static final JedisPool jedisPool;\n\n   static {\n     JedisPoolConfig jedisPoolConfig = new JedisPoolConfig();\n     // 最大连接\n     jedisPoolConfig.setMaxTotal(8);\n     // 最大空闲连接\n     jedisPoolConfig.setMaxIdle(8); \n     // 最小空闲连接\n     jedisPoolConfig.setMinIdle(0);\n     // 设置最长等待时间， ms\n     jedisPoolConfig.setMaxWaitMillis(200);\n     jedisPool = new JedisPool(jedisPoolConfig, \"192.168.150.101\", 6379,\n         1000, \"123321\");\n   }\n   // 获取Jedis对象\n   public static Jedis getJedis(){\n     return jedisPool.getResource();\n   }\n }\n```\n\n3、使用Jedis进行单元测试\n\n```java\nprivate Jedis jedis;\n  // 单元测试的注释写法\n  @BeforeEach\n  void setUp() {\n    // 建立连接\n    jedis = JedisConnectionFactory.getJedis();\n    // 设置密码\n    jedis.auth(\"123321\");\n    // 选择库\n    jedis.select(0);\n}\n  @Test\n  void testString() {\n    // 插入数据，方法名称就是redis命令名称，非常简单\n    String result = jedis.set(\"name\", \"张三\");\n    System.out.println(\"result = \" + result); \n    // 获取数据\n    String name = jedis.get(\"name\");\n    System.out.println(\"name = \" + name);\n}\n  @AfterEach\n  void tearDown() {\n    // 释放资源\n    if (jedis != null) {\n      jedis.close();\n    }\n}\n```\n\n## SpringDataRedis\n\n> 打破Redis只接收String，接收Object类，内部通过JDK的序列化工具进行转换。（即传入一个Object对象，会将其序列化，将其“剁碎”，传入Redis，若想不剁碎，就需要重写RedisTemplate的序列化方式）\n\n 那我们如何重写呢？\n\n```Java\n\n```\n\n存：自动化将对象转JSON,\n\n取：JSON反序列化为对象\n\n什么原理呢？\n\n我们会发现，在自动化转JSON时，会在JSON中第一行加入User的CLASS属性（对应的是User类的名称），所以说在反序列化的时候，会将对应的User写进来。巧妙之处就在于JSON串第一行的Class名称记录。\n\n尽管序列化方式可以满足我们的需求，但时仍然存在问题：为了在反序列化时知道对象的类型，JSON选择将类的Class类型写入JSON结果中，存入Redis，因此导致了额外的内存开销。\n\n那么，如何解决？如何节省内存空间？\n\n为了节约内存空间，一般不会使用JSON序列化工具，而会使用String序列化器，但这只能存储String类型的键值对，所以我们的解决方案就是：用的到对象反序列化时，再手动创建对象的序列化和反序列化。\n\n![image-20230419105307964](http://images.rl0206.love/202305021641031.png)\n\nRedis序列化两种方案：\n\n第一种：自定义Templete，修改RedisTemplete的序列化器为GenericJachson2JsonRedisSerializer；\n\n```\npublic class RedisConfig{\n\t@Bean\n\tpublic RedisTemplete<String,Object> redisTemplete(RedisConnectionFactory connectionFactory){\n\t\t\n\t}\n}\n```\n\n第二种：使用RedisRedisTemplete，手动序列化，读取时，手动反序列化。\n\n","slug":"Redis","published":1,"updated":"2023-10-16T06:58:59.264Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clpkicziv0018fkfofwaz5dy1","content":"<blockquote>\n<ol>\n<li>阅读Redis官方文档：Redis官方文档是学习Redis的最佳资源之一，它提供了全面的介绍和指导，包括数据结构、命令、配置和部署等方面的内容。可以从Redis官方网站上获取最新版本的文档。</li>\n<li>掌握Redis的基本数据结构：Redis支持多种数据结构，如字符串、哈希、列表、集合和有序集合等。要深入了解Redis，必须掌握这些基本数据结构，以及它们的操作和用途。</li>\n<li>实践：阅读Redis文档仅仅是开始，最重要的是实践。使用Redis CLI或者客户端库来执行一些命令，创建一些数据结构，并且观察其行为。尝试使用不同的数据结构和命令，以及探索Redis的一些高级特性，如事务和Lua脚本等。</li>\n<li>学习Redis的应用场景：Redis有很多应用场景，如缓存、消息队列、计数器、排行榜等等。学习这些应用场景可以帮助你更好地理解Redis的特性和优势。</li>\n<li>学习Redis的高级特性：Redis还有很多高级特性，如发布订阅、Lua脚本、事务、持久化、集群等。学习这些特性可以帮助你更好地利用Redis来构建复杂的应用。</li>\n<li>阅读Redis源代码：如果你想深入了解Redis的实现细节，阅读Redis的源代码是一个很好的方式。可以通过GitHub获取Redis的源代码，并尝试阅读和理解其中的实现。</li>\n<li>参加Redis社区：Redis社区是一个非常活跃的社区，有很多专家和开发者会在社区中分享他们的经验和见解。参加Redis社区可以帮助你更好地了解Redis，并与其他Redis用户和开发者互动。</li>\n</ol>\n<p>总之，要系统和高效地学习Redis，需要全面了解Redis的基本概念和数据结构，掌握Redis的应用场景和高级特性，进行实践和尝试，并参加Redis社区。</p>\n</blockquote>\n<h1 id=\"黑马Redis\"><a href=\"#黑马Redis\" class=\"headerlink\" title=\"黑马Redis\"></a>黑马Redis</h1><h2 id=\"Redis介绍\"><a href=\"#Redis介绍\" class=\"headerlink\" title=\"Redis介绍\"></a>Redis介绍</h2><p>简介：什么是Redis？Redis是一种基于键值对的非关系型数据库。</p>\n<p>优点：</p>\n<ul>\n<li>满足很多使用场景。Redis数据库比一般的键值对数据库要强大很多，Redis中的value支持多种数据类型与数据结构，例如：String、hash、list、Set、zset（有序集合）、Bitmaps（位图）、HyperLogLog、GEO（地理信息定位）等。<img src=\"https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/redis-10434dc7-c7a3-4c1a-b484-de3fb37669ee.png\" alt=\"Redis基本数据结构\"></li>\n<li>基于内存，读写性能出色。同时内存数据可定时通过快照和日志的形式保存到硬盘之上，做到断电不丢失。</li>\n<li>还提供了键过期、发布订阅、事物、流水线、Lua脚本等附加功能。</li>\n</ul>\n<p>应用领域：</p>\n<ul>\n<li>缓存：应用最广的地方，很多web应用都会选择使用Redis作为缓存，以降低数据源压力，提高响应速度。<img src=\"https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/redis-d44c2397-5994-452f-8b7b-eb85d2b87685.png\" alt=\"Redis缓存\"></li>\n<li>计数器：天然计数功能，可用来记录浏览量、点赞量等</li>\n<li>排行榜：借助Redis提供的列表和有序集合数据结构，合理使用数据结构构建排行榜系统</li>\n<li>社交网络：点赞与差评、粉丝、共同好友、推送、刷新</li>\n<li>消息队列：提供了发布订阅的功能和阻塞队列的功能，可以满足一般消息队列功能</li>\n<li>分布式锁：分布式环境下，利用Redis是西安分布式锁</li>\n</ul>\n<p><img src=\"http://images.rl0206.love/202305021641013.png\" alt=\"Redis数据结构介绍\"></p>\n<p>Redis有五种基本数据结构。</p>\n<p><strong><code>string</code></strong></p>\n<p>字符串最基础的数据结构。字符串类型的值实际可以是字符串（简单的字符串、复杂的字符串（例如JSON、XML））、数字 （整数、浮点数），甚至是二进制（图片、音频、视频），但是值最大不能超过512MB。</p>\n<p>字符串主要有以下几个典型使用场景：</p>\n<ul>\n<li>缓存功能</li>\n<li>计数</li>\n<li>共享Session</li>\n<li>限速</li>\n</ul>\n<p><strong><code>hash</code></strong></p>\n<p>哈希类型是指键值本身又是一个键值对结构。</p>\n<p>哈希主要有以下典型应用场景：</p>\n<ul>\n<li>缓存用户信息</li>\n<li>缓存对象</li>\n</ul>\n<p><strong><code>list</code></strong></p>\n<p>列表（list）类型是用来存储多个有序的字符串。列表是一种比较灵活的数据结构，它可以充当栈和队列的角色</p>\n<p>列表主要有以下几种使用场景：</p>\n<ul>\n<li>消息队列</li>\n<li>文章列表</li>\n</ul>\n<p><strong><code>set</code></strong></p>\n<p>集合（set）类型也是用来保存多个的字符串元素，但和列表类型不一 样的是，集合中不允许有重复元素，并且集合中的元素是无序的。</p>\n<p>集合主要有如下使用场景：</p>\n<ul>\n<li>标签（tag）</li>\n<li>共同关注</li>\n</ul>\n<p><strong><code>sorted set</code></strong></p>\n<p>有序集合中的元素可以排序。但是它和列表使用索引下标作为排序依据不同的是，它给每个元素设置一个权重（score）作为排序的依据。</p>\n<p>有序集合主要应用场景：</p>\n<ul>\n<li>用户点赞统计</li>\n<li>用户排序</li>\n</ul>\n<p>Redis为什么快？</p>\n<blockquote>\n<p>Redis的速度⾮常的快，单机的Redis就可以⽀撑每秒十几万的并发，相对于MySQL来说，性能是MySQL的⼏⼗倍。速度快的原因主要有⼏点：</p>\n</blockquote>\n<ul>\n<li>完全基于内存</li>\n<li>使用单线程，避免线程切换和竟态产生的消耗</li>\n<li>基于非阻塞的IO多路复用机制</li>\n<li>C语言实现，优化过的数据结构基于几种基本的数据结构，Redis做了大量优化，性能高</li>\n</ul>\n<p>怎么理解多路复用？</p>\n<blockquote>\n<p>引用知乎上一个高赞的回答来解释什么是I/O多路复用。假设你是一个老师，让30个学生解答一道题目，然后检查学生做的是否正确，你有下面几个选择：</p>\n</blockquote>\n<ul>\n<li>第一种选择：按顺序逐个检查，先检查A，然后是B，之后是C、D。。。这中间如果有一个学生卡住，全班都会被耽误。这种模式就好比，你用循环挨个处理socket，根本不具有并发能力。</li>\n<li>第二种选择：你创建30个分身，每个分身检查一个学生的答案是否正确。 这种类似于为每一个用户创建一个进程或者- 线程处理连接。</li>\n<li>第三种选择，你站在讲台上等，谁解答完谁举手。这时C、D举手，表示他们解答问题完毕，你下去依次检查C、D的答案，然后继续回到讲台上等。此时E、A又举手，然后去处理E和A。</li>\n</ul>\n<p>第一种就是阻塞IO模型，第三种就是I/O复用模型。</p>\n<p><img src=\"http://images.rl0206.love/202305021556308.png\" alt=\"I/O模型\"></p>\n<p>Redis如何数据持久化？</p>\n<blockquote>\n<p>Redis是完全基于内存的，要想避免数据断电丢失，就必须把数据持久化，数据持久化的方式有两种：RDB、AOF</p>\n</blockquote>\n<ul>\n<li><p>RDB：RDB持久化是把当前进程数据生成快照保存到硬盘的过程，触发RDB持久化过程分为手动触发和自动触发。RDB⽂件是⼀个压缩的⼆进制⽂件，通过它可以还原某个时刻数据库的状态。由于RDB⽂件是保存在硬盘上的，所以即使Redis崩溃或者退出，只要RDB⽂件存在，就可以⽤它来恢复还原数据库的状态。</p>\n<ul>\n<li>手动触发分别对应save和bgsave命令: <img src=\"https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/redis-ffe56e32-34c5-453d-8859-c2febbe6a038.png\" alt=\"save和bgsave\"><ul>\n<li>save命令：阻塞当前Redis服务器，直到RDB过程完成为止，对于内存比较大的实例会造成长时间阻塞，线上环境不建议使用。</li>\n<li>bgsave命令：Redis进程执行fork操作创建子进程，RDB持久化过程由子进程负责，完成后自动结束。阻塞只发生在fork阶段，一般时间很短。</li>\n</ul>\n</li>\n<li>以下场景会自动触发RDB持久化：<ul>\n<li>使用save相关配置，如“save m n”。表示m秒内数据集存在n次修改时，自动触发bgsave。</li>\n<li>如果从节点执行全量复制操作，主节点自动执行bgsave生成RDB文件并发送给从节点</li>\n<li>执行debug reload命令重新加载Redis时，也会自动触发save操作</li>\n<li>默认情况下执行shutdown命令时，如果没有开启AOF持久化功能则自动执行bgsave。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>AOF（append only file）持久化：以独立日志的方式记录每次写命令， 重启时再重新执行AOF文件中的命令达到恢复数据的目的。AOF的主要作用是解决了数据持久化的实时性，目前已经是Redis持久化的主流方式</p>\n<ul>\n<li><p>AOF的工作流程操作：命令写入 （append）、文件同步（sync）、文件重写（rewrite）、重启加载 （load） </p>\n<p><img src=\"https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/redis-a9fb6202-b1a1-484d-a4fa-fef519090b44.png\" alt=\"AOF工作流程\"></p>\n</li>\n<li><p>流程如下：</p>\n<ul>\n<li>1）所有的写入命令会追加到aof_buf（缓冲区）中。</li>\n<li>2）AOF缓冲区根据对应的策略向硬盘做同步操作。</li>\n<li>3）随着AOF文件越来越大，需要定期对AOF文件进行重写，达到压缩 的目的。</li>\n<li>4）当Redis服务器重启时，可以加载AOF文件进行数据恢复。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Redis命令\"><a href=\"#Redis命令\" class=\"headerlink\" title=\"Redis命令\"></a>Redis命令</h2><p><a href=\"https://redis.io/commands/\">redis帮助文档</a></p>\n<p><img src=\"http://images.rl0206.love/202305021641017.png\" alt=\"image-20230416091404745\"></p>\n<p><img src=\"http://images.rl0206.love/202305021641018.png\" alt=\"image-20230416092238674\"></p>\n<p><img src=\"http://images.rl0206.love/202305021641019.png\" alt=\"image-20230416093225232\"></p>\n<p><img src=\"http://images.rl0206.love/202305021641020.png\" alt=\"image-20230416094344011\"></p>\n<p><img src=\"http://images.rl0206.love/202305021641021.png\" alt=\"image-20230416100340583\"></p>\n<p><img src=\"http://images.rl0206.love/202305021641022.png\" alt=\"image-20230416100753096\"></p>\n<p><img src=\"http://images.rl0206.love/202305021641023.png\" alt=\"image-20230416101608129\"></p>\n<p><img src=\"http://images.rl0206.love/202305021641024.png\" alt=\"image-20230416101850417\"></p>\n<p><img src=\"http://images.rl0206.love/202305021641026.png\" alt=\"image-20230416102809805\"> </p>\n<p><img src=\"http://images.rl0206.love/202305021641027.png\" alt=\"image-20230416103712554\"></p>\n<p><img src=\"http://images.rl0206.love/202305021641028.png\" alt=\"image-20230416105319879\"></p>\n<p>注意：所有的排名都是升序，若要降序，则在Z的后面加REV即可。</p>\n<h2 id=\"Redis进阶\"><a href=\"#Redis进阶\" class=\"headerlink\" title=\"Redis进阶\"></a>Redis进阶</h2><blockquote>\n<p>什么是主从复制？</p>\n</blockquote>\n<ul>\n<li><strong>主从复制</strong>，是指将一台 Redis 服务器的数据，复制到其他的 Redis 服务器。前者称为 **主节点(master)**，后者称为 **从节点(slave)**。且数据的复制是 <strong>单向</strong> 的，只能由主节点到从节点。Redis 主从复制支持 <strong>主从同步</strong> 和 <strong>从从同步</strong> 两种，后者是 Redis 后续版本新增的功能，以减轻主节点的同步负担。</li>\n</ul>\n<p><img src=\"http://images.rl0206.love/202305031511055.png\" alt=\"主从复制图\"></p>\n<blockquote>\n<p>主从复制什么作用？</p>\n</blockquote>\n<ul>\n<li><strong>数据冗余：</strong> 主从复制实现了数据的<strong>热备份</strong>，是持久化之外的一种数据冗余方式。</li>\n<li><strong>故障恢复：</strong> 当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复 *(实际上是一种服务的冗余)*。</li>\n<li><strong>负载均衡：</strong> 在主从复制的基础上，配合读写分离，可以由主节点提供写服务，由从节点提供读服务 <em>（即写 Redis 数据时应用连接主节点，读 Redis 数据时应用连接从节点）</em>，分担服务器负载。尤其是在写少读多的场景下，通过多个从节点分担读负载，可以大大提高 Redis 服务器的并发量。</li>\n<li><strong>高可用基石：</strong> 除了上述作用以外，主从复制还是哨兵和集群能够实施的 <strong>基础</strong>，因此说主从复制是 Redis 高可用的基础。</li>\n</ul>\n<blockquote>\n<p>Redis主从有几种常见的拓扑结构？</p>\n</blockquote>\n<p>Redis的复制拓扑结构可以支持单层或多层复制。</p>\n<p>根据拓扑结构的复杂性可以分为三种：一主一从、一主多从、树状主从。</p>\n<ul>\n<li><p>一主一从结构</p>\n<ul>\n<li><p>一主一从结构是最简单的复制拓扑结构。应用场景：用于主节点出现宕机时从节点提供故障转移支持（故障恢复）</p>\n<p><img src=\"https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/redis-5d91a67c-dbff-4a8d-bf9d-1fe7602d5a27.png\"></p>\n</li>\n</ul>\n</li>\n<li><p>一主多从</p>\n<ul>\n<li><p>一主多从结构（又称星形拓扑结构）。应用场景：使得应用端可以利用多个从节点实现读写分离，对于读占比较大的场景，可以把读命令发送到从节点来分担主节点压力（负载均衡）。</p>\n<p><img src=\"https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/redis-71074254-699a-480b-bbb0-c68f364a380b.png\"></p>\n</li>\n</ul>\n</li>\n<li><p>树状主从</p>\n<ul>\n<li><p>树状主从结构（又称树状拓扑结构）。应用场景：使得从节点不但可以复制主节点数据，同时可以作为其他从节点的主节点继续向下层复制。通过引入复制中间层，可以有效降低主节点负载和需要传送给从节点的数据量（负载均衡）。</p>\n<p><img src=\"https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/redis-dff14203-5e01-4d1b-a775-10ee444ada54.png\"></p>\n</li>\n</ul>\n</li>\n</ul>\n<p>上面说了什么是？什么用？ 以及常见的拓扑结构，接下来详细说一说主从的基本原理，一起搞懂Redis主从吧！</p>\n<blockquote>\n<p>Redis主从复制原理？</p>\n</blockquote>\n<p>Redis主从复制的工作流程大概可以分为如下几步：（官方文档翻译后的答案）<br>1、保存主节点（master）信息 这一步只是保存主节点信息，保存主节点的ip和port。<br>2、主从建立连接 从节点（slave）发现新的主节点后，会尝试和主节点建立网络连接。<br>3、发送ping命令 连接建立成功后从节点发送ping请求进行首次通信，主要是检测主从之间网络套接字是否可用、主节点当前是否可接受处理命令。<br>4、权限验证 如果主节点要求密码验证，从节点必须正确的密码才能通过验证。<br>5、同步数据集 主从复制连接正常通信后，主节点会把持有的数据全部发送给从节点。<br>6、命令持续复制 接下来主节点会持续地把写命令发送给从节点，保证主从数据一致性。</p>\n<p><img src=\"http://images.rl0206.love/202305031556969.png\" alt=\"Redis主从复制工作流程\"></p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs markdown\">Redis主从复制的工作流程如下：（GPT给的2.8以下版本的Redis）<br><br><span class=\"hljs-bullet\">1.</span> 当一个Redis从服务器连接到主服务器时，它会向主服务器发送一个SYNC命令，请求同步数据。<br><span class=\"hljs-bullet\">2.</span> 主服务器接收到SYNC命令后，会开启一个后台线程，将所有写命令记录到一个缓冲区中，同时将缓冲区中的数据发送给从服务器。<br><span class=\"hljs-bullet\">3.</span> 从服务器接收到数据后，将其存储在自己的数据库中，并向主服务器发送一个ACK命令，表示已经接收到数据。<br><span class=\"hljs-bullet\">4.</span> 主服务器接收到ACK命令后，将缓冲区中的数据删除，并继续等待新的写命令。如果从服务器断开连接，主服务器会尝试重新连接。<br><span class=\"hljs-bullet\">5.</span> 当主服务器发生故障或者重启时，从服务器会重新连接到主服务器，并请求同步数据。此时，主服务器会将所有未同步的数据发送给从服务器，并重新开始记录写命令。<br><span class=\"hljs-bullet\">6.</span> 如果主服务器在同步数据时出现错误，从服务器会断开连接，并尝试重新连接到主服务器。如果多次尝试失败，从服务器会成为一个新的主服务器。<br><br>总的来说，Redis主从复制的工作流程是基于异步复制的，主服务器不会等待从服务器的响应，而是将数据发送给从服务器后立即返回。这种方式可以提高性能，但也有可能会导致数据不一致的问题。因此，在使用Redis主从复制时，需要注意数据一致性的问题<br></code></pre></td></tr></table></figure>\n\n\n\n<blockquote>\n<p>主从数据同步的方式？</p>\n</blockquote>\n<p>Redis在2.8及以上版本使用psync命令完成主从数据同步，同步过程分为：全量复制和部分复制。</p>\n<ol>\n<li><p><strong>全量复制</strong> 一般用于初次复制场景，Redis早期支持的复制功能只有全量复制，它会把主节点全部数据一次性发送给从节点，当数据量较大时，会对主从节点和网络造成很大的开销。</p>\n<p>全量复制的完整运行流程如下： <img src=\"https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/redis-aa8d2960-b341-49cc-b04c-201241fd15de.png\" alt=\"全量复制\"></p>\n<ol>\n<li>发送psync命令进行数据同步，由于是第一次进行复制，从节点没有复制偏移量和主节点的运行ID，所以发送psync-1。</li>\n<li>主节点根据psync-1解析出当前为全量复制，回复+FULLRESYNC响应。</li>\n<li>从节点接收主节点的响应数据保存运行ID和偏移量offset</li>\n<li>主节点执行bgsave保存RDB文件到本地</li>\n<li>主节点发送RDB文件给从节点，从节点把接收的RDB文件保存在本地并直接作为从节点的数据文件</li>\n<li>对于从节点开始接收RDB快照到接收完成期间，主节点仍然响应读写命令，因此主节点会把这期间写命令数据保存在复制客户端缓冲区内，当从节点加载完RDB文件后，主节点再把缓冲区内的数据发送给从节点，保证主从之间数据一致性。</li>\n<li>从节点接收完主节点传送来的全部数据后会清空自身旧数据</li>\n<li>从节点清空数据后开始加载RDB文件</li>\n<li>从节点成功加载完RDB后，如果当前节点开启了AOF持久化功能， 它会立刻做bgrewriteaof操作，为了保证全量复制后AOF持久化文件立刻可用。</li>\n</ol>\n<p><strong>部分复制</strong> 部分复制主要是Redis针对全量复制的过高开销做出的一种优化措施， 使用psync{runId}{offset}命令实现。当从节点（slave）正在复制主节点 （master）时，如果出现网络闪断或者命令丢失等异常情况时，从节点会向 主节点要求补发丢失的命令数据，如果主节点的复制积压缓冲区内存在这部分数据则直接发送给从节点，这样就可以保持主从节点复制的一致性。 <img src=\"https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/redis-87600c72-cc6a-4656-81b2-e71864c97f23.png\" alt=\"部分复制\"></p>\n<ol>\n<li>当主从节点之间网络出现中断时，如果超过repl-timeout时间，主节点会认为从节点故障并中断复制连接</li>\n<li>主从连接中断期间主节点依然响应命令，但因复制连接中断命令无法发送给从节点，不过主节点内部存在的复制积压缓冲区，依然可以保存最近一段时间的写命令数据，默认最大缓存1MB。</li>\n<li>当主从节点网络恢复后，从节点会再次连上主节点</li>\n<li>当主从连接恢复后，由于从节点之前保存了自身已复制的偏移量和主节点的运行ID。因此会把它们当作psync参数发送给主节点，要求进行部分复制操作。</li>\n<li>主节点接到psync命令后首先核对参数runId是否与自身一致，如果一 致，说明之前复制的是当前主节点；之后根据参数offset在自身复制积压缓冲区查找，如果偏移量之后的数据存在缓冲区中，则对从节点发送+CONTINUE响应，表示可以进行部分复制。</li>\n<li>主节点根据偏移量把复制积压缓冲区里的数据发送给从节点，保证主从复制进入正常状态。</li>\n</ol>\n</li>\n</ol>\n<blockquote>\n<p>主从复制存在哪些问题？（主要是高可用和分布式两个方面）</p>\n</blockquote>\n<ul>\n<li>一旦主节点出现故障，需要手动将一个从节点设置为主节点，同时还需要修改应用方的主节点的地址，还需要命令之前的从节点去复制新的主节点，整个过程比较麻烦，需要人工进行干预；</li>\n<li>主节点的写作能力和存储能力会受到单机的限制</li>\n</ul>\n<p><strong>那么基于以上只从复制存在的问题，我们该如何解决？！这就引入了哨兵的概念（Redis Sentinel）</strong></p>\n<blockquote>\n<p>什么是Redis Sentinel（哨兵）？</p>\n</blockquote>\n<p>鉴于Redis主从复制存在的一些问题就是需要人工的干预，于是Redis设计出了哨兵系统的方案，借助这个方案可以自动完成故障转移。</p>\n<p><img src=\"http://images.rl0206.love/202305031650481.png\" alt=\"Redis Sentinel\"></p>\n<h2 id=\"Redis客户端\"><a href=\"#Redis客户端\" class=\"headerlink\" title=\"Redis客户端\"></a>Redis客户端</h2><p><img src=\"http://images.rl0206.love/202305021641029.png\" alt=\"image-20230416111339698\"></p>\n<p><img src=\"http://images.rl0206.love/202305021641030.png\" alt=\"image-20230416111856694\"></p>\n<p> Jedis使用的基本步骤：</p>\n<p>1.引入依赖</p>\n<p>2.创建Jedis对象，建立连接</p>\n<p>3.使用Jedis，方法名与Redis命令一致</p>\n<p>4.释放资源</p>\n<p>1、引入依赖</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Java\">&lt;dependency&gt;<br>    &lt;groupId&gt;redis.clients&lt;/groupId&gt;<br>    &lt;artifactId&gt;jedis&lt;/artifactId&gt;<br>    &lt;version&gt;<span class=\"hljs-number\">3.7</span><span class=\"hljs-number\">.0</span>&lt;/version&gt;<br>&lt;/dependency&gt;<br></code></pre></td></tr></table></figure>\n\n<p>2、使用Jedis连接池创建连接</p>\n<p>Jedis本身是线程不安全的，并且频繁的创建和销毁连接会有性能损耗，因此我们推荐大家使用Jedis连接池代替Jedis的直连方式。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">JedisConnectionFactory</span> &#123;<br>   <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span> JedisPool jedisPool;<br><br>   <span class=\"hljs-keyword\">static</span> &#123;<br>     <span class=\"hljs-type\">JedisPoolConfig</span> <span class=\"hljs-variable\">jedisPoolConfig</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">JedisPoolConfig</span>();<br>     <span class=\"hljs-comment\">// 最大连接</span><br>     jedisPoolConfig.setMaxTotal(<span class=\"hljs-number\">8</span>);<br>     <span class=\"hljs-comment\">// 最大空闲连接</span><br>     jedisPoolConfig.setMaxIdle(<span class=\"hljs-number\">8</span>); <br>     <span class=\"hljs-comment\">// 最小空闲连接</span><br>     jedisPoolConfig.setMinIdle(<span class=\"hljs-number\">0</span>);<br>     <span class=\"hljs-comment\">// 设置最长等待时间， ms</span><br>     jedisPoolConfig.setMaxWaitMillis(<span class=\"hljs-number\">200</span>);<br>     jedisPool = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">JedisPool</span>(jedisPoolConfig, <span class=\"hljs-string\">&quot;192.168.150.101&quot;</span>, <span class=\"hljs-number\">6379</span>,<br>         <span class=\"hljs-number\">1000</span>, <span class=\"hljs-string\">&quot;123321&quot;</span>);<br>   &#125;<br>   <span class=\"hljs-comment\">// 获取Jedis对象</span><br>   <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> Jedis <span class=\"hljs-title function_\">getJedis</span><span class=\"hljs-params\">()</span>&#123;<br>     <span class=\"hljs-keyword\">return</span> jedisPool.getResource();<br>   &#125;<br> &#125;<br></code></pre></td></tr></table></figure>\n\n<p>3、使用Jedis进行单元测试</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">private</span> Jedis jedis;<br>  <span class=\"hljs-comment\">// 单元测试的注释写法</span><br>  <span class=\"hljs-meta\">@BeforeEach</span><br>  <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">setUp</span><span class=\"hljs-params\">()</span> &#123;<br>    <span class=\"hljs-comment\">// 建立连接</span><br>    jedis = JedisConnectionFactory.getJedis();<br>    <span class=\"hljs-comment\">// 设置密码</span><br>    jedis.auth(<span class=\"hljs-string\">&quot;123321&quot;</span>);<br>    <span class=\"hljs-comment\">// 选择库</span><br>    jedis.select(<span class=\"hljs-number\">0</span>);<br>&#125;<br>  <span class=\"hljs-meta\">@Test</span><br>  <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">testString</span><span class=\"hljs-params\">()</span> &#123;<br>    <span class=\"hljs-comment\">// 插入数据，方法名称就是redis命令名称，非常简单</span><br>    <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">result</span> <span class=\"hljs-operator\">=</span> jedis.set(<span class=\"hljs-string\">&quot;name&quot;</span>, <span class=\"hljs-string\">&quot;张三&quot;</span>);<br>    System.out.println(<span class=\"hljs-string\">&quot;result = &quot;</span> + result); <br>    <span class=\"hljs-comment\">// 获取数据</span><br>    <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">name</span> <span class=\"hljs-operator\">=</span> jedis.get(<span class=\"hljs-string\">&quot;name&quot;</span>);<br>    System.out.println(<span class=\"hljs-string\">&quot;name = &quot;</span> + name);<br>&#125;<br>  <span class=\"hljs-meta\">@AfterEach</span><br>  <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">tearDown</span><span class=\"hljs-params\">()</span> &#123;<br>    <span class=\"hljs-comment\">// 释放资源</span><br>    <span class=\"hljs-keyword\">if</span> (jedis != <span class=\"hljs-literal\">null</span>) &#123;<br>      jedis.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"SpringDataRedis\"><a href=\"#SpringDataRedis\" class=\"headerlink\" title=\"SpringDataRedis\"></a>SpringDataRedis</h2><blockquote>\n<p>打破Redis只接收String，接收Object类，内部通过JDK的序列化工具进行转换。（即传入一个Object对象，会将其序列化，将其“剁碎”，传入Redis，若想不剁碎，就需要重写RedisTemplate的序列化方式）</p>\n</blockquote>\n<p> 那我们如何重写呢？</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Java\"><br></code></pre></td></tr></table></figure>\n\n<p>存：自动化将对象转JSON,</p>\n<p>取：JSON反序列化为对象</p>\n<p>什么原理呢？</p>\n<p>我们会发现，在自动化转JSON时，会在JSON中第一行加入User的CLASS属性（对应的是User类的名称），所以说在反序列化的时候，会将对应的User写进来。巧妙之处就在于JSON串第一行的Class名称记录。</p>\n<p>尽管序列化方式可以满足我们的需求，但时仍然存在问题：为了在反序列化时知道对象的类型，JSON选择将类的Class类型写入JSON结果中，存入Redis，因此导致了额外的内存开销。</p>\n<p>那么，如何解决？如何节省内存空间？</p>\n<p>为了节约内存空间，一般不会使用JSON序列化工具，而会使用String序列化器，但这只能存储String类型的键值对，所以我们的解决方案就是：用的到对象反序列化时，再手动创建对象的序列化和反序列化。</p>\n<p><img src=\"http://images.rl0206.love/202305021641031.png\" alt=\"image-20230419105307964\"></p>\n<p>Redis序列化两种方案：</p>\n<p>第一种：自定义Templete，修改RedisTemplete的序列化器为GenericJachson2JsonRedisSerializer；</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs typescript\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">RedisConfig</span>&#123;<br>\t<span class=\"hljs-meta\">@Bean</span><br>\t<span class=\"hljs-keyword\">public</span> <span class=\"hljs-title class_\">RedisTemplete</span>&lt;<span class=\"hljs-title class_\">String</span>,<span class=\"hljs-title class_\">Object</span>&gt; <span class=\"hljs-title function_\">redisTemplete</span>(<span class=\"hljs-params\">RedisConnectionFactory connectionFactory</span>)&#123;<br>\t\t<br>\t&#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>第二种：使用RedisRedisTemplete，手动序列化，读取时，手动反序列化。</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<ol>\n<li>阅读Redis官方文档：Redis官方文档是学习Redis的最佳资源之一，它提供了全面的介绍和指导，包括数据结构、命令、配置和部署等方面的内容。可以从Redis官方网站上获取最新版本的文档。</li>\n<li>掌握Redis的基本数据结构：Redis支持多种数据结构，如字符串、哈希、列表、集合和有序集合等。要深入了解Redis，必须掌握这些基本数据结构，以及它们的操作和用途。</li>\n<li>实践：阅读Redis文档仅仅是开始，最重要的是实践。使用Redis CLI或者客户端库来执行一些命令，创建一些数据结构，并且观察其行为。尝试使用不同的数据结构和命令，以及探索Redis的一些高级特性，如事务和Lua脚本等。</li>\n<li>学习Redis的应用场景：Redis有很多应用场景，如缓存、消息队列、计数器、排行榜等等。学习这些应用场景可以帮助你更好地理解Redis的特性和优势。</li>\n<li>学习Redis的高级特性：Redis还有很多高级特性，如发布订阅、Lua脚本、事务、持久化、集群等。学习这些特性可以帮助你更好地利用Redis来构建复杂的应用。</li>\n<li>阅读Redis源代码：如果你想深入了解Redis的实现细节，阅读Redis的源代码是一个很好的方式。可以通过GitHub获取Redis的源代码，并尝试阅读和理解其中的实现。</li>\n<li>参加Redis社区：Redis社区是一个非常活跃的社区，有很多专家和开发者会在社区中分享他们的经验和见解。参加Redis社区可以帮助你更好地了解Redis，并与其他Redis用户和开发者互动。</li>\n</ol>\n<p>总之，要系统和高效地学习Redis，需要全面了解Redis的基本概念和数据结构，掌握Redis的应用场景和高级特性，进行实践和尝试，并参加Redis社区。</p>\n</blockquote>\n<h1 id=\"黑马Redis\"><a href=\"#黑马Redis\" class=\"headerlink\" title=\"黑马Redis\"></a>黑马Redis</h1><h2 id=\"Redis介绍\"><a href=\"#Redis介绍\" class=\"headerlink\" title=\"Redis介绍\"></a>Redis介绍</h2><p>简介：什么是Redis？Redis是一种基于键值对的非关系型数据库。</p>\n<p>优点：</p>\n<ul>\n<li>满足很多使用场景。Redis数据库比一般的键值对数据库要强大很多，Redis中的value支持多种数据类型与数据结构，例如：String、hash、list、Set、zset（有序集合）、Bitmaps（位图）、HyperLogLog、GEO（地理信息定位）等。<img src=\"https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/redis-10434dc7-c7a3-4c1a-b484-de3fb37669ee.png\" alt=\"Redis基本数据结构\"></li>\n<li>基于内存，读写性能出色。同时内存数据可定时通过快照和日志的形式保存到硬盘之上，做到断电不丢失。</li>\n<li>还提供了键过期、发布订阅、事物、流水线、Lua脚本等附加功能。</li>\n</ul>\n<p>应用领域：</p>\n<ul>\n<li>缓存：应用最广的地方，很多web应用都会选择使用Redis作为缓存，以降低数据源压力，提高响应速度。<img src=\"https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/redis-d44c2397-5994-452f-8b7b-eb85d2b87685.png\" alt=\"Redis缓存\"></li>\n<li>计数器：天然计数功能，可用来记录浏览量、点赞量等</li>\n<li>排行榜：借助Redis提供的列表和有序集合数据结构，合理使用数据结构构建排行榜系统</li>\n<li>社交网络：点赞与差评、粉丝、共同好友、推送、刷新</li>\n<li>消息队列：提供了发布订阅的功能和阻塞队列的功能，可以满足一般消息队列功能</li>\n<li>分布式锁：分布式环境下，利用Redis是西安分布式锁</li>\n</ul>\n<p><img src=\"http://images.rl0206.love/202305021641013.png\" alt=\"Redis数据结构介绍\"></p>\n<p>Redis有五种基本数据结构。</p>\n<p><strong><code>string</code></strong></p>\n<p>字符串最基础的数据结构。字符串类型的值实际可以是字符串（简单的字符串、复杂的字符串（例如JSON、XML））、数字 （整数、浮点数），甚至是二进制（图片、音频、视频），但是值最大不能超过512MB。</p>\n<p>字符串主要有以下几个典型使用场景：</p>\n<ul>\n<li>缓存功能</li>\n<li>计数</li>\n<li>共享Session</li>\n<li>限速</li>\n</ul>\n<p><strong><code>hash</code></strong></p>\n<p>哈希类型是指键值本身又是一个键值对结构。</p>\n<p>哈希主要有以下典型应用场景：</p>\n<ul>\n<li>缓存用户信息</li>\n<li>缓存对象</li>\n</ul>\n<p><strong><code>list</code></strong></p>\n<p>列表（list）类型是用来存储多个有序的字符串。列表是一种比较灵活的数据结构，它可以充当栈和队列的角色</p>\n<p>列表主要有以下几种使用场景：</p>\n<ul>\n<li>消息队列</li>\n<li>文章列表</li>\n</ul>\n<p><strong><code>set</code></strong></p>\n<p>集合（set）类型也是用来保存多个的字符串元素，但和列表类型不一 样的是，集合中不允许有重复元素，并且集合中的元素是无序的。</p>\n<p>集合主要有如下使用场景：</p>\n<ul>\n<li>标签（tag）</li>\n<li>共同关注</li>\n</ul>\n<p><strong><code>sorted set</code></strong></p>\n<p>有序集合中的元素可以排序。但是它和列表使用索引下标作为排序依据不同的是，它给每个元素设置一个权重（score）作为排序的依据。</p>\n<p>有序集合主要应用场景：</p>\n<ul>\n<li>用户点赞统计</li>\n<li>用户排序</li>\n</ul>\n<p>Redis为什么快？</p>\n<blockquote>\n<p>Redis的速度⾮常的快，单机的Redis就可以⽀撑每秒十几万的并发，相对于MySQL来说，性能是MySQL的⼏⼗倍。速度快的原因主要有⼏点：</p>\n</blockquote>\n<ul>\n<li>完全基于内存</li>\n<li>使用单线程，避免线程切换和竟态产生的消耗</li>\n<li>基于非阻塞的IO多路复用机制</li>\n<li>C语言实现，优化过的数据结构基于几种基本的数据结构，Redis做了大量优化，性能高</li>\n</ul>\n<p>怎么理解多路复用？</p>\n<blockquote>\n<p>引用知乎上一个高赞的回答来解释什么是I/O多路复用。假设你是一个老师，让30个学生解答一道题目，然后检查学生做的是否正确，你有下面几个选择：</p>\n</blockquote>\n<ul>\n<li>第一种选择：按顺序逐个检查，先检查A，然后是B，之后是C、D。。。这中间如果有一个学生卡住，全班都会被耽误。这种模式就好比，你用循环挨个处理socket，根本不具有并发能力。</li>\n<li>第二种选择：你创建30个分身，每个分身检查一个学生的答案是否正确。 这种类似于为每一个用户创建一个进程或者- 线程处理连接。</li>\n<li>第三种选择，你站在讲台上等，谁解答完谁举手。这时C、D举手，表示他们解答问题完毕，你下去依次检查C、D的答案，然后继续回到讲台上等。此时E、A又举手，然后去处理E和A。</li>\n</ul>\n<p>第一种就是阻塞IO模型，第三种就是I/O复用模型。</p>\n<p><img src=\"http://images.rl0206.love/202305021556308.png\" alt=\"I/O模型\"></p>\n<p>Redis如何数据持久化？</p>\n<blockquote>\n<p>Redis是完全基于内存的，要想避免数据断电丢失，就必须把数据持久化，数据持久化的方式有两种：RDB、AOF</p>\n</blockquote>\n<ul>\n<li><p>RDB：RDB持久化是把当前进程数据生成快照保存到硬盘的过程，触发RDB持久化过程分为手动触发和自动触发。RDB⽂件是⼀个压缩的⼆进制⽂件，通过它可以还原某个时刻数据库的状态。由于RDB⽂件是保存在硬盘上的，所以即使Redis崩溃或者退出，只要RDB⽂件存在，就可以⽤它来恢复还原数据库的状态。</p>\n<ul>\n<li>手动触发分别对应save和bgsave命令: <img src=\"https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/redis-ffe56e32-34c5-453d-8859-c2febbe6a038.png\" alt=\"save和bgsave\"><ul>\n<li>save命令：阻塞当前Redis服务器，直到RDB过程完成为止，对于内存比较大的实例会造成长时间阻塞，线上环境不建议使用。</li>\n<li>bgsave命令：Redis进程执行fork操作创建子进程，RDB持久化过程由子进程负责，完成后自动结束。阻塞只发生在fork阶段，一般时间很短。</li>\n</ul>\n</li>\n<li>以下场景会自动触发RDB持久化：<ul>\n<li>使用save相关配置，如“save m n”。表示m秒内数据集存在n次修改时，自动触发bgsave。</li>\n<li>如果从节点执行全量复制操作，主节点自动执行bgsave生成RDB文件并发送给从节点</li>\n<li>执行debug reload命令重新加载Redis时，也会自动触发save操作</li>\n<li>默认情况下执行shutdown命令时，如果没有开启AOF持久化功能则自动执行bgsave。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>AOF（append only file）持久化：以独立日志的方式记录每次写命令， 重启时再重新执行AOF文件中的命令达到恢复数据的目的。AOF的主要作用是解决了数据持久化的实时性，目前已经是Redis持久化的主流方式</p>\n<ul>\n<li><p>AOF的工作流程操作：命令写入 （append）、文件同步（sync）、文件重写（rewrite）、重启加载 （load） </p>\n<p><img src=\"https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/redis-a9fb6202-b1a1-484d-a4fa-fef519090b44.png\" alt=\"AOF工作流程\"></p>\n</li>\n<li><p>流程如下：</p>\n<ul>\n<li>1）所有的写入命令会追加到aof_buf（缓冲区）中。</li>\n<li>2）AOF缓冲区根据对应的策略向硬盘做同步操作。</li>\n<li>3）随着AOF文件越来越大，需要定期对AOF文件进行重写，达到压缩 的目的。</li>\n<li>4）当Redis服务器重启时，可以加载AOF文件进行数据恢复。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Redis命令\"><a href=\"#Redis命令\" class=\"headerlink\" title=\"Redis命令\"></a>Redis命令</h2><p><a href=\"https://redis.io/commands/\">redis帮助文档</a></p>\n<p><img src=\"http://images.rl0206.love/202305021641017.png\" alt=\"image-20230416091404745\"></p>\n<p><img src=\"http://images.rl0206.love/202305021641018.png\" alt=\"image-20230416092238674\"></p>\n<p><img src=\"http://images.rl0206.love/202305021641019.png\" alt=\"image-20230416093225232\"></p>\n<p><img src=\"http://images.rl0206.love/202305021641020.png\" alt=\"image-20230416094344011\"></p>\n<p><img src=\"http://images.rl0206.love/202305021641021.png\" alt=\"image-20230416100340583\"></p>\n<p><img src=\"http://images.rl0206.love/202305021641022.png\" alt=\"image-20230416100753096\"></p>\n<p><img src=\"http://images.rl0206.love/202305021641023.png\" alt=\"image-20230416101608129\"></p>\n<p><img src=\"http://images.rl0206.love/202305021641024.png\" alt=\"image-20230416101850417\"></p>\n<p><img src=\"http://images.rl0206.love/202305021641026.png\" alt=\"image-20230416102809805\"> </p>\n<p><img src=\"http://images.rl0206.love/202305021641027.png\" alt=\"image-20230416103712554\"></p>\n<p><img src=\"http://images.rl0206.love/202305021641028.png\" alt=\"image-20230416105319879\"></p>\n<p>注意：所有的排名都是升序，若要降序，则在Z的后面加REV即可。</p>\n<h2 id=\"Redis进阶\"><a href=\"#Redis进阶\" class=\"headerlink\" title=\"Redis进阶\"></a>Redis进阶</h2><blockquote>\n<p>什么是主从复制？</p>\n</blockquote>\n<ul>\n<li><strong>主从复制</strong>，是指将一台 Redis 服务器的数据，复制到其他的 Redis 服务器。前者称为 **主节点(master)**，后者称为 **从节点(slave)**。且数据的复制是 <strong>单向</strong> 的，只能由主节点到从节点。Redis 主从复制支持 <strong>主从同步</strong> 和 <strong>从从同步</strong> 两种，后者是 Redis 后续版本新增的功能，以减轻主节点的同步负担。</li>\n</ul>\n<p><img src=\"http://images.rl0206.love/202305031511055.png\" alt=\"主从复制图\"></p>\n<blockquote>\n<p>主从复制什么作用？</p>\n</blockquote>\n<ul>\n<li><strong>数据冗余：</strong> 主从复制实现了数据的<strong>热备份</strong>，是持久化之外的一种数据冗余方式。</li>\n<li><strong>故障恢复：</strong> 当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复 *(实际上是一种服务的冗余)*。</li>\n<li><strong>负载均衡：</strong> 在主从复制的基础上，配合读写分离，可以由主节点提供写服务，由从节点提供读服务 <em>（即写 Redis 数据时应用连接主节点，读 Redis 数据时应用连接从节点）</em>，分担服务器负载。尤其是在写少读多的场景下，通过多个从节点分担读负载，可以大大提高 Redis 服务器的并发量。</li>\n<li><strong>高可用基石：</strong> 除了上述作用以外，主从复制还是哨兵和集群能够实施的 <strong>基础</strong>，因此说主从复制是 Redis 高可用的基础。</li>\n</ul>\n<blockquote>\n<p>Redis主从有几种常见的拓扑结构？</p>\n</blockquote>\n<p>Redis的复制拓扑结构可以支持单层或多层复制。</p>\n<p>根据拓扑结构的复杂性可以分为三种：一主一从、一主多从、树状主从。</p>\n<ul>\n<li><p>一主一从结构</p>\n<ul>\n<li><p>一主一从结构是最简单的复制拓扑结构。应用场景：用于主节点出现宕机时从节点提供故障转移支持（故障恢复）</p>\n<p><img src=\"https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/redis-5d91a67c-dbff-4a8d-bf9d-1fe7602d5a27.png\"></p>\n</li>\n</ul>\n</li>\n<li><p>一主多从</p>\n<ul>\n<li><p>一主多从结构（又称星形拓扑结构）。应用场景：使得应用端可以利用多个从节点实现读写分离，对于读占比较大的场景，可以把读命令发送到从节点来分担主节点压力（负载均衡）。</p>\n<p><img src=\"https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/redis-71074254-699a-480b-bbb0-c68f364a380b.png\"></p>\n</li>\n</ul>\n</li>\n<li><p>树状主从</p>\n<ul>\n<li><p>树状主从结构（又称树状拓扑结构）。应用场景：使得从节点不但可以复制主节点数据，同时可以作为其他从节点的主节点继续向下层复制。通过引入复制中间层，可以有效降低主节点负载和需要传送给从节点的数据量（负载均衡）。</p>\n<p><img src=\"https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/redis-dff14203-5e01-4d1b-a775-10ee444ada54.png\"></p>\n</li>\n</ul>\n</li>\n</ul>\n<p>上面说了什么是？什么用？ 以及常见的拓扑结构，接下来详细说一说主从的基本原理，一起搞懂Redis主从吧！</p>\n<blockquote>\n<p>Redis主从复制原理？</p>\n</blockquote>\n<p>Redis主从复制的工作流程大概可以分为如下几步：（官方文档翻译后的答案）<br>1、保存主节点（master）信息 这一步只是保存主节点信息，保存主节点的ip和port。<br>2、主从建立连接 从节点（slave）发现新的主节点后，会尝试和主节点建立网络连接。<br>3、发送ping命令 连接建立成功后从节点发送ping请求进行首次通信，主要是检测主从之间网络套接字是否可用、主节点当前是否可接受处理命令。<br>4、权限验证 如果主节点要求密码验证，从节点必须正确的密码才能通过验证。<br>5、同步数据集 主从复制连接正常通信后，主节点会把持有的数据全部发送给从节点。<br>6、命令持续复制 接下来主节点会持续地把写命令发送给从节点，保证主从数据一致性。</p>\n<p><img src=\"http://images.rl0206.love/202305031556969.png\" alt=\"Redis主从复制工作流程\"></p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs markdown\">Redis主从复制的工作流程如下：（GPT给的2.8以下版本的Redis）<br><br><span class=\"hljs-bullet\">1.</span> 当一个Redis从服务器连接到主服务器时，它会向主服务器发送一个SYNC命令，请求同步数据。<br><span class=\"hljs-bullet\">2.</span> 主服务器接收到SYNC命令后，会开启一个后台线程，将所有写命令记录到一个缓冲区中，同时将缓冲区中的数据发送给从服务器。<br><span class=\"hljs-bullet\">3.</span> 从服务器接收到数据后，将其存储在自己的数据库中，并向主服务器发送一个ACK命令，表示已经接收到数据。<br><span class=\"hljs-bullet\">4.</span> 主服务器接收到ACK命令后，将缓冲区中的数据删除，并继续等待新的写命令。如果从服务器断开连接，主服务器会尝试重新连接。<br><span class=\"hljs-bullet\">5.</span> 当主服务器发生故障或者重启时，从服务器会重新连接到主服务器，并请求同步数据。此时，主服务器会将所有未同步的数据发送给从服务器，并重新开始记录写命令。<br><span class=\"hljs-bullet\">6.</span> 如果主服务器在同步数据时出现错误，从服务器会断开连接，并尝试重新连接到主服务器。如果多次尝试失败，从服务器会成为一个新的主服务器。<br><br>总的来说，Redis主从复制的工作流程是基于异步复制的，主服务器不会等待从服务器的响应，而是将数据发送给从服务器后立即返回。这种方式可以提高性能，但也有可能会导致数据不一致的问题。因此，在使用Redis主从复制时，需要注意数据一致性的问题<br></code></pre></td></tr></table></figure>\n\n\n\n<blockquote>\n<p>主从数据同步的方式？</p>\n</blockquote>\n<p>Redis在2.8及以上版本使用psync命令完成主从数据同步，同步过程分为：全量复制和部分复制。</p>\n<ol>\n<li><p><strong>全量复制</strong> 一般用于初次复制场景，Redis早期支持的复制功能只有全量复制，它会把主节点全部数据一次性发送给从节点，当数据量较大时，会对主从节点和网络造成很大的开销。</p>\n<p>全量复制的完整运行流程如下： <img src=\"https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/redis-aa8d2960-b341-49cc-b04c-201241fd15de.png\" alt=\"全量复制\"></p>\n<ol>\n<li>发送psync命令进行数据同步，由于是第一次进行复制，从节点没有复制偏移量和主节点的运行ID，所以发送psync-1。</li>\n<li>主节点根据psync-1解析出当前为全量复制，回复+FULLRESYNC响应。</li>\n<li>从节点接收主节点的响应数据保存运行ID和偏移量offset</li>\n<li>主节点执行bgsave保存RDB文件到本地</li>\n<li>主节点发送RDB文件给从节点，从节点把接收的RDB文件保存在本地并直接作为从节点的数据文件</li>\n<li>对于从节点开始接收RDB快照到接收完成期间，主节点仍然响应读写命令，因此主节点会把这期间写命令数据保存在复制客户端缓冲区内，当从节点加载完RDB文件后，主节点再把缓冲区内的数据发送给从节点，保证主从之间数据一致性。</li>\n<li>从节点接收完主节点传送来的全部数据后会清空自身旧数据</li>\n<li>从节点清空数据后开始加载RDB文件</li>\n<li>从节点成功加载完RDB后，如果当前节点开启了AOF持久化功能， 它会立刻做bgrewriteaof操作，为了保证全量复制后AOF持久化文件立刻可用。</li>\n</ol>\n<p><strong>部分复制</strong> 部分复制主要是Redis针对全量复制的过高开销做出的一种优化措施， 使用psync{runId}{offset}命令实现。当从节点（slave）正在复制主节点 （master）时，如果出现网络闪断或者命令丢失等异常情况时，从节点会向 主节点要求补发丢失的命令数据，如果主节点的复制积压缓冲区内存在这部分数据则直接发送给从节点，这样就可以保持主从节点复制的一致性。 <img src=\"https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/redis-87600c72-cc6a-4656-81b2-e71864c97f23.png\" alt=\"部分复制\"></p>\n<ol>\n<li>当主从节点之间网络出现中断时，如果超过repl-timeout时间，主节点会认为从节点故障并中断复制连接</li>\n<li>主从连接中断期间主节点依然响应命令，但因复制连接中断命令无法发送给从节点，不过主节点内部存在的复制积压缓冲区，依然可以保存最近一段时间的写命令数据，默认最大缓存1MB。</li>\n<li>当主从节点网络恢复后，从节点会再次连上主节点</li>\n<li>当主从连接恢复后，由于从节点之前保存了自身已复制的偏移量和主节点的运行ID。因此会把它们当作psync参数发送给主节点，要求进行部分复制操作。</li>\n<li>主节点接到psync命令后首先核对参数runId是否与自身一致，如果一 致，说明之前复制的是当前主节点；之后根据参数offset在自身复制积压缓冲区查找，如果偏移量之后的数据存在缓冲区中，则对从节点发送+CONTINUE响应，表示可以进行部分复制。</li>\n<li>主节点根据偏移量把复制积压缓冲区里的数据发送给从节点，保证主从复制进入正常状态。</li>\n</ol>\n</li>\n</ol>\n<blockquote>\n<p>主从复制存在哪些问题？（主要是高可用和分布式两个方面）</p>\n</blockquote>\n<ul>\n<li>一旦主节点出现故障，需要手动将一个从节点设置为主节点，同时还需要修改应用方的主节点的地址，还需要命令之前的从节点去复制新的主节点，整个过程比较麻烦，需要人工进行干预；</li>\n<li>主节点的写作能力和存储能力会受到单机的限制</li>\n</ul>\n<p><strong>那么基于以上只从复制存在的问题，我们该如何解决？！这就引入了哨兵的概念（Redis Sentinel）</strong></p>\n<blockquote>\n<p>什么是Redis Sentinel（哨兵）？</p>\n</blockquote>\n<p>鉴于Redis主从复制存在的一些问题就是需要人工的干预，于是Redis设计出了哨兵系统的方案，借助这个方案可以自动完成故障转移。</p>\n<p><img src=\"http://images.rl0206.love/202305031650481.png\" alt=\"Redis Sentinel\"></p>\n<h2 id=\"Redis客户端\"><a href=\"#Redis客户端\" class=\"headerlink\" title=\"Redis客户端\"></a>Redis客户端</h2><p><img src=\"http://images.rl0206.love/202305021641029.png\" alt=\"image-20230416111339698\"></p>\n<p><img src=\"http://images.rl0206.love/202305021641030.png\" alt=\"image-20230416111856694\"></p>\n<p> Jedis使用的基本步骤：</p>\n<p>1.引入依赖</p>\n<p>2.创建Jedis对象，建立连接</p>\n<p>3.使用Jedis，方法名与Redis命令一致</p>\n<p>4.释放资源</p>\n<p>1、引入依赖</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Java\">&lt;dependency&gt;<br>    &lt;groupId&gt;redis.clients&lt;/groupId&gt;<br>    &lt;artifactId&gt;jedis&lt;/artifactId&gt;<br>    &lt;version&gt;<span class=\"hljs-number\">3.7</span><span class=\"hljs-number\">.0</span>&lt;/version&gt;<br>&lt;/dependency&gt;<br></code></pre></td></tr></table></figure>\n\n<p>2、使用Jedis连接池创建连接</p>\n<p>Jedis本身是线程不安全的，并且频繁的创建和销毁连接会有性能损耗，因此我们推荐大家使用Jedis连接池代替Jedis的直连方式。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">JedisConnectionFactory</span> &#123;<br>   <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span> JedisPool jedisPool;<br><br>   <span class=\"hljs-keyword\">static</span> &#123;<br>     <span class=\"hljs-type\">JedisPoolConfig</span> <span class=\"hljs-variable\">jedisPoolConfig</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">JedisPoolConfig</span>();<br>     <span class=\"hljs-comment\">// 最大连接</span><br>     jedisPoolConfig.setMaxTotal(<span class=\"hljs-number\">8</span>);<br>     <span class=\"hljs-comment\">// 最大空闲连接</span><br>     jedisPoolConfig.setMaxIdle(<span class=\"hljs-number\">8</span>); <br>     <span class=\"hljs-comment\">// 最小空闲连接</span><br>     jedisPoolConfig.setMinIdle(<span class=\"hljs-number\">0</span>);<br>     <span class=\"hljs-comment\">// 设置最长等待时间， ms</span><br>     jedisPoolConfig.setMaxWaitMillis(<span class=\"hljs-number\">200</span>);<br>     jedisPool = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">JedisPool</span>(jedisPoolConfig, <span class=\"hljs-string\">&quot;192.168.150.101&quot;</span>, <span class=\"hljs-number\">6379</span>,<br>         <span class=\"hljs-number\">1000</span>, <span class=\"hljs-string\">&quot;123321&quot;</span>);<br>   &#125;<br>   <span class=\"hljs-comment\">// 获取Jedis对象</span><br>   <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> Jedis <span class=\"hljs-title function_\">getJedis</span><span class=\"hljs-params\">()</span>&#123;<br>     <span class=\"hljs-keyword\">return</span> jedisPool.getResource();<br>   &#125;<br> &#125;<br></code></pre></td></tr></table></figure>\n\n<p>3、使用Jedis进行单元测试</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">private</span> Jedis jedis;<br>  <span class=\"hljs-comment\">// 单元测试的注释写法</span><br>  <span class=\"hljs-meta\">@BeforeEach</span><br>  <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">setUp</span><span class=\"hljs-params\">()</span> &#123;<br>    <span class=\"hljs-comment\">// 建立连接</span><br>    jedis = JedisConnectionFactory.getJedis();<br>    <span class=\"hljs-comment\">// 设置密码</span><br>    jedis.auth(<span class=\"hljs-string\">&quot;123321&quot;</span>);<br>    <span class=\"hljs-comment\">// 选择库</span><br>    jedis.select(<span class=\"hljs-number\">0</span>);<br>&#125;<br>  <span class=\"hljs-meta\">@Test</span><br>  <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">testString</span><span class=\"hljs-params\">()</span> &#123;<br>    <span class=\"hljs-comment\">// 插入数据，方法名称就是redis命令名称，非常简单</span><br>    <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">result</span> <span class=\"hljs-operator\">=</span> jedis.set(<span class=\"hljs-string\">&quot;name&quot;</span>, <span class=\"hljs-string\">&quot;张三&quot;</span>);<br>    System.out.println(<span class=\"hljs-string\">&quot;result = &quot;</span> + result); <br>    <span class=\"hljs-comment\">// 获取数据</span><br>    <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">name</span> <span class=\"hljs-operator\">=</span> jedis.get(<span class=\"hljs-string\">&quot;name&quot;</span>);<br>    System.out.println(<span class=\"hljs-string\">&quot;name = &quot;</span> + name);<br>&#125;<br>  <span class=\"hljs-meta\">@AfterEach</span><br>  <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">tearDown</span><span class=\"hljs-params\">()</span> &#123;<br>    <span class=\"hljs-comment\">// 释放资源</span><br>    <span class=\"hljs-keyword\">if</span> (jedis != <span class=\"hljs-literal\">null</span>) &#123;<br>      jedis.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"SpringDataRedis\"><a href=\"#SpringDataRedis\" class=\"headerlink\" title=\"SpringDataRedis\"></a>SpringDataRedis</h2><blockquote>\n<p>打破Redis只接收String，接收Object类，内部通过JDK的序列化工具进行转换。（即传入一个Object对象，会将其序列化，将其“剁碎”，传入Redis，若想不剁碎，就需要重写RedisTemplate的序列化方式）</p>\n</blockquote>\n<p> 那我们如何重写呢？</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Java\"><br></code></pre></td></tr></table></figure>\n\n<p>存：自动化将对象转JSON,</p>\n<p>取：JSON反序列化为对象</p>\n<p>什么原理呢？</p>\n<p>我们会发现，在自动化转JSON时，会在JSON中第一行加入User的CLASS属性（对应的是User类的名称），所以说在反序列化的时候，会将对应的User写进来。巧妙之处就在于JSON串第一行的Class名称记录。</p>\n<p>尽管序列化方式可以满足我们的需求，但时仍然存在问题：为了在反序列化时知道对象的类型，JSON选择将类的Class类型写入JSON结果中，存入Redis，因此导致了额外的内存开销。</p>\n<p>那么，如何解决？如何节省内存空间？</p>\n<p>为了节约内存空间，一般不会使用JSON序列化工具，而会使用String序列化器，但这只能存储String类型的键值对，所以我们的解决方案就是：用的到对象反序列化时，再手动创建对象的序列化和反序列化。</p>\n<p><img src=\"http://images.rl0206.love/202305021641031.png\" alt=\"image-20230419105307964\"></p>\n<p>Redis序列化两种方案：</p>\n<p>第一种：自定义Templete，修改RedisTemplete的序列化器为GenericJachson2JsonRedisSerializer；</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs typescript\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">RedisConfig</span>&#123;<br>\t<span class=\"hljs-meta\">@Bean</span><br>\t<span class=\"hljs-keyword\">public</span> <span class=\"hljs-title class_\">RedisTemplete</span>&lt;<span class=\"hljs-title class_\">String</span>,<span class=\"hljs-title class_\">Object</span>&gt; <span class=\"hljs-title function_\">redisTemplete</span>(<span class=\"hljs-params\">RedisConnectionFactory connectionFactory</span>)&#123;<br>\t\t<br>\t&#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>第二种：使用RedisRedisTemplete，手动序列化，读取时，手动反序列化。</p>\n"},{"title":"abstract class && interface","index_img":"https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311151627635.png","excerpt":"你知道抽象类(abstract class)和接口(interface)有什么区别吗？","abbrlink":20249,"date":"2023-10-07T00:58:32.000Z","_content":"\n## 抽象类(abstract class)和接口(interface)有什么区别？\n\n### 代码示例：\n\n```java\n// 抽象类\npublic abstract class Animal {\n    // 非抽象方法\n    public void eat() {\n        System.out.println(\"Animal is eating.\");\n    }\n\n    // 抽象方法\n    public abstract void makeSound();\n}\n\n// 实现抽象类的子类\npublic class Dog extends Animal {\n    // 实现抽象方法\n    public void makeSound() {\n        System.out.println(\"Dog is barking.\");\n    }\n}\n\n// 接口\npublic interface Shape {\n    // 接口中的常量\n    public static final double PI = 3.14;\n\n    // 抽象方法\n    public double getArea();\n\n    // 抽象方法\n    public double getPerimeter();\n}\n\n// 实现接口的类\npublic class Circle implements Shape {\n    private double radius;\n\n    public Circle(double radius) {\n        this.radius = radius;\n    }\n\n    // 实现接口的抽象方法\n    public double getArea() {\n        return PI * radius * radius;\n    }\n\n    // 实现接口的抽象方法\n    public double getPerimeter() {\n        return 2 * PI * radius;\n    }\n}\n```\n\n### 区别：\n\n抽象类：\n\n- 可以包含非抽象方法和抽象方法；\n- 可以包含属性和构造方法；\n- 可以被继承，且一个类只能继承一个抽象类；\n- 抽象方法必须被子类实现；\n- 可以有访问修饰符和static、final等修饰符。\n\n接口：\n\n- 只能包含抽象方法和常量；\n- 可以被类实现，一个类可以实现多个接口；\n- 接口中的方法默认为public，且不能有方法体；\n- 接口中的属性默认为public static final，且不能被修改；\n- JDK8之后，接口中可以有默认方法和静态方法。\n- JDK9 在接⼝中引⼊了私有⽅法和私有静态⽅法。\n\n从设计层面来说：\n\n- 抽象类是对类的抽象，是一种模板设计；\n- 接口是对行为的抽象，是一种行为的规范。\n","source":"_posts/abstractandinterface.md","raw":"---\ntitle: abstract class && interface\nindex_img: https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311151627635.png\nexcerpt: 你知道抽象类(abstract class)和接口(interface)有什么区别吗？\ncategories:\n  - Java notes\ntags:\n  - Java基础\nabbrlink: 20249\ndate: 2023-10-07 08:58:32\n---\n\n## 抽象类(abstract class)和接口(interface)有什么区别？\n\n### 代码示例：\n\n```java\n// 抽象类\npublic abstract class Animal {\n    // 非抽象方法\n    public void eat() {\n        System.out.println(\"Animal is eating.\");\n    }\n\n    // 抽象方法\n    public abstract void makeSound();\n}\n\n// 实现抽象类的子类\npublic class Dog extends Animal {\n    // 实现抽象方法\n    public void makeSound() {\n        System.out.println(\"Dog is barking.\");\n    }\n}\n\n// 接口\npublic interface Shape {\n    // 接口中的常量\n    public static final double PI = 3.14;\n\n    // 抽象方法\n    public double getArea();\n\n    // 抽象方法\n    public double getPerimeter();\n}\n\n// 实现接口的类\npublic class Circle implements Shape {\n    private double radius;\n\n    public Circle(double radius) {\n        this.radius = radius;\n    }\n\n    // 实现接口的抽象方法\n    public double getArea() {\n        return PI * radius * radius;\n    }\n\n    // 实现接口的抽象方法\n    public double getPerimeter() {\n        return 2 * PI * radius;\n    }\n}\n```\n\n### 区别：\n\n抽象类：\n\n- 可以包含非抽象方法和抽象方法；\n- 可以包含属性和构造方法；\n- 可以被继承，且一个类只能继承一个抽象类；\n- 抽象方法必须被子类实现；\n- 可以有访问修饰符和static、final等修饰符。\n\n接口：\n\n- 只能包含抽象方法和常量；\n- 可以被类实现，一个类可以实现多个接口；\n- 接口中的方法默认为public，且不能有方法体；\n- 接口中的属性默认为public static final，且不能被修改；\n- JDK8之后，接口中可以有默认方法和静态方法。\n- JDK9 在接⼝中引⼊了私有⽅法和私有静态⽅法。\n\n从设计层面来说：\n\n- 抽象类是对类的抽象，是一种模板设计；\n- 接口是对行为的抽象，是一种行为的规范。\n","slug":"abstractandinterface","published":1,"updated":"2023-11-15T09:19:05.853Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clpkicziw001afkfo4o02gvdc","content":"<h2 id=\"抽象类-abstract-class-和接口-interface-有什么区别？\"><a href=\"#抽象类-abstract-class-和接口-interface-有什么区别？\" class=\"headerlink\" title=\"抽象类(abstract class)和接口(interface)有什么区别？\"></a>抽象类(abstract class)和接口(interface)有什么区别？</h2><h3 id=\"代码示例：\"><a href=\"#代码示例：\" class=\"headerlink\" title=\"代码示例：\"></a>代码示例：</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">// 抽象类</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Animal</span> &#123;<br>    <span class=\"hljs-comment\">// 非抽象方法</span><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">eat</span><span class=\"hljs-params\">()</span> &#123;<br>        System.out.println(<span class=\"hljs-string\">&quot;Animal is eating.&quot;</span>);<br>    &#125;<br><br>    <span class=\"hljs-comment\">// 抽象方法</span><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">makeSound</span><span class=\"hljs-params\">()</span>;<br>&#125;<br><br><span class=\"hljs-comment\">// 实现抽象类的子类</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Dog</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">Animal</span> &#123;<br>    <span class=\"hljs-comment\">// 实现抽象方法</span><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">makeSound</span><span class=\"hljs-params\">()</span> &#123;<br>        System.out.println(<span class=\"hljs-string\">&quot;Dog is barking.&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class=\"hljs-comment\">// 接口</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">Shape</span> &#123;<br>    <span class=\"hljs-comment\">// 接口中的常量</span><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-type\">double</span> <span class=\"hljs-variable\">PI</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">3.14</span>;<br><br>    <span class=\"hljs-comment\">// 抽象方法</span><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-type\">double</span> <span class=\"hljs-title function_\">getArea</span><span class=\"hljs-params\">()</span>;<br><br>    <span class=\"hljs-comment\">// 抽象方法</span><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-type\">double</span> <span class=\"hljs-title function_\">getPerimeter</span><span class=\"hljs-params\">()</span>;<br>&#125;<br><br><span class=\"hljs-comment\">// 实现接口的类</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Circle</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title class_\">Shape</span> &#123;<br>    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-type\">double</span> radius;<br><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-title function_\">Circle</span><span class=\"hljs-params\">(<span class=\"hljs-type\">double</span> radius)</span> &#123;<br>        <span class=\"hljs-built_in\">this</span>.radius = radius;<br>    &#125;<br><br>    <span class=\"hljs-comment\">// 实现接口的抽象方法</span><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-type\">double</span> <span class=\"hljs-title function_\">getArea</span><span class=\"hljs-params\">()</span> &#123;<br>        <span class=\"hljs-keyword\">return</span> PI * radius * radius;<br>    &#125;<br><br>    <span class=\"hljs-comment\">// 实现接口的抽象方法</span><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-type\">double</span> <span class=\"hljs-title function_\">getPerimeter</span><span class=\"hljs-params\">()</span> &#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">2</span> * PI * radius;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"区别：\"><a href=\"#区别：\" class=\"headerlink\" title=\"区别：\"></a>区别：</h3><p>抽象类：</p>\n<ul>\n<li>可以包含非抽象方法和抽象方法；</li>\n<li>可以包含属性和构造方法；</li>\n<li>可以被继承，且一个类只能继承一个抽象类；</li>\n<li>抽象方法必须被子类实现；</li>\n<li>可以有访问修饰符和static、final等修饰符。</li>\n</ul>\n<p>接口：</p>\n<ul>\n<li>只能包含抽象方法和常量；</li>\n<li>可以被类实现，一个类可以实现多个接口；</li>\n<li>接口中的方法默认为public，且不能有方法体；</li>\n<li>接口中的属性默认为public static final，且不能被修改；</li>\n<li>JDK8之后，接口中可以有默认方法和静态方法。</li>\n<li>JDK9 在接⼝中引⼊了私有⽅法和私有静态⽅法。</li>\n</ul>\n<p>从设计层面来说：</p>\n<ul>\n<li>抽象类是对类的抽象，是一种模板设计；</li>\n<li>接口是对行为的抽象，是一种行为的规范。</li>\n</ul>\n","site":{"data":{}},"more":"<h2 id=\"抽象类-abstract-class-和接口-interface-有什么区别？\"><a href=\"#抽象类-abstract-class-和接口-interface-有什么区别？\" class=\"headerlink\" title=\"抽象类(abstract class)和接口(interface)有什么区别？\"></a>抽象类(abstract class)和接口(interface)有什么区别？</h2><h3 id=\"代码示例：\"><a href=\"#代码示例：\" class=\"headerlink\" title=\"代码示例：\"></a>代码示例：</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">// 抽象类</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Animal</span> &#123;<br>    <span class=\"hljs-comment\">// 非抽象方法</span><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">eat</span><span class=\"hljs-params\">()</span> &#123;<br>        System.out.println(<span class=\"hljs-string\">&quot;Animal is eating.&quot;</span>);<br>    &#125;<br><br>    <span class=\"hljs-comment\">// 抽象方法</span><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">makeSound</span><span class=\"hljs-params\">()</span>;<br>&#125;<br><br><span class=\"hljs-comment\">// 实现抽象类的子类</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Dog</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">Animal</span> &#123;<br>    <span class=\"hljs-comment\">// 实现抽象方法</span><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">makeSound</span><span class=\"hljs-params\">()</span> &#123;<br>        System.out.println(<span class=\"hljs-string\">&quot;Dog is barking.&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class=\"hljs-comment\">// 接口</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">Shape</span> &#123;<br>    <span class=\"hljs-comment\">// 接口中的常量</span><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-type\">double</span> <span class=\"hljs-variable\">PI</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">3.14</span>;<br><br>    <span class=\"hljs-comment\">// 抽象方法</span><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-type\">double</span> <span class=\"hljs-title function_\">getArea</span><span class=\"hljs-params\">()</span>;<br><br>    <span class=\"hljs-comment\">// 抽象方法</span><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-type\">double</span> <span class=\"hljs-title function_\">getPerimeter</span><span class=\"hljs-params\">()</span>;<br>&#125;<br><br><span class=\"hljs-comment\">// 实现接口的类</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Circle</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title class_\">Shape</span> &#123;<br>    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-type\">double</span> radius;<br><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-title function_\">Circle</span><span class=\"hljs-params\">(<span class=\"hljs-type\">double</span> radius)</span> &#123;<br>        <span class=\"hljs-built_in\">this</span>.radius = radius;<br>    &#125;<br><br>    <span class=\"hljs-comment\">// 实现接口的抽象方法</span><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-type\">double</span> <span class=\"hljs-title function_\">getArea</span><span class=\"hljs-params\">()</span> &#123;<br>        <span class=\"hljs-keyword\">return</span> PI * radius * radius;<br>    &#125;<br><br>    <span class=\"hljs-comment\">// 实现接口的抽象方法</span><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-type\">double</span> <span class=\"hljs-title function_\">getPerimeter</span><span class=\"hljs-params\">()</span> &#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">2</span> * PI * radius;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"区别：\"><a href=\"#区别：\" class=\"headerlink\" title=\"区别：\"></a>区别：</h3><p>抽象类：</p>\n<ul>\n<li>可以包含非抽象方法和抽象方法；</li>\n<li>可以包含属性和构造方法；</li>\n<li>可以被继承，且一个类只能继承一个抽象类；</li>\n<li>抽象方法必须被子类实现；</li>\n<li>可以有访问修饰符和static、final等修饰符。</li>\n</ul>\n<p>接口：</p>\n<ul>\n<li>只能包含抽象方法和常量；</li>\n<li>可以被类实现，一个类可以实现多个接口；</li>\n<li>接口中的方法默认为public，且不能有方法体；</li>\n<li>接口中的属性默认为public static final，且不能被修改；</li>\n<li>JDK8之后，接口中可以有默认方法和静态方法。</li>\n<li>JDK9 在接⼝中引⼊了私有⽅法和私有静态⽅法。</li>\n</ul>\n<p>从设计层面来说：</p>\n<ul>\n<li>抽象类是对类的抽象，是一种模板设计；</li>\n<li>接口是对行为的抽象，是一种行为的规范。</li>\n</ul>\n"},{"title":"什么是SSM","index_img":"https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311151627644.png","abbrlink":14117,"date":"2021-12-26T23:14:23.000Z","_content":"\n# 什么是SSM?\nSSM框架是Spring、Spring MVC和MyBatis框架的整合，是标准的MVC模式。它是目前主流的Java EE企业级框架，适用于搭建各种大型的企业级应用系统。SSM框架集由Spring、MyBatis两个开源框架整合而成，其中SpringMVC是Spring中的部分内容。\n\n标准的SSM框架有四层，分别是DAO层（Mapper）、Service层、Controller层和View层。其中，持久层的DAO层（Mapper）主要负责与数据库进行联络的一些任务，如数据持久化等，而Service层提供业务逻辑处理的服务，Controller层负责接收请求并进行处理，View层则负责展示数据。\n\n在SSM框架中，Spring主要用来实现业务对象管理，包括对象的创建和销毁、依赖注入等。MyBatis则作为数据对象的持久化引擎，负责将Java对象映射到数据库表中。Spring MVC则负责请求的转发和视图管理[[0\\SSM框架是Spring、Spring MVC和MyBatis框架的整合，是标准的MVC模式。它是目前主流的Java EE企业级框架，适用于搭建各种大型的企业级应用系统。SSM框架集由Spring、MyBatis两个开源框架整合而成，其中SpringMVC是Spring中的部分内容。\n\n标准的SSM框架有四层，分别是DAO层（Mapper）、Service层、Controller层和View层。其中，持久层的DAO层（Mapper）主要负责与数据库进行联络的一些任务，如数据持久化等，而Service层提供业务逻辑处理的服务，Controller层负责接收请求并进行处理，View层则负责展示数据。\n\n在SSM框架中，Spring主要用来实现业务对象管理，包括对象的创建和销毁、依赖注入等。MyBatis则作为数据对象的持久化引擎，负责将Java对象映射到数据库表中。Spring MVC则负责请求的转发和视图管理。\n\n使用SSM框架搭建项目的步骤如下:\n\n1. 搭建整合的环境。\n2. 搭建Spring的配置。\n3. 使用Spring整合Spring MVC框架。\n4. 使用Spring整合MyBatis框架。\n\nSSM框架的优点是易于复用和简化开发，同时也提高了代码的可维护性和可扩展性。使用SSM框架可以让开发人员更加专注于业务逻辑的实现，而无需关注底层的技术实现。\n\n使用SSM框架搭建项目的步骤如下:\n\n1. 搭建整合的环境。\n2. 搭建Spring的配置。\n3. 使用Spring整合Spring MVC框架。\n4. 使用Spring整合MyBatis框架。\n\nSSM框架的优点是易于复用和简化开发，同时也提高了代码的可维护性和可扩展性。使用SSM框架可以让开发人员更加专注于业务逻辑的实现，而无需关注底层的技术实现。","source":"_posts/SSM.md","raw":"---\ntitle: 什么是SSM\nindex_img: https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311151627644.png\ncategories:\n  - Java notes\ntags:\n  - SSM\nabbrlink: 14117\ndate: 2021-12-27 07:14:23\n---\n\n# 什么是SSM?\nSSM框架是Spring、Spring MVC和MyBatis框架的整合，是标准的MVC模式。它是目前主流的Java EE企业级框架，适用于搭建各种大型的企业级应用系统。SSM框架集由Spring、MyBatis两个开源框架整合而成，其中SpringMVC是Spring中的部分内容。\n\n标准的SSM框架有四层，分别是DAO层（Mapper）、Service层、Controller层和View层。其中，持久层的DAO层（Mapper）主要负责与数据库进行联络的一些任务，如数据持久化等，而Service层提供业务逻辑处理的服务，Controller层负责接收请求并进行处理，View层则负责展示数据。\n\n在SSM框架中，Spring主要用来实现业务对象管理，包括对象的创建和销毁、依赖注入等。MyBatis则作为数据对象的持久化引擎，负责将Java对象映射到数据库表中。Spring MVC则负责请求的转发和视图管理[[0\\SSM框架是Spring、Spring MVC和MyBatis框架的整合，是标准的MVC模式。它是目前主流的Java EE企业级框架，适用于搭建各种大型的企业级应用系统。SSM框架集由Spring、MyBatis两个开源框架整合而成，其中SpringMVC是Spring中的部分内容。\n\n标准的SSM框架有四层，分别是DAO层（Mapper）、Service层、Controller层和View层。其中，持久层的DAO层（Mapper）主要负责与数据库进行联络的一些任务，如数据持久化等，而Service层提供业务逻辑处理的服务，Controller层负责接收请求并进行处理，View层则负责展示数据。\n\n在SSM框架中，Spring主要用来实现业务对象管理，包括对象的创建和销毁、依赖注入等。MyBatis则作为数据对象的持久化引擎，负责将Java对象映射到数据库表中。Spring MVC则负责请求的转发和视图管理。\n\n使用SSM框架搭建项目的步骤如下:\n\n1. 搭建整合的环境。\n2. 搭建Spring的配置。\n3. 使用Spring整合Spring MVC框架。\n4. 使用Spring整合MyBatis框架。\n\nSSM框架的优点是易于复用和简化开发，同时也提高了代码的可维护性和可扩展性。使用SSM框架可以让开发人员更加专注于业务逻辑的实现，而无需关注底层的技术实现。\n\n使用SSM框架搭建项目的步骤如下:\n\n1. 搭建整合的环境。\n2. 搭建Spring的配置。\n3. 使用Spring整合Spring MVC框架。\n4. 使用Spring整合MyBatis框架。\n\nSSM框架的优点是易于复用和简化开发，同时也提高了代码的可维护性和可扩展性。使用SSM框架可以让开发人员更加专注于业务逻辑的实现，而无需关注底层的技术实现。","slug":"SSM","published":1,"updated":"2023-11-15T08:41:51.171Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clpkiczix001efkfoauvdh58t","content":"<h1 id=\"什么是SSM\"><a href=\"#什么是SSM\" class=\"headerlink\" title=\"什么是SSM?\"></a>什么是SSM?</h1><p>SSM框架是Spring、Spring MVC和MyBatis框架的整合，是标准的MVC模式。它是目前主流的Java EE企业级框架，适用于搭建各种大型的企业级应用系统。SSM框架集由Spring、MyBatis两个开源框架整合而成，其中SpringMVC是Spring中的部分内容。</p>\n<p>标准的SSM框架有四层，分别是DAO层（Mapper）、Service层、Controller层和View层。其中，持久层的DAO层（Mapper）主要负责与数据库进行联络的一些任务，如数据持久化等，而Service层提供业务逻辑处理的服务，Controller层负责接收请求并进行处理，View层则负责展示数据。</p>\n<p>在SSM框架中，Spring主要用来实现业务对象管理，包括对象的创建和销毁、依赖注入等。MyBatis则作为数据对象的持久化引擎，负责将Java对象映射到数据库表中。Spring MVC则负责请求的转发和视图管理[[0\\SSM框架是Spring、Spring MVC和MyBatis框架的整合，是标准的MVC模式。它是目前主流的Java EE企业级框架，适用于搭建各种大型的企业级应用系统。SSM框架集由Spring、MyBatis两个开源框架整合而成，其中SpringMVC是Spring中的部分内容。</p>\n<p>标准的SSM框架有四层，分别是DAO层（Mapper）、Service层、Controller层和View层。其中，持久层的DAO层（Mapper）主要负责与数据库进行联络的一些任务，如数据持久化等，而Service层提供业务逻辑处理的服务，Controller层负责接收请求并进行处理，View层则负责展示数据。</p>\n<p>在SSM框架中，Spring主要用来实现业务对象管理，包括对象的创建和销毁、依赖注入等。MyBatis则作为数据对象的持久化引擎，负责将Java对象映射到数据库表中。Spring MVC则负责请求的转发和视图管理。</p>\n<p>使用SSM框架搭建项目的步骤如下:</p>\n<ol>\n<li>搭建整合的环境。</li>\n<li>搭建Spring的配置。</li>\n<li>使用Spring整合Spring MVC框架。</li>\n<li>使用Spring整合MyBatis框架。</li>\n</ol>\n<p>SSM框架的优点是易于复用和简化开发，同时也提高了代码的可维护性和可扩展性。使用SSM框架可以让开发人员更加专注于业务逻辑的实现，而无需关注底层的技术实现。</p>\n<p>使用SSM框架搭建项目的步骤如下:</p>\n<ol>\n<li>搭建整合的环境。</li>\n<li>搭建Spring的配置。</li>\n<li>使用Spring整合Spring MVC框架。</li>\n<li>使用Spring整合MyBatis框架。</li>\n</ol>\n<p>SSM框架的优点是易于复用和简化开发，同时也提高了代码的可维护性和可扩展性。使用SSM框架可以让开发人员更加专注于业务逻辑的实现，而无需关注底层的技术实现。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"什么是SSM\"><a href=\"#什么是SSM\" class=\"headerlink\" title=\"什么是SSM?\"></a>什么是SSM?</h1><p>SSM框架是Spring、Spring MVC和MyBatis框架的整合，是标准的MVC模式。它是目前主流的Java EE企业级框架，适用于搭建各种大型的企业级应用系统。SSM框架集由Spring、MyBatis两个开源框架整合而成，其中SpringMVC是Spring中的部分内容。</p>\n<p>标准的SSM框架有四层，分别是DAO层（Mapper）、Service层、Controller层和View层。其中，持久层的DAO层（Mapper）主要负责与数据库进行联络的一些任务，如数据持久化等，而Service层提供业务逻辑处理的服务，Controller层负责接收请求并进行处理，View层则负责展示数据。</p>\n<p>在SSM框架中，Spring主要用来实现业务对象管理，包括对象的创建和销毁、依赖注入等。MyBatis则作为数据对象的持久化引擎，负责将Java对象映射到数据库表中。Spring MVC则负责请求的转发和视图管理[[0\\SSM框架是Spring、Spring MVC和MyBatis框架的整合，是标准的MVC模式。它是目前主流的Java EE企业级框架，适用于搭建各种大型的企业级应用系统。SSM框架集由Spring、MyBatis两个开源框架整合而成，其中SpringMVC是Spring中的部分内容。</p>\n<p>标准的SSM框架有四层，分别是DAO层（Mapper）、Service层、Controller层和View层。其中，持久层的DAO层（Mapper）主要负责与数据库进行联络的一些任务，如数据持久化等，而Service层提供业务逻辑处理的服务，Controller层负责接收请求并进行处理，View层则负责展示数据。</p>\n<p>在SSM框架中，Spring主要用来实现业务对象管理，包括对象的创建和销毁、依赖注入等。MyBatis则作为数据对象的持久化引擎，负责将Java对象映射到数据库表中。Spring MVC则负责请求的转发和视图管理。</p>\n<p>使用SSM框架搭建项目的步骤如下:</p>\n<ol>\n<li>搭建整合的环境。</li>\n<li>搭建Spring的配置。</li>\n<li>使用Spring整合Spring MVC框架。</li>\n<li>使用Spring整合MyBatis框架。</li>\n</ol>\n<p>SSM框架的优点是易于复用和简化开发，同时也提高了代码的可维护性和可扩展性。使用SSM框架可以让开发人员更加专注于业务逻辑的实现，而无需关注底层的技术实现。</p>\n<p>使用SSM框架搭建项目的步骤如下:</p>\n<ol>\n<li>搭建整合的环境。</li>\n<li>搭建Spring的配置。</li>\n<li>使用Spring整合Spring MVC框架。</li>\n<li>使用Spring整合MyBatis框架。</li>\n</ol>\n<p>SSM框架的优点是易于复用和简化开发，同时也提高了代码的可维护性和可扩展性。使用SSM框架可以让开发人员更加专注于业务逻辑的实现，而无需关注底层的技术实现。</p>\n"},{"title":"聚合搜索中台","index_img":"https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202309120915504.png","excerpt":"聚合搜索就是输入一个关键字，对于用户可以使用户在同一个入口搜索到不同的内容分类，不同形式的内容，提升用户的检索效率；对于企业来说无需对每一个项目进行搜索功能的开发，当有新的内容或者新的网站，可以进行复用，提高开发效率。后端：SpringBoot、MySQL、ES、数据抓取、数据同步（Logstash、Canal）","abbrlink":23054,"date":"2023-08-01T02:21:14.000Z","_content":"\n# 聚合搜索项目\n\n## 项目介绍\n\n> 聚合搜索就是输入一个关键字，对于用户可以使用户在同一个入口搜索到不同的内容分类，不同形式的内容，提升用户的检索效率；对于企业来说无需对每一个项目进行搜索功能的开发，当有新的内容或者新的网站，可以进行复用，提高开发效率。\n\n## 技术栈\n\n前端：\n\n* Vue\n* Ant Design Vue\n* Lodash\n\n后端：\n\n* Spring Boot\n* MySQL\n* ES\n* 数据抓取\n* 数据同步（Logstash、Canal）\n* Guava Retrying\n* 怎么保证API的稳定性？\n\n## 业务流程\n\n1. 先得到不同分类的数据\n2. 提供一个搜索页面\n3. 业务优化（关键词高亮、防抖节流）\n\n> `package.json`\n\n```\n{\n  \"name\": \"yuso-frontend\",\n  \"version\": \"0.1.0\",\n  \"private\": true,\n  \"scripts\": {\n    \"serve\": \"vue-cli-service serve\",\n    \"build\": \"vue-cli-service build\",\n    \"lint\": \"vue-cli-service lint\"\n  },\n  \"dependencies\": {\n  \t// \"^4.0.0-rc.5\"这个版本不行：Can't resolve 'ant-design-vue/dist/antd.css' \n    \"ant-design-vue\": \"^3.3.0-beta.4\",\n    \"axios\": \"^1.3.4\",\n    \"core-js\": \"^3.8.3\",\n    \"vue\": \"^3.2.13\",\n    \"vue-router\": \"^4.0.3\"\n  },\n  \"devDependencies\": {\n    \"@typescript-eslint/eslint-plugin\": \"^5.4.0\",\n    \"@typescript-eslint/parser\": \"^5.4.0\",\n    \"@vue/cli-plugin-babel\": \"~5.0.0\",\n    \"@vue/cli-plugin-eslint\": \"~5.0.0\",\n    \"@vue/cli-plugin-router\": \"~5.0.0\",\n    \"@vue/cli-plugin-typescript\": \"~5.0.0\",\n    \"@vue/cli-service\": \"~5.0.0\",\n    \"@vue/eslint-config-typescript\": \"^9.1.0\",\n    \"eslint\": \"^7.32.0\",\n    \"eslint-config-prettier\": \"^8.3.0\",\n    \"eslint-plugin-prettier\": \"^4.0.0\",\n    \"eslint-plugin-vue\": \"^8.0.3\",\n    \"prettier\": \"^2.4.1\",\n    \"typescript\": \"~4.5.5\"\n  }\n}\n```\n\n## `Day01` 开发计划\n\n* 前端初始化\n* 后端初始化\n* 前端搜索页面开发\n* 整合`Axios`\n* 后端搜索接口开发\n\n\n\n### 前端开发\n\n用URL来记录用户的搜索状态，以便于进行分享。也就是将URL状态与页面状态同步\n\n核心小技巧：把同步状态改成单向的，即只允许URL改变页面状态，不允许反向修改\n\n**步骤分析：**\n\n1. 用户进行页面搜索的时候，URL地址跟着同步改变；\n2. 当URL变动时，页面状态也随之改变（监听URL的变动）\n\n\n\n### 后端开发\n\n直接套用模板\n\n\n\n### 前后端联调\n\n前端整合Axios，自定义Axios实例，完成请求https://www.axios-http.cn/docs/intro\n\n## `Day02`数据分析\n\n### 获取多种不同的数据源\n\n\t1. 获取文章（内部）\n\n​\t抓取网站的内容，例如抓取文章等。。。\n\n​\t**数据抓取的几种方式：**\n\n​\t\t直接访问数据接口（最方便）\n\n​\t\t等网页渲染完毕出明文，从前端内容进行抓取\n\n​\t\t有一种网站是动态请求的，，不会一次加载，例如会用验证码来验证是否是真人（相对复杂，如何解决？后台通过程序控制浏览器，以代替人工继续验证等）selenium、nodejs、puppetter\n\n​\t\t\n\n​\t\t\n\n​\t用户（内部）\n\n​\t图片（外部，不是我们自己的项目）\n\n2. 前后端接口联调，跑通整个页面（至此完全可以应付毕设）\n3. 分析项目的问题，进一步优化，聚合接口的开发\n4. 安装ES\n\n> 断更，待完成！！！\n\n","source":"_posts/aggregateSearch.md","raw":"---\ntitle: 聚合搜索中台\nindex_img: >-\n  https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202309120915504.png\nexcerpt: >-\n  聚合搜索就是输入一个关键字，对于用户可以使用户在同一个入口搜索到不同的内容分类，不同形式的内容，提升用户的检索效率；对于企业来说无需对每一个项目进行搜索功能的开发，当有新的内容或者新的网站，可以进行复用，提高开发效率。后端：SpringBoot、MySQL、ES、数据抓取、数据同步（Logstash、Canal）\ncategories:\n  - Project\ntags:\n  - Vue\n  - Ant Design Vue\n  - Lodash\n  - Spring Boot\n  - MySQL\n  - ES\nabbrlink: 23054\ndate: 2023-08-01 10:21:14\n---\n\n# 聚合搜索项目\n\n## 项目介绍\n\n> 聚合搜索就是输入一个关键字，对于用户可以使用户在同一个入口搜索到不同的内容分类，不同形式的内容，提升用户的检索效率；对于企业来说无需对每一个项目进行搜索功能的开发，当有新的内容或者新的网站，可以进行复用，提高开发效率。\n\n## 技术栈\n\n前端：\n\n* Vue\n* Ant Design Vue\n* Lodash\n\n后端：\n\n* Spring Boot\n* MySQL\n* ES\n* 数据抓取\n* 数据同步（Logstash、Canal）\n* Guava Retrying\n* 怎么保证API的稳定性？\n\n## 业务流程\n\n1. 先得到不同分类的数据\n2. 提供一个搜索页面\n3. 业务优化（关键词高亮、防抖节流）\n\n> `package.json`\n\n```\n{\n  \"name\": \"yuso-frontend\",\n  \"version\": \"0.1.0\",\n  \"private\": true,\n  \"scripts\": {\n    \"serve\": \"vue-cli-service serve\",\n    \"build\": \"vue-cli-service build\",\n    \"lint\": \"vue-cli-service lint\"\n  },\n  \"dependencies\": {\n  \t// \"^4.0.0-rc.5\"这个版本不行：Can't resolve 'ant-design-vue/dist/antd.css' \n    \"ant-design-vue\": \"^3.3.0-beta.4\",\n    \"axios\": \"^1.3.4\",\n    \"core-js\": \"^3.8.3\",\n    \"vue\": \"^3.2.13\",\n    \"vue-router\": \"^4.0.3\"\n  },\n  \"devDependencies\": {\n    \"@typescript-eslint/eslint-plugin\": \"^5.4.0\",\n    \"@typescript-eslint/parser\": \"^5.4.0\",\n    \"@vue/cli-plugin-babel\": \"~5.0.0\",\n    \"@vue/cli-plugin-eslint\": \"~5.0.0\",\n    \"@vue/cli-plugin-router\": \"~5.0.0\",\n    \"@vue/cli-plugin-typescript\": \"~5.0.0\",\n    \"@vue/cli-service\": \"~5.0.0\",\n    \"@vue/eslint-config-typescript\": \"^9.1.0\",\n    \"eslint\": \"^7.32.0\",\n    \"eslint-config-prettier\": \"^8.3.0\",\n    \"eslint-plugin-prettier\": \"^4.0.0\",\n    \"eslint-plugin-vue\": \"^8.0.3\",\n    \"prettier\": \"^2.4.1\",\n    \"typescript\": \"~4.5.5\"\n  }\n}\n```\n\n## `Day01` 开发计划\n\n* 前端初始化\n* 后端初始化\n* 前端搜索页面开发\n* 整合`Axios`\n* 后端搜索接口开发\n\n\n\n### 前端开发\n\n用URL来记录用户的搜索状态，以便于进行分享。也就是将URL状态与页面状态同步\n\n核心小技巧：把同步状态改成单向的，即只允许URL改变页面状态，不允许反向修改\n\n**步骤分析：**\n\n1. 用户进行页面搜索的时候，URL地址跟着同步改变；\n2. 当URL变动时，页面状态也随之改变（监听URL的变动）\n\n\n\n### 后端开发\n\n直接套用模板\n\n\n\n### 前后端联调\n\n前端整合Axios，自定义Axios实例，完成请求https://www.axios-http.cn/docs/intro\n\n## `Day02`数据分析\n\n### 获取多种不同的数据源\n\n\t1. 获取文章（内部）\n\n​\t抓取网站的内容，例如抓取文章等。。。\n\n​\t**数据抓取的几种方式：**\n\n​\t\t直接访问数据接口（最方便）\n\n​\t\t等网页渲染完毕出明文，从前端内容进行抓取\n\n​\t\t有一种网站是动态请求的，，不会一次加载，例如会用验证码来验证是否是真人（相对复杂，如何解决？后台通过程序控制浏览器，以代替人工继续验证等）selenium、nodejs、puppetter\n\n​\t\t\n\n​\t\t\n\n​\t用户（内部）\n\n​\t图片（外部，不是我们自己的项目）\n\n2. 前后端接口联调，跑通整个页面（至此完全可以应付毕设）\n3. 分析项目的问题，进一步优化，聚合接口的开发\n4. 安装ES\n\n> 断更，待完成！！！\n\n","slug":"aggregateSearch","published":1,"updated":"2023-11-26T03:31:08.271Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clpkicziy001gfkfofz08hegw","content":"<h1 id=\"聚合搜索项目\"><a href=\"#聚合搜索项目\" class=\"headerlink\" title=\"聚合搜索项目\"></a>聚合搜索项目</h1><h2 id=\"项目介绍\"><a href=\"#项目介绍\" class=\"headerlink\" title=\"项目介绍\"></a>项目介绍</h2><blockquote>\n<p>聚合搜索就是输入一个关键字，对于用户可以使用户在同一个入口搜索到不同的内容分类，不同形式的内容，提升用户的检索效率；对于企业来说无需对每一个项目进行搜索功能的开发，当有新的内容或者新的网站，可以进行复用，提高开发效率。</p>\n</blockquote>\n<h2 id=\"技术栈\"><a href=\"#技术栈\" class=\"headerlink\" title=\"技术栈\"></a>技术栈</h2><p>前端：</p>\n<ul>\n<li>Vue</li>\n<li>Ant Design Vue</li>\n<li>Lodash</li>\n</ul>\n<p>后端：</p>\n<ul>\n<li>Spring Boot</li>\n<li>MySQL</li>\n<li>ES</li>\n<li>数据抓取</li>\n<li>数据同步（Logstash、Canal）</li>\n<li>Guava Retrying</li>\n<li>怎么保证API的稳定性？</li>\n</ul>\n<h2 id=\"业务流程\"><a href=\"#业务流程\" class=\"headerlink\" title=\"业务流程\"></a>业务流程</h2><ol>\n<li>先得到不同分类的数据</li>\n<li>提供一个搜索页面</li>\n<li>业务优化（关键词高亮、防抖节流）</li>\n</ol>\n<blockquote>\n<p><code>package.json</code></p>\n</blockquote>\n<figure class=\"highlight ada\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ada\">&#123;<br>  <span class=\"hljs-string\">&quot;name&quot;</span>: <span class=\"hljs-string\">&quot;yuso-frontend&quot;</span>,<br>  <span class=\"hljs-string\">&quot;version&quot;</span>: <span class=\"hljs-string\">&quot;0.1.0&quot;</span>,<br>  <span class=\"hljs-string\">&quot;private&quot;</span>: <span class=\"hljs-literal\">true</span>,<br>  <span class=\"hljs-string\">&quot;scripts&quot;</span>: &#123;<br>    <span class=\"hljs-string\">&quot;serve&quot;</span>: <span class=\"hljs-string\">&quot;vue-cli-service serve&quot;</span>,<br>    <span class=\"hljs-string\">&quot;build&quot;</span>: <span class=\"hljs-string\">&quot;vue-cli-service build&quot;</span>,<br>    <span class=\"hljs-string\">&quot;lint&quot;</span>: <span class=\"hljs-string\">&quot;vue-cli-service lint&quot;</span><br>  &#125;,<br>  <span class=\"hljs-string\">&quot;dependencies&quot;</span>: &#123;<br>  \t// <span class=\"hljs-string\">&quot;^4.0.0-rc.5&quot;</span>这个版本不行：Can<span class=\"hljs-symbol\">&#x27;t</span> resolve <span class=\"hljs-symbol\">&#x27;ant</span>-design-vue/dist/antd.css&#x27; <br>    <span class=\"hljs-string\">&quot;ant-design-vue&quot;</span>: <span class=\"hljs-string\">&quot;^3.3.0-beta.4&quot;</span>,<br>    <span class=\"hljs-string\">&quot;axios&quot;</span>: <span class=\"hljs-string\">&quot;^1.3.4&quot;</span>,<br>    <span class=\"hljs-string\">&quot;core-js&quot;</span>: <span class=\"hljs-string\">&quot;^3.8.3&quot;</span>,<br>    <span class=\"hljs-string\">&quot;vue&quot;</span>: <span class=\"hljs-string\">&quot;^3.2.13&quot;</span>,<br>    <span class=\"hljs-string\">&quot;vue-router&quot;</span>: <span class=\"hljs-string\">&quot;^4.0.3&quot;</span><br>  &#125;,<br>  <span class=\"hljs-string\">&quot;devDependencies&quot;</span>: &#123;<br>    <span class=\"hljs-string\">&quot;@typescript-eslint/eslint-plugin&quot;</span>: <span class=\"hljs-string\">&quot;^5.4.0&quot;</span>,<br>    <span class=\"hljs-string\">&quot;@typescript-eslint/parser&quot;</span>: <span class=\"hljs-string\">&quot;^5.4.0&quot;</span>,<br>    <span class=\"hljs-string\">&quot;@vue/cli-plugin-babel&quot;</span>: <span class=\"hljs-string\">&quot;~5.0.0&quot;</span>,<br>    <span class=\"hljs-string\">&quot;@vue/cli-plugin-eslint&quot;</span>: <span class=\"hljs-string\">&quot;~5.0.0&quot;</span>,<br>    <span class=\"hljs-string\">&quot;@vue/cli-plugin-router&quot;</span>: <span class=\"hljs-string\">&quot;~5.0.0&quot;</span>,<br>    <span class=\"hljs-string\">&quot;@vue/cli-plugin-typescript&quot;</span>: <span class=\"hljs-string\">&quot;~5.0.0&quot;</span>,<br>    <span class=\"hljs-string\">&quot;@vue/cli-service&quot;</span>: <span class=\"hljs-string\">&quot;~5.0.0&quot;</span>,<br>    <span class=\"hljs-string\">&quot;@vue/eslint-config-typescript&quot;</span>: <span class=\"hljs-string\">&quot;^9.1.0&quot;</span>,<br>    <span class=\"hljs-string\">&quot;eslint&quot;</span>: <span class=\"hljs-string\">&quot;^7.32.0&quot;</span>,<br>    <span class=\"hljs-string\">&quot;eslint-config-prettier&quot;</span>: <span class=\"hljs-string\">&quot;^8.3.0&quot;</span>,<br>    <span class=\"hljs-string\">&quot;eslint-plugin-prettier&quot;</span>: <span class=\"hljs-string\">&quot;^4.0.0&quot;</span>,<br>    <span class=\"hljs-string\">&quot;eslint-plugin-vue&quot;</span>: <span class=\"hljs-string\">&quot;^8.0.3&quot;</span>,<br>    <span class=\"hljs-string\">&quot;prettier&quot;</span>: <span class=\"hljs-string\">&quot;^2.4.1&quot;</span>,<br>    <span class=\"hljs-string\">&quot;typescript&quot;</span>: <span class=\"hljs-string\">&quot;~4.5.5&quot;</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"Day01-开发计划\"><a href=\"#Day01-开发计划\" class=\"headerlink\" title=\"Day01 开发计划\"></a><code>Day01</code> 开发计划</h2><ul>\n<li>前端初始化</li>\n<li>后端初始化</li>\n<li>前端搜索页面开发</li>\n<li>整合<code>Axios</code></li>\n<li>后端搜索接口开发</li>\n</ul>\n<h3 id=\"前端开发\"><a href=\"#前端开发\" class=\"headerlink\" title=\"前端开发\"></a>前端开发</h3><p>用URL来记录用户的搜索状态，以便于进行分享。也就是将URL状态与页面状态同步</p>\n<p>核心小技巧：把同步状态改成单向的，即只允许URL改变页面状态，不允许反向修改</p>\n<p><strong>步骤分析：</strong></p>\n<ol>\n<li>用户进行页面搜索的时候，URL地址跟着同步改变；</li>\n<li>当URL变动时，页面状态也随之改变（监听URL的变动）</li>\n</ol>\n<h3 id=\"后端开发\"><a href=\"#后端开发\" class=\"headerlink\" title=\"后端开发\"></a>后端开发</h3><p>直接套用模板</p>\n<h3 id=\"前后端联调\"><a href=\"#前后端联调\" class=\"headerlink\" title=\"前后端联调\"></a>前后端联调</h3><p>前端整合Axios，自定义Axios实例，完成请求<a href=\"https://www.axios-http.cn/docs/intro\">https://www.axios-http.cn/docs/intro</a></p>\n<h2 id=\"Day02数据分析\"><a href=\"#Day02数据分析\" class=\"headerlink\" title=\"Day02数据分析\"></a><code>Day02</code>数据分析</h2><h3 id=\"获取多种不同的数据源\"><a href=\"#获取多种不同的数据源\" class=\"headerlink\" title=\"获取多种不同的数据源\"></a>获取多种不同的数据源</h3><pre><code class=\"hljs\">1. 获取文章（内部）\n</code></pre>\n<p>​    抓取网站的内容，例如抓取文章等。。。</p>\n<p>​    <strong>数据抓取的几种方式：</strong></p>\n<p>​        直接访问数据接口（最方便）</p>\n<p>​        等网页渲染完毕出明文，从前端内容进行抓取</p>\n<p>​        有一种网站是动态请求的，，不会一次加载，例如会用验证码来验证是否是真人（相对复杂，如何解决？后台通过程序控制浏览器，以代替人工继续验证等）selenium、nodejs、puppetter</p>\n<p>​        </p>\n<p>​        </p>\n<p>​    用户（内部）</p>\n<p>​    图片（外部，不是我们自己的项目）</p>\n<ol start=\"2\">\n<li>前后端接口联调，跑通整个页面（至此完全可以应付毕设）</li>\n<li>分析项目的问题，进一步优化，聚合接口的开发</li>\n<li>安装ES</li>\n</ol>\n<blockquote>\n<p>断更，待完成！！！</p>\n</blockquote>\n","site":{"data":{}},"more":"<h1 id=\"聚合搜索项目\"><a href=\"#聚合搜索项目\" class=\"headerlink\" title=\"聚合搜索项目\"></a>聚合搜索项目</h1><h2 id=\"项目介绍\"><a href=\"#项目介绍\" class=\"headerlink\" title=\"项目介绍\"></a>项目介绍</h2><blockquote>\n<p>聚合搜索就是输入一个关键字，对于用户可以使用户在同一个入口搜索到不同的内容分类，不同形式的内容，提升用户的检索效率；对于企业来说无需对每一个项目进行搜索功能的开发，当有新的内容或者新的网站，可以进行复用，提高开发效率。</p>\n</blockquote>\n<h2 id=\"技术栈\"><a href=\"#技术栈\" class=\"headerlink\" title=\"技术栈\"></a>技术栈</h2><p>前端：</p>\n<ul>\n<li>Vue</li>\n<li>Ant Design Vue</li>\n<li>Lodash</li>\n</ul>\n<p>后端：</p>\n<ul>\n<li>Spring Boot</li>\n<li>MySQL</li>\n<li>ES</li>\n<li>数据抓取</li>\n<li>数据同步（Logstash、Canal）</li>\n<li>Guava Retrying</li>\n<li>怎么保证API的稳定性？</li>\n</ul>\n<h2 id=\"业务流程\"><a href=\"#业务流程\" class=\"headerlink\" title=\"业务流程\"></a>业务流程</h2><ol>\n<li>先得到不同分类的数据</li>\n<li>提供一个搜索页面</li>\n<li>业务优化（关键词高亮、防抖节流）</li>\n</ol>\n<blockquote>\n<p><code>package.json</code></p>\n</blockquote>\n<figure class=\"highlight ada\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ada\">&#123;<br>  <span class=\"hljs-string\">&quot;name&quot;</span>: <span class=\"hljs-string\">&quot;yuso-frontend&quot;</span>,<br>  <span class=\"hljs-string\">&quot;version&quot;</span>: <span class=\"hljs-string\">&quot;0.1.0&quot;</span>,<br>  <span class=\"hljs-string\">&quot;private&quot;</span>: <span class=\"hljs-literal\">true</span>,<br>  <span class=\"hljs-string\">&quot;scripts&quot;</span>: &#123;<br>    <span class=\"hljs-string\">&quot;serve&quot;</span>: <span class=\"hljs-string\">&quot;vue-cli-service serve&quot;</span>,<br>    <span class=\"hljs-string\">&quot;build&quot;</span>: <span class=\"hljs-string\">&quot;vue-cli-service build&quot;</span>,<br>    <span class=\"hljs-string\">&quot;lint&quot;</span>: <span class=\"hljs-string\">&quot;vue-cli-service lint&quot;</span><br>  &#125;,<br>  <span class=\"hljs-string\">&quot;dependencies&quot;</span>: &#123;<br>  \t// <span class=\"hljs-string\">&quot;^4.0.0-rc.5&quot;</span>这个版本不行：Can<span class=\"hljs-symbol\">&#x27;t</span> resolve <span class=\"hljs-symbol\">&#x27;ant</span>-design-vue/dist/antd.css&#x27; <br>    <span class=\"hljs-string\">&quot;ant-design-vue&quot;</span>: <span class=\"hljs-string\">&quot;^3.3.0-beta.4&quot;</span>,<br>    <span class=\"hljs-string\">&quot;axios&quot;</span>: <span class=\"hljs-string\">&quot;^1.3.4&quot;</span>,<br>    <span class=\"hljs-string\">&quot;core-js&quot;</span>: <span class=\"hljs-string\">&quot;^3.8.3&quot;</span>,<br>    <span class=\"hljs-string\">&quot;vue&quot;</span>: <span class=\"hljs-string\">&quot;^3.2.13&quot;</span>,<br>    <span class=\"hljs-string\">&quot;vue-router&quot;</span>: <span class=\"hljs-string\">&quot;^4.0.3&quot;</span><br>  &#125;,<br>  <span class=\"hljs-string\">&quot;devDependencies&quot;</span>: &#123;<br>    <span class=\"hljs-string\">&quot;@typescript-eslint/eslint-plugin&quot;</span>: <span class=\"hljs-string\">&quot;^5.4.0&quot;</span>,<br>    <span class=\"hljs-string\">&quot;@typescript-eslint/parser&quot;</span>: <span class=\"hljs-string\">&quot;^5.4.0&quot;</span>,<br>    <span class=\"hljs-string\">&quot;@vue/cli-plugin-babel&quot;</span>: <span class=\"hljs-string\">&quot;~5.0.0&quot;</span>,<br>    <span class=\"hljs-string\">&quot;@vue/cli-plugin-eslint&quot;</span>: <span class=\"hljs-string\">&quot;~5.0.0&quot;</span>,<br>    <span class=\"hljs-string\">&quot;@vue/cli-plugin-router&quot;</span>: <span class=\"hljs-string\">&quot;~5.0.0&quot;</span>,<br>    <span class=\"hljs-string\">&quot;@vue/cli-plugin-typescript&quot;</span>: <span class=\"hljs-string\">&quot;~5.0.0&quot;</span>,<br>    <span class=\"hljs-string\">&quot;@vue/cli-service&quot;</span>: <span class=\"hljs-string\">&quot;~5.0.0&quot;</span>,<br>    <span class=\"hljs-string\">&quot;@vue/eslint-config-typescript&quot;</span>: <span class=\"hljs-string\">&quot;^9.1.0&quot;</span>,<br>    <span class=\"hljs-string\">&quot;eslint&quot;</span>: <span class=\"hljs-string\">&quot;^7.32.0&quot;</span>,<br>    <span class=\"hljs-string\">&quot;eslint-config-prettier&quot;</span>: <span class=\"hljs-string\">&quot;^8.3.0&quot;</span>,<br>    <span class=\"hljs-string\">&quot;eslint-plugin-prettier&quot;</span>: <span class=\"hljs-string\">&quot;^4.0.0&quot;</span>,<br>    <span class=\"hljs-string\">&quot;eslint-plugin-vue&quot;</span>: <span class=\"hljs-string\">&quot;^8.0.3&quot;</span>,<br>    <span class=\"hljs-string\">&quot;prettier&quot;</span>: <span class=\"hljs-string\">&quot;^2.4.1&quot;</span>,<br>    <span class=\"hljs-string\">&quot;typescript&quot;</span>: <span class=\"hljs-string\">&quot;~4.5.5&quot;</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"Day01-开发计划\"><a href=\"#Day01-开发计划\" class=\"headerlink\" title=\"Day01 开发计划\"></a><code>Day01</code> 开发计划</h2><ul>\n<li>前端初始化</li>\n<li>后端初始化</li>\n<li>前端搜索页面开发</li>\n<li>整合<code>Axios</code></li>\n<li>后端搜索接口开发</li>\n</ul>\n<h3 id=\"前端开发\"><a href=\"#前端开发\" class=\"headerlink\" title=\"前端开发\"></a>前端开发</h3><p>用URL来记录用户的搜索状态，以便于进行分享。也就是将URL状态与页面状态同步</p>\n<p>核心小技巧：把同步状态改成单向的，即只允许URL改变页面状态，不允许反向修改</p>\n<p><strong>步骤分析：</strong></p>\n<ol>\n<li>用户进行页面搜索的时候，URL地址跟着同步改变；</li>\n<li>当URL变动时，页面状态也随之改变（监听URL的变动）</li>\n</ol>\n<h3 id=\"后端开发\"><a href=\"#后端开发\" class=\"headerlink\" title=\"后端开发\"></a>后端开发</h3><p>直接套用模板</p>\n<h3 id=\"前后端联调\"><a href=\"#前后端联调\" class=\"headerlink\" title=\"前后端联调\"></a>前后端联调</h3><p>前端整合Axios，自定义Axios实例，完成请求<a href=\"https://www.axios-http.cn/docs/intro\">https://www.axios-http.cn/docs/intro</a></p>\n<h2 id=\"Day02数据分析\"><a href=\"#Day02数据分析\" class=\"headerlink\" title=\"Day02数据分析\"></a><code>Day02</code>数据分析</h2><h3 id=\"获取多种不同的数据源\"><a href=\"#获取多种不同的数据源\" class=\"headerlink\" title=\"获取多种不同的数据源\"></a>获取多种不同的数据源</h3><pre><code>1. 获取文章（内部）\n</code></pre>\n<p>​    抓取网站的内容，例如抓取文章等。。。</p>\n<p>​    <strong>数据抓取的几种方式：</strong></p>\n<p>​        直接访问数据接口（最方便）</p>\n<p>​        等网页渲染完毕出明文，从前端内容进行抓取</p>\n<p>​        有一种网站是动态请求的，，不会一次加载，例如会用验证码来验证是否是真人（相对复杂，如何解决？后台通过程序控制浏览器，以代替人工继续验证等）selenium、nodejs、puppetter</p>\n<p>​        </p>\n<p>​        </p>\n<p>​    用户（内部）</p>\n<p>​    图片（外部，不是我们自己的项目）</p>\n<ol start=\"2\">\n<li>前后端接口联调，跑通整个页面（至此完全可以应付毕设）</li>\n<li>分析项目的问题，进一步优化，聚合接口的开发</li>\n<li>安装ES</li>\n</ol>\n<blockquote>\n<p>断更，待完成！！！</p>\n</blockquote>\n"},{"title":"仿哔哩哔哩项目","index_img":"https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202309120915505.png","excerpt":"基于Spring Boot从零到一搭建仿哔哩哔哩项目","abbrlink":45290,"date":"2022-12-23T12:23:01.000Z","_content":"### 从项目角度和技术角度两个维度来看：\n\n> 项目角度：规模大、不同种类的用户群体、高流量、个性化功能针对不同的用户；\n>\n> 技术角度：经典高并发与异步问题、视频流+弹幕定制化功能。\n\n### 项目大纲：（[课程链接](https://coding.imooc.com/class/556.html)）\n\n> 第一章：项目整体介绍、课程设计逻辑、学习方法\n>\n> 第二章：项目架构、环境搭建、效果展示\n>\n> 第三章：通用配置、用户相关功能\n>\n> 第四章：视频流+弹幕加载、性能优化\n>\n> 第五章：全局搜索、系统广播、数据统计、智能推荐\n>\n> 第六章：总结复盘、切面编程、自动化部署、负载均衡\n\n## 从搭建环境开始你的仿哔哩哔哩项目（初入江湖）\n\n### **项目架构：**\n\n基本过程：需求分析--》功能设计--》全局架构（承载、可复用）\n\n### **业务（功能架构）：**\n\n顶层：用户服务，如注册登录、大会员权限、查找感兴趣视频等\n\n中间层：在线视频播放设置、实施弹幕\n\n底层：管理后台，如：视频上传、数据统计、系统消息推送\n\n### **技术架构：**\n\n技术选型：`SpringBoot2.x`+ `Mysql` + `MyBatis` + `Maven`\n\n开发模式：项目采用经典`MVC`，模式控制层（`Controller层`）、服务层（`Service层`）、数据层（`Dao层`）\n\n### **部署架构:**\n\n前端：服务转发 + 负载均衡\n\n后端：业务处理 + 功能实现\n\n工具：缓存 + 队列\n\n### **开发环境：**\n\n`OS`：`Java`的跨平台，任意OS即可\n\n开发工具：`IntelliJ IDEA`，推荐版本2018及以后\n\n必备：`JDK1.8`、`Maven`\n\n### **创建多模块、多环境项目：**\n\n多模块：经典MVC\n\n多环境：添加不同的properties配置文件（测试、部署）\n\n配置好项目的JDK版本与Maven仓库\n\n### **项目运行:**\n\n在`pom.xml`文件中加入`SpringBoot`框架依赖:\n\n```xml\n<parent>\n    <artifactId>spring-boot-starter-parent</artifactId>\n    <groupId>org.springframework.boot</groupId>\n    <version>2.5.1</version>\n</parent>\n\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-web</artifactId>\n    <version>2.5.1</version>\n</dependency>\n```\n\n在子模块`pom.xml`文件中添加模块间依赖关系:\n\n```xml\n<!--配置模块间的依赖关系-->\n<dependency>\n    <groupId>org.example</groupId>\n    <artifactId>imooc-bilibili-dao</artifactId>\n    <version>1.0-SNAPSHOT</version>\n</dependency>\n```\n\n添加启动入口，启动项目：\n\n```java\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.context.ApplicationContext;\n\n/**\n * @author WLei224\n * @create 2023/4/28 21:34\n */\n@SpringBootApplication\npublic class ImoocBilibiliApp {\n    public static void main(String[] args) {\n        ApplicationContext app = SpringApplication.run(ImoocBilibiliApp.class, args);\n    }\n}\n```\n\n多环境配置：\n\n在Service包下创建一个`application.properties`配置文件:\n\n在Controller包下创建多个生产环境：`application-test.properties`、`application-online.properties`\n\n```properties\n#profiles可用于切换生产环境\nspring.profiles.active=test\n```\n\n### **数据库的搭建与持久层框架：**\n\n配置`MySQL`数据库:\n\n引入`MySQL`数据库和持久层`Mybatis`依赖：（`Mybatis`特点：XML形式管理，支持动态`sql`）\n\n```xml\n<dependency>\n    <groupId>mysql</groupId>\n    <artifactId>mysql-connector-java</artifactId>\n    <version>8.0.27</version>\n</dependency>\n<dependency>     \t\t     \n    <groupId>org.mybatis.spring.boot</groupId>\n    <artifactId>mybatis-spring-boot-starter</artifactId>\n    <version>2.2.0</version>\n</dependency>\n```\n\n将数据库连接写入`application.properties`配置文件：\n\n```properties\n#datasource\nspring.datasource.url=jdbc:mysql://localhost:3306/imooc_bilibili\nspring.datasource.username=root\nspring.datasource.password=root(你的密码)\nspring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver\n```\n\n将`Mybatis`配置写入可复用的`application.properties`配置文件中：\n\n```properties\n#mybatis\nmybatis.mapper-locations=classpath:mapper/*.xml\n#项目启动时，告诉SpringBoot扫描class、interface的路径，统一实例化，然后与mapper进行关联\nmybatis.type-aliases-package=com.imooc.bilibili.dao\n```\n\n**开发一个小Demo：**（在持久层`Dao`层进行）\n\n首先要将`mapper`与`dao`层实体类进行关联：(`Demo.xml`)\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD MAPPER 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\n<!--namespace对应着dao层Java实体类文件-->\n<mapper namespace=\"com.imooc.bilibili.dao.DemoDao\">\n\n    <select id=\"query\" parameterType=\"java.lang.Long\" resultType=\"java.lang.Long\">\n        select id from t_demo where id = #{id}\n    </select>\n\n</mapper>\n```\n\n`Controller:` \n\n```java\npackage com.imooc.bilibili.api;\nimport com.imooc.bilibili.service.DemoService;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.RestController;\n\n/**\n * @author WLei224\n * @create 2023/4/29 1:50\n */\n@RestController\npublic class DemoApi {\n\n    @Autowired\n    private DemoService demoService;\n\n\n    @GetMapping(\"/query\")\n    public Long query(Long id){\n        return demoService.query(id);\n    }\n\n}\n```\n\n`Service:`\n\n```java\npackage com.imooc.bilibili.service;\n\nimport com.imooc.bilibili.dao.DemoDao;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Service;\n\n/**\n * @author WLei224\n * @create 2023/4/29 1:33\n */\n@Service\npublic class DemoService {\n\n    @Autowired\n    private DemoDao demoDao;\n\n    public Long query(Long id){\n        return demoDao.query(id);\n    }\n}\n```\n\n`Dao:`\n\n```java\npackage com.imooc.bilibili.dao;\n\nimport org.apache.ibatis.annotations.Mapper;\n\n/**\n * @author WLei224\n * @create 2023/4/29 1:04\n */\n//如何将DemoDao与mapper对应起来呢？ 为什么声明成为接口呢?因为@mapper注解在启动时会自动匹配，把dao的文件封装成一个实体类，从而实现自动实例化的操作\n@Mapper\npublic interface DemoDao {\n    public Long query(Long id);\n}\n```\n\n### 效率提升：实现热部署：\n\n> 热部署：热部署就是当应用程序正在运行的时候升级软件或修改某一部分代码、配置文件时，无需手动重启应用，即可使修改的部分生效\n>\n> 配置方法：`spring-boot-devtools`依赖工具+IDEA配置\n\n1、`IDEA:`Files-->Settings-->Compiles-->Build Project Automately\n\n2、`IDEA注册表：Ctrl+Alt+Shift+/`打开`compiler document save enabled`和`compiler automake allow when app runing`\n\n3、编辑启动类的配置：![image-20230429132152997](http://images.rl0206.love/202304291326170.png)\n\n4、引入全局`pom.xml`依赖：\n\n```xml\n<!-- 热部署 -->\n<dependency>\n     <groupId>org.springframework.boot</groupId>\n     <artifactId>spring-boot-devtools</artifactId>\n     <version>2.0.4.RELEASE</version>\n     <!-- 启用 -->\n     <optional>true</optional>\n</dependency>\n```\n\n热部署已完成。\n## 3从用户功能体验后端经典开发模式（窥得门路）\n\n### 用户模块开发概要与接口设计\n\n> **`RESTful`风格接口设计：**\n>\n> RESTful架构、HTTP方法语义、HTTP方法幂等性、RESTful接口设计原则\n>\n> **用户模块开发概要：**通用功能与通用配置、用户相关功能\n\n### RESTful接口\n\n> REST全称是：Representational State Transfer，中文为表述性状态转移，REST指的是一组架构约束条件和原则\n>\n> RESTful表述的是资源的状态转移，在Web中资源就是URI(Uniform Resource Identifier)\n>\n> 如果一个架构符合REST的约束条件和原则，我们就称它为RESTful架构，HTTP是目前与REST相关的唯一实例\n>\n> RESTful架构应该遵循统一的接口原则，应该使用标准的HTTP方法，如GET和POST，并且遵循这些方法的语义\n\n### HTTP方法的语义\n\n![image-20230429164253420](http://images.rl0206.love/202304291643114.png)\n\n### POST和PUT的区别\n\n这两个概念非常容易混淆，POST通常被认为创建资源，PUT通常被认为更新资源，而实际上，二者均可用于创建资源，更为本质的差别实在幂等性方面。\n\n> 所谓幂等性，如果一个操作执行一次和执行多次的后果是一样的，那么这个操作就具有幂等性。\n>\n> 例如：GET获取多次，   无副作用，  具有幂等性\n>\n> ​\t DELETE删除多次，无副作用，  具有幂等性\n>\n> ​\t POST提交会创建不同的资源，  不具有幂等性（实例如下图）\n>\n> ​\t PUT是创建或更新，无副作用，  具有幂等性\n\n![image-20230429165143109](http://images.rl0206.love/202304291651182.png)\n\n`Demo：RESTfulApi:`\n\n```java\npackage com.imooc.bilibili.api;\n\nimport org.springframework.web.bind.annotation.*;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Map;\n/**\n * @author WLei224\n * @create 2023/4/30 11:01\n */\n@RestController\npublic class RESTfulApi {\n    private final Map<Integer,Map<String,Object>> dataMap;\n    // 声明一个构造方法，同时初始化datamap，进行传参\n    public RESTfulApi() {\n        dataMap = new HashMap<>();\n\n        for (int i = 1; i < 3; i++) {\n            Map<String,Object> data = new HashMap<>();\n            data.put(\"id\",i);\n            data.put(\"name\",\"name\"+i);\n            dataMap.put(i,data);\n        }\n    }\n    // 开始写RESTful的相关方法\n    @GetMapping(\"objects/{id}\")\n    public Map<String,Object> getData(@PathVariable Integer id){\n        return dataMap.get(id);\n    }\n\n    @DeleteMapping(\"objects/{id}\")\n    public String deleteData(@PathVariable Integer id){\n        dataMap.remove(id);\n        return \"Success\";\n    }\n\n    @PostMapping(\"objects\")\n    public String postData(@RequestBody Map<String,Object> data){\n        Integer[] idArray = dataMap.keySet().toArray(new Integer[0]);\n        Arrays.sort(idArray);\n        int nextId = idArray[idArray.length-1] + 1;\n        // data.put(\"id\",nextId);\n        // data.put(\"name\",\"name\" + nextId);\n        dataMap.put(nextId,data);\n        return \"Success!\";\n    }\n\t// 区别就在于幂等性，存在则更新，不存在则新增\n    @PutMapping(\"objects\")\n    public String putData(@RequestBody Map<String,Object> data){\n        Integer id = Integer.valueOf(String.valueOf(data.get(\"id\")));\n        Map<String,Object> hasData = dataMap.get(id);\n        if (hasData == null) {\n            Integer[] idArray = dataMap.keySet().toArray(new Integer[0]);\n            Arrays.sort(idArray);\n            int nextId = idArray[idArray.length-1] + 1;\n            // data.put(\"id\",nextId);\n            // data.put(\"name\",\"name\" + nextId);\n            dataMap.put(nextId,data);\n        } else {\n            dataMap.put(id,data);\n        }\n        return \"Success!\";\n    }\n}\n```\n\n### RESTful接口URL命名原则：\n\n> 1、HTTP方法后跟的URL必须是名词的复数形式\n>\n> 2、URL总不采用大小写混合的驼峰命名，尽量全部小写，如果涉及多个单词，可用”-“连接\n>\n> 3、示例：/users、/users-fans、 反例：/getUser、/getUserFans\n\n### RESTful接口URL分级原则\n\n> 1、一级用来定位资源分类，如：/users表示需要定位到用户相关资源\n>\n> 2、二级仍用来定位具体某个资源，如：/users/20/fans/1表示id为20的用户的id为1的粉丝\n\n### RESTful接口命名示例\n\n![image-20230430153315090](http://images.rl0206.love/202304301533812.png)\n\n![image-20230430153406940](http://images.rl0206.love/202304301534235.png)\n\n###  通用功能与配置\n\n#### **通用功能：**\n\n加解密工具（`AES`、`RSA`、`MD5`）、json数据返回类\n\n顶层POM.xml添加commons-codec依赖，\n\n添加对应的工具包到service包的util包下\n\n>  `什么是AES加密`\n\n`AES:`\n\n*Advanced Encryption Standard*高级加密标准，是最常见的对称加密算法，对称加密即加解密只有一个密钥，可使用密钥恢复明文，加密速度非常快。\n\n`使用场景：`\n\n适合发送大量数据的场合。\n\n`看下源码：`\n\n![image-20230519170635001](http://images.rl0206.love/202305191736417.png)\n\n> `什么是RSA加密？`\n\n`RSA:`\n\n是一种非对称加密，即：有公钥与私钥之分，公钥用于数据加密，私钥用于数据解密，同样是可逆的，即可以通过私钥进行解密。公钥提供给外部进行使用，私钥放在服务器，保护数据安全。\n\n`特点：`\n\n加密安全性很高，但是加密速度非常之慢。\n\n`使用场景：`\n\n由特点可知，加密慢，但是安全。因此适合对加密次数要求较少的场景。例如：用户的登陆，加密一次，便不用加密，而且安全性还较高。\n\n`拓展：非对称加密的流程是什么，在实际应用中是如何进行加密的？`\n\n下面以用户注册登录场景为例，来说一下非对称加密在实际中的应用：\n\n因为RSA加密中的公钥是提供给外部进行加密使用的，用户在前端注册登录时，为了保证输入的密码其安全性（防止拦截后密码泄露），将公钥返回到前端，前端使用公钥进行加密，加密后的暗文通过接口然后传给后端，后端再通过私钥进行解密，得到密码。\n\n`加解密源码：`\n\n```java\npublic static String encrypt(String source) throws Exception {\n\tbyte[] decoded = Base64.decodeBase64(PUBLIC_KEY);\n\tRSAPublicKey rsaPublicKey = (RSAPublicKey) KeyFactory.getInstance(\"RSA\")\n\t\t\t.generatePublic(new X509EncodedKeySpec(decoded));\n\tCipher cipher = Cipher.getInstance(\"RSA\");\n\tcipher.init(1, rsaPublicKey);\n\treturn Base64.encodeBase64String(cipher.doFinal(source.getBytes(StandardCharsets.UTF_8)));\n}\npublic static String decrypt(String text) throws Exception {\n\tCipher cipher = getCipher();\n\tbyte[] inputByte = Base64.decodeBase64(text.getBytes(StandardCharsets.UTF_8));\n\treturn new String(cipher.doFinal(inputByte));\n}\n```\n\n`最后说一下MD5加密：`\n\n`MD5：`\n\n非对称加密，即不可逆，无法看到加密前的明文。\n\n`特点：`\n\n加密速度快，无需密钥，但是安全性不高需要搭配随机盐值使用。随机盐就是一个随机数，防止黑客将加密后的MD5还原回去。\n\n#### **通用配置：**\n\n`Json信息转换配置 && 全局异常处理配置`\n\n> `JSON返回数据配置：`\n\n`什么是JSON？：JSON就是一种轻量化数据交换格式。`\n\n`为什么会用到JSON返回数据类和数据类转换呢？因为JSON轻量化，前端需要展示不同的数据格式时，这就需要用到JSON信息转换了。`\n\n如何新建JSON信息转换配置？\n\nService包下新建config包，用于放以后所有的配置类。\n\n此处涉及到Spring Boot相关的注解名，下面来说一下常见的注解：\n\n```txt\n@Configuration：标志着Java文件是一个配置类，经常搭配@Bean使用，表示向上下文注入实体类，使其生效；\n@Component：是@Configuration注解的内部注解，在Spring Boot启动阶段，自动的将Configuration\n对应的文件注入到Sping Boot上下文；\n@Bean：表示向上下文注入实体类，使其生效；\n```\n\n`HttpMessageConverters：`是一个对Http方法，接收请求，或做转换的一个工具类框架，返回的就是一个@Bean类型，因为此方法是一个JSON类型，所以要引入一个fastJson依赖（目前世界行公认效率最高的工具包）。\n\n```xml\n<dependency>\n\t<groupId>com.alibaba</groupId>\n\t<artifactId>fastjson</artifactId>\n\t<version>1.2.78</version>\n</dependency>\n```\n\n然后配置一些和fastjson相关的配置类。\n\n例如：配置相关的数据返回类型的时间格式、序列化的相关配置、\n\n```java\nfastJsonConfig.setSerializerFeatures(\n                // 格式化输出\n                SerializerFeature.PrettyFormat,\n                // 如果输出的数据是空的，那么系统会直接把这个数据去掉，不会在前端进行显示，这个配置项可以显示出一个空串\n                SerializerFeature.WriteNullStringAsEmpty,\n                // 功能同上，列表\n                SerializerFeature.WriteNullListAsEmpty,\n                // 同上，集合\n                SerializerFeature.WriteMapNullValue,\n                // 升序排列\n                SerializerFeature.MapSortField,\n                // 进制循环引用（防止循环引用后，输出多余的引用字符串） 非常有用的一个配置\n                SerializerFeature.DisableCircularReferenceDetect\n);\n```\n\n循环引用：\n\n![image-20230520144308894](http://images.rl0206.love/202305201545971.png)\n\n> `全局异常处理配置：`\n\n放在Service包下的handle包中，命名为全局异常处理类（`CommonGlobalExceptionHandler.class`）：\n\n```Java\npackage com.imooc.bilibili.service.handler;\n\nimport com.imooc.bilibili.dao.damain.JsonResponse;\nimport com.imooc.bilibili.dao.damain.exception.ConditionException;\nimport org.springframework.core.Ordered;\nimport org.springframework.core.annotation.Order;\nimport org.springframework.web.bind.annotation.ControllerAdvice;\nimport org.springframework.web.bind.annotation.ExceptionHandler;\nimport org.springframework.web.bind.annotation.ResponseBody;\n\nimport javax.servlet.http.HttpServletRequest;\n\n/**\n * @author WLei224\n * @create 2023/5/20 16:38\n */\n@ControllerAdvice\n@Order(Ordered.HIGHEST_PRECEDENCE) // 最高优先级\npublic class CommonGlobalExceptionHandler {\n\n    @ExceptionHandler(value = Exception.class)\n    @ResponseBody\n    public JsonResponse<String> commonExceptionHandler(HttpServletRequest request, Exception e){\n        String errorMsg = e.getMessage();\n        if(e instanceof ConditionException){\n            String errorCode = ((ConditionException) e).getCode();\n            return new JsonResponse<>(errorCode,errorMsg);\n        }else{\n            return new JsonResponse<>(\"500\",errorMsg);\n        }\n    }\n}\n```\n\n在此之前，我定义了一个条件异常，并添加了状态码等信息，然后这个类的代码功能就是，抓取条件异常信息，然后通过`json数据返回类型jsonResponse`返回异常信息。 \n\n### 用户注册与登录\n\n数据库库表设计：用户表、用户信息表\n\n```sql\nCREATE TABLE `t_user` (\n  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '主键',\n  `phone` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci DEFAULT NULL COMMENT '手机号',\n  `email` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci DEFAULT NULL COMMENT '邮箱',\n  `password` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci DEFAULT NULL COMMENT '密码',\n  `salt` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci DEFAULT NULL COMMENT '盐值',\n  `createTime` datetime DEFAULT NULL COMMENT '创建时间',\n  `updateTime` datetime DEFAULT NULL COMMENT '更新时间',\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB AUTO_INCREMENT=17 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci COMMENT='用户表';\n\nCREATE TABLE `t_user_info` (\n  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '主键',\n  `userId` bigint(20) DEFAULT NULL COMMENT '用户id',\n  `nick` varchar(100) DEFAULT NULL COMMENT '昵称',\n  `avatar` varchar(255) DEFAULT NULL COMMENT '头像',\n  `sign` text COMMENT '签名',\n  `gender` varchar(2) DEFAULT NULL COMMENT '性别：0男 1女 2未知',\n  `birth` varchar(20) DEFAULT NULL COMMENT '生日',\n  `createTime` datetime DEFAULT NULL COMMENT '创建时间',\n  `updateTime` datetime DEFAULT NULL COMMENT '更新时间',\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB AUTO_INCREMENT=10 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci COMMENT='用户基本信息表';\n```\n\n相关接口（API）：获取RSA公钥、用户注册、用户登录\n\n> 项目编写步骤：\n>\n> entity(domain)->dao（@Mapper交给MyBatis）->service(注入dao)->api(controller)注入service[先留一个bug]\n>\n> \n>\n> 项目整体的逻辑：\n>\n> 前端访问到我们的api接口层（也就是控制层）之后，会跳转到相关的业务逻辑层（service），在业务实现逻辑层中可能会用到与数据库之间的交互，那么service就会去访问dao层（数据持久层，放的是与数据库进行交互的接口），dao层通过@Mapper注解与MyBatis产生关联，通过MyBatis进行交互，交互的结果返回给service业务逻辑层，业务逻辑层返回给控制层接口，然后在前端体现了出来。\n>\n> 以上层层嵌套的架构，可以让代码更加清晰、优雅。\n\n🆗，通过以上步骤，实体类已经新建好了，下面进行相关接口的业务逻辑书写\n\n* 获取RSA公钥\n\n@GetMapping\n\n* 用户注册\n\n@PostMapping\n\n同样是按照接口的编写顺序来进行coding，在@Api中写接口，service中写实现，\n\n* 用户登录\n\n\n\n\n\n### 基于JWT的用户token验证\n\n`JWT`:`JSON Web Token`，`JWT`是一个规范，用于在空间受限环境下安全传递\"声明\"。\n\n**什么是声明呢？**\n\n声明分为三个部分：\n\n一、头部（header）\n\n​\t声明的类型、声明的加密算法（通常使用SHA256）\n\n二、载荷（payload）\n\n​\t用于存放有效信息的，一般包含签发者、所面向的用户、接受方、过期时间、签发时间以及唯一身份标识（userId）\n\n三、签名（signature）\n\n​\t主要由头部、载荷、以及密钥组成加密而成\n\nJWT的优点：\n\n跨语言支持（因为`JWT`使用的是`JSON`数据格式，所以多语言都支持）、便于传输（见定义：空间受限的环境之下，说明`JWT`是数据量很小的，因此便于传输）、易于扩展（因为`JWT`有`payload`的部分，因为数据的分类很多、定制化强，可以通过`payload`进行数据添加，所以易于扩展）\n\n\n\n说到session之前，先来说一下基于session的用户验证：\n\n* 基于session的用户身份验证\n* 验证过程：服务端验证浏览器携带的用户名和密码，验证通过后生成用户凭证保存在服务端（session），浏览器再次访问时，服务端查询session，实现登陆状态保持。\n* 缺点：随着用户的增多，服务端的压力增大；若浏览器的cookie被第三方或者攻击者拦截，容易受到跨站请求伪造攻击；分布式系统下扩展不强（多台服务器部署应用，用户在不同的服务器进行访问，因为session不会共享，所以不会进行自动登录）。\n\n说到session验证，再来说一下token验证：\n\n* 基于token的用户验证\n* 验证过程：服务器端验证浏览器携带的用户名和密码，验证通过后，生成用户令牌（token），不同于session的一点是，服务端不会保存token，而会返回给浏览器，浏览器接收到token之后，进而写在浏览器的localstory中，那么什么是local story呢？localstory不同于cookie，它可以保存在本地，大小也比cookie大很多，所以在请求时就可以不用把token放在cookie中请求服务器，可以放在请求头中或者body中，这样就可以降低跨站请求拦截的风险，最后服务端拿到token之后进行校验是否正确，正确就证明是合法用户。\n* 优点：token不存储在服务器，不会造成服务器的压力；token可以存储在非cookie中的（local story），安全性更高；分布式系统下扩展性较强（token生成之后返回前端，前端拿到之后在请求服务端，服务端再对token进行验证即可）。\n\n","source":"_posts/bilibili.md","raw":"---\ntitle: 仿哔哩哔哩项目\nindex_img: >-\n  https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202309120915505.png\ncategories:\n  - Project\ntags:\n  - SpringBoot\n  - Mysql\n  - MyBatis\n  - Maven\nexcerpt: 基于Spring Boot从零到一搭建仿哔哩哔哩项目\nabbrlink: 45290\ndate: 2022-12-23 20:23:01\n---\n### 从项目角度和技术角度两个维度来看：\n\n> 项目角度：规模大、不同种类的用户群体、高流量、个性化功能针对不同的用户；\n>\n> 技术角度：经典高并发与异步问题、视频流+弹幕定制化功能。\n\n### 项目大纲：（[课程链接](https://coding.imooc.com/class/556.html)）\n\n> 第一章：项目整体介绍、课程设计逻辑、学习方法\n>\n> 第二章：项目架构、环境搭建、效果展示\n>\n> 第三章：通用配置、用户相关功能\n>\n> 第四章：视频流+弹幕加载、性能优化\n>\n> 第五章：全局搜索、系统广播、数据统计、智能推荐\n>\n> 第六章：总结复盘、切面编程、自动化部署、负载均衡\n\n## 从搭建环境开始你的仿哔哩哔哩项目（初入江湖）\n\n### **项目架构：**\n\n基本过程：需求分析--》功能设计--》全局架构（承载、可复用）\n\n### **业务（功能架构）：**\n\n顶层：用户服务，如注册登录、大会员权限、查找感兴趣视频等\n\n中间层：在线视频播放设置、实施弹幕\n\n底层：管理后台，如：视频上传、数据统计、系统消息推送\n\n### **技术架构：**\n\n技术选型：`SpringBoot2.x`+ `Mysql` + `MyBatis` + `Maven`\n\n开发模式：项目采用经典`MVC`，模式控制层（`Controller层`）、服务层（`Service层`）、数据层（`Dao层`）\n\n### **部署架构:**\n\n前端：服务转发 + 负载均衡\n\n后端：业务处理 + 功能实现\n\n工具：缓存 + 队列\n\n### **开发环境：**\n\n`OS`：`Java`的跨平台，任意OS即可\n\n开发工具：`IntelliJ IDEA`，推荐版本2018及以后\n\n必备：`JDK1.8`、`Maven`\n\n### **创建多模块、多环境项目：**\n\n多模块：经典MVC\n\n多环境：添加不同的properties配置文件（测试、部署）\n\n配置好项目的JDK版本与Maven仓库\n\n### **项目运行:**\n\n在`pom.xml`文件中加入`SpringBoot`框架依赖:\n\n```xml\n<parent>\n    <artifactId>spring-boot-starter-parent</artifactId>\n    <groupId>org.springframework.boot</groupId>\n    <version>2.5.1</version>\n</parent>\n\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-web</artifactId>\n    <version>2.5.1</version>\n</dependency>\n```\n\n在子模块`pom.xml`文件中添加模块间依赖关系:\n\n```xml\n<!--配置模块间的依赖关系-->\n<dependency>\n    <groupId>org.example</groupId>\n    <artifactId>imooc-bilibili-dao</artifactId>\n    <version>1.0-SNAPSHOT</version>\n</dependency>\n```\n\n添加启动入口，启动项目：\n\n```java\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.context.ApplicationContext;\n\n/**\n * @author WLei224\n * @create 2023/4/28 21:34\n */\n@SpringBootApplication\npublic class ImoocBilibiliApp {\n    public static void main(String[] args) {\n        ApplicationContext app = SpringApplication.run(ImoocBilibiliApp.class, args);\n    }\n}\n```\n\n多环境配置：\n\n在Service包下创建一个`application.properties`配置文件:\n\n在Controller包下创建多个生产环境：`application-test.properties`、`application-online.properties`\n\n```properties\n#profiles可用于切换生产环境\nspring.profiles.active=test\n```\n\n### **数据库的搭建与持久层框架：**\n\n配置`MySQL`数据库:\n\n引入`MySQL`数据库和持久层`Mybatis`依赖：（`Mybatis`特点：XML形式管理，支持动态`sql`）\n\n```xml\n<dependency>\n    <groupId>mysql</groupId>\n    <artifactId>mysql-connector-java</artifactId>\n    <version>8.0.27</version>\n</dependency>\n<dependency>     \t\t     \n    <groupId>org.mybatis.spring.boot</groupId>\n    <artifactId>mybatis-spring-boot-starter</artifactId>\n    <version>2.2.0</version>\n</dependency>\n```\n\n将数据库连接写入`application.properties`配置文件：\n\n```properties\n#datasource\nspring.datasource.url=jdbc:mysql://localhost:3306/imooc_bilibili\nspring.datasource.username=root\nspring.datasource.password=root(你的密码)\nspring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver\n```\n\n将`Mybatis`配置写入可复用的`application.properties`配置文件中：\n\n```properties\n#mybatis\nmybatis.mapper-locations=classpath:mapper/*.xml\n#项目启动时，告诉SpringBoot扫描class、interface的路径，统一实例化，然后与mapper进行关联\nmybatis.type-aliases-package=com.imooc.bilibili.dao\n```\n\n**开发一个小Demo：**（在持久层`Dao`层进行）\n\n首先要将`mapper`与`dao`层实体类进行关联：(`Demo.xml`)\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD MAPPER 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\n<!--namespace对应着dao层Java实体类文件-->\n<mapper namespace=\"com.imooc.bilibili.dao.DemoDao\">\n\n    <select id=\"query\" parameterType=\"java.lang.Long\" resultType=\"java.lang.Long\">\n        select id from t_demo where id = #{id}\n    </select>\n\n</mapper>\n```\n\n`Controller:` \n\n```java\npackage com.imooc.bilibili.api;\nimport com.imooc.bilibili.service.DemoService;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.RestController;\n\n/**\n * @author WLei224\n * @create 2023/4/29 1:50\n */\n@RestController\npublic class DemoApi {\n\n    @Autowired\n    private DemoService demoService;\n\n\n    @GetMapping(\"/query\")\n    public Long query(Long id){\n        return demoService.query(id);\n    }\n\n}\n```\n\n`Service:`\n\n```java\npackage com.imooc.bilibili.service;\n\nimport com.imooc.bilibili.dao.DemoDao;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Service;\n\n/**\n * @author WLei224\n * @create 2023/4/29 1:33\n */\n@Service\npublic class DemoService {\n\n    @Autowired\n    private DemoDao demoDao;\n\n    public Long query(Long id){\n        return demoDao.query(id);\n    }\n}\n```\n\n`Dao:`\n\n```java\npackage com.imooc.bilibili.dao;\n\nimport org.apache.ibatis.annotations.Mapper;\n\n/**\n * @author WLei224\n * @create 2023/4/29 1:04\n */\n//如何将DemoDao与mapper对应起来呢？ 为什么声明成为接口呢?因为@mapper注解在启动时会自动匹配，把dao的文件封装成一个实体类，从而实现自动实例化的操作\n@Mapper\npublic interface DemoDao {\n    public Long query(Long id);\n}\n```\n\n### 效率提升：实现热部署：\n\n> 热部署：热部署就是当应用程序正在运行的时候升级软件或修改某一部分代码、配置文件时，无需手动重启应用，即可使修改的部分生效\n>\n> 配置方法：`spring-boot-devtools`依赖工具+IDEA配置\n\n1、`IDEA:`Files-->Settings-->Compiles-->Build Project Automately\n\n2、`IDEA注册表：Ctrl+Alt+Shift+/`打开`compiler document save enabled`和`compiler automake allow when app runing`\n\n3、编辑启动类的配置：![image-20230429132152997](http://images.rl0206.love/202304291326170.png)\n\n4、引入全局`pom.xml`依赖：\n\n```xml\n<!-- 热部署 -->\n<dependency>\n     <groupId>org.springframework.boot</groupId>\n     <artifactId>spring-boot-devtools</artifactId>\n     <version>2.0.4.RELEASE</version>\n     <!-- 启用 -->\n     <optional>true</optional>\n</dependency>\n```\n\n热部署已完成。\n## 3从用户功能体验后端经典开发模式（窥得门路）\n\n### 用户模块开发概要与接口设计\n\n> **`RESTful`风格接口设计：**\n>\n> RESTful架构、HTTP方法语义、HTTP方法幂等性、RESTful接口设计原则\n>\n> **用户模块开发概要：**通用功能与通用配置、用户相关功能\n\n### RESTful接口\n\n> REST全称是：Representational State Transfer，中文为表述性状态转移，REST指的是一组架构约束条件和原则\n>\n> RESTful表述的是资源的状态转移，在Web中资源就是URI(Uniform Resource Identifier)\n>\n> 如果一个架构符合REST的约束条件和原则，我们就称它为RESTful架构，HTTP是目前与REST相关的唯一实例\n>\n> RESTful架构应该遵循统一的接口原则，应该使用标准的HTTP方法，如GET和POST，并且遵循这些方法的语义\n\n### HTTP方法的语义\n\n![image-20230429164253420](http://images.rl0206.love/202304291643114.png)\n\n### POST和PUT的区别\n\n这两个概念非常容易混淆，POST通常被认为创建资源，PUT通常被认为更新资源，而实际上，二者均可用于创建资源，更为本质的差别实在幂等性方面。\n\n> 所谓幂等性，如果一个操作执行一次和执行多次的后果是一样的，那么这个操作就具有幂等性。\n>\n> 例如：GET获取多次，   无副作用，  具有幂等性\n>\n> ​\t DELETE删除多次，无副作用，  具有幂等性\n>\n> ​\t POST提交会创建不同的资源，  不具有幂等性（实例如下图）\n>\n> ​\t PUT是创建或更新，无副作用，  具有幂等性\n\n![image-20230429165143109](http://images.rl0206.love/202304291651182.png)\n\n`Demo：RESTfulApi:`\n\n```java\npackage com.imooc.bilibili.api;\n\nimport org.springframework.web.bind.annotation.*;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Map;\n/**\n * @author WLei224\n * @create 2023/4/30 11:01\n */\n@RestController\npublic class RESTfulApi {\n    private final Map<Integer,Map<String,Object>> dataMap;\n    // 声明一个构造方法，同时初始化datamap，进行传参\n    public RESTfulApi() {\n        dataMap = new HashMap<>();\n\n        for (int i = 1; i < 3; i++) {\n            Map<String,Object> data = new HashMap<>();\n            data.put(\"id\",i);\n            data.put(\"name\",\"name\"+i);\n            dataMap.put(i,data);\n        }\n    }\n    // 开始写RESTful的相关方法\n    @GetMapping(\"objects/{id}\")\n    public Map<String,Object> getData(@PathVariable Integer id){\n        return dataMap.get(id);\n    }\n\n    @DeleteMapping(\"objects/{id}\")\n    public String deleteData(@PathVariable Integer id){\n        dataMap.remove(id);\n        return \"Success\";\n    }\n\n    @PostMapping(\"objects\")\n    public String postData(@RequestBody Map<String,Object> data){\n        Integer[] idArray = dataMap.keySet().toArray(new Integer[0]);\n        Arrays.sort(idArray);\n        int nextId = idArray[idArray.length-1] + 1;\n        // data.put(\"id\",nextId);\n        // data.put(\"name\",\"name\" + nextId);\n        dataMap.put(nextId,data);\n        return \"Success!\";\n    }\n\t// 区别就在于幂等性，存在则更新，不存在则新增\n    @PutMapping(\"objects\")\n    public String putData(@RequestBody Map<String,Object> data){\n        Integer id = Integer.valueOf(String.valueOf(data.get(\"id\")));\n        Map<String,Object> hasData = dataMap.get(id);\n        if (hasData == null) {\n            Integer[] idArray = dataMap.keySet().toArray(new Integer[0]);\n            Arrays.sort(idArray);\n            int nextId = idArray[idArray.length-1] + 1;\n            // data.put(\"id\",nextId);\n            // data.put(\"name\",\"name\" + nextId);\n            dataMap.put(nextId,data);\n        } else {\n            dataMap.put(id,data);\n        }\n        return \"Success!\";\n    }\n}\n```\n\n### RESTful接口URL命名原则：\n\n> 1、HTTP方法后跟的URL必须是名词的复数形式\n>\n> 2、URL总不采用大小写混合的驼峰命名，尽量全部小写，如果涉及多个单词，可用”-“连接\n>\n> 3、示例：/users、/users-fans、 反例：/getUser、/getUserFans\n\n### RESTful接口URL分级原则\n\n> 1、一级用来定位资源分类，如：/users表示需要定位到用户相关资源\n>\n> 2、二级仍用来定位具体某个资源，如：/users/20/fans/1表示id为20的用户的id为1的粉丝\n\n### RESTful接口命名示例\n\n![image-20230430153315090](http://images.rl0206.love/202304301533812.png)\n\n![image-20230430153406940](http://images.rl0206.love/202304301534235.png)\n\n###  通用功能与配置\n\n#### **通用功能：**\n\n加解密工具（`AES`、`RSA`、`MD5`）、json数据返回类\n\n顶层POM.xml添加commons-codec依赖，\n\n添加对应的工具包到service包的util包下\n\n>  `什么是AES加密`\n\n`AES:`\n\n*Advanced Encryption Standard*高级加密标准，是最常见的对称加密算法，对称加密即加解密只有一个密钥，可使用密钥恢复明文，加密速度非常快。\n\n`使用场景：`\n\n适合发送大量数据的场合。\n\n`看下源码：`\n\n![image-20230519170635001](http://images.rl0206.love/202305191736417.png)\n\n> `什么是RSA加密？`\n\n`RSA:`\n\n是一种非对称加密，即：有公钥与私钥之分，公钥用于数据加密，私钥用于数据解密，同样是可逆的，即可以通过私钥进行解密。公钥提供给外部进行使用，私钥放在服务器，保护数据安全。\n\n`特点：`\n\n加密安全性很高，但是加密速度非常之慢。\n\n`使用场景：`\n\n由特点可知，加密慢，但是安全。因此适合对加密次数要求较少的场景。例如：用户的登陆，加密一次，便不用加密，而且安全性还较高。\n\n`拓展：非对称加密的流程是什么，在实际应用中是如何进行加密的？`\n\n下面以用户注册登录场景为例，来说一下非对称加密在实际中的应用：\n\n因为RSA加密中的公钥是提供给外部进行加密使用的，用户在前端注册登录时，为了保证输入的密码其安全性（防止拦截后密码泄露），将公钥返回到前端，前端使用公钥进行加密，加密后的暗文通过接口然后传给后端，后端再通过私钥进行解密，得到密码。\n\n`加解密源码：`\n\n```java\npublic static String encrypt(String source) throws Exception {\n\tbyte[] decoded = Base64.decodeBase64(PUBLIC_KEY);\n\tRSAPublicKey rsaPublicKey = (RSAPublicKey) KeyFactory.getInstance(\"RSA\")\n\t\t\t.generatePublic(new X509EncodedKeySpec(decoded));\n\tCipher cipher = Cipher.getInstance(\"RSA\");\n\tcipher.init(1, rsaPublicKey);\n\treturn Base64.encodeBase64String(cipher.doFinal(source.getBytes(StandardCharsets.UTF_8)));\n}\npublic static String decrypt(String text) throws Exception {\n\tCipher cipher = getCipher();\n\tbyte[] inputByte = Base64.decodeBase64(text.getBytes(StandardCharsets.UTF_8));\n\treturn new String(cipher.doFinal(inputByte));\n}\n```\n\n`最后说一下MD5加密：`\n\n`MD5：`\n\n非对称加密，即不可逆，无法看到加密前的明文。\n\n`特点：`\n\n加密速度快，无需密钥，但是安全性不高需要搭配随机盐值使用。随机盐就是一个随机数，防止黑客将加密后的MD5还原回去。\n\n#### **通用配置：**\n\n`Json信息转换配置 && 全局异常处理配置`\n\n> `JSON返回数据配置：`\n\n`什么是JSON？：JSON就是一种轻量化数据交换格式。`\n\n`为什么会用到JSON返回数据类和数据类转换呢？因为JSON轻量化，前端需要展示不同的数据格式时，这就需要用到JSON信息转换了。`\n\n如何新建JSON信息转换配置？\n\nService包下新建config包，用于放以后所有的配置类。\n\n此处涉及到Spring Boot相关的注解名，下面来说一下常见的注解：\n\n```txt\n@Configuration：标志着Java文件是一个配置类，经常搭配@Bean使用，表示向上下文注入实体类，使其生效；\n@Component：是@Configuration注解的内部注解，在Spring Boot启动阶段，自动的将Configuration\n对应的文件注入到Sping Boot上下文；\n@Bean：表示向上下文注入实体类，使其生效；\n```\n\n`HttpMessageConverters：`是一个对Http方法，接收请求，或做转换的一个工具类框架，返回的就是一个@Bean类型，因为此方法是一个JSON类型，所以要引入一个fastJson依赖（目前世界行公认效率最高的工具包）。\n\n```xml\n<dependency>\n\t<groupId>com.alibaba</groupId>\n\t<artifactId>fastjson</artifactId>\n\t<version>1.2.78</version>\n</dependency>\n```\n\n然后配置一些和fastjson相关的配置类。\n\n例如：配置相关的数据返回类型的时间格式、序列化的相关配置、\n\n```java\nfastJsonConfig.setSerializerFeatures(\n                // 格式化输出\n                SerializerFeature.PrettyFormat,\n                // 如果输出的数据是空的，那么系统会直接把这个数据去掉，不会在前端进行显示，这个配置项可以显示出一个空串\n                SerializerFeature.WriteNullStringAsEmpty,\n                // 功能同上，列表\n                SerializerFeature.WriteNullListAsEmpty,\n                // 同上，集合\n                SerializerFeature.WriteMapNullValue,\n                // 升序排列\n                SerializerFeature.MapSortField,\n                // 进制循环引用（防止循环引用后，输出多余的引用字符串） 非常有用的一个配置\n                SerializerFeature.DisableCircularReferenceDetect\n);\n```\n\n循环引用：\n\n![image-20230520144308894](http://images.rl0206.love/202305201545971.png)\n\n> `全局异常处理配置：`\n\n放在Service包下的handle包中，命名为全局异常处理类（`CommonGlobalExceptionHandler.class`）：\n\n```Java\npackage com.imooc.bilibili.service.handler;\n\nimport com.imooc.bilibili.dao.damain.JsonResponse;\nimport com.imooc.bilibili.dao.damain.exception.ConditionException;\nimport org.springframework.core.Ordered;\nimport org.springframework.core.annotation.Order;\nimport org.springframework.web.bind.annotation.ControllerAdvice;\nimport org.springframework.web.bind.annotation.ExceptionHandler;\nimport org.springframework.web.bind.annotation.ResponseBody;\n\nimport javax.servlet.http.HttpServletRequest;\n\n/**\n * @author WLei224\n * @create 2023/5/20 16:38\n */\n@ControllerAdvice\n@Order(Ordered.HIGHEST_PRECEDENCE) // 最高优先级\npublic class CommonGlobalExceptionHandler {\n\n    @ExceptionHandler(value = Exception.class)\n    @ResponseBody\n    public JsonResponse<String> commonExceptionHandler(HttpServletRequest request, Exception e){\n        String errorMsg = e.getMessage();\n        if(e instanceof ConditionException){\n            String errorCode = ((ConditionException) e).getCode();\n            return new JsonResponse<>(errorCode,errorMsg);\n        }else{\n            return new JsonResponse<>(\"500\",errorMsg);\n        }\n    }\n}\n```\n\n在此之前，我定义了一个条件异常，并添加了状态码等信息，然后这个类的代码功能就是，抓取条件异常信息，然后通过`json数据返回类型jsonResponse`返回异常信息。 \n\n### 用户注册与登录\n\n数据库库表设计：用户表、用户信息表\n\n```sql\nCREATE TABLE `t_user` (\n  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '主键',\n  `phone` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci DEFAULT NULL COMMENT '手机号',\n  `email` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci DEFAULT NULL COMMENT '邮箱',\n  `password` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci DEFAULT NULL COMMENT '密码',\n  `salt` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci DEFAULT NULL COMMENT '盐值',\n  `createTime` datetime DEFAULT NULL COMMENT '创建时间',\n  `updateTime` datetime DEFAULT NULL COMMENT '更新时间',\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB AUTO_INCREMENT=17 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci COMMENT='用户表';\n\nCREATE TABLE `t_user_info` (\n  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '主键',\n  `userId` bigint(20) DEFAULT NULL COMMENT '用户id',\n  `nick` varchar(100) DEFAULT NULL COMMENT '昵称',\n  `avatar` varchar(255) DEFAULT NULL COMMENT '头像',\n  `sign` text COMMENT '签名',\n  `gender` varchar(2) DEFAULT NULL COMMENT '性别：0男 1女 2未知',\n  `birth` varchar(20) DEFAULT NULL COMMENT '生日',\n  `createTime` datetime DEFAULT NULL COMMENT '创建时间',\n  `updateTime` datetime DEFAULT NULL COMMENT '更新时间',\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB AUTO_INCREMENT=10 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci COMMENT='用户基本信息表';\n```\n\n相关接口（API）：获取RSA公钥、用户注册、用户登录\n\n> 项目编写步骤：\n>\n> entity(domain)->dao（@Mapper交给MyBatis）->service(注入dao)->api(controller)注入service[先留一个bug]\n>\n> \n>\n> 项目整体的逻辑：\n>\n> 前端访问到我们的api接口层（也就是控制层）之后，会跳转到相关的业务逻辑层（service），在业务实现逻辑层中可能会用到与数据库之间的交互，那么service就会去访问dao层（数据持久层，放的是与数据库进行交互的接口），dao层通过@Mapper注解与MyBatis产生关联，通过MyBatis进行交互，交互的结果返回给service业务逻辑层，业务逻辑层返回给控制层接口，然后在前端体现了出来。\n>\n> 以上层层嵌套的架构，可以让代码更加清晰、优雅。\n\n🆗，通过以上步骤，实体类已经新建好了，下面进行相关接口的业务逻辑书写\n\n* 获取RSA公钥\n\n@GetMapping\n\n* 用户注册\n\n@PostMapping\n\n同样是按照接口的编写顺序来进行coding，在@Api中写接口，service中写实现，\n\n* 用户登录\n\n\n\n\n\n### 基于JWT的用户token验证\n\n`JWT`:`JSON Web Token`，`JWT`是一个规范，用于在空间受限环境下安全传递\"声明\"。\n\n**什么是声明呢？**\n\n声明分为三个部分：\n\n一、头部（header）\n\n​\t声明的类型、声明的加密算法（通常使用SHA256）\n\n二、载荷（payload）\n\n​\t用于存放有效信息的，一般包含签发者、所面向的用户、接受方、过期时间、签发时间以及唯一身份标识（userId）\n\n三、签名（signature）\n\n​\t主要由头部、载荷、以及密钥组成加密而成\n\nJWT的优点：\n\n跨语言支持（因为`JWT`使用的是`JSON`数据格式，所以多语言都支持）、便于传输（见定义：空间受限的环境之下，说明`JWT`是数据量很小的，因此便于传输）、易于扩展（因为`JWT`有`payload`的部分，因为数据的分类很多、定制化强，可以通过`payload`进行数据添加，所以易于扩展）\n\n\n\n说到session之前，先来说一下基于session的用户验证：\n\n* 基于session的用户身份验证\n* 验证过程：服务端验证浏览器携带的用户名和密码，验证通过后生成用户凭证保存在服务端（session），浏览器再次访问时，服务端查询session，实现登陆状态保持。\n* 缺点：随着用户的增多，服务端的压力增大；若浏览器的cookie被第三方或者攻击者拦截，容易受到跨站请求伪造攻击；分布式系统下扩展不强（多台服务器部署应用，用户在不同的服务器进行访问，因为session不会共享，所以不会进行自动登录）。\n\n说到session验证，再来说一下token验证：\n\n* 基于token的用户验证\n* 验证过程：服务器端验证浏览器携带的用户名和密码，验证通过后，生成用户令牌（token），不同于session的一点是，服务端不会保存token，而会返回给浏览器，浏览器接收到token之后，进而写在浏览器的localstory中，那么什么是local story呢？localstory不同于cookie，它可以保存在本地，大小也比cookie大很多，所以在请求时就可以不用把token放在cookie中请求服务器，可以放在请求头中或者body中，这样就可以降低跨站请求拦截的风险，最后服务端拿到token之后进行校验是否正确，正确就证明是合法用户。\n* 优点：token不存储在服务器，不会造成服务器的压力；token可以存储在非cookie中的（local story），安全性更高；分布式系统下扩展性较强（token生成之后返回前端，前端拿到之后在请求服务端，服务端再对token进行验证即可）。\n\n","slug":"bilibili","published":1,"updated":"2023-11-26T03:39:37.259Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clpkicziz001lfkfo3tjjgjz8","content":"<h3 id=\"从项目角度和技术角度两个维度来看：\"><a href=\"#从项目角度和技术角度两个维度来看：\" class=\"headerlink\" title=\"从项目角度和技术角度两个维度来看：\"></a>从项目角度和技术角度两个维度来看：</h3><blockquote>\n<p>项目角度：规模大、不同种类的用户群体、高流量、个性化功能针对不同的用户；</p>\n<p>技术角度：经典高并发与异步问题、视频流+弹幕定制化功能。</p>\n</blockquote>\n<h3 id=\"项目大纲：（课程链接）\"><a href=\"#项目大纲：（课程链接）\" class=\"headerlink\" title=\"项目大纲：（课程链接）\"></a>项目大纲：（<a href=\"https://coding.imooc.com/class/556.html\">课程链接</a>）</h3><blockquote>\n<p>第一章：项目整体介绍、课程设计逻辑、学习方法</p>\n<p>第二章：项目架构、环境搭建、效果展示</p>\n<p>第三章：通用配置、用户相关功能</p>\n<p>第四章：视频流+弹幕加载、性能优化</p>\n<p>第五章：全局搜索、系统广播、数据统计、智能推荐</p>\n<p>第六章：总结复盘、切面编程、自动化部署、负载均衡</p>\n</blockquote>\n<h2 id=\"从搭建环境开始你的仿哔哩哔哩项目（初入江湖）\"><a href=\"#从搭建环境开始你的仿哔哩哔哩项目（初入江湖）\" class=\"headerlink\" title=\"从搭建环境开始你的仿哔哩哔哩项目（初入江湖）\"></a>从搭建环境开始你的仿哔哩哔哩项目（初入江湖）</h2><h3 id=\"项目架构：\"><a href=\"#项目架构：\" class=\"headerlink\" title=\"项目架构：\"></a><strong>项目架构：</strong></h3><p>基本过程：需求分析–》功能设计–》全局架构（承载、可复用）</p>\n<h3 id=\"业务（功能架构）：\"><a href=\"#业务（功能架构）：\" class=\"headerlink\" title=\"业务（功能架构）：\"></a><strong>业务（功能架构）：</strong></h3><p>顶层：用户服务，如注册登录、大会员权限、查找感兴趣视频等</p>\n<p>中间层：在线视频播放设置、实施弹幕</p>\n<p>底层：管理后台，如：视频上传、数据统计、系统消息推送</p>\n<h3 id=\"技术架构：\"><a href=\"#技术架构：\" class=\"headerlink\" title=\"技术架构：\"></a><strong>技术架构：</strong></h3><p>技术选型：<code>SpringBoot2.x</code>+ <code>Mysql</code> + <code>MyBatis</code> + <code>Maven</code></p>\n<p>开发模式：项目采用经典<code>MVC</code>，模式控制层（<code>Controller层</code>）、服务层（<code>Service层</code>）、数据层（<code>Dao层</code>）</p>\n<h3 id=\"部署架构\"><a href=\"#部署架构\" class=\"headerlink\" title=\"部署架构:\"></a><strong>部署架构:</strong></h3><p>前端：服务转发 + 负载均衡</p>\n<p>后端：业务处理 + 功能实现</p>\n<p>工具：缓存 + 队列</p>\n<h3 id=\"开发环境：\"><a href=\"#开发环境：\" class=\"headerlink\" title=\"开发环境：\"></a><strong>开发环境：</strong></h3><p><code>OS</code>：<code>Java</code>的跨平台，任意OS即可</p>\n<p>开发工具：<code>IntelliJ IDEA</code>，推荐版本2018及以后</p>\n<p>必备：<code>JDK1.8</code>、<code>Maven</code></p>\n<h3 id=\"创建多模块、多环境项目：\"><a href=\"#创建多模块、多环境项目：\" class=\"headerlink\" title=\"创建多模块、多环境项目：\"></a><strong>创建多模块、多环境项目：</strong></h3><p>多模块：经典MVC</p>\n<p>多环境：添加不同的properties配置文件（测试、部署）</p>\n<p>配置好项目的JDK版本与Maven仓库</p>\n<h3 id=\"项目运行\"><a href=\"#项目运行\" class=\"headerlink\" title=\"项目运行:\"></a><strong>项目运行:</strong></h3><p>在<code>pom.xml</code>文件中加入<code>SpringBoot</code>框架依赖:</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">parent</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>spring-boot-starter-parent<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>2.5.1<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">parent</span>&gt;</span><br><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>spring-boot-starter-web<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>2.5.1<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<p>在子模块<code>pom.xml</code>文件中添加模块间依赖关系:</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs xml\"><span class=\"hljs-comment\">&lt;!--配置模块间的依赖关系--&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.example<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>imooc-bilibili-dao<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>1.0-SNAPSHOT<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<p>添加启动入口，启动项目：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">import</span> org.springframework.boot.SpringApplication;<br><span class=\"hljs-keyword\">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;<br><span class=\"hljs-keyword\">import</span> org.springframework.context.ApplicationContext;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * <span class=\"hljs-doctag\">@author</span> WLei224</span><br><span class=\"hljs-comment\"> * <span class=\"hljs-doctag\">@create</span> 2023/4/28 21:34</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-meta\">@SpringBootApplication</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ImoocBilibiliApp</span> &#123;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> &#123;<br>        <span class=\"hljs-type\">ApplicationContext</span> <span class=\"hljs-variable\">app</span> <span class=\"hljs-operator\">=</span> SpringApplication.run(ImoocBilibiliApp.class, args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>多环境配置：</p>\n<p>在Service包下创建一个<code>application.properties</code>配置文件:</p>\n<p>在Controller包下创建多个生产环境：<code>application-test.properties</code>、<code>application-online.properties</code></p>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs properties\"><span class=\"hljs-comment\">#profiles可用于切换生产环境</span><br><span class=\"hljs-attr\">spring.profiles.active</span>=<span class=\"hljs-string\">test</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"数据库的搭建与持久层框架：\"><a href=\"#数据库的搭建与持久层框架：\" class=\"headerlink\" title=\"数据库的搭建与持久层框架：\"></a><strong>数据库的搭建与持久层框架：</strong></h3><p>配置<code>MySQL</code>数据库:</p>\n<p>引入<code>MySQL</code>数据库和持久层<code>Mybatis</code>依赖：（<code>Mybatis</code>特点：XML形式管理，支持动态<code>sql</code>）</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>mysql<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>mysql-connector-java<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>8.0.27<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>     \t\t     <br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.mybatis.spring.boot<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>2.2.0<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<p>将数据库连接写入<code>application.properties</code>配置文件：</p>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs properties\"><span class=\"hljs-comment\">#datasource</span><br><span class=\"hljs-attr\">spring.datasource.url</span>=<span class=\"hljs-string\">jdbc:mysql://localhost:3306/imooc_bilibili</span><br><span class=\"hljs-attr\">spring.datasource.username</span>=<span class=\"hljs-string\">root</span><br><span class=\"hljs-attr\">spring.datasource.password</span>=<span class=\"hljs-string\">root(你的密码)</span><br><span class=\"hljs-attr\">spring.datasource.driver-class-name</span>=<span class=\"hljs-string\">com.mysql.cj.jdbc.Driver</span><br></code></pre></td></tr></table></figure>\n\n<p>将<code>Mybatis</code>配置写入可复用的<code>application.properties</code>配置文件中：</p>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs properties\"><span class=\"hljs-comment\">#mybatis</span><br><span class=\"hljs-attr\">mybatis.mapper-locations</span>=<span class=\"hljs-string\">classpath:mapper/*.xml</span><br><span class=\"hljs-comment\">#项目启动时，告诉SpringBoot扫描class、interface的路径，统一实例化，然后与mapper进行关联</span><br><span class=\"hljs-attr\">mybatis.type-aliases-package</span>=<span class=\"hljs-string\">com.imooc.bilibili.dao</span><br></code></pre></td></tr></table></figure>\n\n<p><strong>开发一个小Demo：</strong>（在持久层<code>Dao</code>层进行）</p>\n<p>首先要将<code>mapper</code>与<code>dao</code>层实体类进行关联：(<code>Demo.xml</code>)</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs xml\"><span class=\"hljs-meta\">&lt;?xml version=<span class=\"hljs-string\">&quot;1.0&quot;</span> encoding=<span class=\"hljs-string\">&quot;UTF-8&quot;</span> ?&gt;</span><br><span class=\"hljs-meta\">&lt;!DOCTYPE <span class=\"hljs-keyword\">mapper</span> <span class=\"hljs-keyword\">PUBLIC</span> <span class=\"hljs-string\">&quot;-//mybatis.org//DTD MAPPER 3.0//EN&quot;</span></span><br><span class=\"hljs-meta\">        <span class=\"hljs-string\">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span><br><span class=\"hljs-comment\">&lt;!--namespace对应着dao层Java实体类文件--&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">mapper</span> <span class=\"hljs-attr\">namespace</span>=<span class=\"hljs-string\">&quot;com.imooc.bilibili.dao.DemoDao&quot;</span>&gt;</span><br><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">select</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;query&quot;</span> <span class=\"hljs-attr\">parameterType</span>=<span class=\"hljs-string\">&quot;java.lang.Long&quot;</span> <span class=\"hljs-attr\">resultType</span>=<span class=\"hljs-string\">&quot;java.lang.Long&quot;</span>&gt;</span><br>        select id from t_demo where id = #&#123;id&#125;<br>    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">select</span>&gt;</span><br><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">mapper</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<p><code>Controller:</code> </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">package</span> com.imooc.bilibili.api;<br><span class=\"hljs-keyword\">import</span> com.imooc.bilibili.service.DemoService;<br><span class=\"hljs-keyword\">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class=\"hljs-keyword\">import</span> org.springframework.web.bind.annotation.GetMapping;<br><span class=\"hljs-keyword\">import</span> org.springframework.web.bind.annotation.RestController;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * <span class=\"hljs-doctag\">@author</span> WLei224</span><br><span class=\"hljs-comment\"> * <span class=\"hljs-doctag\">@create</span> 2023/4/29 1:50</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-meta\">@RestController</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">DemoApi</span> &#123;<br><br>    <span class=\"hljs-meta\">@Autowired</span><br>    <span class=\"hljs-keyword\">private</span> DemoService demoService;<br><br><br>    <span class=\"hljs-meta\">@GetMapping(&quot;/query&quot;)</span><br>    <span class=\"hljs-keyword\">public</span> Long <span class=\"hljs-title function_\">query</span><span class=\"hljs-params\">(Long id)</span>&#123;<br>        <span class=\"hljs-keyword\">return</span> demoService.query(id);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><code>Service:</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">package</span> com.imooc.bilibili.service;<br><br><span class=\"hljs-keyword\">import</span> com.imooc.bilibili.dao.DemoDao;<br><span class=\"hljs-keyword\">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class=\"hljs-keyword\">import</span> org.springframework.stereotype.Service;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * <span class=\"hljs-doctag\">@author</span> WLei224</span><br><span class=\"hljs-comment\"> * <span class=\"hljs-doctag\">@create</span> 2023/4/29 1:33</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-meta\">@Service</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">DemoService</span> &#123;<br><br>    <span class=\"hljs-meta\">@Autowired</span><br>    <span class=\"hljs-keyword\">private</span> DemoDao demoDao;<br><br>    <span class=\"hljs-keyword\">public</span> Long <span class=\"hljs-title function_\">query</span><span class=\"hljs-params\">(Long id)</span>&#123;<br>        <span class=\"hljs-keyword\">return</span> demoDao.query(id);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><code>Dao:</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">package</span> com.imooc.bilibili.dao;<br><br><span class=\"hljs-keyword\">import</span> org.apache.ibatis.annotations.Mapper;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * <span class=\"hljs-doctag\">@author</span> WLei224</span><br><span class=\"hljs-comment\"> * <span class=\"hljs-doctag\">@create</span> 2023/4/29 1:04</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-comment\">//如何将DemoDao与mapper对应起来呢？ 为什么声明成为接口呢?因为@mapper注解在启动时会自动匹配，把dao的文件封装成一个实体类，从而实现自动实例化的操作</span><br><span class=\"hljs-meta\">@Mapper</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">DemoDao</span> &#123;<br>    <span class=\"hljs-keyword\">public</span> Long <span class=\"hljs-title function_\">query</span><span class=\"hljs-params\">(Long id)</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"效率提升：实现热部署：\"><a href=\"#效率提升：实现热部署：\" class=\"headerlink\" title=\"效率提升：实现热部署：\"></a>效率提升：实现热部署：</h3><blockquote>\n<p>热部署：热部署就是当应用程序正在运行的时候升级软件或修改某一部分代码、配置文件时，无需手动重启应用，即可使修改的部分生效</p>\n<p>配置方法：<code>spring-boot-devtools</code>依赖工具+IDEA配置</p>\n</blockquote>\n<p>1、<code>IDEA:</code>Files–&gt;Settings–&gt;Compiles–&gt;Build Project Automately</p>\n<p>2、<code>IDEA注册表：Ctrl+Alt+Shift+/</code>打开<code>compiler document save enabled</code>和<code>compiler automake allow when app runing</code></p>\n<p>3、编辑启动类的配置：<img src=\"http://images.rl0206.love/202304291326170.png\" alt=\"image-20230429132152997\"></p>\n<p>4、引入全局<code>pom.xml</code>依赖：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs xml\"><span class=\"hljs-comment\">&lt;!-- 热部署 --&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span><br>     <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span><br>     <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>spring-boot-devtools<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span><br>     <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>2.0.4.RELEASE<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span><br>     <span class=\"hljs-comment\">&lt;!-- 启用 --&gt;</span><br>     <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">optional</span>&gt;</span>true<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">optional</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<p>热部署已完成。</p>\n<h2 id=\"3从用户功能体验后端经典开发模式（窥得门路）\"><a href=\"#3从用户功能体验后端经典开发模式（窥得门路）\" class=\"headerlink\" title=\"3从用户功能体验后端经典开发模式（窥得门路）\"></a>3从用户功能体验后端经典开发模式（窥得门路）</h2><h3 id=\"用户模块开发概要与接口设计\"><a href=\"#用户模块开发概要与接口设计\" class=\"headerlink\" title=\"用户模块开发概要与接口设计\"></a>用户模块开发概要与接口设计</h3><blockquote>\n<p><strong><code>RESTful</code>风格接口设计：</strong></p>\n<p>RESTful架构、HTTP方法语义、HTTP方法幂等性、RESTful接口设计原则</p>\n<p><strong>用户模块开发概要：</strong>通用功能与通用配置、用户相关功能</p>\n</blockquote>\n<h3 id=\"RESTful接口\"><a href=\"#RESTful接口\" class=\"headerlink\" title=\"RESTful接口\"></a>RESTful接口</h3><blockquote>\n<p>REST全称是：Representational State Transfer，中文为表述性状态转移，REST指的是一组架构约束条件和原则</p>\n<p>RESTful表述的是资源的状态转移，在Web中资源就是URI(Uniform Resource Identifier)</p>\n<p>如果一个架构符合REST的约束条件和原则，我们就称它为RESTful架构，HTTP是目前与REST相关的唯一实例</p>\n<p>RESTful架构应该遵循统一的接口原则，应该使用标准的HTTP方法，如GET和POST，并且遵循这些方法的语义</p>\n</blockquote>\n<h3 id=\"HTTP方法的语义\"><a href=\"#HTTP方法的语义\" class=\"headerlink\" title=\"HTTP方法的语义\"></a>HTTP方法的语义</h3><p><img src=\"http://images.rl0206.love/202304291643114.png\" alt=\"image-20230429164253420\"></p>\n<h3 id=\"POST和PUT的区别\"><a href=\"#POST和PUT的区别\" class=\"headerlink\" title=\"POST和PUT的区别\"></a>POST和PUT的区别</h3><p>这两个概念非常容易混淆，POST通常被认为创建资源，PUT通常被认为更新资源，而实际上，二者均可用于创建资源，更为本质的差别实在幂等性方面。</p>\n<blockquote>\n<p>所谓幂等性，如果一个操作执行一次和执行多次的后果是一样的，那么这个操作就具有幂等性。</p>\n<p>例如：GET获取多次，   无副作用，  具有幂等性</p>\n<p>​     DELETE删除多次，无副作用，  具有幂等性</p>\n<p>​     POST提交会创建不同的资源，  不具有幂等性（实例如下图）</p>\n<p>​     PUT是创建或更新，无副作用，  具有幂等性</p>\n</blockquote>\n<p><img src=\"http://images.rl0206.love/202304291651182.png\" alt=\"image-20230429165143109\"></p>\n<p><code>Demo：RESTfulApi:</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">package</span> com.imooc.bilibili.api;<br><br><span class=\"hljs-keyword\">import</span> org.springframework.web.bind.annotation.*;<br><span class=\"hljs-keyword\">import</span> java.util.Arrays;<br><span class=\"hljs-keyword\">import</span> java.util.HashMap;<br><span class=\"hljs-keyword\">import</span> java.util.Map;<br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * <span class=\"hljs-doctag\">@author</span> WLei224</span><br><span class=\"hljs-comment\"> * <span class=\"hljs-doctag\">@create</span> 2023/4/30 11:01</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-meta\">@RestController</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">RESTfulApi</span> &#123;<br>    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">final</span> Map&lt;Integer,Map&lt;String,Object&gt;&gt; dataMap;<br>    <span class=\"hljs-comment\">// 声明一个构造方法，同时初始化datamap，进行传参</span><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-title function_\">RESTfulApi</span><span class=\"hljs-params\">()</span> &#123;<br>        dataMap = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">HashMap</span>&lt;&gt;();<br><br>        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">i</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">1</span>; i &lt; <span class=\"hljs-number\">3</span>; i++) &#123;<br>            Map&lt;String,Object&gt; data = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">HashMap</span>&lt;&gt;();<br>            data.put(<span class=\"hljs-string\">&quot;id&quot;</span>,i);<br>            data.put(<span class=\"hljs-string\">&quot;name&quot;</span>,<span class=\"hljs-string\">&quot;name&quot;</span>+i);<br>            dataMap.put(i,data);<br>        &#125;<br>    &#125;<br>    <span class=\"hljs-comment\">// 开始写RESTful的相关方法</span><br>    <span class=\"hljs-meta\">@GetMapping(&quot;objects/&#123;id&#125;&quot;)</span><br>    <span class=\"hljs-keyword\">public</span> Map&lt;String,Object&gt; <span class=\"hljs-title function_\">getData</span><span class=\"hljs-params\">(<span class=\"hljs-meta\">@PathVariable</span> Integer id)</span>&#123;<br>        <span class=\"hljs-keyword\">return</span> dataMap.get(id);<br>    &#125;<br><br>    <span class=\"hljs-meta\">@DeleteMapping(&quot;objects/&#123;id&#125;&quot;)</span><br>    <span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title function_\">deleteData</span><span class=\"hljs-params\">(<span class=\"hljs-meta\">@PathVariable</span> Integer id)</span>&#123;<br>        dataMap.remove(id);<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&quot;Success&quot;</span>;<br>    &#125;<br><br>    <span class=\"hljs-meta\">@PostMapping(&quot;objects&quot;)</span><br>    <span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title function_\">postData</span><span class=\"hljs-params\">(<span class=\"hljs-meta\">@RequestBody</span> Map&lt;String,Object&gt; data)</span>&#123;<br>        Integer[] idArray = dataMap.keySet().toArray(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Integer</span>[<span class=\"hljs-number\">0</span>]);<br>        Arrays.sort(idArray);<br>        <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">nextId</span> <span class=\"hljs-operator\">=</span> idArray[idArray.length-<span class=\"hljs-number\">1</span>] + <span class=\"hljs-number\">1</span>;<br>        <span class=\"hljs-comment\">// data.put(&quot;id&quot;,nextId);</span><br>        <span class=\"hljs-comment\">// data.put(&quot;name&quot;,&quot;name&quot; + nextId);</span><br>        dataMap.put(nextId,data);<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&quot;Success!&quot;</span>;<br>    &#125;<br>\t<span class=\"hljs-comment\">// 区别就在于幂等性，存在则更新，不存在则新增</span><br>    <span class=\"hljs-meta\">@PutMapping(&quot;objects&quot;)</span><br>    <span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title function_\">putData</span><span class=\"hljs-params\">(<span class=\"hljs-meta\">@RequestBody</span> Map&lt;String,Object&gt; data)</span>&#123;<br>        <span class=\"hljs-type\">Integer</span> <span class=\"hljs-variable\">id</span> <span class=\"hljs-operator\">=</span> Integer.valueOf(String.valueOf(data.get(<span class=\"hljs-string\">&quot;id&quot;</span>)));<br>        Map&lt;String,Object&gt; hasData = dataMap.get(id);<br>        <span class=\"hljs-keyword\">if</span> (hasData == <span class=\"hljs-literal\">null</span>) &#123;<br>            Integer[] idArray = dataMap.keySet().toArray(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Integer</span>[<span class=\"hljs-number\">0</span>]);<br>            Arrays.sort(idArray);<br>            <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">nextId</span> <span class=\"hljs-operator\">=</span> idArray[idArray.length-<span class=\"hljs-number\">1</span>] + <span class=\"hljs-number\">1</span>;<br>            <span class=\"hljs-comment\">// data.put(&quot;id&quot;,nextId);</span><br>            <span class=\"hljs-comment\">// data.put(&quot;name&quot;,&quot;name&quot; + nextId);</span><br>            dataMap.put(nextId,data);<br>        &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>            dataMap.put(id,data);<br>        &#125;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&quot;Success!&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"RESTful接口URL命名原则：\"><a href=\"#RESTful接口URL命名原则：\" class=\"headerlink\" title=\"RESTful接口URL命名原则：\"></a>RESTful接口URL命名原则：</h3><blockquote>\n<p>1、HTTP方法后跟的URL必须是名词的复数形式</p>\n<p>2、URL总不采用大小写混合的驼峰命名，尽量全部小写，如果涉及多个单词，可用”-“连接</p>\n<p>3、示例：/users、/users-fans、 反例：/getUser、/getUserFans</p>\n</blockquote>\n<h3 id=\"RESTful接口URL分级原则\"><a href=\"#RESTful接口URL分级原则\" class=\"headerlink\" title=\"RESTful接口URL分级原则\"></a>RESTful接口URL分级原则</h3><blockquote>\n<p>1、一级用来定位资源分类，如：/users表示需要定位到用户相关资源</p>\n<p>2、二级仍用来定位具体某个资源，如：/users/20/fans/1表示id为20的用户的id为1的粉丝</p>\n</blockquote>\n<h3 id=\"RESTful接口命名示例\"><a href=\"#RESTful接口命名示例\" class=\"headerlink\" title=\"RESTful接口命名示例\"></a>RESTful接口命名示例</h3><p><img src=\"http://images.rl0206.love/202304301533812.png\" alt=\"image-20230430153315090\"></p>\n<p><img src=\"http://images.rl0206.love/202304301534235.png\" alt=\"image-20230430153406940\"></p>\n<h3 id=\"通用功能与配置\"><a href=\"#通用功能与配置\" class=\"headerlink\" title=\"通用功能与配置\"></a>通用功能与配置</h3><h4 id=\"通用功能：\"><a href=\"#通用功能：\" class=\"headerlink\" title=\"通用功能：\"></a><strong>通用功能：</strong></h4><p>加解密工具（<code>AES</code>、<code>RSA</code>、<code>MD5</code>）、json数据返回类</p>\n<p>顶层POM.xml添加commons-codec依赖，</p>\n<p>添加对应的工具包到service包的util包下</p>\n<blockquote>\n<p> <code>什么是AES加密</code></p>\n</blockquote>\n<p><code>AES:</code></p>\n<p><em>Advanced Encryption Standard</em>高级加密标准，是最常见的对称加密算法，对称加密即加解密只有一个密钥，可使用密钥恢复明文，加密速度非常快。</p>\n<p><code>使用场景：</code></p>\n<p>适合发送大量数据的场合。</p>\n<p><code>看下源码：</code></p>\n<p><img src=\"http://images.rl0206.love/202305191736417.png\" alt=\"image-20230519170635001\"></p>\n<blockquote>\n<p><code>什么是RSA加密？</code></p>\n</blockquote>\n<p><code>RSA:</code></p>\n<p>是一种非对称加密，即：有公钥与私钥之分，公钥用于数据加密，私钥用于数据解密，同样是可逆的，即可以通过私钥进行解密。公钥提供给外部进行使用，私钥放在服务器，保护数据安全。</p>\n<p><code>特点：</code></p>\n<p>加密安全性很高，但是加密速度非常之慢。</p>\n<p><code>使用场景：</code></p>\n<p>由特点可知，加密慢，但是安全。因此适合对加密次数要求较少的场景。例如：用户的登陆，加密一次，便不用加密，而且安全性还较高。</p>\n<p><code>拓展：非对称加密的流程是什么，在实际应用中是如何进行加密的？</code></p>\n<p>下面以用户注册登录场景为例，来说一下非对称加密在实际中的应用：</p>\n<p>因为RSA加密中的公钥是提供给外部进行加密使用的，用户在前端注册登录时，为了保证输入的密码其安全性（防止拦截后密码泄露），将公钥返回到前端，前端使用公钥进行加密，加密后的暗文通过接口然后传给后端，后端再通过私钥进行解密，得到密码。</p>\n<p><code>加解密源码：</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> String <span class=\"hljs-title function_\">encrypt</span><span class=\"hljs-params\">(String source)</span> <span class=\"hljs-keyword\">throws</span> Exception &#123;<br>\t<span class=\"hljs-type\">byte</span>[] decoded = Base64.decodeBase64(PUBLIC_KEY);<br>\t<span class=\"hljs-type\">RSAPublicKey</span> <span class=\"hljs-variable\">rsaPublicKey</span> <span class=\"hljs-operator\">=</span> (RSAPublicKey) KeyFactory.getInstance(<span class=\"hljs-string\">&quot;RSA&quot;</span>)<br>\t\t\t.generatePublic(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">X509EncodedKeySpec</span>(decoded));<br>\t<span class=\"hljs-type\">Cipher</span> <span class=\"hljs-variable\">cipher</span> <span class=\"hljs-operator\">=</span> Cipher.getInstance(<span class=\"hljs-string\">&quot;RSA&quot;</span>);<br>\tcipher.init(<span class=\"hljs-number\">1</span>, rsaPublicKey);<br>\t<span class=\"hljs-keyword\">return</span> Base64.encodeBase64String(cipher.doFinal(source.getBytes(StandardCharsets.UTF_8)));<br>&#125;<br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> String <span class=\"hljs-title function_\">decrypt</span><span class=\"hljs-params\">(String text)</span> <span class=\"hljs-keyword\">throws</span> Exception &#123;<br>\t<span class=\"hljs-type\">Cipher</span> <span class=\"hljs-variable\">cipher</span> <span class=\"hljs-operator\">=</span> getCipher();<br>\t<span class=\"hljs-type\">byte</span>[] inputByte = Base64.decodeBase64(text.getBytes(StandardCharsets.UTF_8));<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">String</span>(cipher.doFinal(inputByte));<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><code>最后说一下MD5加密：</code></p>\n<p><code>MD5：</code></p>\n<p>非对称加密，即不可逆，无法看到加密前的明文。</p>\n<p><code>特点：</code></p>\n<p>加密速度快，无需密钥，但是安全性不高需要搭配随机盐值使用。随机盐就是一个随机数，防止黑客将加密后的MD5还原回去。</p>\n<h4 id=\"通用配置：\"><a href=\"#通用配置：\" class=\"headerlink\" title=\"通用配置：\"></a><strong>通用配置：</strong></h4><p><code>Json信息转换配置 &amp;&amp; 全局异常处理配置</code></p>\n<blockquote>\n<p><code>JSON返回数据配置：</code></p>\n</blockquote>\n<p><code>什么是JSON？：JSON就是一种轻量化数据交换格式。</code></p>\n<p><code>为什么会用到JSON返回数据类和数据类转换呢？因为JSON轻量化，前端需要展示不同的数据格式时，这就需要用到JSON信息转换了。</code></p>\n<p>如何新建JSON信息转换配置？</p>\n<p>Service包下新建config包，用于放以后所有的配置类。</p>\n<p>此处涉及到Spring Boot相关的注解名，下面来说一下常见的注解：</p>\n<figure class=\"highlight txt\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs txt\">@Configuration：标志着Java文件是一个配置类，经常搭配@Bean使用，表示向上下文注入实体类，使其生效；<br>@Component：是@Configuration注解的内部注解，在Spring Boot启动阶段，自动的将Configuration<br>对应的文件注入到Sping Boot上下文；<br>@Bean：表示向上下文注入实体类，使其生效；<br></code></pre></td></tr></table></figure>\n\n<p><code>HttpMessageConverters：</code>是一个对Http方法，接收请求，或做转换的一个工具类框架，返回的就是一个@Bean类型，因为此方法是一个JSON类型，所以要引入一个fastJson依赖（目前世界行公认效率最高的工具包）。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span><br>\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>com.alibaba<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span><br>\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>fastjson<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span><br>\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>1.2.78<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<p>然后配置一些和fastjson相关的配置类。</p>\n<p>例如：配置相关的数据返回类型的时间格式、序列化的相关配置、</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">fastJsonConfig.setSerializerFeatures(<br>                <span class=\"hljs-comment\">// 格式化输出</span><br>                SerializerFeature.PrettyFormat,<br>                <span class=\"hljs-comment\">// 如果输出的数据是空的，那么系统会直接把这个数据去掉，不会在前端进行显示，这个配置项可以显示出一个空串</span><br>                SerializerFeature.WriteNullStringAsEmpty,<br>                <span class=\"hljs-comment\">// 功能同上，列表</span><br>                SerializerFeature.WriteNullListAsEmpty,<br>                <span class=\"hljs-comment\">// 同上，集合</span><br>                SerializerFeature.WriteMapNullValue,<br>                <span class=\"hljs-comment\">// 升序排列</span><br>                SerializerFeature.MapSortField,<br>                <span class=\"hljs-comment\">// 进制循环引用（防止循环引用后，输出多余的引用字符串） 非常有用的一个配置</span><br>                SerializerFeature.DisableCircularReferenceDetect<br>);<br></code></pre></td></tr></table></figure>\n\n<p>循环引用：</p>\n<p><img src=\"http://images.rl0206.love/202305201545971.png\" alt=\"image-20230520144308894\"></p>\n<blockquote>\n<p><code>全局异常处理配置：</code></p>\n</blockquote>\n<p>放在Service包下的handle包中，命名为全局异常处理类（<code>CommonGlobalExceptionHandler.class</code>）：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Java\"><span class=\"hljs-keyword\">package</span> com.imooc.bilibili.service.handler;<br><br><span class=\"hljs-keyword\">import</span> com.imooc.bilibili.dao.damain.JsonResponse;<br><span class=\"hljs-keyword\">import</span> com.imooc.bilibili.dao.damain.exception.ConditionException;<br><span class=\"hljs-keyword\">import</span> org.springframework.core.Ordered;<br><span class=\"hljs-keyword\">import</span> org.springframework.core.annotation.Order;<br><span class=\"hljs-keyword\">import</span> org.springframework.web.bind.annotation.ControllerAdvice;<br><span class=\"hljs-keyword\">import</span> org.springframework.web.bind.annotation.ExceptionHandler;<br><span class=\"hljs-keyword\">import</span> org.springframework.web.bind.annotation.ResponseBody;<br><br><span class=\"hljs-keyword\">import</span> javax.servlet.http.HttpServletRequest;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * <span class=\"hljs-doctag\">@author</span> WLei224</span><br><span class=\"hljs-comment\"> * <span class=\"hljs-doctag\">@create</span> 2023/5/20 16:38</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-meta\">@ControllerAdvice</span><br><span class=\"hljs-meta\">@Order(Ordered.HIGHEST_PRECEDENCE)</span> <span class=\"hljs-comment\">// 最高优先级</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">CommonGlobalExceptionHandler</span> &#123;<br><br>    <span class=\"hljs-meta\">@ExceptionHandler(value = Exception.class)</span><br>    <span class=\"hljs-meta\">@ResponseBody</span><br>    <span class=\"hljs-keyword\">public</span> JsonResponse&lt;String&gt; <span class=\"hljs-title function_\">commonExceptionHandler</span><span class=\"hljs-params\">(HttpServletRequest request, Exception e)</span>&#123;<br>        <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">errorMsg</span> <span class=\"hljs-operator\">=</span> e.getMessage();<br>        <span class=\"hljs-keyword\">if</span>(e <span class=\"hljs-keyword\">instanceof</span> ConditionException)&#123;<br>            <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">errorCode</span> <span class=\"hljs-operator\">=</span> ((ConditionException) e).getCode();<br>            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">JsonResponse</span>&lt;&gt;(errorCode,errorMsg);<br>        &#125;<span class=\"hljs-keyword\">else</span>&#123;<br>            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">JsonResponse</span>&lt;&gt;(<span class=\"hljs-string\">&quot;500&quot;</span>,errorMsg);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>在此之前，我定义了一个条件异常，并添加了状态码等信息，然后这个类的代码功能就是，抓取条件异常信息，然后通过<code>json数据返回类型jsonResponse</code>返回异常信息。 </p>\n<h3 id=\"用户注册与登录\"><a href=\"#用户注册与登录\" class=\"headerlink\" title=\"用户注册与登录\"></a>用户注册与登录</h3><p>数据库库表设计：用户表、用户信息表</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">CREATE</span> <span class=\"hljs-keyword\">TABLE</span> `t_user` (<br>  `id` <span class=\"hljs-type\">bigint</span>(<span class=\"hljs-number\">20</span>) <span class=\"hljs-keyword\">NOT</span> <span class=\"hljs-keyword\">NULL</span> AUTO_INCREMENT COMMENT <span class=\"hljs-string\">&#x27;主键&#x27;</span>,<br>  `phone` <span class=\"hljs-type\">varchar</span>(<span class=\"hljs-number\">100</span>) <span class=\"hljs-type\">CHARACTER</span> <span class=\"hljs-keyword\">SET</span> utf8mb4 <span class=\"hljs-keyword\">COLLATE</span> utf8mb4_0900_ai_ci <span class=\"hljs-keyword\">DEFAULT</span> <span class=\"hljs-keyword\">NULL</span> COMMENT <span class=\"hljs-string\">&#x27;手机号&#x27;</span>,<br>  `email` <span class=\"hljs-type\">varchar</span>(<span class=\"hljs-number\">100</span>) <span class=\"hljs-type\">CHARACTER</span> <span class=\"hljs-keyword\">SET</span> utf8mb4 <span class=\"hljs-keyword\">COLLATE</span> utf8mb4_0900_ai_ci <span class=\"hljs-keyword\">DEFAULT</span> <span class=\"hljs-keyword\">NULL</span> COMMENT <span class=\"hljs-string\">&#x27;邮箱&#x27;</span>,<br>  `password` <span class=\"hljs-type\">varchar</span>(<span class=\"hljs-number\">255</span>) <span class=\"hljs-type\">CHARACTER</span> <span class=\"hljs-keyword\">SET</span> utf8mb4 <span class=\"hljs-keyword\">COLLATE</span> utf8mb4_0900_ai_ci <span class=\"hljs-keyword\">DEFAULT</span> <span class=\"hljs-keyword\">NULL</span> COMMENT <span class=\"hljs-string\">&#x27;密码&#x27;</span>,<br>  `salt` <span class=\"hljs-type\">varchar</span>(<span class=\"hljs-number\">50</span>) <span class=\"hljs-type\">CHARACTER</span> <span class=\"hljs-keyword\">SET</span> utf8mb4 <span class=\"hljs-keyword\">COLLATE</span> utf8mb4_0900_ai_ci <span class=\"hljs-keyword\">DEFAULT</span> <span class=\"hljs-keyword\">NULL</span> COMMENT <span class=\"hljs-string\">&#x27;盐值&#x27;</span>,<br>  `createTime` datetime <span class=\"hljs-keyword\">DEFAULT</span> <span class=\"hljs-keyword\">NULL</span> COMMENT <span class=\"hljs-string\">&#x27;创建时间&#x27;</span>,<br>  `updateTime` datetime <span class=\"hljs-keyword\">DEFAULT</span> <span class=\"hljs-keyword\">NULL</span> COMMENT <span class=\"hljs-string\">&#x27;更新时间&#x27;</span>,<br>  <span class=\"hljs-keyword\">PRIMARY</span> KEY (`id`)<br>) ENGINE<span class=\"hljs-operator\">=</span>InnoDB AUTO_INCREMENT<span class=\"hljs-operator\">=</span><span class=\"hljs-number\">17</span> <span class=\"hljs-keyword\">DEFAULT</span> CHARSET<span class=\"hljs-operator\">=</span>utf8mb4 <span class=\"hljs-keyword\">COLLATE</span><span class=\"hljs-operator\">=</span>utf8mb4_0900_ai_ci COMMENT<span class=\"hljs-operator\">=</span><span class=\"hljs-string\">&#x27;用户表&#x27;</span>;<br><br><span class=\"hljs-keyword\">CREATE</span> <span class=\"hljs-keyword\">TABLE</span> `t_user_info` (<br>  `id` <span class=\"hljs-type\">bigint</span>(<span class=\"hljs-number\">20</span>) <span class=\"hljs-keyword\">NOT</span> <span class=\"hljs-keyword\">NULL</span> AUTO_INCREMENT COMMENT <span class=\"hljs-string\">&#x27;主键&#x27;</span>,<br>  `userId` <span class=\"hljs-type\">bigint</span>(<span class=\"hljs-number\">20</span>) <span class=\"hljs-keyword\">DEFAULT</span> <span class=\"hljs-keyword\">NULL</span> COMMENT <span class=\"hljs-string\">&#x27;用户id&#x27;</span>,<br>  `nick` <span class=\"hljs-type\">varchar</span>(<span class=\"hljs-number\">100</span>) <span class=\"hljs-keyword\">DEFAULT</span> <span class=\"hljs-keyword\">NULL</span> COMMENT <span class=\"hljs-string\">&#x27;昵称&#x27;</span>,<br>  `avatar` <span class=\"hljs-type\">varchar</span>(<span class=\"hljs-number\">255</span>) <span class=\"hljs-keyword\">DEFAULT</span> <span class=\"hljs-keyword\">NULL</span> COMMENT <span class=\"hljs-string\">&#x27;头像&#x27;</span>,<br>  `sign` text COMMENT <span class=\"hljs-string\">&#x27;签名&#x27;</span>,<br>  `gender` <span class=\"hljs-type\">varchar</span>(<span class=\"hljs-number\">2</span>) <span class=\"hljs-keyword\">DEFAULT</span> <span class=\"hljs-keyword\">NULL</span> COMMENT <span class=\"hljs-string\">&#x27;性别：0男 1女 2未知&#x27;</span>,<br>  `birth` <span class=\"hljs-type\">varchar</span>(<span class=\"hljs-number\">20</span>) <span class=\"hljs-keyword\">DEFAULT</span> <span class=\"hljs-keyword\">NULL</span> COMMENT <span class=\"hljs-string\">&#x27;生日&#x27;</span>,<br>  `createTime` datetime <span class=\"hljs-keyword\">DEFAULT</span> <span class=\"hljs-keyword\">NULL</span> COMMENT <span class=\"hljs-string\">&#x27;创建时间&#x27;</span>,<br>  `updateTime` datetime <span class=\"hljs-keyword\">DEFAULT</span> <span class=\"hljs-keyword\">NULL</span> COMMENT <span class=\"hljs-string\">&#x27;更新时间&#x27;</span>,<br>  <span class=\"hljs-keyword\">PRIMARY</span> KEY (`id`)<br>) ENGINE<span class=\"hljs-operator\">=</span>InnoDB AUTO_INCREMENT<span class=\"hljs-operator\">=</span><span class=\"hljs-number\">10</span> <span class=\"hljs-keyword\">DEFAULT</span> CHARSET<span class=\"hljs-operator\">=</span>utf8mb4 <span class=\"hljs-keyword\">COLLATE</span><span class=\"hljs-operator\">=</span>utf8mb4_0900_ai_ci COMMENT<span class=\"hljs-operator\">=</span><span class=\"hljs-string\">&#x27;用户基本信息表&#x27;</span>;<br></code></pre></td></tr></table></figure>\n\n<p>相关接口（API）：获取RSA公钥、用户注册、用户登录</p>\n<blockquote>\n<p>项目编写步骤：</p>\n<p>entity(domain)-&gt;dao（@Mapper交给MyBatis）-&gt;service(注入dao)-&gt;api(controller)注入service[先留一个bug]</p>\n<p>项目整体的逻辑：</p>\n<p>前端访问到我们的api接口层（也就是控制层）之后，会跳转到相关的业务逻辑层（service），在业务实现逻辑层中可能会用到与数据库之间的交互，那么service就会去访问dao层（数据持久层，放的是与数据库进行交互的接口），dao层通过@Mapper注解与MyBatis产生关联，通过MyBatis进行交互，交互的结果返回给service业务逻辑层，业务逻辑层返回给控制层接口，然后在前端体现了出来。</p>\n<p>以上层层嵌套的架构，可以让代码更加清晰、优雅。</p>\n</blockquote>\n<p>🆗，通过以上步骤，实体类已经新建好了，下面进行相关接口的业务逻辑书写</p>\n<ul>\n<li>获取RSA公钥</li>\n</ul>\n<p>@GetMapping</p>\n<ul>\n<li>用户注册</li>\n</ul>\n<p>@PostMapping</p>\n<p>同样是按照接口的编写顺序来进行coding，在@Api中写接口，service中写实现，</p>\n<ul>\n<li>用户登录</li>\n</ul>\n<h3 id=\"基于JWT的用户token验证\"><a href=\"#基于JWT的用户token验证\" class=\"headerlink\" title=\"基于JWT的用户token验证\"></a>基于JWT的用户token验证</h3><p><code>JWT</code>:<code>JSON Web Token</code>，<code>JWT</code>是一个规范，用于在空间受限环境下安全传递”声明”。</p>\n<p><strong>什么是声明呢？</strong></p>\n<p>声明分为三个部分：</p>\n<p>一、头部（header）</p>\n<p>​    声明的类型、声明的加密算法（通常使用SHA256）</p>\n<p>二、载荷（payload）</p>\n<p>​    用于存放有效信息的，一般包含签发者、所面向的用户、接受方、过期时间、签发时间以及唯一身份标识（userId）</p>\n<p>三、签名（signature）</p>\n<p>​    主要由头部、载荷、以及密钥组成加密而成</p>\n<p>JWT的优点：</p>\n<p>跨语言支持（因为<code>JWT</code>使用的是<code>JSON</code>数据格式，所以多语言都支持）、便于传输（见定义：空间受限的环境之下，说明<code>JWT</code>是数据量很小的，因此便于传输）、易于扩展（因为<code>JWT</code>有<code>payload</code>的部分，因为数据的分类很多、定制化强，可以通过<code>payload</code>进行数据添加，所以易于扩展）</p>\n<p>说到session之前，先来说一下基于session的用户验证：</p>\n<ul>\n<li>基于session的用户身份验证</li>\n<li>验证过程：服务端验证浏览器携带的用户名和密码，验证通过后生成用户凭证保存在服务端（session），浏览器再次访问时，服务端查询session，实现登陆状态保持。</li>\n<li>缺点：随着用户的增多，服务端的压力增大；若浏览器的cookie被第三方或者攻击者拦截，容易受到跨站请求伪造攻击；分布式系统下扩展不强（多台服务器部署应用，用户在不同的服务器进行访问，因为session不会共享，所以不会进行自动登录）。</li>\n</ul>\n<p>说到session验证，再来说一下token验证：</p>\n<ul>\n<li>基于token的用户验证</li>\n<li>验证过程：服务器端验证浏览器携带的用户名和密码，验证通过后，生成用户令牌（token），不同于session的一点是，服务端不会保存token，而会返回给浏览器，浏览器接收到token之后，进而写在浏览器的localstory中，那么什么是local story呢？localstory不同于cookie，它可以保存在本地，大小也比cookie大很多，所以在请求时就可以不用把token放在cookie中请求服务器，可以放在请求头中或者body中，这样就可以降低跨站请求拦截的风险，最后服务端拿到token之后进行校验是否正确，正确就证明是合法用户。</li>\n<li>优点：token不存储在服务器，不会造成服务器的压力；token可以存储在非cookie中的（local story），安全性更高；分布式系统下扩展性较强（token生成之后返回前端，前端拿到之后在请求服务端，服务端再对token进行验证即可）。</li>\n</ul>\n","site":{"data":{}},"more":"<h3 id=\"从项目角度和技术角度两个维度来看：\"><a href=\"#从项目角度和技术角度两个维度来看：\" class=\"headerlink\" title=\"从项目角度和技术角度两个维度来看：\"></a>从项目角度和技术角度两个维度来看：</h3><blockquote>\n<p>项目角度：规模大、不同种类的用户群体、高流量、个性化功能针对不同的用户；</p>\n<p>技术角度：经典高并发与异步问题、视频流+弹幕定制化功能。</p>\n</blockquote>\n<h3 id=\"项目大纲：（课程链接）\"><a href=\"#项目大纲：（课程链接）\" class=\"headerlink\" title=\"项目大纲：（课程链接）\"></a>项目大纲：（<a href=\"https://coding.imooc.com/class/556.html\">课程链接</a>）</h3><blockquote>\n<p>第一章：项目整体介绍、课程设计逻辑、学习方法</p>\n<p>第二章：项目架构、环境搭建、效果展示</p>\n<p>第三章：通用配置、用户相关功能</p>\n<p>第四章：视频流+弹幕加载、性能优化</p>\n<p>第五章：全局搜索、系统广播、数据统计、智能推荐</p>\n<p>第六章：总结复盘、切面编程、自动化部署、负载均衡</p>\n</blockquote>\n<h2 id=\"从搭建环境开始你的仿哔哩哔哩项目（初入江湖）\"><a href=\"#从搭建环境开始你的仿哔哩哔哩项目（初入江湖）\" class=\"headerlink\" title=\"从搭建环境开始你的仿哔哩哔哩项目（初入江湖）\"></a>从搭建环境开始你的仿哔哩哔哩项目（初入江湖）</h2><h3 id=\"项目架构：\"><a href=\"#项目架构：\" class=\"headerlink\" title=\"项目架构：\"></a><strong>项目架构：</strong></h3><p>基本过程：需求分析–》功能设计–》全局架构（承载、可复用）</p>\n<h3 id=\"业务（功能架构）：\"><a href=\"#业务（功能架构）：\" class=\"headerlink\" title=\"业务（功能架构）：\"></a><strong>业务（功能架构）：</strong></h3><p>顶层：用户服务，如注册登录、大会员权限、查找感兴趣视频等</p>\n<p>中间层：在线视频播放设置、实施弹幕</p>\n<p>底层：管理后台，如：视频上传、数据统计、系统消息推送</p>\n<h3 id=\"技术架构：\"><a href=\"#技术架构：\" class=\"headerlink\" title=\"技术架构：\"></a><strong>技术架构：</strong></h3><p>技术选型：<code>SpringBoot2.x</code>+ <code>Mysql</code> + <code>MyBatis</code> + <code>Maven</code></p>\n<p>开发模式：项目采用经典<code>MVC</code>，模式控制层（<code>Controller层</code>）、服务层（<code>Service层</code>）、数据层（<code>Dao层</code>）</p>\n<h3 id=\"部署架构\"><a href=\"#部署架构\" class=\"headerlink\" title=\"部署架构:\"></a><strong>部署架构:</strong></h3><p>前端：服务转发 + 负载均衡</p>\n<p>后端：业务处理 + 功能实现</p>\n<p>工具：缓存 + 队列</p>\n<h3 id=\"开发环境：\"><a href=\"#开发环境：\" class=\"headerlink\" title=\"开发环境：\"></a><strong>开发环境：</strong></h3><p><code>OS</code>：<code>Java</code>的跨平台，任意OS即可</p>\n<p>开发工具：<code>IntelliJ IDEA</code>，推荐版本2018及以后</p>\n<p>必备：<code>JDK1.8</code>、<code>Maven</code></p>\n<h3 id=\"创建多模块、多环境项目：\"><a href=\"#创建多模块、多环境项目：\" class=\"headerlink\" title=\"创建多模块、多环境项目：\"></a><strong>创建多模块、多环境项目：</strong></h3><p>多模块：经典MVC</p>\n<p>多环境：添加不同的properties配置文件（测试、部署）</p>\n<p>配置好项目的JDK版本与Maven仓库</p>\n<h3 id=\"项目运行\"><a href=\"#项目运行\" class=\"headerlink\" title=\"项目运行:\"></a><strong>项目运行:</strong></h3><p>在<code>pom.xml</code>文件中加入<code>SpringBoot</code>框架依赖:</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">parent</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>spring-boot-starter-parent<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>2.5.1<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">parent</span>&gt;</span><br><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>spring-boot-starter-web<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>2.5.1<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<p>在子模块<code>pom.xml</code>文件中添加模块间依赖关系:</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs xml\"><span class=\"hljs-comment\">&lt;!--配置模块间的依赖关系--&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.example<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>imooc-bilibili-dao<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>1.0-SNAPSHOT<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<p>添加启动入口，启动项目：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">import</span> org.springframework.boot.SpringApplication;<br><span class=\"hljs-keyword\">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;<br><span class=\"hljs-keyword\">import</span> org.springframework.context.ApplicationContext;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * <span class=\"hljs-doctag\">@author</span> WLei224</span><br><span class=\"hljs-comment\"> * <span class=\"hljs-doctag\">@create</span> 2023/4/28 21:34</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-meta\">@SpringBootApplication</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ImoocBilibiliApp</span> &#123;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> &#123;<br>        <span class=\"hljs-type\">ApplicationContext</span> <span class=\"hljs-variable\">app</span> <span class=\"hljs-operator\">=</span> SpringApplication.run(ImoocBilibiliApp.class, args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>多环境配置：</p>\n<p>在Service包下创建一个<code>application.properties</code>配置文件:</p>\n<p>在Controller包下创建多个生产环境：<code>application-test.properties</code>、<code>application-online.properties</code></p>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs properties\"><span class=\"hljs-comment\">#profiles可用于切换生产环境</span><br><span class=\"hljs-attr\">spring.profiles.active</span>=<span class=\"hljs-string\">test</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"数据库的搭建与持久层框架：\"><a href=\"#数据库的搭建与持久层框架：\" class=\"headerlink\" title=\"数据库的搭建与持久层框架：\"></a><strong>数据库的搭建与持久层框架：</strong></h3><p>配置<code>MySQL</code>数据库:</p>\n<p>引入<code>MySQL</code>数据库和持久层<code>Mybatis</code>依赖：（<code>Mybatis</code>特点：XML形式管理，支持动态<code>sql</code>）</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>mysql<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>mysql-connector-java<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>8.0.27<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>     \t\t     <br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.mybatis.spring.boot<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>2.2.0<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<p>将数据库连接写入<code>application.properties</code>配置文件：</p>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs properties\"><span class=\"hljs-comment\">#datasource</span><br><span class=\"hljs-attr\">spring.datasource.url</span>=<span class=\"hljs-string\">jdbc:mysql://localhost:3306/imooc_bilibili</span><br><span class=\"hljs-attr\">spring.datasource.username</span>=<span class=\"hljs-string\">root</span><br><span class=\"hljs-attr\">spring.datasource.password</span>=<span class=\"hljs-string\">root(你的密码)</span><br><span class=\"hljs-attr\">spring.datasource.driver-class-name</span>=<span class=\"hljs-string\">com.mysql.cj.jdbc.Driver</span><br></code></pre></td></tr></table></figure>\n\n<p>将<code>Mybatis</code>配置写入可复用的<code>application.properties</code>配置文件中：</p>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs properties\"><span class=\"hljs-comment\">#mybatis</span><br><span class=\"hljs-attr\">mybatis.mapper-locations</span>=<span class=\"hljs-string\">classpath:mapper/*.xml</span><br><span class=\"hljs-comment\">#项目启动时，告诉SpringBoot扫描class、interface的路径，统一实例化，然后与mapper进行关联</span><br><span class=\"hljs-attr\">mybatis.type-aliases-package</span>=<span class=\"hljs-string\">com.imooc.bilibili.dao</span><br></code></pre></td></tr></table></figure>\n\n<p><strong>开发一个小Demo：</strong>（在持久层<code>Dao</code>层进行）</p>\n<p>首先要将<code>mapper</code>与<code>dao</code>层实体类进行关联：(<code>Demo.xml</code>)</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs xml\"><span class=\"hljs-meta\">&lt;?xml version=<span class=\"hljs-string\">&quot;1.0&quot;</span> encoding=<span class=\"hljs-string\">&quot;UTF-8&quot;</span> ?&gt;</span><br><span class=\"hljs-meta\">&lt;!DOCTYPE <span class=\"hljs-keyword\">mapper</span> <span class=\"hljs-keyword\">PUBLIC</span> <span class=\"hljs-string\">&quot;-//mybatis.org//DTD MAPPER 3.0//EN&quot;</span></span><br><span class=\"hljs-meta\">        <span class=\"hljs-string\">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span><br><span class=\"hljs-comment\">&lt;!--namespace对应着dao层Java实体类文件--&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">mapper</span> <span class=\"hljs-attr\">namespace</span>=<span class=\"hljs-string\">&quot;com.imooc.bilibili.dao.DemoDao&quot;</span>&gt;</span><br><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">select</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;query&quot;</span> <span class=\"hljs-attr\">parameterType</span>=<span class=\"hljs-string\">&quot;java.lang.Long&quot;</span> <span class=\"hljs-attr\">resultType</span>=<span class=\"hljs-string\">&quot;java.lang.Long&quot;</span>&gt;</span><br>        select id from t_demo where id = #&#123;id&#125;<br>    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">select</span>&gt;</span><br><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">mapper</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<p><code>Controller:</code> </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">package</span> com.imooc.bilibili.api;<br><span class=\"hljs-keyword\">import</span> com.imooc.bilibili.service.DemoService;<br><span class=\"hljs-keyword\">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class=\"hljs-keyword\">import</span> org.springframework.web.bind.annotation.GetMapping;<br><span class=\"hljs-keyword\">import</span> org.springframework.web.bind.annotation.RestController;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * <span class=\"hljs-doctag\">@author</span> WLei224</span><br><span class=\"hljs-comment\"> * <span class=\"hljs-doctag\">@create</span> 2023/4/29 1:50</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-meta\">@RestController</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">DemoApi</span> &#123;<br><br>    <span class=\"hljs-meta\">@Autowired</span><br>    <span class=\"hljs-keyword\">private</span> DemoService demoService;<br><br><br>    <span class=\"hljs-meta\">@GetMapping(&quot;/query&quot;)</span><br>    <span class=\"hljs-keyword\">public</span> Long <span class=\"hljs-title function_\">query</span><span class=\"hljs-params\">(Long id)</span>&#123;<br>        <span class=\"hljs-keyword\">return</span> demoService.query(id);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><code>Service:</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">package</span> com.imooc.bilibili.service;<br><br><span class=\"hljs-keyword\">import</span> com.imooc.bilibili.dao.DemoDao;<br><span class=\"hljs-keyword\">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class=\"hljs-keyword\">import</span> org.springframework.stereotype.Service;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * <span class=\"hljs-doctag\">@author</span> WLei224</span><br><span class=\"hljs-comment\"> * <span class=\"hljs-doctag\">@create</span> 2023/4/29 1:33</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-meta\">@Service</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">DemoService</span> &#123;<br><br>    <span class=\"hljs-meta\">@Autowired</span><br>    <span class=\"hljs-keyword\">private</span> DemoDao demoDao;<br><br>    <span class=\"hljs-keyword\">public</span> Long <span class=\"hljs-title function_\">query</span><span class=\"hljs-params\">(Long id)</span>&#123;<br>        <span class=\"hljs-keyword\">return</span> demoDao.query(id);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><code>Dao:</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">package</span> com.imooc.bilibili.dao;<br><br><span class=\"hljs-keyword\">import</span> org.apache.ibatis.annotations.Mapper;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * <span class=\"hljs-doctag\">@author</span> WLei224</span><br><span class=\"hljs-comment\"> * <span class=\"hljs-doctag\">@create</span> 2023/4/29 1:04</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-comment\">//如何将DemoDao与mapper对应起来呢？ 为什么声明成为接口呢?因为@mapper注解在启动时会自动匹配，把dao的文件封装成一个实体类，从而实现自动实例化的操作</span><br><span class=\"hljs-meta\">@Mapper</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">DemoDao</span> &#123;<br>    <span class=\"hljs-keyword\">public</span> Long <span class=\"hljs-title function_\">query</span><span class=\"hljs-params\">(Long id)</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"效率提升：实现热部署：\"><a href=\"#效率提升：实现热部署：\" class=\"headerlink\" title=\"效率提升：实现热部署：\"></a>效率提升：实现热部署：</h3><blockquote>\n<p>热部署：热部署就是当应用程序正在运行的时候升级软件或修改某一部分代码、配置文件时，无需手动重启应用，即可使修改的部分生效</p>\n<p>配置方法：<code>spring-boot-devtools</code>依赖工具+IDEA配置</p>\n</blockquote>\n<p>1、<code>IDEA:</code>Files–&gt;Settings–&gt;Compiles–&gt;Build Project Automately</p>\n<p>2、<code>IDEA注册表：Ctrl+Alt+Shift+/</code>打开<code>compiler document save enabled</code>和<code>compiler automake allow when app runing</code></p>\n<p>3、编辑启动类的配置：<img src=\"http://images.rl0206.love/202304291326170.png\" alt=\"image-20230429132152997\"></p>\n<p>4、引入全局<code>pom.xml</code>依赖：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs xml\"><span class=\"hljs-comment\">&lt;!-- 热部署 --&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span><br>     <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span><br>     <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>spring-boot-devtools<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span><br>     <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>2.0.4.RELEASE<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span><br>     <span class=\"hljs-comment\">&lt;!-- 启用 --&gt;</span><br>     <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">optional</span>&gt;</span>true<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">optional</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<p>热部署已完成。</p>\n<h2 id=\"3从用户功能体验后端经典开发模式（窥得门路）\"><a href=\"#3从用户功能体验后端经典开发模式（窥得门路）\" class=\"headerlink\" title=\"3从用户功能体验后端经典开发模式（窥得门路）\"></a>3从用户功能体验后端经典开发模式（窥得门路）</h2><h3 id=\"用户模块开发概要与接口设计\"><a href=\"#用户模块开发概要与接口设计\" class=\"headerlink\" title=\"用户模块开发概要与接口设计\"></a>用户模块开发概要与接口设计</h3><blockquote>\n<p><strong><code>RESTful</code>风格接口设计：</strong></p>\n<p>RESTful架构、HTTP方法语义、HTTP方法幂等性、RESTful接口设计原则</p>\n<p><strong>用户模块开发概要：</strong>通用功能与通用配置、用户相关功能</p>\n</blockquote>\n<h3 id=\"RESTful接口\"><a href=\"#RESTful接口\" class=\"headerlink\" title=\"RESTful接口\"></a>RESTful接口</h3><blockquote>\n<p>REST全称是：Representational State Transfer，中文为表述性状态转移，REST指的是一组架构约束条件和原则</p>\n<p>RESTful表述的是资源的状态转移，在Web中资源就是URI(Uniform Resource Identifier)</p>\n<p>如果一个架构符合REST的约束条件和原则，我们就称它为RESTful架构，HTTP是目前与REST相关的唯一实例</p>\n<p>RESTful架构应该遵循统一的接口原则，应该使用标准的HTTP方法，如GET和POST，并且遵循这些方法的语义</p>\n</blockquote>\n<h3 id=\"HTTP方法的语义\"><a href=\"#HTTP方法的语义\" class=\"headerlink\" title=\"HTTP方法的语义\"></a>HTTP方法的语义</h3><p><img src=\"http://images.rl0206.love/202304291643114.png\" alt=\"image-20230429164253420\"></p>\n<h3 id=\"POST和PUT的区别\"><a href=\"#POST和PUT的区别\" class=\"headerlink\" title=\"POST和PUT的区别\"></a>POST和PUT的区别</h3><p>这两个概念非常容易混淆，POST通常被认为创建资源，PUT通常被认为更新资源，而实际上，二者均可用于创建资源，更为本质的差别实在幂等性方面。</p>\n<blockquote>\n<p>所谓幂等性，如果一个操作执行一次和执行多次的后果是一样的，那么这个操作就具有幂等性。</p>\n<p>例如：GET获取多次，   无副作用，  具有幂等性</p>\n<p>​     DELETE删除多次，无副作用，  具有幂等性</p>\n<p>​     POST提交会创建不同的资源，  不具有幂等性（实例如下图）</p>\n<p>​     PUT是创建或更新，无副作用，  具有幂等性</p>\n</blockquote>\n<p><img src=\"http://images.rl0206.love/202304291651182.png\" alt=\"image-20230429165143109\"></p>\n<p><code>Demo：RESTfulApi:</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">package</span> com.imooc.bilibili.api;<br><br><span class=\"hljs-keyword\">import</span> org.springframework.web.bind.annotation.*;<br><span class=\"hljs-keyword\">import</span> java.util.Arrays;<br><span class=\"hljs-keyword\">import</span> java.util.HashMap;<br><span class=\"hljs-keyword\">import</span> java.util.Map;<br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * <span class=\"hljs-doctag\">@author</span> WLei224</span><br><span class=\"hljs-comment\"> * <span class=\"hljs-doctag\">@create</span> 2023/4/30 11:01</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-meta\">@RestController</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">RESTfulApi</span> &#123;<br>    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">final</span> Map&lt;Integer,Map&lt;String,Object&gt;&gt; dataMap;<br>    <span class=\"hljs-comment\">// 声明一个构造方法，同时初始化datamap，进行传参</span><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-title function_\">RESTfulApi</span><span class=\"hljs-params\">()</span> &#123;<br>        dataMap = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">HashMap</span>&lt;&gt;();<br><br>        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">i</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">1</span>; i &lt; <span class=\"hljs-number\">3</span>; i++) &#123;<br>            Map&lt;String,Object&gt; data = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">HashMap</span>&lt;&gt;();<br>            data.put(<span class=\"hljs-string\">&quot;id&quot;</span>,i);<br>            data.put(<span class=\"hljs-string\">&quot;name&quot;</span>,<span class=\"hljs-string\">&quot;name&quot;</span>+i);<br>            dataMap.put(i,data);<br>        &#125;<br>    &#125;<br>    <span class=\"hljs-comment\">// 开始写RESTful的相关方法</span><br>    <span class=\"hljs-meta\">@GetMapping(&quot;objects/&#123;id&#125;&quot;)</span><br>    <span class=\"hljs-keyword\">public</span> Map&lt;String,Object&gt; <span class=\"hljs-title function_\">getData</span><span class=\"hljs-params\">(<span class=\"hljs-meta\">@PathVariable</span> Integer id)</span>&#123;<br>        <span class=\"hljs-keyword\">return</span> dataMap.get(id);<br>    &#125;<br><br>    <span class=\"hljs-meta\">@DeleteMapping(&quot;objects/&#123;id&#125;&quot;)</span><br>    <span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title function_\">deleteData</span><span class=\"hljs-params\">(<span class=\"hljs-meta\">@PathVariable</span> Integer id)</span>&#123;<br>        dataMap.remove(id);<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&quot;Success&quot;</span>;<br>    &#125;<br><br>    <span class=\"hljs-meta\">@PostMapping(&quot;objects&quot;)</span><br>    <span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title function_\">postData</span><span class=\"hljs-params\">(<span class=\"hljs-meta\">@RequestBody</span> Map&lt;String,Object&gt; data)</span>&#123;<br>        Integer[] idArray = dataMap.keySet().toArray(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Integer</span>[<span class=\"hljs-number\">0</span>]);<br>        Arrays.sort(idArray);<br>        <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">nextId</span> <span class=\"hljs-operator\">=</span> idArray[idArray.length-<span class=\"hljs-number\">1</span>] + <span class=\"hljs-number\">1</span>;<br>        <span class=\"hljs-comment\">// data.put(&quot;id&quot;,nextId);</span><br>        <span class=\"hljs-comment\">// data.put(&quot;name&quot;,&quot;name&quot; + nextId);</span><br>        dataMap.put(nextId,data);<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&quot;Success!&quot;</span>;<br>    &#125;<br>\t<span class=\"hljs-comment\">// 区别就在于幂等性，存在则更新，不存在则新增</span><br>    <span class=\"hljs-meta\">@PutMapping(&quot;objects&quot;)</span><br>    <span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title function_\">putData</span><span class=\"hljs-params\">(<span class=\"hljs-meta\">@RequestBody</span> Map&lt;String,Object&gt; data)</span>&#123;<br>        <span class=\"hljs-type\">Integer</span> <span class=\"hljs-variable\">id</span> <span class=\"hljs-operator\">=</span> Integer.valueOf(String.valueOf(data.get(<span class=\"hljs-string\">&quot;id&quot;</span>)));<br>        Map&lt;String,Object&gt; hasData = dataMap.get(id);<br>        <span class=\"hljs-keyword\">if</span> (hasData == <span class=\"hljs-literal\">null</span>) &#123;<br>            Integer[] idArray = dataMap.keySet().toArray(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Integer</span>[<span class=\"hljs-number\">0</span>]);<br>            Arrays.sort(idArray);<br>            <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">nextId</span> <span class=\"hljs-operator\">=</span> idArray[idArray.length-<span class=\"hljs-number\">1</span>] + <span class=\"hljs-number\">1</span>;<br>            <span class=\"hljs-comment\">// data.put(&quot;id&quot;,nextId);</span><br>            <span class=\"hljs-comment\">// data.put(&quot;name&quot;,&quot;name&quot; + nextId);</span><br>            dataMap.put(nextId,data);<br>        &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>            dataMap.put(id,data);<br>        &#125;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&quot;Success!&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"RESTful接口URL命名原则：\"><a href=\"#RESTful接口URL命名原则：\" class=\"headerlink\" title=\"RESTful接口URL命名原则：\"></a>RESTful接口URL命名原则：</h3><blockquote>\n<p>1、HTTP方法后跟的URL必须是名词的复数形式</p>\n<p>2、URL总不采用大小写混合的驼峰命名，尽量全部小写，如果涉及多个单词，可用”-“连接</p>\n<p>3、示例：/users、/users-fans、 反例：/getUser、/getUserFans</p>\n</blockquote>\n<h3 id=\"RESTful接口URL分级原则\"><a href=\"#RESTful接口URL分级原则\" class=\"headerlink\" title=\"RESTful接口URL分级原则\"></a>RESTful接口URL分级原则</h3><blockquote>\n<p>1、一级用来定位资源分类，如：/users表示需要定位到用户相关资源</p>\n<p>2、二级仍用来定位具体某个资源，如：/users/20/fans/1表示id为20的用户的id为1的粉丝</p>\n</blockquote>\n<h3 id=\"RESTful接口命名示例\"><a href=\"#RESTful接口命名示例\" class=\"headerlink\" title=\"RESTful接口命名示例\"></a>RESTful接口命名示例</h3><p><img src=\"http://images.rl0206.love/202304301533812.png\" alt=\"image-20230430153315090\"></p>\n<p><img src=\"http://images.rl0206.love/202304301534235.png\" alt=\"image-20230430153406940\"></p>\n<h3 id=\"通用功能与配置\"><a href=\"#通用功能与配置\" class=\"headerlink\" title=\"通用功能与配置\"></a>通用功能与配置</h3><h4 id=\"通用功能：\"><a href=\"#通用功能：\" class=\"headerlink\" title=\"通用功能：\"></a><strong>通用功能：</strong></h4><p>加解密工具（<code>AES</code>、<code>RSA</code>、<code>MD5</code>）、json数据返回类</p>\n<p>顶层POM.xml添加commons-codec依赖，</p>\n<p>添加对应的工具包到service包的util包下</p>\n<blockquote>\n<p> <code>什么是AES加密</code></p>\n</blockquote>\n<p><code>AES:</code></p>\n<p><em>Advanced Encryption Standard</em>高级加密标准，是最常见的对称加密算法，对称加密即加解密只有一个密钥，可使用密钥恢复明文，加密速度非常快。</p>\n<p><code>使用场景：</code></p>\n<p>适合发送大量数据的场合。</p>\n<p><code>看下源码：</code></p>\n<p><img src=\"http://images.rl0206.love/202305191736417.png\" alt=\"image-20230519170635001\"></p>\n<blockquote>\n<p><code>什么是RSA加密？</code></p>\n</blockquote>\n<p><code>RSA:</code></p>\n<p>是一种非对称加密，即：有公钥与私钥之分，公钥用于数据加密，私钥用于数据解密，同样是可逆的，即可以通过私钥进行解密。公钥提供给外部进行使用，私钥放在服务器，保护数据安全。</p>\n<p><code>特点：</code></p>\n<p>加密安全性很高，但是加密速度非常之慢。</p>\n<p><code>使用场景：</code></p>\n<p>由特点可知，加密慢，但是安全。因此适合对加密次数要求较少的场景。例如：用户的登陆，加密一次，便不用加密，而且安全性还较高。</p>\n<p><code>拓展：非对称加密的流程是什么，在实际应用中是如何进行加密的？</code></p>\n<p>下面以用户注册登录场景为例，来说一下非对称加密在实际中的应用：</p>\n<p>因为RSA加密中的公钥是提供给外部进行加密使用的，用户在前端注册登录时，为了保证输入的密码其安全性（防止拦截后密码泄露），将公钥返回到前端，前端使用公钥进行加密，加密后的暗文通过接口然后传给后端，后端再通过私钥进行解密，得到密码。</p>\n<p><code>加解密源码：</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> String <span class=\"hljs-title function_\">encrypt</span><span class=\"hljs-params\">(String source)</span> <span class=\"hljs-keyword\">throws</span> Exception &#123;<br>\t<span class=\"hljs-type\">byte</span>[] decoded = Base64.decodeBase64(PUBLIC_KEY);<br>\t<span class=\"hljs-type\">RSAPublicKey</span> <span class=\"hljs-variable\">rsaPublicKey</span> <span class=\"hljs-operator\">=</span> (RSAPublicKey) KeyFactory.getInstance(<span class=\"hljs-string\">&quot;RSA&quot;</span>)<br>\t\t\t.generatePublic(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">X509EncodedKeySpec</span>(decoded));<br>\t<span class=\"hljs-type\">Cipher</span> <span class=\"hljs-variable\">cipher</span> <span class=\"hljs-operator\">=</span> Cipher.getInstance(<span class=\"hljs-string\">&quot;RSA&quot;</span>);<br>\tcipher.init(<span class=\"hljs-number\">1</span>, rsaPublicKey);<br>\t<span class=\"hljs-keyword\">return</span> Base64.encodeBase64String(cipher.doFinal(source.getBytes(StandardCharsets.UTF_8)));<br>&#125;<br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> String <span class=\"hljs-title function_\">decrypt</span><span class=\"hljs-params\">(String text)</span> <span class=\"hljs-keyword\">throws</span> Exception &#123;<br>\t<span class=\"hljs-type\">Cipher</span> <span class=\"hljs-variable\">cipher</span> <span class=\"hljs-operator\">=</span> getCipher();<br>\t<span class=\"hljs-type\">byte</span>[] inputByte = Base64.decodeBase64(text.getBytes(StandardCharsets.UTF_8));<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">String</span>(cipher.doFinal(inputByte));<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><code>最后说一下MD5加密：</code></p>\n<p><code>MD5：</code></p>\n<p>非对称加密，即不可逆，无法看到加密前的明文。</p>\n<p><code>特点：</code></p>\n<p>加密速度快，无需密钥，但是安全性不高需要搭配随机盐值使用。随机盐就是一个随机数，防止黑客将加密后的MD5还原回去。</p>\n<h4 id=\"通用配置：\"><a href=\"#通用配置：\" class=\"headerlink\" title=\"通用配置：\"></a><strong>通用配置：</strong></h4><p><code>Json信息转换配置 &amp;&amp; 全局异常处理配置</code></p>\n<blockquote>\n<p><code>JSON返回数据配置：</code></p>\n</blockquote>\n<p><code>什么是JSON？：JSON就是一种轻量化数据交换格式。</code></p>\n<p><code>为什么会用到JSON返回数据类和数据类转换呢？因为JSON轻量化，前端需要展示不同的数据格式时，这就需要用到JSON信息转换了。</code></p>\n<p>如何新建JSON信息转换配置？</p>\n<p>Service包下新建config包，用于放以后所有的配置类。</p>\n<p>此处涉及到Spring Boot相关的注解名，下面来说一下常见的注解：</p>\n<figure class=\"highlight txt\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs txt\">@Configuration：标志着Java文件是一个配置类，经常搭配@Bean使用，表示向上下文注入实体类，使其生效；<br>@Component：是@Configuration注解的内部注解，在Spring Boot启动阶段，自动的将Configuration<br>对应的文件注入到Sping Boot上下文；<br>@Bean：表示向上下文注入实体类，使其生效；<br></code></pre></td></tr></table></figure>\n\n<p><code>HttpMessageConverters：</code>是一个对Http方法，接收请求，或做转换的一个工具类框架，返回的就是一个@Bean类型，因为此方法是一个JSON类型，所以要引入一个fastJson依赖（目前世界行公认效率最高的工具包）。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span><br>\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>com.alibaba<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span><br>\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>fastjson<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span><br>\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>1.2.78<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<p>然后配置一些和fastjson相关的配置类。</p>\n<p>例如：配置相关的数据返回类型的时间格式、序列化的相关配置、</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">fastJsonConfig.setSerializerFeatures(<br>                <span class=\"hljs-comment\">// 格式化输出</span><br>                SerializerFeature.PrettyFormat,<br>                <span class=\"hljs-comment\">// 如果输出的数据是空的，那么系统会直接把这个数据去掉，不会在前端进行显示，这个配置项可以显示出一个空串</span><br>                SerializerFeature.WriteNullStringAsEmpty,<br>                <span class=\"hljs-comment\">// 功能同上，列表</span><br>                SerializerFeature.WriteNullListAsEmpty,<br>                <span class=\"hljs-comment\">// 同上，集合</span><br>                SerializerFeature.WriteMapNullValue,<br>                <span class=\"hljs-comment\">// 升序排列</span><br>                SerializerFeature.MapSortField,<br>                <span class=\"hljs-comment\">// 进制循环引用（防止循环引用后，输出多余的引用字符串） 非常有用的一个配置</span><br>                SerializerFeature.DisableCircularReferenceDetect<br>);<br></code></pre></td></tr></table></figure>\n\n<p>循环引用：</p>\n<p><img src=\"http://images.rl0206.love/202305201545971.png\" alt=\"image-20230520144308894\"></p>\n<blockquote>\n<p><code>全局异常处理配置：</code></p>\n</blockquote>\n<p>放在Service包下的handle包中，命名为全局异常处理类（<code>CommonGlobalExceptionHandler.class</code>）：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Java\"><span class=\"hljs-keyword\">package</span> com.imooc.bilibili.service.handler;<br><br><span class=\"hljs-keyword\">import</span> com.imooc.bilibili.dao.damain.JsonResponse;<br><span class=\"hljs-keyword\">import</span> com.imooc.bilibili.dao.damain.exception.ConditionException;<br><span class=\"hljs-keyword\">import</span> org.springframework.core.Ordered;<br><span class=\"hljs-keyword\">import</span> org.springframework.core.annotation.Order;<br><span class=\"hljs-keyword\">import</span> org.springframework.web.bind.annotation.ControllerAdvice;<br><span class=\"hljs-keyword\">import</span> org.springframework.web.bind.annotation.ExceptionHandler;<br><span class=\"hljs-keyword\">import</span> org.springframework.web.bind.annotation.ResponseBody;<br><br><span class=\"hljs-keyword\">import</span> javax.servlet.http.HttpServletRequest;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * <span class=\"hljs-doctag\">@author</span> WLei224</span><br><span class=\"hljs-comment\"> * <span class=\"hljs-doctag\">@create</span> 2023/5/20 16:38</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-meta\">@ControllerAdvice</span><br><span class=\"hljs-meta\">@Order(Ordered.HIGHEST_PRECEDENCE)</span> <span class=\"hljs-comment\">// 最高优先级</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">CommonGlobalExceptionHandler</span> &#123;<br><br>    <span class=\"hljs-meta\">@ExceptionHandler(value = Exception.class)</span><br>    <span class=\"hljs-meta\">@ResponseBody</span><br>    <span class=\"hljs-keyword\">public</span> JsonResponse&lt;String&gt; <span class=\"hljs-title function_\">commonExceptionHandler</span><span class=\"hljs-params\">(HttpServletRequest request, Exception e)</span>&#123;<br>        <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">errorMsg</span> <span class=\"hljs-operator\">=</span> e.getMessage();<br>        <span class=\"hljs-keyword\">if</span>(e <span class=\"hljs-keyword\">instanceof</span> ConditionException)&#123;<br>            <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">errorCode</span> <span class=\"hljs-operator\">=</span> ((ConditionException) e).getCode();<br>            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">JsonResponse</span>&lt;&gt;(errorCode,errorMsg);<br>        &#125;<span class=\"hljs-keyword\">else</span>&#123;<br>            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">JsonResponse</span>&lt;&gt;(<span class=\"hljs-string\">&quot;500&quot;</span>,errorMsg);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>在此之前，我定义了一个条件异常，并添加了状态码等信息，然后这个类的代码功能就是，抓取条件异常信息，然后通过<code>json数据返回类型jsonResponse</code>返回异常信息。 </p>\n<h3 id=\"用户注册与登录\"><a href=\"#用户注册与登录\" class=\"headerlink\" title=\"用户注册与登录\"></a>用户注册与登录</h3><p>数据库库表设计：用户表、用户信息表</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">CREATE</span> <span class=\"hljs-keyword\">TABLE</span> `t_user` (<br>  `id` <span class=\"hljs-type\">bigint</span>(<span class=\"hljs-number\">20</span>) <span class=\"hljs-keyword\">NOT</span> <span class=\"hljs-keyword\">NULL</span> AUTO_INCREMENT COMMENT <span class=\"hljs-string\">&#x27;主键&#x27;</span>,<br>  `phone` <span class=\"hljs-type\">varchar</span>(<span class=\"hljs-number\">100</span>) <span class=\"hljs-type\">CHARACTER</span> <span class=\"hljs-keyword\">SET</span> utf8mb4 <span class=\"hljs-keyword\">COLLATE</span> utf8mb4_0900_ai_ci <span class=\"hljs-keyword\">DEFAULT</span> <span class=\"hljs-keyword\">NULL</span> COMMENT <span class=\"hljs-string\">&#x27;手机号&#x27;</span>,<br>  `email` <span class=\"hljs-type\">varchar</span>(<span class=\"hljs-number\">100</span>) <span class=\"hljs-type\">CHARACTER</span> <span class=\"hljs-keyword\">SET</span> utf8mb4 <span class=\"hljs-keyword\">COLLATE</span> utf8mb4_0900_ai_ci <span class=\"hljs-keyword\">DEFAULT</span> <span class=\"hljs-keyword\">NULL</span> COMMENT <span class=\"hljs-string\">&#x27;邮箱&#x27;</span>,<br>  `password` <span class=\"hljs-type\">varchar</span>(<span class=\"hljs-number\">255</span>) <span class=\"hljs-type\">CHARACTER</span> <span class=\"hljs-keyword\">SET</span> utf8mb4 <span class=\"hljs-keyword\">COLLATE</span> utf8mb4_0900_ai_ci <span class=\"hljs-keyword\">DEFAULT</span> <span class=\"hljs-keyword\">NULL</span> COMMENT <span class=\"hljs-string\">&#x27;密码&#x27;</span>,<br>  `salt` <span class=\"hljs-type\">varchar</span>(<span class=\"hljs-number\">50</span>) <span class=\"hljs-type\">CHARACTER</span> <span class=\"hljs-keyword\">SET</span> utf8mb4 <span class=\"hljs-keyword\">COLLATE</span> utf8mb4_0900_ai_ci <span class=\"hljs-keyword\">DEFAULT</span> <span class=\"hljs-keyword\">NULL</span> COMMENT <span class=\"hljs-string\">&#x27;盐值&#x27;</span>,<br>  `createTime` datetime <span class=\"hljs-keyword\">DEFAULT</span> <span class=\"hljs-keyword\">NULL</span> COMMENT <span class=\"hljs-string\">&#x27;创建时间&#x27;</span>,<br>  `updateTime` datetime <span class=\"hljs-keyword\">DEFAULT</span> <span class=\"hljs-keyword\">NULL</span> COMMENT <span class=\"hljs-string\">&#x27;更新时间&#x27;</span>,<br>  <span class=\"hljs-keyword\">PRIMARY</span> KEY (`id`)<br>) ENGINE<span class=\"hljs-operator\">=</span>InnoDB AUTO_INCREMENT<span class=\"hljs-operator\">=</span><span class=\"hljs-number\">17</span> <span class=\"hljs-keyword\">DEFAULT</span> CHARSET<span class=\"hljs-operator\">=</span>utf8mb4 <span class=\"hljs-keyword\">COLLATE</span><span class=\"hljs-operator\">=</span>utf8mb4_0900_ai_ci COMMENT<span class=\"hljs-operator\">=</span><span class=\"hljs-string\">&#x27;用户表&#x27;</span>;<br><br><span class=\"hljs-keyword\">CREATE</span> <span class=\"hljs-keyword\">TABLE</span> `t_user_info` (<br>  `id` <span class=\"hljs-type\">bigint</span>(<span class=\"hljs-number\">20</span>) <span class=\"hljs-keyword\">NOT</span> <span class=\"hljs-keyword\">NULL</span> AUTO_INCREMENT COMMENT <span class=\"hljs-string\">&#x27;主键&#x27;</span>,<br>  `userId` <span class=\"hljs-type\">bigint</span>(<span class=\"hljs-number\">20</span>) <span class=\"hljs-keyword\">DEFAULT</span> <span class=\"hljs-keyword\">NULL</span> COMMENT <span class=\"hljs-string\">&#x27;用户id&#x27;</span>,<br>  `nick` <span class=\"hljs-type\">varchar</span>(<span class=\"hljs-number\">100</span>) <span class=\"hljs-keyword\">DEFAULT</span> <span class=\"hljs-keyword\">NULL</span> COMMENT <span class=\"hljs-string\">&#x27;昵称&#x27;</span>,<br>  `avatar` <span class=\"hljs-type\">varchar</span>(<span class=\"hljs-number\">255</span>) <span class=\"hljs-keyword\">DEFAULT</span> <span class=\"hljs-keyword\">NULL</span> COMMENT <span class=\"hljs-string\">&#x27;头像&#x27;</span>,<br>  `sign` text COMMENT <span class=\"hljs-string\">&#x27;签名&#x27;</span>,<br>  `gender` <span class=\"hljs-type\">varchar</span>(<span class=\"hljs-number\">2</span>) <span class=\"hljs-keyword\">DEFAULT</span> <span class=\"hljs-keyword\">NULL</span> COMMENT <span class=\"hljs-string\">&#x27;性别：0男 1女 2未知&#x27;</span>,<br>  `birth` <span class=\"hljs-type\">varchar</span>(<span class=\"hljs-number\">20</span>) <span class=\"hljs-keyword\">DEFAULT</span> <span class=\"hljs-keyword\">NULL</span> COMMENT <span class=\"hljs-string\">&#x27;生日&#x27;</span>,<br>  `createTime` datetime <span class=\"hljs-keyword\">DEFAULT</span> <span class=\"hljs-keyword\">NULL</span> COMMENT <span class=\"hljs-string\">&#x27;创建时间&#x27;</span>,<br>  `updateTime` datetime <span class=\"hljs-keyword\">DEFAULT</span> <span class=\"hljs-keyword\">NULL</span> COMMENT <span class=\"hljs-string\">&#x27;更新时间&#x27;</span>,<br>  <span class=\"hljs-keyword\">PRIMARY</span> KEY (`id`)<br>) ENGINE<span class=\"hljs-operator\">=</span>InnoDB AUTO_INCREMENT<span class=\"hljs-operator\">=</span><span class=\"hljs-number\">10</span> <span class=\"hljs-keyword\">DEFAULT</span> CHARSET<span class=\"hljs-operator\">=</span>utf8mb4 <span class=\"hljs-keyword\">COLLATE</span><span class=\"hljs-operator\">=</span>utf8mb4_0900_ai_ci COMMENT<span class=\"hljs-operator\">=</span><span class=\"hljs-string\">&#x27;用户基本信息表&#x27;</span>;<br></code></pre></td></tr></table></figure>\n\n<p>相关接口（API）：获取RSA公钥、用户注册、用户登录</p>\n<blockquote>\n<p>项目编写步骤：</p>\n<p>entity(domain)-&gt;dao（@Mapper交给MyBatis）-&gt;service(注入dao)-&gt;api(controller)注入service[先留一个bug]</p>\n<p>项目整体的逻辑：</p>\n<p>前端访问到我们的api接口层（也就是控制层）之后，会跳转到相关的业务逻辑层（service），在业务实现逻辑层中可能会用到与数据库之间的交互，那么service就会去访问dao层（数据持久层，放的是与数据库进行交互的接口），dao层通过@Mapper注解与MyBatis产生关联，通过MyBatis进行交互，交互的结果返回给service业务逻辑层，业务逻辑层返回给控制层接口，然后在前端体现了出来。</p>\n<p>以上层层嵌套的架构，可以让代码更加清晰、优雅。</p>\n</blockquote>\n<p>🆗，通过以上步骤，实体类已经新建好了，下面进行相关接口的业务逻辑书写</p>\n<ul>\n<li>获取RSA公钥</li>\n</ul>\n<p>@GetMapping</p>\n<ul>\n<li>用户注册</li>\n</ul>\n<p>@PostMapping</p>\n<p>同样是按照接口的编写顺序来进行coding，在@Api中写接口，service中写实现，</p>\n<ul>\n<li>用户登录</li>\n</ul>\n<h3 id=\"基于JWT的用户token验证\"><a href=\"#基于JWT的用户token验证\" class=\"headerlink\" title=\"基于JWT的用户token验证\"></a>基于JWT的用户token验证</h3><p><code>JWT</code>:<code>JSON Web Token</code>，<code>JWT</code>是一个规范，用于在空间受限环境下安全传递”声明”。</p>\n<p><strong>什么是声明呢？</strong></p>\n<p>声明分为三个部分：</p>\n<p>一、头部（header）</p>\n<p>​    声明的类型、声明的加密算法（通常使用SHA256）</p>\n<p>二、载荷（payload）</p>\n<p>​    用于存放有效信息的，一般包含签发者、所面向的用户、接受方、过期时间、签发时间以及唯一身份标识（userId）</p>\n<p>三、签名（signature）</p>\n<p>​    主要由头部、载荷、以及密钥组成加密而成</p>\n<p>JWT的优点：</p>\n<p>跨语言支持（因为<code>JWT</code>使用的是<code>JSON</code>数据格式，所以多语言都支持）、便于传输（见定义：空间受限的环境之下，说明<code>JWT</code>是数据量很小的，因此便于传输）、易于扩展（因为<code>JWT</code>有<code>payload</code>的部分，因为数据的分类很多、定制化强，可以通过<code>payload</code>进行数据添加，所以易于扩展）</p>\n<p>说到session之前，先来说一下基于session的用户验证：</p>\n<ul>\n<li>基于session的用户身份验证</li>\n<li>验证过程：服务端验证浏览器携带的用户名和密码，验证通过后生成用户凭证保存在服务端（session），浏览器再次访问时，服务端查询session，实现登陆状态保持。</li>\n<li>缺点：随着用户的增多，服务端的压力增大；若浏览器的cookie被第三方或者攻击者拦截，容易受到跨站请求伪造攻击；分布式系统下扩展不强（多台服务器部署应用，用户在不同的服务器进行访问，因为session不会共享，所以不会进行自动登录）。</li>\n</ul>\n<p>说到session验证，再来说一下token验证：</p>\n<ul>\n<li>基于token的用户验证</li>\n<li>验证过程：服务器端验证浏览器携带的用户名和密码，验证通过后，生成用户令牌（token），不同于session的一点是，服务端不会保存token，而会返回给浏览器，浏览器接收到token之后，进而写在浏览器的localstory中，那么什么是local story呢？localstory不同于cookie，它可以保存在本地，大小也比cookie大很多，所以在请求时就可以不用把token放在cookie中请求服务器，可以放在请求头中或者body中，这样就可以降低跨站请求拦截的风险，最后服务端拿到token之后进行校验是否正确，正确就证明是合法用户。</li>\n<li>优点：token不存储在服务器，不会造成服务器的压力；token可以存储在非cookie中的（local story），安全性更高；分布式系统下扩展性较强（token生成之后返回前端，前端拿到之后在请求服务端，服务端再对token进行验证即可）。</li>\n</ul>\n"},{"title":"Java Collection","index_img":"https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311151627635.png","excerpt":"你是怎么理解Java中的集合的？","abbrlink":48337,"date":"2022-09-07T00:58:32.000Z","_content":"![](https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/collection-1.png)\n\n## 怎么理解HashMap的数据结构呢？\n\n![](https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/collection-8.png)\n\nHashMap是一种基于哈希表实现的键值对数据结构，它通过哈希函数将键映射到哈希表的桶（bucket）中，并在桶中存储对应的值。HashMap的数据结构可以理解为一个由桶组成的数组和一个保存键值对数量的计数器。\n\n在HashMap中，每个桶都是一个链表或红黑树，用于解决哈希冲突。当多个键映射到同一个桶时，它们会被存储在同一个桶的链表或红黑树中，通过比较键的值来查找、插入和删除键值对。\n\n在HashMap中，每个键值对由一个键和一个值组成，其中键是唯一的。在插入键值对时，HashMap首先根据键的哈希值计算出对应的桶，然后在桶中进行查找，如果桶中已经存在相同的键，则更新对应的值，否则将新的键值对插入到桶的末尾或红黑树中。在查找键值对时，HashMap首先根据键的哈希值找到对应的桶，然后在桶中进行查找，如果找到则返回对应的值，否则返回null。\n\n由于哈希表的查找、插入和删除操作的时间复杂度通常为O(1)，因此HashMap在实现高效的键值对存储、查找和操作方面具有很好的性能。但是，由于哈希冲突的存在，HashMap的性能在数据集很大或者哈希函数不够均匀的情况下可能会受到影响。因此，在使用HashMap时需要注意选择合适的哈希函数，以避免哈希冲突和性能问题。\n\n> 如果还没有理解，就看下面的例子：\n\n我们可以把HashMap想象成一个盒子，里面可以放很多小球，每个小球都有一个编号和对应的颜色。我们可以通过编号来找到对应的小球的颜色。\n\n为了快速找到编号对应的小球，我们需要在盒子里面建立一个分布均匀的网格，把小球放在对应的网格里面。这个网格就是哈希表，而网格中的每个小格子就是哈希表的桶。\n\n当我们要找到某个编号对应的小球时，就可以通过哈希函数把编号转换成一个桶的位置，然后在对应的桶中查找对应的小球。如果找到了，则返回对应的颜色；如果没有找到，则返回null。\n\n如果多个小球的编号对应的桶位置相同，这就是哈希冲突。为了解决哈希冲突，我们可以在桶中建立一个链表，把编号对应的小球放在链表的末尾。这样，在查找时，我们可以遍历链表，找到对应的小球。\n\n当链表中的小球数量很多时，遍历链表的效率会变低，因此，我们可以把链表转换成红黑树，以提高查找效率。\n\n总之，HashMap的数据结构就是一个由桶组成的数组，每个桶中可以存储多个键值对。在查找、插入和删除键值对时，我们需要先通过哈希函数找到对应的桶，然后在桶中进行查找和操作。如果多个键映射到同一个桶，则在桶中使用链表或红黑树解决哈希冲突。","source":"_posts/collection.md","raw":"---\ntitle: Java Collection\nindex_img: https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311151627635.png\nexcerpt: 你是怎么理解Java中的集合的？\ncategories:\n  - Java notes\ntags:\n  - Java基础\nabbrlink: 48337\ndate: 2022-09-07 08:58:32\n---\n![](https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/collection-1.png)\n\n## 怎么理解HashMap的数据结构呢？\n\n![](https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/collection-8.png)\n\nHashMap是一种基于哈希表实现的键值对数据结构，它通过哈希函数将键映射到哈希表的桶（bucket）中，并在桶中存储对应的值。HashMap的数据结构可以理解为一个由桶组成的数组和一个保存键值对数量的计数器。\n\n在HashMap中，每个桶都是一个链表或红黑树，用于解决哈希冲突。当多个键映射到同一个桶时，它们会被存储在同一个桶的链表或红黑树中，通过比较键的值来查找、插入和删除键值对。\n\n在HashMap中，每个键值对由一个键和一个值组成，其中键是唯一的。在插入键值对时，HashMap首先根据键的哈希值计算出对应的桶，然后在桶中进行查找，如果桶中已经存在相同的键，则更新对应的值，否则将新的键值对插入到桶的末尾或红黑树中。在查找键值对时，HashMap首先根据键的哈希值找到对应的桶，然后在桶中进行查找，如果找到则返回对应的值，否则返回null。\n\n由于哈希表的查找、插入和删除操作的时间复杂度通常为O(1)，因此HashMap在实现高效的键值对存储、查找和操作方面具有很好的性能。但是，由于哈希冲突的存在，HashMap的性能在数据集很大或者哈希函数不够均匀的情况下可能会受到影响。因此，在使用HashMap时需要注意选择合适的哈希函数，以避免哈希冲突和性能问题。\n\n> 如果还没有理解，就看下面的例子：\n\n我们可以把HashMap想象成一个盒子，里面可以放很多小球，每个小球都有一个编号和对应的颜色。我们可以通过编号来找到对应的小球的颜色。\n\n为了快速找到编号对应的小球，我们需要在盒子里面建立一个分布均匀的网格，把小球放在对应的网格里面。这个网格就是哈希表，而网格中的每个小格子就是哈希表的桶。\n\n当我们要找到某个编号对应的小球时，就可以通过哈希函数把编号转换成一个桶的位置，然后在对应的桶中查找对应的小球。如果找到了，则返回对应的颜色；如果没有找到，则返回null。\n\n如果多个小球的编号对应的桶位置相同，这就是哈希冲突。为了解决哈希冲突，我们可以在桶中建立一个链表，把编号对应的小球放在链表的末尾。这样，在查找时，我们可以遍历链表，找到对应的小球。\n\n当链表中的小球数量很多时，遍历链表的效率会变低，因此，我们可以把链表转换成红黑树，以提高查找效率。\n\n总之，HashMap的数据结构就是一个由桶组成的数组，每个桶中可以存储多个键值对。在查找、插入和删除键值对时，我们需要先通过哈希函数找到对应的桶，然后在桶中进行查找和操作。如果多个键映射到同一个桶，则在桶中使用链表或红黑树解决哈希冲突。","slug":"collection","published":1,"updated":"2023-11-26T03:43:02.850Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clpkiczj0001nfkfo0m9x2hlg","content":"<p><img src=\"https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/collection-1.png\"></p>\n<h2 id=\"怎么理解HashMap的数据结构呢？\"><a href=\"#怎么理解HashMap的数据结构呢？\" class=\"headerlink\" title=\"怎么理解HashMap的数据结构呢？\"></a>怎么理解HashMap的数据结构呢？</h2><p><img src=\"https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/collection-8.png\"></p>\n<p>HashMap是一种基于哈希表实现的键值对数据结构，它通过哈希函数将键映射到哈希表的桶（bucket）中，并在桶中存储对应的值。HashMap的数据结构可以理解为一个由桶组成的数组和一个保存键值对数量的计数器。</p>\n<p>在HashMap中，每个桶都是一个链表或红黑树，用于解决哈希冲突。当多个键映射到同一个桶时，它们会被存储在同一个桶的链表或红黑树中，通过比较键的值来查找、插入和删除键值对。</p>\n<p>在HashMap中，每个键值对由一个键和一个值组成，其中键是唯一的。在插入键值对时，HashMap首先根据键的哈希值计算出对应的桶，然后在桶中进行查找，如果桶中已经存在相同的键，则更新对应的值，否则将新的键值对插入到桶的末尾或红黑树中。在查找键值对时，HashMap首先根据键的哈希值找到对应的桶，然后在桶中进行查找，如果找到则返回对应的值，否则返回null。</p>\n<p>由于哈希表的查找、插入和删除操作的时间复杂度通常为O(1)，因此HashMap在实现高效的键值对存储、查找和操作方面具有很好的性能。但是，由于哈希冲突的存在，HashMap的性能在数据集很大或者哈希函数不够均匀的情况下可能会受到影响。因此，在使用HashMap时需要注意选择合适的哈希函数，以避免哈希冲突和性能问题。</p>\n<blockquote>\n<p>如果还没有理解，就看下面的例子：</p>\n</blockquote>\n<p>我们可以把HashMap想象成一个盒子，里面可以放很多小球，每个小球都有一个编号和对应的颜色。我们可以通过编号来找到对应的小球的颜色。</p>\n<p>为了快速找到编号对应的小球，我们需要在盒子里面建立一个分布均匀的网格，把小球放在对应的网格里面。这个网格就是哈希表，而网格中的每个小格子就是哈希表的桶。</p>\n<p>当我们要找到某个编号对应的小球时，就可以通过哈希函数把编号转换成一个桶的位置，然后在对应的桶中查找对应的小球。如果找到了，则返回对应的颜色；如果没有找到，则返回null。</p>\n<p>如果多个小球的编号对应的桶位置相同，这就是哈希冲突。为了解决哈希冲突，我们可以在桶中建立一个链表，把编号对应的小球放在链表的末尾。这样，在查找时，我们可以遍历链表，找到对应的小球。</p>\n<p>当链表中的小球数量很多时，遍历链表的效率会变低，因此，我们可以把链表转换成红黑树，以提高查找效率。</p>\n<p>总之，HashMap的数据结构就是一个由桶组成的数组，每个桶中可以存储多个键值对。在查找、插入和删除键值对时，我们需要先通过哈希函数找到对应的桶，然后在桶中进行查找和操作。如果多个键映射到同一个桶，则在桶中使用链表或红黑树解决哈希冲突。</p>\n","site":{"data":{}},"more":"<p><img src=\"https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/collection-1.png\"></p>\n<h2 id=\"怎么理解HashMap的数据结构呢？\"><a href=\"#怎么理解HashMap的数据结构呢？\" class=\"headerlink\" title=\"怎么理解HashMap的数据结构呢？\"></a>怎么理解HashMap的数据结构呢？</h2><p><img src=\"https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/collection-8.png\"></p>\n<p>HashMap是一种基于哈希表实现的键值对数据结构，它通过哈希函数将键映射到哈希表的桶（bucket）中，并在桶中存储对应的值。HashMap的数据结构可以理解为一个由桶组成的数组和一个保存键值对数量的计数器。</p>\n<p>在HashMap中，每个桶都是一个链表或红黑树，用于解决哈希冲突。当多个键映射到同一个桶时，它们会被存储在同一个桶的链表或红黑树中，通过比较键的值来查找、插入和删除键值对。</p>\n<p>在HashMap中，每个键值对由一个键和一个值组成，其中键是唯一的。在插入键值对时，HashMap首先根据键的哈希值计算出对应的桶，然后在桶中进行查找，如果桶中已经存在相同的键，则更新对应的值，否则将新的键值对插入到桶的末尾或红黑树中。在查找键值对时，HashMap首先根据键的哈希值找到对应的桶，然后在桶中进行查找，如果找到则返回对应的值，否则返回null。</p>\n<p>由于哈希表的查找、插入和删除操作的时间复杂度通常为O(1)，因此HashMap在实现高效的键值对存储、查找和操作方面具有很好的性能。但是，由于哈希冲突的存在，HashMap的性能在数据集很大或者哈希函数不够均匀的情况下可能会受到影响。因此，在使用HashMap时需要注意选择合适的哈希函数，以避免哈希冲突和性能问题。</p>\n<blockquote>\n<p>如果还没有理解，就看下面的例子：</p>\n</blockquote>\n<p>我们可以把HashMap想象成一个盒子，里面可以放很多小球，每个小球都有一个编号和对应的颜色。我们可以通过编号来找到对应的小球的颜色。</p>\n<p>为了快速找到编号对应的小球，我们需要在盒子里面建立一个分布均匀的网格，把小球放在对应的网格里面。这个网格就是哈希表，而网格中的每个小格子就是哈希表的桶。</p>\n<p>当我们要找到某个编号对应的小球时，就可以通过哈希函数把编号转换成一个桶的位置，然后在对应的桶中查找对应的小球。如果找到了，则返回对应的颜色；如果没有找到，则返回null。</p>\n<p>如果多个小球的编号对应的桶位置相同，这就是哈希冲突。为了解决哈希冲突，我们可以在桶中建立一个链表，把编号对应的小球放在链表的末尾。这样，在查找时，我们可以遍历链表，找到对应的小球。</p>\n<p>当链表中的小球数量很多时，遍历链表的效率会变低，因此，我们可以把链表转换成红黑树，以提高查找效率。</p>\n<p>总之，HashMap的数据结构就是一个由桶组成的数组，每个桶中可以存储多个键值对。在查找、插入和删除键值对时，我们需要先通过哈希函数找到对应的桶，然后在桶中进行查找和操作。如果多个键映射到同一个桶，则在桶中使用链表或红黑树解决哈希冲突。</p>\n"},{"title":"csh","banner_img":"https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202308211940248.jpg","hide":true,"abbrlink":49364,"date":"2023-08-31T16:00:00.000Z","_content":"\n> 亲爱的CSH\n>\n> &nbsp;&nbsp;&nbsp;&nbsp;展信舒颜，见字如晤!\n>\n> &#160;&#160;&#160;&#160;没想到吧，我也没想到，哈哈哈哈！没想到什么呢？没想到提前收到了生日的手写信！你小子就偷着乐吧。\n>\n> &#160;&#160;&#160;&#160;首先，提前祝你17岁生日快乐，距离及冠之礼又近了一步啦（划重点，及冠之礼古时指几岁），只能远在百里外为你送上祝福！祝你脚踏实地、沉着冷静、去寻找宇宙中属于自己的光辉！弱小的人，才习惯嘲讽与否定，内心强大的人，从不吝啬赞美与鼓励。去寻找吧，立刻！我们定要活在鲜花与掌声之中。（划重点，表达的什么主旨？）\n>\n> &#160;&#160;&#160;&#160;进入正题，很荣幸能够以老师的身份给你传授知识与道理，通过那段时间，也让我们进一步了解到彼此有趣的灵魂。我很喜欢用“回首“二字，回首俯瞰往事，思考如何做的更好。好多人都以为自己什么道理都懂，其实不然，似乎我们懂得都是说不出来的道理、做不到的事情。所以并不是我们提前到达了不惑之年，这是假不惑，准确来说是拖延。\n>\n> &#160;&#160;&#160;&#160;为什么我们这个年纪要懂如此深奥的道理？不断探索未知领域！因为我们同处一条无岸河流，要想成功，我们只能奔涌（如何奔涌？）。所以[奔涌吧，后浪！](https://www.bilibili.com/video/BV1FV411d7u7?p=1&vd_source=37756bb794d3b4d975dc0cc76348a511)\n>\n> &#160;&#160;&#160;&#160;所以... ...(这很欧亨利！)\n>\n> &#160;&#160;&#160;&#160;写在最后，这就是今年特殊的生日礼物了，不要失望，绝对不是敷衍，我等你24年6月的好消息！\n>\n> <div>\n>   <div style=\"text-align: right;\">WL</div>\n>   <div style=\"text-align: right;\">2023年8月21日书</div>\n> </div>\t\t\t\t\t\t\t\t\t\n\n","source":"_posts/csh.md","raw":"---\ntitle: csh\nbanner_img: >-\n  https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202308211940248.jpg\nhide: true\nabbrlink: 49364\ndate: 2023-09-01 00:00:00\n---\n\n> 亲爱的CSH\n>\n> &nbsp;&nbsp;&nbsp;&nbsp;展信舒颜，见字如晤!\n>\n> &#160;&#160;&#160;&#160;没想到吧，我也没想到，哈哈哈哈！没想到什么呢？没想到提前收到了生日的手写信！你小子就偷着乐吧。\n>\n> &#160;&#160;&#160;&#160;首先，提前祝你17岁生日快乐，距离及冠之礼又近了一步啦（划重点，及冠之礼古时指几岁），只能远在百里外为你送上祝福！祝你脚踏实地、沉着冷静、去寻找宇宙中属于自己的光辉！弱小的人，才习惯嘲讽与否定，内心强大的人，从不吝啬赞美与鼓励。去寻找吧，立刻！我们定要活在鲜花与掌声之中。（划重点，表达的什么主旨？）\n>\n> &#160;&#160;&#160;&#160;进入正题，很荣幸能够以老师的身份给你传授知识与道理，通过那段时间，也让我们进一步了解到彼此有趣的灵魂。我很喜欢用“回首“二字，回首俯瞰往事，思考如何做的更好。好多人都以为自己什么道理都懂，其实不然，似乎我们懂得都是说不出来的道理、做不到的事情。所以并不是我们提前到达了不惑之年，这是假不惑，准确来说是拖延。\n>\n> &#160;&#160;&#160;&#160;为什么我们这个年纪要懂如此深奥的道理？不断探索未知领域！因为我们同处一条无岸河流，要想成功，我们只能奔涌（如何奔涌？）。所以[奔涌吧，后浪！](https://www.bilibili.com/video/BV1FV411d7u7?p=1&vd_source=37756bb794d3b4d975dc0cc76348a511)\n>\n> &#160;&#160;&#160;&#160;所以... ...(这很欧亨利！)\n>\n> &#160;&#160;&#160;&#160;写在最后，这就是今年特殊的生日礼物了，不要失望，绝对不是敷衍，我等你24年6月的好消息！\n>\n> <div>\n>   <div style=\"text-align: right;\">WL</div>\n>   <div style=\"text-align: right;\">2023年8月21日书</div>\n> </div>\t\t\t\t\t\t\t\t\t\n\n","slug":"csh","published":1,"updated":"2023-10-16T06:58:59.281Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clpkiczj1001rfkfogsqg41dj","content":"<blockquote>\n<p>亲爱的CSH</p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;展信舒颜，见字如晤!</p>\n<p>&#160;&#160;&#160;&#160;没想到吧，我也没想到，哈哈哈哈！没想到什么呢？没想到提前收到了生日的手写信！你小子就偷着乐吧。</p>\n<p>&#160;&#160;&#160;&#160;首先，提前祝你17岁生日快乐，距离及冠之礼又近了一步啦（划重点，及冠之礼古时指几岁），只能远在百里外为你送上祝福！祝你脚踏实地、沉着冷静、去寻找宇宙中属于自己的光辉！弱小的人，才习惯嘲讽与否定，内心强大的人，从不吝啬赞美与鼓励。去寻找吧，立刻！我们定要活在鲜花与掌声之中。（划重点，表达的什么主旨？）</p>\n<p>&#160;&#160;&#160;&#160;进入正题，很荣幸能够以老师的身份给你传授知识与道理，通过那段时间，也让我们进一步了解到彼此有趣的灵魂。我很喜欢用“回首“二字，回首俯瞰往事，思考如何做的更好。好多人都以为自己什么道理都懂，其实不然，似乎我们懂得都是说不出来的道理、做不到的事情。所以并不是我们提前到达了不惑之年，这是假不惑，准确来说是拖延。</p>\n<p>&#160;&#160;&#160;&#160;为什么我们这个年纪要懂如此深奥的道理？不断探索未知领域！因为我们同处一条无岸河流，要想成功，我们只能奔涌（如何奔涌？）。所以<a href=\"https://www.bilibili.com/video/BV1FV411d7u7?p=1&vd_source=37756bb794d3b4d975dc0cc76348a511\">奔涌吧，后浪！</a></p>\n<p>&#160;&#160;&#160;&#160;所以… …(这很欧亨利！)</p>\n<p>&#160;&#160;&#160;&#160;写在最后，这就是今年特殊的生日礼物了，不要失望，绝对不是敷衍，我等你24年6月的好消息！</p>\n<div>\n  <div style=\"text-align: right;\">WL</div>\n  <div style=\"text-align: right;\">2023年8月21日书</div>\n</div>                                    \n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>亲爱的CSH</p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;展信舒颜，见字如晤!</p>\n<p>&#160;&#160;&#160;&#160;没想到吧，我也没想到，哈哈哈哈！没想到什么呢？没想到提前收到了生日的手写信！你小子就偷着乐吧。</p>\n<p>&#160;&#160;&#160;&#160;首先，提前祝你17岁生日快乐，距离及冠之礼又近了一步啦（划重点，及冠之礼古时指几岁），只能远在百里外为你送上祝福！祝你脚踏实地、沉着冷静、去寻找宇宙中属于自己的光辉！弱小的人，才习惯嘲讽与否定，内心强大的人，从不吝啬赞美与鼓励。去寻找吧，立刻！我们定要活在鲜花与掌声之中。（划重点，表达的什么主旨？）</p>\n<p>&#160;&#160;&#160;&#160;进入正题，很荣幸能够以老师的身份给你传授知识与道理，通过那段时间，也让我们进一步了解到彼此有趣的灵魂。我很喜欢用“回首“二字，回首俯瞰往事，思考如何做的更好。好多人都以为自己什么道理都懂，其实不然，似乎我们懂得都是说不出来的道理、做不到的事情。所以并不是我们提前到达了不惑之年，这是假不惑，准确来说是拖延。</p>\n<p>&#160;&#160;&#160;&#160;为什么我们这个年纪要懂如此深奥的道理？不断探索未知领域！因为我们同处一条无岸河流，要想成功，我们只能奔涌（如何奔涌？）。所以<a href=\"https://www.bilibili.com/video/BV1FV411d7u7?p=1&vd_source=37756bb794d3b4d975dc0cc76348a511\">奔涌吧，后浪！</a></p>\n<p>&#160;&#160;&#160;&#160;所以… …(这很欧亨利！)</p>\n<p>&#160;&#160;&#160;&#160;写在最后，这就是今年特殊的生日礼物了，不要失望，绝对不是敷衍，我等你24年6月的好消息！</p>\n<div>\n  <div style=\"text-align: right;\">WL</div>\n  <div style=\"text-align: right;\">2023年8月21日书</div>\n</div>                                    \n</blockquote>\n"},{"title":"API开放平台","index_img":"https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311151627634.png","banner_img":"https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311151627632.png","excerpt":"项目介绍：前端开发的时候有有时会需要后端的接口，如果此时有一个 API 接口可以使用，那么就无需后端接口了。本项目是一个提供 API 接口调用的平台，用户可以注册与登录，开通接口的调用权限，用户可以使用接口，每次调用会进行次数统计。管理院可以发布接口、下线接口、接入接口，以及可视化接口的调用情况。","sticky":100,"abbrlink":2239,"date":"2023-06-03T04:34:12.000Z","_content":"\n# API开放平台\n\n> 写在最前面：\n>\n> ​\t学到的知识与收到的建议：\n>\n> \t1. 把自己所有的数据库建表语句总结到一起，后续有用；\n> \t1. 记录Bug文档\n> \t1. 多记录一些需求的解决方案、提高自己的架构能力\n\n## 项目介绍\n\n> 前端开发的时候有有时会需要后端的接口，如果此时有一个API接口可以使用，那么就无需后端借口了\n\n一个提供API接口调用的平台，用户可以注册与登录，开通接口的调用权限，用户可以使用接口，每次调用会进行次数统计。管理院可以发布接口、下线接口、接入接口，以及可视化接口的调用情况。\n\n\n\n一个API接口平台：\n\n1. 防止攻击\n2. 使用限制\n3. 统计调用次数\n4. 计费\n5. 流量保护\n6. API接入\n\n## 预计完成时间\n\n5-6周\n\n## 业务流程\n\n前台、SDK、API网关、模拟接口、后台    共五个子模块\n\n**难点**：思想\n\n## 技术选型\n\n* 前端\n  * Ant Design Pro\n  * React\n  * Ant Design Pro Components\n  * Umi\n  * Umi Request（Axios的封装）--请求库（前后端联调）\n* 后端\n  * Spring Boot\n  * Spring Boot Stater（SDK开发）--可以发布到maven仓库----**简历亮点**\n  * ？？？？？？（网关、限流、日志实现）\n\n## 项目计划\n\n### Day01--项目初始化\n\n项目介绍、设计、技术选型\n\n基础项目的搭建\n\n接口管理\n\n用户查看接口的权限\n\n\n\n### Day02--接口调用\n\n1. 继续开发接口管理前端页面 15min\n2. 开发模拟API接口 5min\n3. 开发调用接口的代码 10-20min\n4. 保证调用的安全性（API签名认证） 15min\n5. 客户端SDK的开发 15min\n6. 管理员接口的发布与调用 15min\n7. 接口文档的展示、接口在线调用 15min\n\n\n\n### Day03--接口计费与保护\n\n统计用户调用次数\n\n限流\n\n计费\n\n日志\n\n开通\n\n### Day04--管理员统计分析\n\n提供可视化平台，展示所有接口的调用情况，便于管理价格\n\n接口预警\n\n\n\n\n\n## Day01 需求分析\n\n1. 管理员可以对接口信息进行增删改查\n\n2. 用户可以访问前台，查看接口信息\n\n### 今日计划\n\n1. 项目脚手架搭建（初始化项目）10分钟前端、5-10分钟后端 \n1. 管理员可以对接口信息进行增删改查\n1. 用户可以访问前台，查看接口的信息\n\n\n\n\n\n\n\n\n\n### 项目初始化（前后端）\n\n* ### 前端\n\n1. 使用Ant Design Pro提供的`pro-cli`来快速的初始化脚手架。\n\n   ```bash\n   # 查看node和npm版本\n   建议16和8\n   # 使用 npm\n   npm i @ant-design/pro-cli -g\n   pro create myapi-frontend\n   # 下载项目所需要的依赖\n   yarn\n   此时可能会遇到node版本要求的问题，因为版本更新迭代的原因，我当时要求的是使用16.14.0的node版本，\n   如果感觉切换node版本麻烦的话，这里推荐使用nvm（node的版本管理工具），使用方法自行百度\n   ```\n\n2. 项目瘦身\n\n\t遇到了一个大坑，星球的球友们也都遇到了，下面是球友的解决方法，亲测有效。\n\n   ```bash\n   # 关闭ESLint中与Prettier重复的规则，确保代码格式化的一致性\n   yarn add eslint-config-prettier --dev\n   # 用于检查和修复JavaScript代码中的常见问题\n   yarn add eslint-plugin-unicorn --dev\n   ```\n### 项目去除国际化存在问题的解决方法\n\n![image-20230630231124235](https://cdn.jsdelivr.net/gh/wl2o2o/blogCdn/img/202307010940465.png)\n\n​\tjest脚本命令中有`jest`不知道是否需要删掉，鱼皮的文件中没有出现，可能是跟某些版本有关，奇奇妙妙，记录一下\n\n![image-20230630233743871](https://cdn.jsdelivr.net/gh/wl2o2o/blogCdn/img/202307010940466.png)\n\n* ### 后端\n\n3. 后端项目初始化\n\n​\t直接使用鱼总提供的万能模板`springboot-init`,改成项目的名字，然后全局搜索关键字进行替换\n\n​\t连接数据库\n\n​\t测试运行\n\n4. 数据库库表设计\n\n​\t**接口信息表**\n\n```sql\n# 数据库初始化\n# @author <a href=\"https://github.com/liyupi\">程序员鱼皮</a>\n# @from <a href=\"https://yupi.icu\">编程导航知识星球</a>\n-- 创建库\ncreate database if not exists myapi;\n\n-- 切换库\nuse myapi;\n\n-- 用户表\ncreate table if not exists user\n(\n    id           bigint auto_increment comment 'id' primary key,\n    userName     varchar(256)                           null comment '用户昵称',\n    userAccount  varchar(256)                           not null comment '账号',\n    userAvatar   varchar(1024)                          null comment '用户头像',\n    gender       tinyint                                null comment '性别',\n    userRole     varchar(256) default 'user'            not null comment '用户角色：user / admin',\n    userPassword varchar(512)                           not null comment '密码',\n    `accessKey` varchar(512) not null comment 'accessKey',\n    `secretKey` varchar(512) not null comment 'secretKey',\n    createTime   datetime     default CURRENT_TIMESTAMP not null comment '创建时间',\n    updateTime   datetime     default CURRENT_TIMESTAMP not null on update CURRENT_TIMESTAMP comment '更新时间',\n    isDelete     tinyint      default 0                 not null comment '是否删除',\n    constraint uni_userAccount\n        unique (userAccount)\n) comment '用户';\n\n-- 接口信息\ncreate table if not exists myapi.`interface_info`\n(\n    `id` bigint not null auto_increment comment '主键' primary key,\n    `name` varchar(256) not null comment '名称',\n    `description` varchar(256) null comment '描述',\n    `url` varchar(512) not null comment '接口地址',\n    `requestHeader` text null comment '请求头',\n    `responseHeader` text null comment '响应头',\n    `status` int default 0 not null comment '接口状态（0-关闭，1-开启）',\n    `method` varchar(256) not null comment '请求类型',\n    `userId` bigint not null comment '创建人',\n    `createTime` datetime default CURRENT_TIMESTAMP not null comment '创建时间',\n    `updateTime` datetime default CURRENT_TIMESTAMP not null on update CURRENT_TIMESTAMP comment '更新时间',\n    `isDelete` tinyint default 0 not null comment '是否删除(0-未删, 1-已删)'\n) comment  '接口信息';\n\n-- 用户调用接口关系表\ncreate table if not exists myapi.`user_interface_info`\n(\n    `id` bigint not null auto_increment comment '主键' primary key,\n    `userId` bigint not null comment '调用用户 id',\n    `interfaceInfoId` bigint not null comment '接口 id',\n    `totalNum` int default 0 not null comment '总调用次数',\n    `leftNum` int default 0 not null comment '剩余调用次数',\n    `status` int default 0 not null comment '0-正常，1-禁用',\n    `createTime` datetime default CURRENT_TIMESTAMP not null comment '创建时间',\n    `updateTime` datetime default CURRENT_TIMESTAMP not null on update CURRENT_TIMESTAMP comment '更新时间',\n    `isDelete` tinyint default 0 not null comment '是否删除(0-未删, 1-已删)'\n) comment '用户调用接口关系';\n\ninsert into myapi.`interface_info` (`name`, `description`, `url`, `requestHeader`, `responseHeader`, `status`, `method`, `userId`) values ('许擎宇', '薛聪健', 'www.cary-king.net', '潘博涛', '谭聪健', 0, '石炫明', 9500534531);\ninsert into myapi.`interface_info` (`name`, `description`, `url`, `requestHeader`, `responseHeader`, `status`, `method`, `userId`) values ('陆弘文', '白志强', 'www.leslee-kuhn.net', '潘懿轩', '马鸿涛', 0, '陈峻熙', 3982575846);\ninsert into myapi.`interface_info` (`name`, `description`, `url`, `requestHeader`, `responseHeader`, `status`, `method`, `userId`) values ('毛建辉', '罗文', 'www.rosaria-kilback.io', '冯子默', '彭哲瀚', 0, '赵远航', 121776355);\ninsert into myapi.`interface_info` (`name`, `description`, `url`, `requestHeader`, `responseHeader`, `status`, `method`, `userId`) values ('彭雨泽', '蔡煜祺', 'www.norris-bergstrom.biz', '董思源', '田晓博', 0, '潘擎宇', 740);\ninsert into myapi.`interface_info` (`name`, `description`, `url`, `requestHeader`, `responseHeader`, `status`, `method`, `userId`) values ('傅志强', '陈梓晨', 'www.jordan-reinger.com', '金志强', '熊锦程', 0, '邓睿渊', 35542559);\ninsert into myapi.`interface_info` (`name`, `description`, `url`, `requestHeader`, `responseHeader`, `status`, `method`, `userId`) values ('吕黎昕', '孔越彬', 'www.fe-okon.info', '万伟宸', '林昊然', 0, '孟荣轩', 1445);\ninsert into myapi.`interface_info` (`name`, `description`, `url`, `requestHeader`, `responseHeader`, `status`, `method`, `userId`) values ('夏雪松', '许子骞', 'www.lashawna-legros.co', '蔡昊然', '胡鹏涛', 0, '钟立辉', 34075514);\ninsert into myapi.`interface_info` (`name`, `description`, `url`, `requestHeader`, `responseHeader`, `status`, `method`, `userId`) values ('严钰轩', '阎志泽', 'www.kay-funk.biz', '莫皓轩', '郭黎昕', 0, '龚天宇', 70956);\ninsert into myapi.`interface_info` (`name`, `description`, `url`, `requestHeader`, `responseHeader`, `status`, `method`, `userId`) values ('萧嘉懿', '曹熠彤', 'www.margarette-lindgren.biz', '田泽洋', '邓睿渊', 0, '梁志强', 98);\ninsert into myapi.`interface_info` (`name`, `description`, `url`, `requestHeader`, `responseHeader`, `status`, `method`, `userId`) values ('杜驰', '冯思源', 'www.vashti-auer.org', '黎健柏', '武博文', 0, '李伟宸', 9);\ninsert into myapi.`interface_info` (`name`, `description`, `url`, `requestHeader`, `responseHeader`, `status`, `method`, `userId`) values ('史金鑫', '蔡鹏涛', 'www.diann-keebler.org', '徐烨霖', '阎建辉', 0, '李烨伟', 125);\ninsert into myapi.`interface_info` (`name`, `description`, `url`, `requestHeader`, `responseHeader`, `status`, `method`, `userId`) values ('林炫明', '贾旭尧', 'www.dotty-kuvalis.io', '梁雨泽', '龙伟泽', 0, '许智渊', 79998);\ninsert into myapi.`interface_info` (`name`, `description`, `url`, `requestHeader`, `responseHeader`, `status`, `method`, `userId`) values ('何钰轩', '赖智宸', 'www.andy-adams.net', '崔思淼', '白鸿煊', 0, '邵振家', 7167482751);\ninsert into myapi.`interface_info` (`name`, `description`, `url`, `requestHeader`, `responseHeader`, `status`, `method`, `userId`) values ('魏志强', '于立诚', 'www.ione-aufderhar.biz', '朱懿轩', '万智渊', 0, '唐昊强', 741098);\ninsert into myapi.`interface_info` (`name`, `description`, `url`, `requestHeader`, `responseHeader`, `status`, `method`, `userId`) values ('严君浩', '金胤祥', 'www.duane-boyle.org', '雷昊焱', '侯思聪', 0, '郝思', 580514);\ninsert into myapi.`interface_info` (`name`, `description`, `url`, `requestHeader`, `responseHeader`, `status`, `method`, `userId`) values ('姚皓轩', '金鹏', 'www.lyda-klein.biz', '杜昊强', '邵志泽', 0, '冯鸿涛', 6546);\ninsert into myapi.`interface_info` (`name`, `description`, `url`, `requestHeader`, `responseHeader`, `status`, `method`, `userId`) values ('廖驰', '沈泽洋', 'www.consuelo-sipes.info', '彭昊然', '邓耀杰', 0, '周彬', 7761037);\ninsert into myapi.`interface_info` (`name`, `description`, `url`, `requestHeader`, `responseHeader`, `status`, `method`, `userId`) values ('赖智渊', '邓志泽', 'www.emerson-mann.co', '熊明哲', '贺哲瀚', 0, '田鹏', 381422);\ninsert into myapi.`interface_info` (`name`, `description`, `url`, `requestHeader`, `responseHeader`, `status`, `method`, `userId`) values ('许涛', '陆致远', 'www.vella-ankunding.name', '贾哲瀚', '莫昊焱', 0, '袁越彬', 4218096);\ninsert into myapi.`interface_info` (`name`, `description`, `url`, `requestHeader`, `responseHeader`, `status`, `method`, `userId`) values ('吕峻熙', '沈鹏飞', 'www.shari-reichel.org', '郭鸿煊', '覃烨霖', 0, '熊黎昕', 493);\n\n```\n\n\n\n> 留一个小bug，数据库建表语句直接套用的最终建表语句，user表中涉及到两个关于key的字段，手动改成了可以为空，若有问题，后续再做出更改\n\n> 利用`MyBatisX`插件生成接口管理的增删改查代码\n\n将生成的代码逻辑复制到项目的dao、service、mapper包里，\n\n然后还剩一个controller层，直接复制一份模板中的controller层的代码，进行复用\n\n注意此时模糊查询使用的字段不是content，而是description，进行相应的更改。\n\n此时，增删改查操作已完成，就这么简单 \n\n跑通后端\n\n* ### 前端\n\n使用oneapi插件自动生成（openapi规范）\n\n![image-20230701235258820](https://cdn.jsdelivr.net/gh/wl2o2o/blogCdn/img/202307012353984.png)\n\n\n\n> 先前，我们登陆时是采用的start假数据进行登录，此时使用dev，登陆页面是存在问题的，因为脚手架自动生成的页面会强制要求登录，此时的登录接口与我们oneapi自动生成的接口对应不上，需要手动进行更改User》》Login》》index.tsx\n>\n\n因为没有开发注册页面，可以从注册中心项目中复制一个过来\n\n为了便捷的进行开发，先从swagger注册一个账号，然后登录发现没有进行跳转，通过分析得出，是因为前端没有记录用户的登录状态，所以要进一步进行完善，在typings.d.ts中进行定义全局登录态\n\n\n\n改造页面，将前端展示的表格，用来展示自己的数据\n\n\n\n\n\n## Day02 接口调用开发（前端）\n\n> 首先发现一个问题，使用后端swagger进行user密码更改的时候，密码没有进行加密，会导致前端进行校验的时候返回用户名或者密码不正确的信息\n\n* ### 优化前端展示页面（改路由，先不删）\n\n  * 保持前后端组件名一致\n  * 优化页面代码\n  * 首页没有页面，后续进行开发一个非管理员用户可以看到的页面\n  * 调整导航栏的位置，可以先使用antDesignPro框架提供的切换导航布局小设置\n  \n* ### 新建模态框的编写真的很搞心态，最后的原因竟然是因为一个小的错误（静下心来）（血泪教训，做完项目过一遍react）\n\n* ### 完善修改框\n\n  * 此处设计到React的核心知识点，也是重中之重（useEffect、useRef）\n\n  * ```tsx\n    const formRef = useRef<ProFormInstance>();\n    \n    useEffect(() => {\n      if(formRef){\n        formRef.current?.setFieldsValue(values);\n      } \n    }, [values])\n    \n    return (\n        <Modal visible={visible} footer={null} onCancel={() => onCancel?.()}>\n          <ProTable\n            type=\"form\"\n            columns={columns}\n            // 因为这里使用的form组件，只会初始化一次，所以会造成点击修改按钮进行修改的话，数据是不会变的\n            // form={{\n            //   initialValues: values\n            // }}\n            \n            // 所以此处用到了监听\n            formRef={formRef}\n            \n            onSubmit={async (value) => {\n              onSubmit?.(value);\n            }}\n          />\n        </Modal>\n      );\n    ```\n\n  * > 此处有Bug，后端报空指针\n\n\n* ### 完善删除框\n\n  * 仿照以上步骤完成\n\n  * > 此时发现进行相关操作之后数据不会自动更新，所以我们引入actionRef，它可以拿到proTable的控制权，使用actionRef.current?.reload()\n\n\n\n\n\n### 模拟接口项目（smartapi-interface）（后端）\n\n提供三个模拟接口\n\n1. GET接口\n2. POST接口（url传参）\n3. POST接口（Restful）\n\n\n\n\n\n### 开始开发模拟接口项目部分\n\n采用创建几个controller控制层小接口，前端传参进行调用，但是这样不符合逻辑，所以我们要通过后端来进行传参！\n\n\n\n### 开发调用接口\n\n几种HTTP调用方式\n\n\t1. HttpClient\n\t1. RestTemplete\n\t1. 工具（OKHttp、HuTool）\n\n这里我们使用HuTool来进行调用[HuTool](https://hutool.cn/docs/#/)\n\n\n\n参考文档是一个好东西，利用好\n\n\n\n那么现在已经开发好调用接口了，但是用户调用你的接口，或者黑客黑你的接口，所以需要对调用者进行一个调用限制，那么如何加以限制？\n\n这时可以联想一下我们平时调用第三方接口时，都会有一些key\n\n\n\n### API 签名认证（客户端与服务端有点迷惑，后续捋顺）\n\n\n\n**本质：**\n\n1. 签发签名\n\n\t2. 使用签名(校验签名)\n\n\n\n**为什么需要？**\n\n1. 保证安全性，不能随便一个人就可以调用\n\n\n\n**怎么实现？（复杂、无序、无规律）**\n\n通过http request header头传递参数。\n\n参数1：assesKey：调用的标识（一串无规则字符串） User A、B\n\n参数2：secretKey：相当于密码\n\n也就是用户名和密钥，区别就是ak、sk是无状态的\n\n在服务端数据库表中新增以上两个字段，用户客户端进行校验。\n\n\n\n\n\n但是这样的方法时容易被拦截的，不能把密钥直接在服务器之间进行传递，要进行加密。所以要对密码进一步进行加密。\n\n\n\n参数3：用户请求参数（更严格）\n\n\n\n参数4：sign\n\n加密方式：对称机密、非对称加密、不可解密加密（MD5）\n\n\n\n用户参数 + 密钥 ==》 **签名生成算法** ==》不可解密的值\n\nwl + abcdefgh ==》afdasfafszv（通过签名算法加密）\n\n那么如何知道这个签名是否正确？\n\n**服务端会通过用一摸一样的参数和算法去生成签名，只要和用户才能属的签名一致，则正确!**\n\n\n\n\n\n**怎么防重放？**\n\n参数5：加nonce随机数，保证只能用一次，但是服务端也要保存随机数\n\n参数6：timestamp时间戳（加上时间戳可以保证随机数可以清除）\n\n**API签名认证是一个很灵活的设计，具体要有哪些参数、参数名一定要根据实际场景来（比如userId、appId、version、固定值等）**\n\n\n\n思考：难道开发者每次调用接口都需要自己来写签名算法吗？\n\n\n\n\n\n\n\n\n\n### 开发一个简单易用的SDK\n\n\n\n理想情况：开发者只需要关心调用哪些接口、传递哪些参数，就跟调用自己的代码一样简单。\n\n\n\n开发stater的好处：\n\n1. 开发者引入之后，可以直接在application.yml中写配置，自动创建客户端。\n\n\n\n### 创建SDK项目（开发starter）（简历亮点）\n\n引入依赖：\n\n1. lombook\n2. Spring Configuration Processor（自动生成配置文件写代码的提示）\n\n\n\n改造pom依赖，一定要删掉build标签内的代码，因为我们在进行构建依赖包，不是要直接运行的jar的项目\n\n\n\n\n\n尝试把打好的包发布到maven中\n\n\n\n\n\n\n\n\n\n## Day03 接口保护与优化\n\n\n\n> 此时，我们发现鱼总的后端项目模块中已经包含前面单独创建好的SDK和interface模拟接口项目了，那么我们如何把这两个添加到后端的项目中呢？\n>\n> 方案一：\n>\n> ​\t受尚医通项目的影响，我想应该可以通过增加子模块的方法拉进行添加，但是添加之后好像是不太行，跟鱼总的不一样，这种方法应该是可以使多个项目在同一个窗口中打开（解决了之前我的疑虑）\n>\n> 方案二：\n>\n> ​\t我们看到鱼总的后端项目中，另外两个项目（SDK和interface）是两个目录的标识，于是我就直接复制粘贴到后端项目的文件夹中了，然后Java源文件会变成红J，可以通过右键rsc下main下的Java文件夹，然后mark Directory as--》Sources Root，将Java文件夹标记为源码根目录，如图所示：\n>\n> ![image-20230708205543307](https://cdn.jsdelivr.net/gh/wl2o2o/blogCdn/img/202307092023528.png)\n>\n> 然后我们发现maven的pom依赖文件的图标也不对，也通过桐言的方法，右键--》add maven project标记为maven项目，大功告成！\n\n1.开发接口发布/下线的功能（管理员）\n\n2.前端浏览接口，查看 接口文档，申请签名（注册）\n\n3.在线测试（用户）\n\n4.统一用户调用接口次数\n\n5.优化系统-API网关\n\n### 开发接口发布/下线的功能（仅管理员） \n\n> 此处又涉及到了一个待学知识点：\n>\n> Spring的AOP切面应用\n>\n> 可以用来通过注解的方式进行权限管理。\n\n### 后端接口： \n\n**发布接口**（仅管理员） \n\n1.校验该接口是否存在\n\n2.判断接口是否可以被调用\n\n​\t利用开发好的SDK，通过调用接口看是否能够进行调用的通\n\n​\t第一步：启动smartapi-interface项目\n\n​\t第二步：在smartapi-backend中引入SDK的依赖\n\n​\t第三步：在application.yml中写入ak、sk\n\n​\t第四步：在接口中引入客户端的实例\n\n​\t\t\t@Resource\n\n​\t\t\tprivate SmartApiClient smartapiclient\n\n> TODO:\n>\n> > >  1. 判断接口是否可以调用时，由固定方法名改为可以根据测试地址进行调用\n> > >  2. 用户测试接口判断接口是否可以调用时，由固定方法名改为可以根据测试地址进行调用\n\n3.修改数据库接口字段为1\n\n**下线接口**（仅管理员） \n\n1.校验该接口是否存在\n\n2.修改数据库接口字段为 0\n\n按钮已添加并完善。测试中出现一个经典问题，如图所示：\n\n![image-20230710000821503](https://cdn.jsdelivr.net/gh/wl2o2o/blogCdn/img/202307100008989.png)\n\n\n\n> 待办事件：\n>\n> 流程：\n>\n> \n>\n> **前端**添加上线、下线按钮、√、增加用户浏览页面、查看接口文档、申请签名\n>\n> **后端**申请签名（更改完善数据库写生成签名的算法）\n>\n> **前端**\n>\n> 新增在线调用的按钮\n>\n> **后端**\n>\n> 开发在线调用的接口\n>\n> \n\n\n\n\n\n\n\n### 前端浏览接口\n\n```react\nimport { PageContainer } from '@ant-design/pro-components';\nimport React, {useEffect, useState} from 'react';\nimport {List, message} from \"antd\";\nimport {\n  listInterfaceInfoByPageUsingGET\n} from \"@/services/smartapi-backend/interfaceInfoController\";\n\n\n/**\n * 主页\n * @constructor\n */\nconst Index: React.FC = () => {\n\n  const [loading, setLoading] = useState(false);\n  const [list, setList] = useState<API.InterfaceInfo[]>([]);\n  const [total ,setTotal] = useState<number>(0);\n\n  const loadData = async (current=1 , pageSize = 8 ) =>{\n    setLoading(true);\n    try {\n      const res = await listInterfaceInfoByPageUsingGET({\n        current,pageSize\n      });\n      setList(res?.data?.records ?? []);\n      setTotal(res?.data?.total ?? 0);\n\n    } catch (error: any) {\n\n      message.error('请求失败,'+error.message);\n      return false;\n    }\n    setLoading(false);\n  }\n  useEffect(() => {\n    loadData();\n  },[])\n\n\n  return (\n    <PageContainer title=\"在线接口开放平台\">\n      <List\n        className=\"my-list\"\n        loading={loading}\n        itemLayout=\"horizontal\"\n        dataSource={list}\n        renderItem={item => {\n\n          const apiLink =`/interface_info/${item.id}`;\n          return(\n            <List.Item\n              actions={[<a key={item.id} href={apiLink}>查看</a>]}\n            >\n              <List.Item.Meta\n                title={<a href={apiLink}>{item.name}</a>}\n                description={item.description}\n              />\n            </List.Item>\n          )\n        }\n\n        }\n        pagination ={\n          {\n            // eslint-disable-next-line @typescript-eslint/no-shadow\n            showTotal(total: number){\n              return '总数：' +total;\n            },\n            pageSize: 8,\n            total,\n            onChange(page,pageSize){\n              loadData(page,pageSize);\n            }\n          }\n        }\n      />\n    </PageContainer>\n  );\n};\n\nexport default Index;\n```\n\n### 查看接口文档\n\n```react\nimport { PageContainer } from '@ant-design/pro-components';\nimport React, {useEffect, useState} from 'react';\nimport {Card, Descriptions, message} from \"antd\";\nimport {\n  getInterfaceInfoByIdUsingGET,\n\n} from \"@/services/smartapi-backend/interfaceInfoController\";\nimport { useParams} from \"@@/exports\";\n\n\n/**\n * 主页\n * @constructor\n */\nconst Index: React.FC = () => {\n\n  const [loading, setLoading] = useState(false);\n  const [data, setData] = useState<API.InterfaceInfo>();\n  const params  = useParams();\n\n  const loadData = async () =>{\n    if (!params.id){\n      message.error('参数不存在');\n      return ;\n    }\n    setLoading(true);\n    try {\n      const res = await getInterfaceInfoByIdUsingGET({\n        id: Number(params.id)\n      });\n      setData(res.data);\n\n    } catch (error: any) {\n\n      message.error('请求失败,'+error.message);\n      return false;\n    }\n    setLoading(false);\n  }\n  useEffect(() => {\n    loadData();\n  },[])\n\n  return (\n    <PageContainer title=\"查看接口文档\">\n      <Card>\n        {\n          data?(\n            <Descriptions title={data.name} column={1}>\n              <Descriptions.Item label=\"描述\">{data.description}</Descriptions.Item>\n              <Descriptions.Item label=\"接口状态\">{data.status? '正常': '关闭'}</Descriptions.Item>\n              <Descriptions.Item label=\"请求地址\">{data.url}</Descriptions.Item>\n              <Descriptions.Item label=\"请求方法\">{data.method}</Descriptions.Item>\n              <Descriptions.Item label=\"请求头\">{data.requestHeader}</Descriptions.Item>\n              <Descriptions.Item label=\"响应头\">{data.responseHeader}</Descriptions.Item>\n              <Descriptions.Item label=\"创建时间\">{data.createTime}</Descriptions.Item>\n              <Descriptions.Item label=\"更新时间\">{data.updateTime}</Descriptions.Item>\n            </Descriptions>\n          ):(\n            <>接口不存在</>\n          )}\n      </Card>\n    </PageContainer>\n  );\n};\n\nexport default Index;\n```\n\n### 申请签名（注册） \n\n通过数据库新增字段、更改用户注册的逻辑（使用DigestUtil加密算法生成ak、sk，然后加入数据库）\n\n> 留一个小作业:\n>\n> 新增一个小拓展功能：用户可以手动更改自己的ak、sk\n\n### 新建真实数据（前端）\n\n**新建这些真实的数据**\n\n```text\ngetUsernameByPost,\n\n获取用户名,\n\nhttp://localhost:8123/name/user,\n\n{”Content-Type“: ”application/json“},\n\n{”Content-Type“: ”application/json“},\n\n```\n\noh my god，此时发现遗忘了一个重要的请求参数字段，于是通过建表语句、IDEA客户端modify table，来增加这么一个字段。\n\n修改相应的model实体包中的字段信息以及向mybatisplus.xml中添加这个字段。\n\n重启项目---》前端重新使用openai插件生成接口\n\n前端也需要完善修改组件的表单列名，新增一个requestParams\n\n完成！\n\n**完善接口信息的请求参数信息**\n\n**在线调用**\n\n前端界面的编写，通过ant design组件库利用现成的表单组件来完成在线按钮的添加与请求参数的基本表单。\n\n![image-20230710023831281](https://cdn.jsdelivr.net/gh/wl2o2o/blogCdn/img/202307100238354.png)\n\n请求参数的类型（JSON类型）\n\n> 又一个小作业：\n>\n> 在线调用的扩展点：\n>\n> 先跑通整个流程，然后根据请求头和请求类型的不同设计不同的表单和界面，增强用户体验\n\n\n\n### 后端调用流程\n\n![image-20230710024253445](https://cdn.jsdelivr.net/gh/wl2o2o/blogCdn/img/202307100242406.png)\n\n按照标准的企业开发流程来说：\n\n一定会选择第一种开发方式，不然后期的网关与计费就毫无作用，\n\n第二种方式可以用来自己调用测试。\n\n\n\n流程：\n\n1. 前端将用户输入的请求参数与要进行测试的接口id发给平台后端\n2. 在调用前进行一些校验\n3. 平台后端去调用模拟接口\n\n```Java\n/**\n     * 测试调用\n     *\n     * @param interfaceInfoInvokeRequest\n     * @param request\n     * @return\n     */\n    @PostMapping(\"/invoke\")\n    public BaseResponse<Object> invokeInterfaceInfo(@RequestBody InterfaceInfoInvokeRequest interfaceInfoInvokeRequest,\n                                                    HttpServletRequest request) {\n        if (interfaceInfoInvokeRequest == null || interfaceInfoInvokeRequest.getId() <= 0) {\n            throw new BusinessException(ErrorCode.PARAMS_ERROR);\n        }\n        long id = interfaceInfoInvokeRequest.getId();\n        String userRequestParams = interfaceInfoInvokeRequest.getUserRequestParams();\n        // 判断是否存在\n        InterfaceInfo oldInterfaceInfo = interfaceInfoService.getById(id);\n        if (oldInterfaceInfo == null) {\n            throw new BusinessException(ErrorCode.NOT_FOUND_ERROR);\n        }\n        if (oldInterfaceInfo.getStatus() == InterfaceInfoStatusEnum.OFFLINE.getValue()) {\n            throw new BusinessException(ErrorCode.PARAMS_ERROR, \"接口已关闭\");\n        }\n        User loginUser = userService.getLoginUser(request);\n        String accessKey = loginUser.getAccessKey();\n        String secretKey = loginUser.getSecretKey();\n        MyClient tempClient = new MyClient(accessKey, secretKey);\n        Gson gson = new Gson();\n        com.wl.smartapiclientsdk.model.User user = gson.fromJson(userRequestParams, com.wl.smartapiclientsdk.model.User.class);\n        String usernameByPost = tempClient.getUserNameByPost(user);\n        return ResultUtils.success(usernameByPost);\n    }\n```\n\n后端调用逻辑已完成\n\n现在继续完善前端的接口，将前端点击调用按钮后改为我们刚才通过后端实现的真实的功能。\n\n```\nconst onFinish = (values: any) => {\n    if (!params.id){\n      message.error('接口不存在');\n      return ;\n    }\n    try {\n      invokeInterfaceInfoUsingPOST({\n        id: params.id,\n        ...values\n      })\n      message.success('请求成功');\n      return true;\n    } catch (error: any) {\n      message.error('请求失败，' + error.message);\n    }\n  };\n```\n\n逻辑打通之后还要进行回显数据：\n\n```\n// async 是设置同步的意思\n\n const onFinish = async (values: any) => {\n    if (!params.id){\n      message.error('接口不存在');\n      return ;\n    }\n    try {\n// 等待\n\n      const res = await invokeInterfaceInfoUsingPOST({\n        id: params.id,\n        ...values\n      })\n// 将res.data赋给setInvokeRes\n\n      setInvokeRes(res.data);\n      message.success('请求成功');\n      return true;\n    } catch (error: any) {\n      message.error('请求失败，' + error.message);\n    }\n  };\n```\n\n然后在表单处新增一个卡片，用于接收invokeRes进行数据回显。\n\n已完成，测试通过！\n\n并且完善了一个缓冲显示的loading\n\n\n\nTODO:\n\n> >  1. 判断接口是否可以调用时，由固定方法名改为可以根据测试地址进行调用\n> >  2. 用户测试接口判断接口是否可以调用时，由固定方法名改为可以根据测试地址进行调用\n> >  3. 此时任何人调用模拟接口都是可以的，因为我们的SDK是写死在配置文件中的，所以后续再进行完善，从数据库中进行校验！\n\n\n\nover！\n\n下面我们的网关用Spring Cloud GateWay实现\n\n\n\n## Day04 \n\n1. 开发接口调用次数统计  20min\n\n2. 优化系统的架构---学习架构设计、接触应用场景==>面对一个需求就会自然而然地提高开发效率。 60min\n\n   （怎么把一个项目的架构设计做的更加合理，涉及到API网关的知识）\n\n   * 网关是什么？\n   * 网关的作用？\n   * 网关的应用场景以及实现？\n   * 结合业务去应用网关\n\n### 接口调用次数统计\n\n需求：\n\n\t1. 用户每次调用接口成功，次数加1（或者设定一定的调用次数，每次减1）\n\t1. 给用户分配或者用户自助申请接口调用次数\n\n> 业务流程：\n>\n> 1. 用户调用接口（之前已完成）\n> 2. 修改数据库，调用次数（加1或者减1）\n\n设计库表：\n\n> 哪个用户？哪个接口？\n>\n> 用户 => 接口（多对多）\n\n用户接口关系表：\n\n```\n-- 用户调用接口关系表\ncreate table if not exists smartapi.`user_interface_info`\n(\n    `id` bigint not null auto_increment comment '主键' primary key,\n    `userId` bigint not null comment '调用用户 id',\n    `interfaceInfoId` bigint not null comment '接口 id',\n    `totalNum` int default 0 not null comment '总调用次数',\n    `leftNum` int default 0 not null comment '剩余调用次数',\n    `status` int default 0 not null comment '0-正常，1-禁用',\n    `createTime` datetime default CURRENT_TIMESTAMP not null comment '创建时间',\n    `updateTime` datetime default CURRENT_TIMESTAMP not null on update CURRENT_TIMESTAMP comment '更新时间',\n    `isDelete` tinyint default 0 not null comment '是否删除(0-未删, 1-已删)'\n) comment '用户调用接口关系';\n```\n\n### 步骤：\n\n1. 开发基本的增删改查（给管理员使用）\n\n   > 直接使用Mybatis-X生成相关的实体类（注意在删除字段上米娜加上逻辑删除@TableLogic）、mapper、service实现类没然后移动到项目对应的包中。\n   >\n   > 复制写好的Controller，改那些增删改查！ 完成√\n\n2. 开发用户调用接口次数加1（或者减1）\n\n   问：如果每个接口的方法，都写调用次数 + 1，是不是比较麻烦，如果在本项目中，将这个调用次数+ 1，封装成一个方法，也是可以的，但是`代码侵入性很强！`\n\n   致命问题是：接口开发者需要自己进行调用！\n\n   解决方法：\n\n   1. Spring中的AOP（推荐，是Spring的一个核心特性）\n   2. Servelet中的拦截器、过滤器（Fillter）\n   3. 通用的方法（缺点：代码侵入性强，需要自己调用）\n   4. 网关\n\n\n\n简单说一下AOP切面的基本过程：\n\n> 先说一下AOP切面的作用：\n>\n> 就相当于在接口或者方法调用前或者调用之后帮你做一些事情，其底层的原理就是动态代理。\n>\n> 使用AOP切面的\n>\n> 优点：\n>\n> 独立于接口，在每个接口调用前后加 1\n>\n> 缺点：\n>\n> 只存在于单个项目中，如果每个团队都要写一个自己的切面\n>\n> // TODO：下去看一下AOP的流程，熟悉一下\n\n\n\n我们在这个项目中使用网关来实现接口调用次数。\n\n网关就当与在所有接口的入口前加了一层检票口，如图所示：\n\n![image-20230716015231451](https://cdn.jsdelivr.net/gh/wl2o2o/blogCdn/img/202307160152994.png)\n\n因为网关实现的有调用次数的统计，所以开发者可以通关网关来查看，而用户调用接口时直接输入请求参数、请求地址即可。\n\n### 网关：\n\n这里为什么写这么多理论呢？写代码不一定是最重要的，重要的是思想！逻辑思想明白之后，无非就是看文档、百度实现。\n\n> 什么是网关呢？就相当于车票检票口，统一去检票。\n>\n> 优点？统一去进行一些操作、处理一些问题。\n>\n> 作用？\n>\n> 1. 路由\n>\n> 2. 负载均衡\n>\n> 3. 统一鉴权\n>\n> 4. 统一处理跨域\n>\n> 5. 统一业务处理（缓存）\n>\n> 6. 访问控制\n>\n> 7. 发布控制（灰度发布，也就是慢慢控制接口的流量，不断开放给更多用户，然后达到升级接口的目的）\n>\n> 8. 流量染色（给流量添加一些标识，比如新的请求头信息）\n>\n> 9. 统一接口保护 \n>\n>    1. 限制请求\n>\n>    2. 信息脱敏（网关可以操作你的请求口，进而抹去敏感信息）\n>\n>    3. 降级（熔断，保险起见，接口下线后，可以返回一些提示信息）\n>\n>    4. 限流\n>\n>       （// TODO：学习令牌桶算法，学习露桶算法，学习一下）\n>\n>    5. RedislimitHandler\n>\n>    6. 超时时间\n>\n>    7. 重试（业务保护）\n>\n> 10. 统一日志\n>\n> 11. 统一文档（将下游项目的文档统一聚合，展示到一个页面）\n\n\n\n### 路由\n\n起到转发的作用，比如有接口A和接口B,网关会记录这些信息，根据用户访问的地址和参数，转发请求到对应的接口（服务器/集群）\n\n用户a调用接口A\n\n/a=>接口A /b=>接口B\n\nhttps://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#gateway-request-predicates-factories\n\n### 负载均衡 \n\n在路由的基础上可以转发到某一个服务器\n\n/c => 服务A/ 集群A（随机转发到其中的某一个机器）\n\nuri从固定地址改成b:xx\n\n### 统一鉴权 \n\n判断用户是否有权限进行操作，无论访问什么接口，我都统一去判断权限，不用重复写\n\n### 统一处理跨域 \n\n网关统一处理跨域，不用在每个项目单独处理\n\nhttps://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#cors-configuration\n\n### 统一业务处理 \n\n把每个项目中都要做的通用逻辑放到上层（网关），统一处理，比如本项目的次数统计\n\n### 访问控制 \n\n黑白名单，比如限制ddos ip\n\n### 发布控制 \n\n灰度发布，比如上线新接口，先给新接口分配 20%流量，老接口80% ,再慢慢调整比例\n\nhttps://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#the-weight-route-predicate- factory\n\n### 流量染色 \n\n区分用户来源\n\n给请求（流量）添加一些标识，一般是设置请求头中，添加新的请求头 https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#the-addrequestheader-gatewayfilter-factory\n\n全局染色：https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#default-filters\n\n### 接口保护 \n\n1 限制请求 https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#requestheadersiz-gatewayfilter-factory \n\n2 信息脱敏 https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#the-removerequestheader-gatewayfilter-factory \n\n3 降级（熔断） 进行兜底 https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#fallback-headers \n\n4 限流 https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#the-requestratelimiter-gatewayfilter-factory \n\n5 超时时间   超时就中断 https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#http-timeouts-configuration \n\n6 重试（业务保护）： https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#the-retry-gatewayfilter-factory \n\n### 统一日志 \n\n统一的请求，响应信息记录\n\n### 统一文档 \n\n将下游项目的文档进行聚合，在一个页面统一查看\n\n建议用：https://doc.xiaominfo.com/docs/middleware-sources/,aggregation-introduction\n\n\n### 网关的分类\n\n1. 全局网关（接入层网关）：作用是负载均衡、请求日志，不和业务逻辑绑定\n\n2. 业务网关（微服务网关：会有一些业务逻辑）：作用是根据不同的请求转发到不同的项目接口\n\n   参考文章：https://blog.csdn.net/qq21040559/article/,details/,122961395\n\n### 实现\n\n1. Nginx（推荐的全局型网关）\n\n2. Kong网关（适合API网关）--收费！！\n\n3. `Spring Cloud Gateway`（取代了Zuul，因为架构设计并不太好，并发量也有限）\n\n   > 优点：用到了NIO、多路复用、底层Netty、React模型；\n   >\n   > 最大的亮点：可以用Java代码写逻辑，其他网关都需要学习一些其他语言（Nginx需要学到一些Lua脚本）\n\n网关技术选型：https://zhuanlan.zhihu.com/p/500587132\n\n### Spring Cloud Gateway用法\n\n官网是最好的老是去看官网\n\n去看官网：https://spring.io/projects/spring-cloud-gateway\n\n官方文档：https://docs.spring.io/spring-cloud-gateway/docs/current/reference//html/\n\n\n\n\n\n### 创建一个Gateway项目\n\n小作业：完成官网的小demo（编程式demo）\n\n\n\n\n\n## Day05 把API网关应用到项目中\n\n任务：\n\n1. 完成统一的用户鉴权、统一的接口调用次数统计（API网关应用）\n2. 完善功能\n\n\n\n### 将用到的特性\n\n1. 路由（转发请求到模拟接口项目）\n\n2. ~~负载均衡（需要用到注册中心）~~\n3. 统一鉴权(accessKey，secretKey)\n4. 统一处理跨域\n5. 统一业务处理（每次请求接口后，接口调用次数+1）\n6. 访问控制（黑白名单）\n7. ~~发布控制~~\n8. 流量染色(记录请求是否为网关来的)\n9. ~~统一接口保护~~ \n   1. 限制请求\n   2. 信息脱敏\n   3. 降级（熔断）\n   4. 限流 学习令牌桶算法，学习露桶算法，学习一下RedislimitHandler\n   5. 超时时间\n   6. 重试（业务保护）\n10. 统一日志(记录每次的请求和响应)\n11. ~~统一文档~~\n\n\n\n### 业务逻辑\n\n> 为什么会用到API网关？\n>\n> 结合架构图来说，简单来说也就是加一个检票口，同时也可以添加流量染色、链路追踪的功能、灰度发布等等。。。\n\n1. 用户发送请求到API网关（请求转发）\n2. *请求日志*\n3. *黑白名单*\n4. 用户鉴权（如何？判断ak、sk）\n5. 请求的模拟接口是否存在？\n6. 请求转发，调用模拟接口\n7. 响应日志\n8. 调用成功，接口调用次数 + 1\n9. 调用失败，返回规范错误码\n\n\n\n### 实现\n\n1. **请求转发**\n\n   [使用前缀匹配断言](https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#the-path-route-predicate-factory)\n\n   所有路径为：`/api/**` 的请求转发，转发到http://localhost:8123/api/**\n\n   比如：\n\n   请求于http://localhost:8090/api/name/get?/name=wlei224\n\n   转发到http://localhost:8123/api/name/get?/name=wlei224\n\n```yaml\nspring:\n  cloud:\n    gateway:\n      routes:\n      - id: path_route\n        uri: https://example.org\n        predicates:\n        - Path=/red/{segment},/blue/{segment}\n```\n\n2. 其他业务逻辑\n\n> ​\ttodo：Spring注解\t  @component\n\n​\t使用Spring Cloud Gateway中的GlobalFilter实现请求拦截处理（类似于AOP）\n\n​\t![image-20230725194819206](https://cdn.jsdelivr.net/gh/wl2o2o/blogCdn/img/202307251948339.png)\n\n​\t[GlobalFilter](https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#gateway-combined-global-filter-and-gatewayfilter-ordering)直接复制代码到网关项目的全局异常类中。\n\n​\t验证通过√\n\n2. 正式开始写业务逻辑\n\n> 1. 用户发送请求到API网关（请求转发）√\n>\n>    代码能运行到这个controller业务逻辑层，就说明用户已经发送了请求\n>\n> 2. *请求日志*\n>\n>    ![image-20230728115938432](https://cdn.jsdelivr.net/gh/wl2o2o/blogCdn/img/202307281159504.png)\n>\n>    我们发现请求参数中含有一个交换机，于是可以试着从这里找到request请求，拿到请求头中的信息；\n>\n>    添加`@Slf4j`注解，用log.info在控制台输出请求头日志；\n>\n> 3. *黑白名单*\n>\n>    在权限管理业务中一般设置的是白名单，这样只有允许的才可以进行访问，更加安全！\n>\n>    在IDEA中直接敲`prsf`写一个白名单常量。\n>\n>    ```Java\n>    // 2. 访问控制 -- 设置黑白名单（可以用设置响应状态码来实现）\n>    ServerHttpResponse response = exchange.getResponse();\n>    if(!IP_WHITE_LIST.contains(sourceAdress)) {\n>        // handleNoAuth(response);\n>        response.setStatusCode(HttpStatus.FORBIDDEN);\n>    \treturn response.setComplete();\n>    }\n>    ```\n>\n>    \n>\n> 4. 用户鉴权（如何？判断ak、sk）\n>\n>    ```java\n>    //  用户鉴权（如何？判断ak、sk）\n>    HttpHeaders headers = request.getHeaders();\n>    String accessKey = headers.getFirst(\"accessKey\");\n>    String nonce = headers.getFirst(\"nonce\");\n>    String timeStamp = headers.getFirst(\"timeStamp\");\n>    String sign = headers.getFirst(\"sign\");\n>    String body = headers.getFirst(\"body\");\n>    // TODO 要去数据库中查询\n>    // 为了方便进行校验，直接进行判断数据，正规来说应该从数据库中进行校验数据\n>    if (!\"wl\".equals(accessKey)){\n>        // throw new RuntimeException(\"无权限！\");\n>        // 封装了一个方法，专门用于处理异常请求\n>        return handleNoAuth(response);\n>    }\n>    if (Long.parseLong(nonce) > 10000L){\n>    \treturn handleNoAuth(response);\n>    }\n>                                                                                                                   \n>    //  时间戳校验自己实现，时间和当前时间不能超过5min\n>    Long currentTime = System.currentTimeMillis() / 1000;\n>    Long FIVE_MINUTES = 60 * 5L;\n>    if ((currentTime-Long.parseLong(timeStamp)) >= FIVE_MINUTES) {\n>    \treturn handleNoAuth(response);\n>    }\n>                                                                                                                   \n>    // TODO 要去数据库中查询\n>    String serverSign = SignUtils.getSign(body, \"abcdefgh\");\n>    if (!serverSign.equals(sign)) {\n>    \tthrow new RuntimeException(\"无权限！\");\n>    }\n>    ```\n>\n>    \n>\n> 5. 请求的模拟接口是否存在？\n>\n>    // TODO 从数据库中进行查询接口是否存在，以及请求方法是否匹配（严格的话可以再校验一下请求参数，但是业务层面的请求参数不建议放到全局请求网关里面）\n>    // 因为数据库的访问方法已经再backend中已经写过，操作较为复杂的话不建议重复写，所以我们可以采用远程调用的方式（也就是可以说是微服务，这个项目完全可以写成微服务：`OpenFeigh`，目前项目的定位还是`分布式项目`结合微服务的远程调用，避免重复写业务逻辑）\n>\n>    \n>\n> 6. 请求转发，调用模拟接口\n>\n>    ```java\n>    Mono<Void> filter = chain.filter(exchange);\n>    ```\n>\n>    \n>\n> 7. 响应日志\n>\n>    ```java\n>    log.info(\"响应：\" + response.getStatusCode());\n>    ```\n>\n>    \n>\n> 8. 调用成功，接口调用次数 + 1\n>\n>    ```java\n>    // TODO invokeCount\n>    ```\n>\n> 9. 调用失败，返回规范错误码\n>\n>    ```Java\n>    // 用户鉴权异常\n>        public Mono<Void> handleNoAuth(ServerHttpResponse response) {\n>            response.setStatusCode(HttpStatus.FORBIDDEN);\n>            return response.setComplete();\n>        }\n>        // 自定义错误异常\n>        public Mono<Void> handleInvokeError(ServerHttpResponse response) {\n>            response.setStatusCode(HttpStatus.INTERNAL_SERVER_ERROR);\n>            return response.setComplete();\n>        }\n>    ```\n>\n>    \n>\n\n* 为了方便进行业务逻辑的编写，我们可以向上面一样，将提前编写好的业务流程粘贴到类文件中。\n\n\n\n### 测试\n\n通过测试我们发现，通过http://127.0.0.1:8090/api/name/get?name=wl进行访问时，还是会遭到拒绝，为什么呢？此时不是请求头丢失，而是我们根本就没写请求头，跑通这个逻辑的话，可以从前端进行调用测试。\n\n![image-20230803025109861](https://cdn.jsdelivr.net/gh/wl2o2o/blogCdn/img/202308030251719.png)\n\n### 🧑‍💻业务逻辑预期结果：\n\n等模拟接口调用完成，才记录响应日志、统计调用次数。\n\n### 存在问题：\n\n> 虽然上述代码可以跑通，但是还存在一个问题，我们通过debug模式可以看到，代码在执行到请求转发的`Mono<Void> filter = chain.filter(exchange);`方法后，并没有进入到方法中，反而是继续执行下面的代码，直到`chain.filter`方法之后才进入模拟接口方法中。\n>\n> `原因：`\n>\n> chain.filter是个异步操作，可以理解为前端的promise\n>\n> `解决方案：`\n>\n> 利用Spring Cloud Gateway提供的自定义响应装饰器中的response装饰者，以次增强原有response的处理能力\n>\n> 引申：什么叫装饰者设计模式？\n>\n> ​\t作用就是：在原本类的基础上对原有类的能力的增强，也就可以理解为给response买了一件装备，拥有了更多的能力。解释成代码语言意思就是，增写response部分代码，实现需要的功能。\n>\n> `参考博客：` \n>\n> https://blog.csdn.net/qq_19636353/article/details/126759522  (以这个为主) \n>\n> `其他参考：` \n>\n> https://blog.csdn.net/m0_67595943/article/details/124667975 \n>\n> https://blog.csdn.net/weixin_43933728/article/details/121359727?spm=1001.2014.3001.5501 \n>\n> https://blog.csdn.net/zx156955/article/details/121670681 https://blog.csdn.net/qq_39529562/article/details/108911983\n\n```java\npublic Mono<Void> handleResponse(ServerWebExchange exchange, GatewayFilterChain chain){  \n\n    try {  \n        //从交换寄拿响应对象  \n        ServerHttpResponse originalResponse = exchange.getResponse();  \n        //缓冲区工厂，拿到缓存数据  \n        DataBufferFactory bufferFactory = originalResponse.bufferFactory();  \n        //拿到响应码  \n        HttpStatus statusCode = originalResponse.getStatusCode();  \n        if(statusCode == HttpStatus.OK){  \n            //装饰，增强能力  \n            ServerHttpResponseDecorator decoratedResponse = new ServerHttpResponseDecorator(originalResponse) {  \n            //等调用完转发的接口后才会执行\n                @Override  \n                public Mono<Void> writeWith(Publisher<? extends DataBuffer> body) {  \n                    log.info(\"body instanceof Flux: {}\", (body instanceof Flux));  \n                    //对象是响应式的  \n                    if (body instanceof Flux) {  \n                        //我们拿到真正的body  \n                        Flux<? extends DataBuffer> fluxBody = Flux.from(body); \n                        //往返回值里面写数据  \n                        //拼接字符串  \n                        return super.writeWith(fluxBody.map(dataBuffer -> { \n                            // 7. TODO 调用成功，接口调用次数 + 1 invokeCount\n                            byte[] content = new byte[dataBuffer.readableByteCount()];  \n                            dataBuffer.read(content);  \n                            DataBufferUtils.release(dataBuffer);//释放掉内存  \n                            // 构建日志  \n                            StringBuilder sb2 = new StringBuilder(200);  \n                            sb2.append(\"<--- {} {} \\n\");  \n                            List<Object> rspArgs = new ArrayList<>();  \n                            rspArgs.add(originalResponse.getStatusCode());  \n                            //rspArgs.add(requestUrl);  \n                            String data = new String(content, StandardCharsets.UTF_8);//data \n                            sb2.append(data);  \n                            log.info(sb2.toString(), rspArgs.toArray());//log.info(\"<-- {} {}\\n\", originalResponse.getStatusCode(), data);  \n                           return bufferFactory.wrap(content);  \n                        }));  \n                    } else {  \n                        // 8. 调用失败，fan'hui一个规范的\n                        log.error(\"<--- {} 响应code异常\", getStatusCode());  \n                    }  \n                    return super.writeWith(body);  \n                }  \n            };  \n            //设置 response 对象为装饰过的  \n            return chain.filter(exchange.mutate().response(decoratedResponse).build());  \n        }  \n        return chain.filter(exchange);//降级处理返回数据  \n    }catch (Exception e){\n        log.error(\"gateway log exception.\\n\" + e);  \n        return chain.filter(exchange);\n    }\n}\n```\n\n## Day06 完善网关的业务逻辑\n\n### 今日计划\n\n1. 补充完整网关的业务逻辑（如何操作数据库?如何服用之前写过的方法？RPC）\n2. 完善系统的TODO和其他功能，并开发一个管理员的监控统计功能\n\n\n\n### 网关业务逻辑\n\n问题：之前的项目已经写过了调用数据库的那些mybatis的业务逻辑，复制粘贴太麻烦\n\n解决：用一个可以直接调用的解决方法：RPC\n\n\n\n### 如何调用其他项目的方法\n\n1. 复制粘贴代码和相关依赖\n2. HTTP请求（提供接口，供其他项目进行调用）\n3. jar包调用\n4. 把公共代码达成jar包，其他项目直接引用\n\n### HTTP请求怎么调用\n\n1. 提供方开发一个接口（地址、请求方法、参数、返回值）\n2. 调用方使用`HTTP Client`之类的代码取发送HTTP请求\n\n\n\n### RPC（remote produce call）\n\n**作用：像调用本地方法一样去调用远程方法**\n\n优点：\n\n\t1. 对开发者更加透明，减少了调用见的沟通成本\n\t1. RPC向远程服务器发送请求时，未必要使用HTTP协议，比如：TCP/IP、或者自己封装的协议。（内部服务更加适用）\n\n### `Feign && RPC`\n\n> Feign底层用的HTTP协议，虽然也可以很方便的进行调用，但是区别在于Feign只是让请求过程更加精简,HTTP请求其实可以做到和RPC一样的事情，但是还有区别：RPC向远程服务器发送请求时，未必要使用HTTP协议，比如：TCP/IP、或者自己封装的协议。\n\nHTTP协议是一个7层协议，如果想要接口的性能更高，可以使用TCP/IP协议，更加原生的协议。\n\n一般来说微服务项目内部的接口，用`RPC`的性能可能会更加高一点，协议可选项更加多一点。\n\n`工作流程图：`\n\n![image-20230729232829504](https://cdn.jsdelivr.net/gh/wl2o2o/blogCdn/img/202307292328515.png)\n\n🆗，现在模型已经搭建好了，那么如何进行实现呢？使用Dubbo框架（如何学习？看官方文档）\n\n### Dubbo框架（RPC实现）（阿里公司的）\n\n其它类似的框架还有`GRPC`（Google公司的）、`TRPC`（腾讯公司的）\n\n最好的学习方式：[阅读官方文档！](https://cn.dubbo.apache.org/zh-cn/overview/mannual/java-sdk/quick-start/spring-boot/)\n\n\n\n### 两种使用方式\n\n1. Spring Boot代码（注解+编程式）：写Java接口，服务提供者和消费者都去引用这个接口 偏程导\n\n2. IDL(接口调用语言)：创建一个公共的接口定义文件，服务提供者和消费者读取这个文件。\n\n   优点：\n\n   * 跨语言，所有的框架都认识\n\n   * 底层是Triple（自定义封装协议，优点见[官文](https://cn.dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/protocol/triple/)）\n\n     ![image-20230730003800623](https://cdn.jsdelivr.net/gh/wl2o2o/blogCdn/img/202307300038465.png)\n\n### 示例项目学习\n\n```\ngit clone -b master https://github.com/apache/dubbo-samples.git\n```\n\nzookeeper注册中心：通过内嵌的方式运行，更方便\n\n最先启动注册中心，先启动服务提供者，再启动服务消费者\n\n### 整合应用\n\n1. 服务提供者：backend\n\n   a. 实际情况应该是去数据库中查是否已分配给用户\n\n   b. 从数据库中查询模拟接口是否存在，以及请求方法是否匹配（还可以校验请求参数）\n\n   c. 调用成功，接口调用次数+1 invokeCount\n\n2. gateway项日作为服务调用者，调用这3个方法\n\n\n\n> 整合步骤：\n>\n> 1. 依赖引入  视频事件：`00:52`\n>\n>    ```\n>                                                                                                                \n>    ```\n>\n>    \n>\n> 2. 将官方示例代码中的privider包粘到backend中\n\n\n\n\n\n\n\n\n\n## Day07 完善网关业务与上线\n\n### 今日计划\n\n1. 完善网关的业务\n2. 开发管理员的分析功能\n3. 项目上线\n\n\n\n### 整合nacos\n\n> 遇到一个`nocos`小BUG：\n>\n> Dubbo整合nocos的时候，提供者与消费者的包名不一样，这时，提供者将接口的信息注册到nacos文档时，用到的是provider的包名路径，如果出现消费者的包名路径与提供者的包名不同的时候，这时消费者就会报错找不到提供者的Service服务，如图：\n>\n> ![image-20230731193204173](https://cdn.jsdelivr.net/gh/wl2o2o/blogCdn/img/202307311932647.png)\n\n\n\n### 重新梳理网关的业务逻辑\n\n1. 实际情况应该是去数据库中查是否已分配给用户\n\n   a 先根据 accessKey 判断用户是否存在，查到 secretKey\n   b 对比 secretKey 和用户传的加密后的 secretKey 是否一致\n\n2. 从数据库中查询模拟接口是否存在，以及请求方法是否匹配（还可以校验请求参数）\n\n3. 调用成功，接口调用次数+1 invokeCount\n\n\n\n### 公共服务\n\n> 目的是让方法、实体在多个项目中进行复用，避免重复编写\n\n* 业务分析\n\n  * 1. 数据库中是否已分配给用户密钥（accesskey、secretkey，返回用户信息，为空表示不存在）√\n    2. 从数据库中查询模拟接口是否存在（请求路径、请求方法、请求参数，返回接口信息，为空表示不存在）\n    3. 接口调用次数 + 1 `invokeCount`（ak、sk、请求接口路径）√\n\n\n\n\n* 使用步骤：\n  * 1. 新建干净的 maven 项目，只保留必要的公共依赖\n  \n  * 2. 抽取 service 和实体类\n  \n  * 3. install 本地 maven 包\n  \n  * 4. 让服务提供者引入 common 包，测试是否正常运行（出现Bug，backend包中的实现类一直报错：\n  \n       > `'getBaseMapper()' in 'com.baomidou.mybatisplus.extension.service.impl.ServiceImpl' clashes with 'getBaseMapper()' in 'com.baomidou.mybatisplus.extension.service.IService'; attempting to use incompatible return type`\n       >\n       > 原因是`UserInterfaceInfoMapper`类中，忘记更改引入的实体类路径。\n       >\n       > 小技巧：![image-20230803051309362](https://cdn.jsdelivr.net/gh/wl2o2o/blogCdn/img/202308030513641.png)\n       >\n       > 可以通过这种方式快速实现外部提供的的接口。\n  \n  * 5. 让服务消费者引入 common 包\n\n* 业务流程\n\n  * 1. 新建干净的 maven 项目，只保留必要的公共依赖\n\n  * 2. 抽取 service 和实体类\n\n  * 3. install 本地 maven 包\n  \n  * 4. 让服务提供者引入 common 包，测试是否正常运行，加上@DubboService，以便供其它类使用\n\n    ```java\n    // mybatisplus真好用！业务crud手到擒来！\n    /**\n     * @author WLei224\n     * @create 2023/8/3 5:15\n     */\n    public class InnerInterfaceInfoServiceImpl implements InnerInterfaceInfoService {\n        @Resource\n        private InterfaceInfoMapper interfaceInfoMapper;\n        @Override\n        public InterfaceInfo getInterfaceInfo(String url, String method) {\n            if (StringUtils.isAnyBlank(url,method)){\n                throw new BusinessException(ErrorCode.PARAMS_ERROR);\n            }\n            QueryWrapper<InterfaceInfo> queryWrapper = new QueryWrapper<>();\n            queryWrapper.eq(\"url\",url);\n            queryWrapper.eq(\"method\",method);\n            return interfaceInfoMapper.selectOne(queryWrapper);\n        }\n    }\n    ```\n\n   * 5. 让服务消费者引入 common 包\n  \n     > 1. API网关项目中引入 common 依赖\n     >\n     > 2. 使用服务提供者提供的服务（@DubboService和@DubboReference）\n     >\n     >    通过@DubboReference注入公共模块中编写好的三个服务\n     >\n     > 3. 完善网关中的todo标签，完善业务逻辑\n  \n  ### 问题\n  \n  ​\t项目调试中存在一个问题：需要手动对接口的调用次数进行分配，这里考虑可以增加一个管理调用次数的接口。\n\n### 统计分析功能\n\n#### 需求\n\n各个接口的总调用次数的占比图（饼图），取调用次数最多的三个接口，从而进行分析出哪个接口还没有人进行调用，进而对其降低资源或者下线，高频接口（增加资源、提高收费）\n\n#### 实现\n\n* **前端**\n\n  * 强烈推荐使用现成的库\n\n    * Echarts：https://echarts.apache.org/zh/index.html（推荐）\n\n    * AntV：https://antv.vision/zh（推荐）\n\n    * BizCharts\n\n    * 如果是 React 项目，用这个库：https://github.com/hustcc/echarts-for-react\n\n    * > 怎么用？\n      >\n      > 1. 看官网\n      > 2. 找到快速入门、按文档去引入库\n      > 3. 进入示例页面\n      > 4. 找到你要的图\n      > 5. 在线调试\n      > 6. 复制代码\n      > 7. 改为真实数据\n\n* **后端**\n\n  * 写一个接口，得到下列示例数据：\n    接口 A：2次\n    接口 B：3次\n\n  * 步骤：\n\n    1. SQL 查询调用数据：\n\n       ```sql\n       select interfaceInfoId, sum(totalNum) as totalNum from user_interface_info group by interfaceInfoId order by totalNum desc limit 3;\n       ```\n\n    2. 业务层去关联查询接口信息。\n    \n       `controller`:（就不写Service了，直接写业务逻辑）\n    \n       ```java\n       /**\n        * 分析控制器\n        * @author yupi\n        */\n       @RestController\n       @RequestMapping(\"/analysis\")\n       @Slf4j\n       public class AnalysisController {\n       \n           @Resource\n           private UserInterfaceInfoMapper userInterfaceInfoMapper;\n       \n           @Resource\n           private InterfaceInfoService interfaceInfoService;\n       \n           @GetMapping(\"/top/interface/invoke\")\n           @AuthCheck(mustRole = \"admin\")\n           public BaseResponse<List<InterfaceInfoVO>> listTopInvokeInterfaceInfo() {\n               List<UserInterfaceInfo> userInterfaceInfoList = userInterfaceInfoMapper.listTopInvokeInterfaceInfo(3);\n       \n               Map<Long, List<UserInterfaceInfo>> interfaceInfoIdObjMap = userInterfaceInfoList.stream()\n                       .collect(Collectors.groupingBy(UserInterfaceInfo::getInterfaceInfoId));\n       \n               QueryWrapper<InterfaceInfo> queryWrapper = new QueryWrapper<>();\n               queryWrapper.in(\"id\", interfaceInfoIdObjMap.keySet());\n               List<InterfaceInfo> list = interfaceInfoService.list(queryWrapper);\n       \n               if (CollectionUtils.isEmpty(list)) {\n                   throw new BusinessException(ErrorCode.SYSTEM_ERROR);\n               }\n               List<InterfaceInfoVO> interfaceInfoVOList = list.stream().map(interfaceInfo -> {\n                   InterfaceInfoVO interfaceInfoVO = new InterfaceInfoVO();\n                   BeanUtils.copyProperties(interfaceInfo, interfaceInfoVO);\n                   int totalNum = interfaceInfoIdObjMap.get(interfaceInfo.getId()).get(0).getTotalNum();\n                   interfaceInfoVO.setTotalNum(totalNum);\n                   return interfaceInfoVO;\n               }).collect(Collectors.toList());\n               return ResultUtils.success(interfaceInfoVOList);\n           }\n       }\n       ```\n    \n       `封装类`：\n    \n       ```java\n       /**\n        * 接口信息封装视图\n        * @TableName product\n        */\n       @EqualsAndHashCode(callSuper = true)\n       @Data\n       public class InterfaceInfoVO extends InterfaceInfo {\n       \n           /**\n            * 调用次数\n            */\n           private Integer totalNum;\n       \n           private static final long serialVersionUID = 1L;\n       }\n       ```\n    \n       `UserInterfaceInfoMapper`:\n    \n       ```java\n       /**\n        * @Entity com.wl.smartapicommon.model.entity.UserInterfaceInfo\n        */\n       public interface UserInterfaceInfoMapper extends BaseMapper<UserInterfaceInfo> {\n       \n           // 获取前几个调用次数最多的接口\n           List<UserInterfaceInfo> listTopInvokeInterfaceInfo(int limit);\n       \n       }\n       ```\n    \n       `xml中添加sql语句`：\n    \n       ```xml\n       <select id=\"listTopInvokeInterfaceInfo\" resultType=\"com.wl.smartapicommon.model.entity.UserInterfaceInfo\">\n           select interfaceInfoId, sum(totalNum) as totalNum\n           from user_interface_info\n           group by interfaceInfoId\n           order by totalNum\n           desc limit #{limit};\n       </select>\n       ```\n    \n\n## 上线计划\n\n* 前端：参考之前用户中心或伙伴匹配系统的上线方式\n* 后端：\n  * backend 项目：web 项目，部署 spring boot 的 jar 包（对外的）\n  * gateway 网关项目：web 项目，部署 spring boot 的 jar 包（对外的）\n  * interface 模拟接口项目：web 项目，部署 spring boot 的 jar 包（不建议对外暴露的）\n\n***关键：网络必须要连通***\n\n>如果自己学习用：单个服务器部署这三个项目就足够。\n>如果你是搞大事，多个服务器建议在 同一内网 ，内网交互会更快、且更安全。\n\n\n\n#### 上线环境准备\n\n1. docker安装\n\n   ```shell\n   curl -fsSL https://get.docker.com | bash -s docker --mirror Aliyun\n   systemctl start docker \n   systemctl enable docker\n   systenctl restart docker\n   ```\n\n2. 宝塔面板\n\n   ```shell\n   # 安装命令\n   yum install -y wget && wget -O install.sh http://download.bt.cn/install/install_6.0.sh && sh install.sh\n   # 卸载命令\n   systemct stop bt\n   rm -rf /www/server/panel\n   rm -f /etc/init.d/bt\n   \n   rm -rf /root/.pyenv/versions/3.7.0/envs/btpanel/lib/python3.7/site-packages/pycache\n   rm -rf /root/.pyenv/versions/3.7.0/envs/btpanel/lib/python3.7/site-packages/btpanel/__pycache__\n   rm -rf /root/.pyenv/versions/3.7.0/envs/btpanel/lib/python3.7/site-packages/panelApp/__pycache__\n   \n   rm -rf /www/server/panel/logs/*\n   ```\n\n3. [Docker 安装 Nginx](https://blog.csdn.net/u010148813/article/details/126172372)\n\n   ```shell\n   # 拉取官方的最新版本的镜像\n   $ docker pull nginx\n   \n   # 使用以下命令来运行 nginx 容器\n   $ docker run --name nginx -p 80:80 -d nginx\n   \n   # 在宿主机家目录创建用于放配置文件的文件夹\n   $ mkdir -p /root/docker-nginx/{conf,html,logs}\n   \n   # 从容器nginx中复制nginx.conf文件到宿主机\n   $ docker cp nginx:/etc/nginx/nginx.conf /root/docker-nginx       \n   $ docker cp nginx:/etc/nginx/conf.d/default.conf /root/docker-nginx/conf/\n   $ docker cp nginx:/usr/share/nginx/html/ /root/docker-nginx/\n   \n   \n   ----------------------------------------------\n   说明：\n   宿主机：就是你的云服务器或者虚拟机。\n   ~ 目录，也就是我们常说的家目录/home/your_username.(如果是云服务器，且没有创建普通用户，那么家目录就是 /root 了，也就是我们说的管理员用户，拥有最高权限，所以命令就不用加上 sudo 了)\n   \n   刚才的操作是把你在docker中拉取的 Nginx 的镜像配置文件复制了一份到家目录，这样可以便于后续对 nginx 的配置，say Why?，因为我们接下来会通过映射，将我们复制到宿主机的配置文件直接映射到 docker 容器中的 Nginx 中，是不是很方便，下次若需要配置，就可以直接在宿主机中进行配置了，否则还需要通过 `$ docker exec -it nginx bash` 命令进入到 Nginx 的镜像之中。\n   ```\n   \n   \n   \n   - 打包一下复制好的配置文件（备份，以免操作失误可补救）\n   \n   ```shell\n   # 删掉 nginx 容器\n   $ docker stop nginx\n   $ docker rm nginx\n   \n   # 重新运行容器，并加上配置文件的映射\n   $ docker run -p 80:80 \\\n   -v /root/docker-nginx/nginx.conf:/etc/nginx/nginx.conf \\\n   -v /root/docker-nginx/logs:/var/log/nginx \\\n   -v /root/docker-nginx/html:/usr/share/nginx/html \\\n   -v /root/docker-nginx/conf:/etc/nginx/conf.d \\\n   --name nginx \\\n   --privileged=true \\\n   --restart=always \\\n   -d nginx\n   \n   ----------------------------------------------\n   终于完成！如遇到403或者无法访问此网站等其他问题，首先去你购买的云服务器的安全组新增 80 端口，如果你开了代理，试着重启或者注销电脑。\n   参考链接：https://blog.csdn.net/l123lgx/article/details/122619851\n   \n   server {\n       listen 80;\n       server_name localhost;\n       #charset koi8-r;\n       #access_log logs/host.access.log main;\n       location / {\n           root html;\n           index index.html index.htm;\n   \t}\n       #error_page 404 /404.html;\n       # redirect server error pages to the static page /50x.html\n       #\n       error_page 500 502 503 504 /50x.html;\n       location = /50x.html {\n       \troot html;\n       }\n       # proxy the PHP scripts to Apache listening on 127.0.0.1:80\n       #\n       #location ~ \\.php$ {\n       # proxy_pass http://127.0.0.1;\n       #}\n       # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000\n       #\n       #location ~ \\.php$ {\n       # root html;\n       # fastcgi_pass 127.0.0.1:9000;\n       # fastcgi_index index.php;\n       # fastcgi_param SCRIPT_FILENAME /scripts$fastcgi_script_name;\n       # include fastcgi_params;\n       #}\n       # deny access to .htaccess files, if Apache's document root\n       # concurs with nginx's one\n       #\n       #location ~ /\\.ht {\n       # deny all;\n       #}\n   }\n       # another virtual host using mix of IP-, name-, and port-based configuration\n       #\n       #server {\n       # listen 8000;\n       # listen somename:8080;\n       # server_name somename alias another.alias;\n       # location / {\n       # root html;\n       # index index.html index.htm;\n       # }\n       #}\n       # HTTPS server\n       #\n       #server {\n       # listen 443 ssl;\n       # server_name localhost;\n       # ssl_certificate cert.pem;\n       # ssl_certificate_key cert.key;\n       # ssl_session_cache shared:SSL:1m;\n       # ssl_session_timeout 5m;\n       # ssl_ciphers HIGH:!aNULL:!MD5;\n       # ssl_prefer_server_ciphers on;\n       # location / {\n       # root html;\n       # index index.html index.htm;\n       # }\n       #}\n   \n   ```\n   \n   复习一下`tar`命令的用法：\n   \n   <img src=\"https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202308260050797.png\" alt=\"image-20230826005051120\" style=\"zoom:50%;\" />\n   \n   解压的话亦是同理：\n   \n   > 解压 tar 存档文件的常用命令是 `tar -xzvf`。下面是对这些参数的解释：\n   >\n   > - `-x`：表示从存档文件中提取（解压）文件。\n   > - `-z`：表示使用 gzip 压缩算法进行解压缩。使用此参数可以解压被 gzip 压缩的 tar 存档文件。\n   > - `-v`：表示在命令执行过程中显示详细信息，即显示提取的文件列表。\n   > - `-f`：指定要提取的存档文件的名称。紧跟在 `-f` 参数后面的是存档文件的名称。\n   \n   4. `docker`安装`MySQL`\n   \n      ```shell\n      docker pull mysql\n      \n      # 在宿主机家目录创建用于放配置文件的文件夹\n      $ mkdir -p /root/docker-mysql/{conf,data,log}\n      \n      # 在配置文件目录:/root/docker-mysql/conf新建一个my.cnf配置文件，写入下面内容，设置客户端和mysql服务器端编码都为utf8\n      [client]\n      default_character_set=utf8\n      [mysqld]\n      collation_server=utf8_general_ci\n      character_set_server=utf8\n      \n      docker run -p 3306:3306 \\\n      --privileged=true \\\n      -v /root/docker-mysql/log:/var/log/mysql \\\n      -v /root/docker-mysql/data:/var/lib/mysql \\\n      -v /root/docker-mysql/conf:/etc/mysql/conf.d \\\n      -e MYSQL_ROOT_PASSWORD=你的MySQL密码 \\\n      --name mysql \\\n      -d mysql\n      \n      docker exec -it mysql bash\n      \n      mysql -u root -p\n      \n      如果遇到`Navicat`连接不上的问题，请看下面的链接。\n      ```\n   \n      记录一个大坑，宝塔面板添加3306端口号，被腾讯云服务器拦截了，无语了，还是通过云服务器控制台（推荐✨）或者防火墙命令来添加端口吧。\n   \n      参考链接：https://www.cnblogs.com/--eric/p/17145834.html\n   \n   \n   \n   5. `JDK`安装\n   \n      ```shell\n      # yum 安装免环境变量的配置\n      $ yum install -y java-1.8.0-openjdk*\n      ```\n   \n   6. `maven`安装\n   \n      ```shell\n      通过以下命令获取安装包或者通过本地浏览器下载到主机，然后通过 ftp 传输到 Linux 服务器\n      curl -O https://dlcdn.apache.org/maven/maven-3/3.8.8/binaries/apache-maven-3.8.8-bin.tar.gz\n      \n      tar -zxvf apache-maven-3.8.8-bin.tar.gz\n      \n      vim /etc/profile\n      \n      文件空白处增加两行内容：\n      export MAVEN_HOME=/root/services/apache-maven-3.8.8\n      export PATH=$MAVEN_HOME/bin:$PATH\n      \n      source /etc/profile\n      \n      mvn --version\n      \n      ```\n   \n      \n   \n   7. `redis`安装\n   \n      ```shell\n      docker pull redis\n      \n      mkdir -p /root/docker-redis/conf\n      \n      # 入redis配置文件夹\n      cd /root/docker-redis/conf  \n      \n      # 下载redis配置文件\n      wget http://download.redis.io/redis-stable/redis.conf   \n      \n      vim redis.conf  // 修改配置文件\n      1. appendonly yes    启动Redis持久化功能 (默认 no , 所有信息都存储在内存 [重启丢失] 。设置为 yes , 将存储在硬盘 [重启还在])\n      2. protected-mode no    关闭protected-mode模式，此时外部网络可以直接访问\n      3. bind 0.0.0.0    设置所有IP都可以访问\n      4. requirepass 密码    设置密码\n      如果你设置了密码,需要通过如下命令进入Redis控制台\n      ## 进入Redis容器\n              docker exec -it redis bash\n      ## 通过密码进入Redis控制台\n              redis-cli -h 127.0.0.1 -p 6379 -a [你的密码]\n              \n      mkdir -p /root/docker-redis/data\n      \n      docker run -p 6379:6379 \\\n      -v /root/docker-redis/conf/redis.conf:/etc/redis/redis.conf \\\n      -v /root/docker-redis/data:/data \\\n      -e REDIS_ROOT_PASSWORD=你的Redis密码 \\\n      --restart=always \\\n      --name redis \\\n      -d redis\n      \n      \n      不要忘记打开防火墙6379端口，通过宝塔面板或者命令，或者云服务器控制台\n      ```\n   \n      \n   \n   8. `nacos`安装\n   \n      ```shell\n      docker pull nacos/nacos-server\n      \n      # 在宿主机家目录创建用于放配置文件的文件夹\n      $ mkdir -p /root/docker-nacos/nacos/{init.d,logs}\n      \n      vim /root/docker-nacos/nacos/init.d/application.properties \n      \n      server.contextPath=/nacos\n      server.servlet.contextPath=/nacos\n      server.port=8848\n       \n      spring.datasource.platform=mysql\n      db.num=1\n      db.url.0=jdbc:mysql://xx.xx.xx.x:3306/nacos_devtest_prod?characterEncoding=utf8&connectTimeout=1000&socketTimeout=3000&autoReconnect=true\n      db.user=user\n      db.password=pass\n       \n      nacos.cmdb.dumpTaskInterval=3600\n      nacos.cmdb.eventTaskInterval=10\n      nacos.cmdb.labelTaskInterval=300\n      nacos.cmdb.loadDataAtStart=false\n      management.metrics.export.elastic.enabled=false\n      management.metrics.export.influx.enabled=false\n      server.tomcat.accesslog.enabled=true\n      server.tomcat.accesslog.pattern=%h %l %u %t \"%r\" %s %b %D %{User-Agent}i\n      nacos.security.ignore.urls=/,/**/*.css,/**/*.js,/**/*.html,/**/*.map,/**/*.svg,/**/*.png,/**/*.ico,/console-fe/public/**,/v1/auth/login,/v1/console/health/**,/v1/cs/**,/v1/ns/**,/v1/cmdb/**,/actuator/**,/v1/console/server/**\n      nacos.naming.distro.taskDispatchThreadCount=1\n      nacos.naming.distro.taskDispatchPeriod=200\n      nacos.naming.distro.batchSyncKeyCount=1000\n      nacos.naming.distro.initDataRatio=0.9\n      nacos.naming.distro.syncRetryDelay=5000\n      nacos.naming.data.warmup=true\n      nacos.naming.expireInstance=true\n      \n      \n      docker run -p 8848:8848 \\\n      -e JVM_XMS=256m \\\n      -e JVM_XMX=256m \\\n      -e MODE=standalone \\\n      -e PREFER_HOST_MODE=hostname \\\n      -v /root/docker-nacos/nacos/logs:/home/nacos/logs \\\n      -v /root/docker-nacos/nacos/init.d/application.properties:/home/nacos/init.d/application.properties \\\n      --name nacos \\\n      --privileged=true \\\n      --restart=always \\\n      -d nacos/nacos-server\n      ```\n   \n      参考链接：https://blog.csdn.net/yexiaomodemo/article/details/123355202\n   \n      \n   \n   9. `rabbitmq`安装\n   \n      ```shell\n      docker pull rabbitmq\n      \n      docker run -p 5672:5672 -p 15672:15672 \\\n      -v /root/docker-rabbitmq/config/:/etc/rabbitmq/ \\\n      -e RABBITMQ_DEFAULT_USER=admin \\\n      -e RABBITMQ_DEFAULT_PASS=admin \\\n      --hostname myRabbit \\\n      --name rabbitmq \\\n      --restart=always \\\n      -d rabbitmq\n      \n      docker exec -it rabbitmq bash\n      \n      # 启动可视化插件\n      rabbitmq-plugins enable rabbitmq_management\n      \n      使用浏览器打开web管理端：http://Server-IP:15672 \n      ```\n   \n\n  \t参考链接：\n\n​\t  https://blog.csdn.net/qq_42977003/article/details/128107521\n​\t  https://blog.csdn.net/feritylamb/article/details/128434465\n\n#### 一、原始部署\n\n​\t缺点：需要一个个配置环境，安装必须软件\n\n#### 二、宝塔面板部署\n\n​\t优点：可视化安装与配置\n\n#### 三、docker部署\n\n> Docker是一种开源的容器化平台，用于构建、发布和运行应用程序。通过使用Docker，您可以将应用程序及其依赖项打包到一个称为容器的独立单元中，以便在任何环境中运行，而无需担心环境差异或依赖问题。\n>\n> 以下是一些与Docker相关的常用概念和命令：\n>\n> 1. 镜像（Image）：镜像是Docker容器的基础，它包含了运行应用程序所需的一切，包括代码、运行时环境、库和依赖项。您可以通过构建自定义镜像或从Docker Hub等镜像仓库中获取现有的镜像。\n> 2. 容器（Container）：容器是基于镜像创建的运行实例，它是一个独立、隔离的执行环境。容器可以启动、停止、重启和删除，每个容器都具有自己的文件系统、进程空间和网络接口。\n> 3. Dockerfile：Dockerfile是用于定义镜像构建过程的文本文件。它包含一系列指令，用于指定基础镜像、安装软件、复制文件、设置环境变量等。\n> 4. Docker Compose：Docker Compose是一个用于定义和运行多个容器应用的工具。它使用一个YAML文件来定义各个服务及其依赖关系，并可以一键启动、停止和管理整个应用程序的容器群。\n>\n> 一些常用的Docker命令包括：\n>\n> - `docker build`：根据Dockerfile构建镜像。\n> - `docker run`：创建并运行一个新的容器。\n> - `docker stop`：停止一个正在运行的容器。\n> - `docker start`：启动已经停止的容器。\n> - `docker rm`：删除一个或多个容器。\n> - `docker images`：列出本地已下载的镜像。\n> - `docker pull`：从镜像仓库下载镜像。\n> - `docker push`：将本地镜像推送到镜像仓库。\n>\n> 这只是Docker的一小部分功能和命令，Docker还提供了许多其他功能，如网络配置、数据卷、容器编排等。如果您想更深入了解Docker的使用，请参考官方文档或相关教程。\n>\n> \n>\n> docker如何打包一个镜像，命令是什么?\n>\n> \n>\n> 要打包一个Docker镜像，您需要编写一个Dockerfile，其中包含构建镜像所需的指令和配置。然后，使用`docker build`命令来构建镜像。以下是基本的步骤和相应的命令：\n>\n> 1. 创建一个Dockerfile：在您的项目目录中创建一个名为`Dockerfile`的文本文件，可以使用任何文本编辑器打开并编辑它。\n>\n> 2. 在Dockerfile中定义镜像构建过程：Dockerfile包含一系列指令，用于指定基础镜像、安装软件、复制文件、设置环境变量等。根据您的应用程序需求，编写适当的指令。\n>\n>    以下是一个简单的Dockerfile示例：\n>\n>    ```dockerfile\n>    # 使用官方的 Node.js 作为基础镜像\n>    FROM node:14\n>\n>    # 设置工作目录\n>    WORKDIR /app\n>\n>    # 复制应用程序代码到容器中\n>    COPY . .\n>\n>    # 安装应用程序依赖\n>    RUN npm install\n>\n>    # 暴露应用程序的端口\n>    EXPOSE 3000\n>\n>    # 定义启动容器时运行的命令\n>    CMD [\"npm\", \"start\"]\n>\n>    这个示例中，我们使用了官方的Node.js 14镜像作为基础镜像，将应用程序代码复制到容器中，安装依赖项，暴露端口3000，并在容器启动时运行`npm start`命令。\n>    ```\n>\n> 3. 构建镜像：在终端中，切换到包含Dockerfile的目录，并运行以下命令来构建镜像：\n>\n>    ```\n>    docker build -t image_name:tag .\n>    ```\n>\n>    - `-t`参数用于指定镜像的名称和标签。您可以根据需要自定义名称和标签。\n>    - `.`表示Dockerfile所在的当前目录。确保在运行命令之前，您已经切换到正确的目录。\n>\n>    例如，要构建一个名为`myapp`的镜像，标签为`v1.0`，可以运行以下命令：\n>\n>    ```\n>    docker build -t myapp:v1.0 .\n>    ```\n>\n> 4. 等待构建完成：Docker将执行Dockerfile中的每个指令，并构建镜像。这可能需要一些时间，取决于您的镜像大小和复杂性。\n>\n> 5. 查看构建的镜像：构建完成后，可以使用以下命令查看本地的镜像列表：\n>\n>    ```\n>    docker images\n>    ```\n>\n>    您将看到刚刚构建的镜像以及其名称、标签和大小等信息。\n>\n> 通过以上步骤，您就可以使用Dockerfile和`docker build`命令来打包构建自己的Docker镜像。请根据您的应用程序需求和环境配置适当地编辑Dockerfile。\n\n##### 前端部署例子：\n\n`dockerfile`文件：\n\n```dockerfile\nFROM nginx\n\nWORKDIR /usr/share/nginx/html/\nUSER root\n\nCOPY ./docker/nginx.conf /etc/nginx/conf.d/default.conf\n\nCOPY ./dist  /usr/share/nginx/html/\n\nEXPOSE 80\n\nCMD [\"nginx\", \"-g\", \"daemon off;\"]\n```\n\n`nginx.conf`文件：\n\n```nginx\nserver {\n    listen 80;\n\n    # gzip config\n    gzip on;\n    gzip_min_length 1k;\n    gzip_comp_level 9;\n    gzip_types text/plain text/css text/javascript application/json application/javascript application/x-javascript application/xml;\n    gzip_vary on;\n    gzip_disable \"MSIE [1-6]\\.\";\n\n    root /usr/share/nginx/html;\n    include /etc/nginx/mime.types;\n\n    location / {\n        try_files $uri /index.html;\n    }\n\n}\n```\n\n\n\n### 项目扩展思路\n\n1. 用户自己可以申请更换签名\n\n2. 怎么让其他用户也能上传接口？\n\n   > * 需要提供一个机制（一个页面），让用户来输入自己的接口host（都武器的地址）、接口信息、将接口写入数据库；\n   > * 可以在interfaceInfo表中加个host字段，以次区分服务器地址，让接口提供者更灵活的接入系统；\n   > * 将接口信息入库前，要对接口进行校验，比如检查地址是否遵循规则、是否可以正常调用,并遵循甲方要求（使用SDK）\n\n3. 网关校验是否还有调用次数\n\n   需要考虑并发的问题，防止瞬间调用超频。\n\n4. 网关优化\n\n   比如增加限流、降级保护、提高性能等。还可以考虑搭配Nginx网关使用。\n\n5. 功能增强\n\n   可以针对不同的请求头或者接口类型来设计前端界面和表单，百年与用户进行调用，增强体验。\n\n   （可以参考swagger、postman、kniffj的界面）\n\n\n\n## 项目优化\n\n### 扩展思路\n\n 1. 用户可以申请更换签名\n 2. 怎么让其他用户也上传接口？ \n需要提供一个机制（界面），让用户输入自己的接口 host（服务器地址）、接口信息，将接口信息写入数据库。\n可以在 interfaceInfo 表里加个 host 字段，区分服务器地址，让接口提供者更灵活地接入系统。\n将接口信息写入数据库之前，要对接口进行校验（比如检查他的地址是否遵循规则，测试调用），保证他是正常的。\n将接口信息写入数据库之前遵循咱们的要求（并且使用咱们的 sdk），\n在接入时，平台需要测试调用这个接口，保证他是正常的。\n 3. 网关校验是否还有调用次数 \n需要考虑并发问题，防止瞬间调用超额。\n 4. 网关优化 \n比如增加限流 / 降级保护，提高性能等。还可以考虑搭配 Nginx 网关使用。\n 5. 功能增强 \n可以针对不同的请求头或者接口类型来设计前端界面和表单，便于用户调用，获得更好的体验。\n可以参考 swagger、postman、knife4j 的页面。","source":"_posts/api.md","raw":"---\ntitle: API开放平台\nindex_img: https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311151627634.png\nbanner_img: https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311151627632.png\nexcerpt: >-\n  项目介绍：前端开发的时候有有时会需要后端的接口，如果此时有一个 API 接口可以使用，那么就无需后端接口了。本项目是一个提供 API\n  接口调用的平台，用户可以注册与登录，开通接口的调用权限，用户可以使用接口，每次调用会进行次数统计。管理院可以发布接口、下线接口、接入接口，以及可视化接口的调用情况。\nsticky: 100\ncategories:\n  - Project\ntags:\n  - Ant Design Pro\n  - React\n  - Ant Design Pro Components\n  - Umi\n  - Umi Request\n  - Spring Boot\n  - SDK开发\nabbrlink: 2239\ndate: 2023-06-03 12:34:12\n---\n\n# API开放平台\n\n> 写在最前面：\n>\n> ​\t学到的知识与收到的建议：\n>\n> \t1. 把自己所有的数据库建表语句总结到一起，后续有用；\n> \t1. 记录Bug文档\n> \t1. 多记录一些需求的解决方案、提高自己的架构能力\n\n## 项目介绍\n\n> 前端开发的时候有有时会需要后端的接口，如果此时有一个API接口可以使用，那么就无需后端借口了\n\n一个提供API接口调用的平台，用户可以注册与登录，开通接口的调用权限，用户可以使用接口，每次调用会进行次数统计。管理院可以发布接口、下线接口、接入接口，以及可视化接口的调用情况。\n\n\n\n一个API接口平台：\n\n1. 防止攻击\n2. 使用限制\n3. 统计调用次数\n4. 计费\n5. 流量保护\n6. API接入\n\n## 预计完成时间\n\n5-6周\n\n## 业务流程\n\n前台、SDK、API网关、模拟接口、后台    共五个子模块\n\n**难点**：思想\n\n## 技术选型\n\n* 前端\n  * Ant Design Pro\n  * React\n  * Ant Design Pro Components\n  * Umi\n  * Umi Request（Axios的封装）--请求库（前后端联调）\n* 后端\n  * Spring Boot\n  * Spring Boot Stater（SDK开发）--可以发布到maven仓库----**简历亮点**\n  * ？？？？？？（网关、限流、日志实现）\n\n## 项目计划\n\n### Day01--项目初始化\n\n项目介绍、设计、技术选型\n\n基础项目的搭建\n\n接口管理\n\n用户查看接口的权限\n\n\n\n### Day02--接口调用\n\n1. 继续开发接口管理前端页面 15min\n2. 开发模拟API接口 5min\n3. 开发调用接口的代码 10-20min\n4. 保证调用的安全性（API签名认证） 15min\n5. 客户端SDK的开发 15min\n6. 管理员接口的发布与调用 15min\n7. 接口文档的展示、接口在线调用 15min\n\n\n\n### Day03--接口计费与保护\n\n统计用户调用次数\n\n限流\n\n计费\n\n日志\n\n开通\n\n### Day04--管理员统计分析\n\n提供可视化平台，展示所有接口的调用情况，便于管理价格\n\n接口预警\n\n\n\n\n\n## Day01 需求分析\n\n1. 管理员可以对接口信息进行增删改查\n\n2. 用户可以访问前台，查看接口信息\n\n### 今日计划\n\n1. 项目脚手架搭建（初始化项目）10分钟前端、5-10分钟后端 \n1. 管理员可以对接口信息进行增删改查\n1. 用户可以访问前台，查看接口的信息\n\n\n\n\n\n\n\n\n\n### 项目初始化（前后端）\n\n* ### 前端\n\n1. 使用Ant Design Pro提供的`pro-cli`来快速的初始化脚手架。\n\n   ```bash\n   # 查看node和npm版本\n   建议16和8\n   # 使用 npm\n   npm i @ant-design/pro-cli -g\n   pro create myapi-frontend\n   # 下载项目所需要的依赖\n   yarn\n   此时可能会遇到node版本要求的问题，因为版本更新迭代的原因，我当时要求的是使用16.14.0的node版本，\n   如果感觉切换node版本麻烦的话，这里推荐使用nvm（node的版本管理工具），使用方法自行百度\n   ```\n\n2. 项目瘦身\n\n\t遇到了一个大坑，星球的球友们也都遇到了，下面是球友的解决方法，亲测有效。\n\n   ```bash\n   # 关闭ESLint中与Prettier重复的规则，确保代码格式化的一致性\n   yarn add eslint-config-prettier --dev\n   # 用于检查和修复JavaScript代码中的常见问题\n   yarn add eslint-plugin-unicorn --dev\n   ```\n### 项目去除国际化存在问题的解决方法\n\n![image-20230630231124235](https://cdn.jsdelivr.net/gh/wl2o2o/blogCdn/img/202307010940465.png)\n\n​\tjest脚本命令中有`jest`不知道是否需要删掉，鱼皮的文件中没有出现，可能是跟某些版本有关，奇奇妙妙，记录一下\n\n![image-20230630233743871](https://cdn.jsdelivr.net/gh/wl2o2o/blogCdn/img/202307010940466.png)\n\n* ### 后端\n\n3. 后端项目初始化\n\n​\t直接使用鱼总提供的万能模板`springboot-init`,改成项目的名字，然后全局搜索关键字进行替换\n\n​\t连接数据库\n\n​\t测试运行\n\n4. 数据库库表设计\n\n​\t**接口信息表**\n\n```sql\n# 数据库初始化\n# @author <a href=\"https://github.com/liyupi\">程序员鱼皮</a>\n# @from <a href=\"https://yupi.icu\">编程导航知识星球</a>\n-- 创建库\ncreate database if not exists myapi;\n\n-- 切换库\nuse myapi;\n\n-- 用户表\ncreate table if not exists user\n(\n    id           bigint auto_increment comment 'id' primary key,\n    userName     varchar(256)                           null comment '用户昵称',\n    userAccount  varchar(256)                           not null comment '账号',\n    userAvatar   varchar(1024)                          null comment '用户头像',\n    gender       tinyint                                null comment '性别',\n    userRole     varchar(256) default 'user'            not null comment '用户角色：user / admin',\n    userPassword varchar(512)                           not null comment '密码',\n    `accessKey` varchar(512) not null comment 'accessKey',\n    `secretKey` varchar(512) not null comment 'secretKey',\n    createTime   datetime     default CURRENT_TIMESTAMP not null comment '创建时间',\n    updateTime   datetime     default CURRENT_TIMESTAMP not null on update CURRENT_TIMESTAMP comment '更新时间',\n    isDelete     tinyint      default 0                 not null comment '是否删除',\n    constraint uni_userAccount\n        unique (userAccount)\n) comment '用户';\n\n-- 接口信息\ncreate table if not exists myapi.`interface_info`\n(\n    `id` bigint not null auto_increment comment '主键' primary key,\n    `name` varchar(256) not null comment '名称',\n    `description` varchar(256) null comment '描述',\n    `url` varchar(512) not null comment '接口地址',\n    `requestHeader` text null comment '请求头',\n    `responseHeader` text null comment '响应头',\n    `status` int default 0 not null comment '接口状态（0-关闭，1-开启）',\n    `method` varchar(256) not null comment '请求类型',\n    `userId` bigint not null comment '创建人',\n    `createTime` datetime default CURRENT_TIMESTAMP not null comment '创建时间',\n    `updateTime` datetime default CURRENT_TIMESTAMP not null on update CURRENT_TIMESTAMP comment '更新时间',\n    `isDelete` tinyint default 0 not null comment '是否删除(0-未删, 1-已删)'\n) comment  '接口信息';\n\n-- 用户调用接口关系表\ncreate table if not exists myapi.`user_interface_info`\n(\n    `id` bigint not null auto_increment comment '主键' primary key,\n    `userId` bigint not null comment '调用用户 id',\n    `interfaceInfoId` bigint not null comment '接口 id',\n    `totalNum` int default 0 not null comment '总调用次数',\n    `leftNum` int default 0 not null comment '剩余调用次数',\n    `status` int default 0 not null comment '0-正常，1-禁用',\n    `createTime` datetime default CURRENT_TIMESTAMP not null comment '创建时间',\n    `updateTime` datetime default CURRENT_TIMESTAMP not null on update CURRENT_TIMESTAMP comment '更新时间',\n    `isDelete` tinyint default 0 not null comment '是否删除(0-未删, 1-已删)'\n) comment '用户调用接口关系';\n\ninsert into myapi.`interface_info` (`name`, `description`, `url`, `requestHeader`, `responseHeader`, `status`, `method`, `userId`) values ('许擎宇', '薛聪健', 'www.cary-king.net', '潘博涛', '谭聪健', 0, '石炫明', 9500534531);\ninsert into myapi.`interface_info` (`name`, `description`, `url`, `requestHeader`, `responseHeader`, `status`, `method`, `userId`) values ('陆弘文', '白志强', 'www.leslee-kuhn.net', '潘懿轩', '马鸿涛', 0, '陈峻熙', 3982575846);\ninsert into myapi.`interface_info` (`name`, `description`, `url`, `requestHeader`, `responseHeader`, `status`, `method`, `userId`) values ('毛建辉', '罗文', 'www.rosaria-kilback.io', '冯子默', '彭哲瀚', 0, '赵远航', 121776355);\ninsert into myapi.`interface_info` (`name`, `description`, `url`, `requestHeader`, `responseHeader`, `status`, `method`, `userId`) values ('彭雨泽', '蔡煜祺', 'www.norris-bergstrom.biz', '董思源', '田晓博', 0, '潘擎宇', 740);\ninsert into myapi.`interface_info` (`name`, `description`, `url`, `requestHeader`, `responseHeader`, `status`, `method`, `userId`) values ('傅志强', '陈梓晨', 'www.jordan-reinger.com', '金志强', '熊锦程', 0, '邓睿渊', 35542559);\ninsert into myapi.`interface_info` (`name`, `description`, `url`, `requestHeader`, `responseHeader`, `status`, `method`, `userId`) values ('吕黎昕', '孔越彬', 'www.fe-okon.info', '万伟宸', '林昊然', 0, '孟荣轩', 1445);\ninsert into myapi.`interface_info` (`name`, `description`, `url`, `requestHeader`, `responseHeader`, `status`, `method`, `userId`) values ('夏雪松', '许子骞', 'www.lashawna-legros.co', '蔡昊然', '胡鹏涛', 0, '钟立辉', 34075514);\ninsert into myapi.`interface_info` (`name`, `description`, `url`, `requestHeader`, `responseHeader`, `status`, `method`, `userId`) values ('严钰轩', '阎志泽', 'www.kay-funk.biz', '莫皓轩', '郭黎昕', 0, '龚天宇', 70956);\ninsert into myapi.`interface_info` (`name`, `description`, `url`, `requestHeader`, `responseHeader`, `status`, `method`, `userId`) values ('萧嘉懿', '曹熠彤', 'www.margarette-lindgren.biz', '田泽洋', '邓睿渊', 0, '梁志强', 98);\ninsert into myapi.`interface_info` (`name`, `description`, `url`, `requestHeader`, `responseHeader`, `status`, `method`, `userId`) values ('杜驰', '冯思源', 'www.vashti-auer.org', '黎健柏', '武博文', 0, '李伟宸', 9);\ninsert into myapi.`interface_info` (`name`, `description`, `url`, `requestHeader`, `responseHeader`, `status`, `method`, `userId`) values ('史金鑫', '蔡鹏涛', 'www.diann-keebler.org', '徐烨霖', '阎建辉', 0, '李烨伟', 125);\ninsert into myapi.`interface_info` (`name`, `description`, `url`, `requestHeader`, `responseHeader`, `status`, `method`, `userId`) values ('林炫明', '贾旭尧', 'www.dotty-kuvalis.io', '梁雨泽', '龙伟泽', 0, '许智渊', 79998);\ninsert into myapi.`interface_info` (`name`, `description`, `url`, `requestHeader`, `responseHeader`, `status`, `method`, `userId`) values ('何钰轩', '赖智宸', 'www.andy-adams.net', '崔思淼', '白鸿煊', 0, '邵振家', 7167482751);\ninsert into myapi.`interface_info` (`name`, `description`, `url`, `requestHeader`, `responseHeader`, `status`, `method`, `userId`) values ('魏志强', '于立诚', 'www.ione-aufderhar.biz', '朱懿轩', '万智渊', 0, '唐昊强', 741098);\ninsert into myapi.`interface_info` (`name`, `description`, `url`, `requestHeader`, `responseHeader`, `status`, `method`, `userId`) values ('严君浩', '金胤祥', 'www.duane-boyle.org', '雷昊焱', '侯思聪', 0, '郝思', 580514);\ninsert into myapi.`interface_info` (`name`, `description`, `url`, `requestHeader`, `responseHeader`, `status`, `method`, `userId`) values ('姚皓轩', '金鹏', 'www.lyda-klein.biz', '杜昊强', '邵志泽', 0, '冯鸿涛', 6546);\ninsert into myapi.`interface_info` (`name`, `description`, `url`, `requestHeader`, `responseHeader`, `status`, `method`, `userId`) values ('廖驰', '沈泽洋', 'www.consuelo-sipes.info', '彭昊然', '邓耀杰', 0, '周彬', 7761037);\ninsert into myapi.`interface_info` (`name`, `description`, `url`, `requestHeader`, `responseHeader`, `status`, `method`, `userId`) values ('赖智渊', '邓志泽', 'www.emerson-mann.co', '熊明哲', '贺哲瀚', 0, '田鹏', 381422);\ninsert into myapi.`interface_info` (`name`, `description`, `url`, `requestHeader`, `responseHeader`, `status`, `method`, `userId`) values ('许涛', '陆致远', 'www.vella-ankunding.name', '贾哲瀚', '莫昊焱', 0, '袁越彬', 4218096);\ninsert into myapi.`interface_info` (`name`, `description`, `url`, `requestHeader`, `responseHeader`, `status`, `method`, `userId`) values ('吕峻熙', '沈鹏飞', 'www.shari-reichel.org', '郭鸿煊', '覃烨霖', 0, '熊黎昕', 493);\n\n```\n\n\n\n> 留一个小bug，数据库建表语句直接套用的最终建表语句，user表中涉及到两个关于key的字段，手动改成了可以为空，若有问题，后续再做出更改\n\n> 利用`MyBatisX`插件生成接口管理的增删改查代码\n\n将生成的代码逻辑复制到项目的dao、service、mapper包里，\n\n然后还剩一个controller层，直接复制一份模板中的controller层的代码，进行复用\n\n注意此时模糊查询使用的字段不是content，而是description，进行相应的更改。\n\n此时，增删改查操作已完成，就这么简单 \n\n跑通后端\n\n* ### 前端\n\n使用oneapi插件自动生成（openapi规范）\n\n![image-20230701235258820](https://cdn.jsdelivr.net/gh/wl2o2o/blogCdn/img/202307012353984.png)\n\n\n\n> 先前，我们登陆时是采用的start假数据进行登录，此时使用dev，登陆页面是存在问题的，因为脚手架自动生成的页面会强制要求登录，此时的登录接口与我们oneapi自动生成的接口对应不上，需要手动进行更改User》》Login》》index.tsx\n>\n\n因为没有开发注册页面，可以从注册中心项目中复制一个过来\n\n为了便捷的进行开发，先从swagger注册一个账号，然后登录发现没有进行跳转，通过分析得出，是因为前端没有记录用户的登录状态，所以要进一步进行完善，在typings.d.ts中进行定义全局登录态\n\n\n\n改造页面，将前端展示的表格，用来展示自己的数据\n\n\n\n\n\n## Day02 接口调用开发（前端）\n\n> 首先发现一个问题，使用后端swagger进行user密码更改的时候，密码没有进行加密，会导致前端进行校验的时候返回用户名或者密码不正确的信息\n\n* ### 优化前端展示页面（改路由，先不删）\n\n  * 保持前后端组件名一致\n  * 优化页面代码\n  * 首页没有页面，后续进行开发一个非管理员用户可以看到的页面\n  * 调整导航栏的位置，可以先使用antDesignPro框架提供的切换导航布局小设置\n  \n* ### 新建模态框的编写真的很搞心态，最后的原因竟然是因为一个小的错误（静下心来）（血泪教训，做完项目过一遍react）\n\n* ### 完善修改框\n\n  * 此处设计到React的核心知识点，也是重中之重（useEffect、useRef）\n\n  * ```tsx\n    const formRef = useRef<ProFormInstance>();\n    \n    useEffect(() => {\n      if(formRef){\n        formRef.current?.setFieldsValue(values);\n      } \n    }, [values])\n    \n    return (\n        <Modal visible={visible} footer={null} onCancel={() => onCancel?.()}>\n          <ProTable\n            type=\"form\"\n            columns={columns}\n            // 因为这里使用的form组件，只会初始化一次，所以会造成点击修改按钮进行修改的话，数据是不会变的\n            // form={{\n            //   initialValues: values\n            // }}\n            \n            // 所以此处用到了监听\n            formRef={formRef}\n            \n            onSubmit={async (value) => {\n              onSubmit?.(value);\n            }}\n          />\n        </Modal>\n      );\n    ```\n\n  * > 此处有Bug，后端报空指针\n\n\n* ### 完善删除框\n\n  * 仿照以上步骤完成\n\n  * > 此时发现进行相关操作之后数据不会自动更新，所以我们引入actionRef，它可以拿到proTable的控制权，使用actionRef.current?.reload()\n\n\n\n\n\n### 模拟接口项目（smartapi-interface）（后端）\n\n提供三个模拟接口\n\n1. GET接口\n2. POST接口（url传参）\n3. POST接口（Restful）\n\n\n\n\n\n### 开始开发模拟接口项目部分\n\n采用创建几个controller控制层小接口，前端传参进行调用，但是这样不符合逻辑，所以我们要通过后端来进行传参！\n\n\n\n### 开发调用接口\n\n几种HTTP调用方式\n\n\t1. HttpClient\n\t1. RestTemplete\n\t1. 工具（OKHttp、HuTool）\n\n这里我们使用HuTool来进行调用[HuTool](https://hutool.cn/docs/#/)\n\n\n\n参考文档是一个好东西，利用好\n\n\n\n那么现在已经开发好调用接口了，但是用户调用你的接口，或者黑客黑你的接口，所以需要对调用者进行一个调用限制，那么如何加以限制？\n\n这时可以联想一下我们平时调用第三方接口时，都会有一些key\n\n\n\n### API 签名认证（客户端与服务端有点迷惑，后续捋顺）\n\n\n\n**本质：**\n\n1. 签发签名\n\n\t2. 使用签名(校验签名)\n\n\n\n**为什么需要？**\n\n1. 保证安全性，不能随便一个人就可以调用\n\n\n\n**怎么实现？（复杂、无序、无规律）**\n\n通过http request header头传递参数。\n\n参数1：assesKey：调用的标识（一串无规则字符串） User A、B\n\n参数2：secretKey：相当于密码\n\n也就是用户名和密钥，区别就是ak、sk是无状态的\n\n在服务端数据库表中新增以上两个字段，用户客户端进行校验。\n\n\n\n\n\n但是这样的方法时容易被拦截的，不能把密钥直接在服务器之间进行传递，要进行加密。所以要对密码进一步进行加密。\n\n\n\n参数3：用户请求参数（更严格）\n\n\n\n参数4：sign\n\n加密方式：对称机密、非对称加密、不可解密加密（MD5）\n\n\n\n用户参数 + 密钥 ==》 **签名生成算法** ==》不可解密的值\n\nwl + abcdefgh ==》afdasfafszv（通过签名算法加密）\n\n那么如何知道这个签名是否正确？\n\n**服务端会通过用一摸一样的参数和算法去生成签名，只要和用户才能属的签名一致，则正确!**\n\n\n\n\n\n**怎么防重放？**\n\n参数5：加nonce随机数，保证只能用一次，但是服务端也要保存随机数\n\n参数6：timestamp时间戳（加上时间戳可以保证随机数可以清除）\n\n**API签名认证是一个很灵活的设计，具体要有哪些参数、参数名一定要根据实际场景来（比如userId、appId、version、固定值等）**\n\n\n\n思考：难道开发者每次调用接口都需要自己来写签名算法吗？\n\n\n\n\n\n\n\n\n\n### 开发一个简单易用的SDK\n\n\n\n理想情况：开发者只需要关心调用哪些接口、传递哪些参数，就跟调用自己的代码一样简单。\n\n\n\n开发stater的好处：\n\n1. 开发者引入之后，可以直接在application.yml中写配置，自动创建客户端。\n\n\n\n### 创建SDK项目（开发starter）（简历亮点）\n\n引入依赖：\n\n1. lombook\n2. Spring Configuration Processor（自动生成配置文件写代码的提示）\n\n\n\n改造pom依赖，一定要删掉build标签内的代码，因为我们在进行构建依赖包，不是要直接运行的jar的项目\n\n\n\n\n\n尝试把打好的包发布到maven中\n\n\n\n\n\n\n\n\n\n## Day03 接口保护与优化\n\n\n\n> 此时，我们发现鱼总的后端项目模块中已经包含前面单独创建好的SDK和interface模拟接口项目了，那么我们如何把这两个添加到后端的项目中呢？\n>\n> 方案一：\n>\n> ​\t受尚医通项目的影响，我想应该可以通过增加子模块的方法拉进行添加，但是添加之后好像是不太行，跟鱼总的不一样，这种方法应该是可以使多个项目在同一个窗口中打开（解决了之前我的疑虑）\n>\n> 方案二：\n>\n> ​\t我们看到鱼总的后端项目中，另外两个项目（SDK和interface）是两个目录的标识，于是我就直接复制粘贴到后端项目的文件夹中了，然后Java源文件会变成红J，可以通过右键rsc下main下的Java文件夹，然后mark Directory as--》Sources Root，将Java文件夹标记为源码根目录，如图所示：\n>\n> ![image-20230708205543307](https://cdn.jsdelivr.net/gh/wl2o2o/blogCdn/img/202307092023528.png)\n>\n> 然后我们发现maven的pom依赖文件的图标也不对，也通过桐言的方法，右键--》add maven project标记为maven项目，大功告成！\n\n1.开发接口发布/下线的功能（管理员）\n\n2.前端浏览接口，查看 接口文档，申请签名（注册）\n\n3.在线测试（用户）\n\n4.统一用户调用接口次数\n\n5.优化系统-API网关\n\n### 开发接口发布/下线的功能（仅管理员） \n\n> 此处又涉及到了一个待学知识点：\n>\n> Spring的AOP切面应用\n>\n> 可以用来通过注解的方式进行权限管理。\n\n### 后端接口： \n\n**发布接口**（仅管理员） \n\n1.校验该接口是否存在\n\n2.判断接口是否可以被调用\n\n​\t利用开发好的SDK，通过调用接口看是否能够进行调用的通\n\n​\t第一步：启动smartapi-interface项目\n\n​\t第二步：在smartapi-backend中引入SDK的依赖\n\n​\t第三步：在application.yml中写入ak、sk\n\n​\t第四步：在接口中引入客户端的实例\n\n​\t\t\t@Resource\n\n​\t\t\tprivate SmartApiClient smartapiclient\n\n> TODO:\n>\n> > >  1. 判断接口是否可以调用时，由固定方法名改为可以根据测试地址进行调用\n> > >  2. 用户测试接口判断接口是否可以调用时，由固定方法名改为可以根据测试地址进行调用\n\n3.修改数据库接口字段为1\n\n**下线接口**（仅管理员） \n\n1.校验该接口是否存在\n\n2.修改数据库接口字段为 0\n\n按钮已添加并完善。测试中出现一个经典问题，如图所示：\n\n![image-20230710000821503](https://cdn.jsdelivr.net/gh/wl2o2o/blogCdn/img/202307100008989.png)\n\n\n\n> 待办事件：\n>\n> 流程：\n>\n> \n>\n> **前端**添加上线、下线按钮、√、增加用户浏览页面、查看接口文档、申请签名\n>\n> **后端**申请签名（更改完善数据库写生成签名的算法）\n>\n> **前端**\n>\n> 新增在线调用的按钮\n>\n> **后端**\n>\n> 开发在线调用的接口\n>\n> \n\n\n\n\n\n\n\n### 前端浏览接口\n\n```react\nimport { PageContainer } from '@ant-design/pro-components';\nimport React, {useEffect, useState} from 'react';\nimport {List, message} from \"antd\";\nimport {\n  listInterfaceInfoByPageUsingGET\n} from \"@/services/smartapi-backend/interfaceInfoController\";\n\n\n/**\n * 主页\n * @constructor\n */\nconst Index: React.FC = () => {\n\n  const [loading, setLoading] = useState(false);\n  const [list, setList] = useState<API.InterfaceInfo[]>([]);\n  const [total ,setTotal] = useState<number>(0);\n\n  const loadData = async (current=1 , pageSize = 8 ) =>{\n    setLoading(true);\n    try {\n      const res = await listInterfaceInfoByPageUsingGET({\n        current,pageSize\n      });\n      setList(res?.data?.records ?? []);\n      setTotal(res?.data?.total ?? 0);\n\n    } catch (error: any) {\n\n      message.error('请求失败,'+error.message);\n      return false;\n    }\n    setLoading(false);\n  }\n  useEffect(() => {\n    loadData();\n  },[])\n\n\n  return (\n    <PageContainer title=\"在线接口开放平台\">\n      <List\n        className=\"my-list\"\n        loading={loading}\n        itemLayout=\"horizontal\"\n        dataSource={list}\n        renderItem={item => {\n\n          const apiLink =`/interface_info/${item.id}`;\n          return(\n            <List.Item\n              actions={[<a key={item.id} href={apiLink}>查看</a>]}\n            >\n              <List.Item.Meta\n                title={<a href={apiLink}>{item.name}</a>}\n                description={item.description}\n              />\n            </List.Item>\n          )\n        }\n\n        }\n        pagination ={\n          {\n            // eslint-disable-next-line @typescript-eslint/no-shadow\n            showTotal(total: number){\n              return '总数：' +total;\n            },\n            pageSize: 8,\n            total,\n            onChange(page,pageSize){\n              loadData(page,pageSize);\n            }\n          }\n        }\n      />\n    </PageContainer>\n  );\n};\n\nexport default Index;\n```\n\n### 查看接口文档\n\n```react\nimport { PageContainer } from '@ant-design/pro-components';\nimport React, {useEffect, useState} from 'react';\nimport {Card, Descriptions, message} from \"antd\";\nimport {\n  getInterfaceInfoByIdUsingGET,\n\n} from \"@/services/smartapi-backend/interfaceInfoController\";\nimport { useParams} from \"@@/exports\";\n\n\n/**\n * 主页\n * @constructor\n */\nconst Index: React.FC = () => {\n\n  const [loading, setLoading] = useState(false);\n  const [data, setData] = useState<API.InterfaceInfo>();\n  const params  = useParams();\n\n  const loadData = async () =>{\n    if (!params.id){\n      message.error('参数不存在');\n      return ;\n    }\n    setLoading(true);\n    try {\n      const res = await getInterfaceInfoByIdUsingGET({\n        id: Number(params.id)\n      });\n      setData(res.data);\n\n    } catch (error: any) {\n\n      message.error('请求失败,'+error.message);\n      return false;\n    }\n    setLoading(false);\n  }\n  useEffect(() => {\n    loadData();\n  },[])\n\n  return (\n    <PageContainer title=\"查看接口文档\">\n      <Card>\n        {\n          data?(\n            <Descriptions title={data.name} column={1}>\n              <Descriptions.Item label=\"描述\">{data.description}</Descriptions.Item>\n              <Descriptions.Item label=\"接口状态\">{data.status? '正常': '关闭'}</Descriptions.Item>\n              <Descriptions.Item label=\"请求地址\">{data.url}</Descriptions.Item>\n              <Descriptions.Item label=\"请求方法\">{data.method}</Descriptions.Item>\n              <Descriptions.Item label=\"请求头\">{data.requestHeader}</Descriptions.Item>\n              <Descriptions.Item label=\"响应头\">{data.responseHeader}</Descriptions.Item>\n              <Descriptions.Item label=\"创建时间\">{data.createTime}</Descriptions.Item>\n              <Descriptions.Item label=\"更新时间\">{data.updateTime}</Descriptions.Item>\n            </Descriptions>\n          ):(\n            <>接口不存在</>\n          )}\n      </Card>\n    </PageContainer>\n  );\n};\n\nexport default Index;\n```\n\n### 申请签名（注册） \n\n通过数据库新增字段、更改用户注册的逻辑（使用DigestUtil加密算法生成ak、sk，然后加入数据库）\n\n> 留一个小作业:\n>\n> 新增一个小拓展功能：用户可以手动更改自己的ak、sk\n\n### 新建真实数据（前端）\n\n**新建这些真实的数据**\n\n```text\ngetUsernameByPost,\n\n获取用户名,\n\nhttp://localhost:8123/name/user,\n\n{”Content-Type“: ”application/json“},\n\n{”Content-Type“: ”application/json“},\n\n```\n\noh my god，此时发现遗忘了一个重要的请求参数字段，于是通过建表语句、IDEA客户端modify table，来增加这么一个字段。\n\n修改相应的model实体包中的字段信息以及向mybatisplus.xml中添加这个字段。\n\n重启项目---》前端重新使用openai插件生成接口\n\n前端也需要完善修改组件的表单列名，新增一个requestParams\n\n完成！\n\n**完善接口信息的请求参数信息**\n\n**在线调用**\n\n前端界面的编写，通过ant design组件库利用现成的表单组件来完成在线按钮的添加与请求参数的基本表单。\n\n![image-20230710023831281](https://cdn.jsdelivr.net/gh/wl2o2o/blogCdn/img/202307100238354.png)\n\n请求参数的类型（JSON类型）\n\n> 又一个小作业：\n>\n> 在线调用的扩展点：\n>\n> 先跑通整个流程，然后根据请求头和请求类型的不同设计不同的表单和界面，增强用户体验\n\n\n\n### 后端调用流程\n\n![image-20230710024253445](https://cdn.jsdelivr.net/gh/wl2o2o/blogCdn/img/202307100242406.png)\n\n按照标准的企业开发流程来说：\n\n一定会选择第一种开发方式，不然后期的网关与计费就毫无作用，\n\n第二种方式可以用来自己调用测试。\n\n\n\n流程：\n\n1. 前端将用户输入的请求参数与要进行测试的接口id发给平台后端\n2. 在调用前进行一些校验\n3. 平台后端去调用模拟接口\n\n```Java\n/**\n     * 测试调用\n     *\n     * @param interfaceInfoInvokeRequest\n     * @param request\n     * @return\n     */\n    @PostMapping(\"/invoke\")\n    public BaseResponse<Object> invokeInterfaceInfo(@RequestBody InterfaceInfoInvokeRequest interfaceInfoInvokeRequest,\n                                                    HttpServletRequest request) {\n        if (interfaceInfoInvokeRequest == null || interfaceInfoInvokeRequest.getId() <= 0) {\n            throw new BusinessException(ErrorCode.PARAMS_ERROR);\n        }\n        long id = interfaceInfoInvokeRequest.getId();\n        String userRequestParams = interfaceInfoInvokeRequest.getUserRequestParams();\n        // 判断是否存在\n        InterfaceInfo oldInterfaceInfo = interfaceInfoService.getById(id);\n        if (oldInterfaceInfo == null) {\n            throw new BusinessException(ErrorCode.NOT_FOUND_ERROR);\n        }\n        if (oldInterfaceInfo.getStatus() == InterfaceInfoStatusEnum.OFFLINE.getValue()) {\n            throw new BusinessException(ErrorCode.PARAMS_ERROR, \"接口已关闭\");\n        }\n        User loginUser = userService.getLoginUser(request);\n        String accessKey = loginUser.getAccessKey();\n        String secretKey = loginUser.getSecretKey();\n        MyClient tempClient = new MyClient(accessKey, secretKey);\n        Gson gson = new Gson();\n        com.wl.smartapiclientsdk.model.User user = gson.fromJson(userRequestParams, com.wl.smartapiclientsdk.model.User.class);\n        String usernameByPost = tempClient.getUserNameByPost(user);\n        return ResultUtils.success(usernameByPost);\n    }\n```\n\n后端调用逻辑已完成\n\n现在继续完善前端的接口，将前端点击调用按钮后改为我们刚才通过后端实现的真实的功能。\n\n```\nconst onFinish = (values: any) => {\n    if (!params.id){\n      message.error('接口不存在');\n      return ;\n    }\n    try {\n      invokeInterfaceInfoUsingPOST({\n        id: params.id,\n        ...values\n      })\n      message.success('请求成功');\n      return true;\n    } catch (error: any) {\n      message.error('请求失败，' + error.message);\n    }\n  };\n```\n\n逻辑打通之后还要进行回显数据：\n\n```\n// async 是设置同步的意思\n\n const onFinish = async (values: any) => {\n    if (!params.id){\n      message.error('接口不存在');\n      return ;\n    }\n    try {\n// 等待\n\n      const res = await invokeInterfaceInfoUsingPOST({\n        id: params.id,\n        ...values\n      })\n// 将res.data赋给setInvokeRes\n\n      setInvokeRes(res.data);\n      message.success('请求成功');\n      return true;\n    } catch (error: any) {\n      message.error('请求失败，' + error.message);\n    }\n  };\n```\n\n然后在表单处新增一个卡片，用于接收invokeRes进行数据回显。\n\n已完成，测试通过！\n\n并且完善了一个缓冲显示的loading\n\n\n\nTODO:\n\n> >  1. 判断接口是否可以调用时，由固定方法名改为可以根据测试地址进行调用\n> >  2. 用户测试接口判断接口是否可以调用时，由固定方法名改为可以根据测试地址进行调用\n> >  3. 此时任何人调用模拟接口都是可以的，因为我们的SDK是写死在配置文件中的，所以后续再进行完善，从数据库中进行校验！\n\n\n\nover！\n\n下面我们的网关用Spring Cloud GateWay实现\n\n\n\n## Day04 \n\n1. 开发接口调用次数统计  20min\n\n2. 优化系统的架构---学习架构设计、接触应用场景==>面对一个需求就会自然而然地提高开发效率。 60min\n\n   （怎么把一个项目的架构设计做的更加合理，涉及到API网关的知识）\n\n   * 网关是什么？\n   * 网关的作用？\n   * 网关的应用场景以及实现？\n   * 结合业务去应用网关\n\n### 接口调用次数统计\n\n需求：\n\n\t1. 用户每次调用接口成功，次数加1（或者设定一定的调用次数，每次减1）\n\t1. 给用户分配或者用户自助申请接口调用次数\n\n> 业务流程：\n>\n> 1. 用户调用接口（之前已完成）\n> 2. 修改数据库，调用次数（加1或者减1）\n\n设计库表：\n\n> 哪个用户？哪个接口？\n>\n> 用户 => 接口（多对多）\n\n用户接口关系表：\n\n```\n-- 用户调用接口关系表\ncreate table if not exists smartapi.`user_interface_info`\n(\n    `id` bigint not null auto_increment comment '主键' primary key,\n    `userId` bigint not null comment '调用用户 id',\n    `interfaceInfoId` bigint not null comment '接口 id',\n    `totalNum` int default 0 not null comment '总调用次数',\n    `leftNum` int default 0 not null comment '剩余调用次数',\n    `status` int default 0 not null comment '0-正常，1-禁用',\n    `createTime` datetime default CURRENT_TIMESTAMP not null comment '创建时间',\n    `updateTime` datetime default CURRENT_TIMESTAMP not null on update CURRENT_TIMESTAMP comment '更新时间',\n    `isDelete` tinyint default 0 not null comment '是否删除(0-未删, 1-已删)'\n) comment '用户调用接口关系';\n```\n\n### 步骤：\n\n1. 开发基本的增删改查（给管理员使用）\n\n   > 直接使用Mybatis-X生成相关的实体类（注意在删除字段上米娜加上逻辑删除@TableLogic）、mapper、service实现类没然后移动到项目对应的包中。\n   >\n   > 复制写好的Controller，改那些增删改查！ 完成√\n\n2. 开发用户调用接口次数加1（或者减1）\n\n   问：如果每个接口的方法，都写调用次数 + 1，是不是比较麻烦，如果在本项目中，将这个调用次数+ 1，封装成一个方法，也是可以的，但是`代码侵入性很强！`\n\n   致命问题是：接口开发者需要自己进行调用！\n\n   解决方法：\n\n   1. Spring中的AOP（推荐，是Spring的一个核心特性）\n   2. Servelet中的拦截器、过滤器（Fillter）\n   3. 通用的方法（缺点：代码侵入性强，需要自己调用）\n   4. 网关\n\n\n\n简单说一下AOP切面的基本过程：\n\n> 先说一下AOP切面的作用：\n>\n> 就相当于在接口或者方法调用前或者调用之后帮你做一些事情，其底层的原理就是动态代理。\n>\n> 使用AOP切面的\n>\n> 优点：\n>\n> 独立于接口，在每个接口调用前后加 1\n>\n> 缺点：\n>\n> 只存在于单个项目中，如果每个团队都要写一个自己的切面\n>\n> // TODO：下去看一下AOP的流程，熟悉一下\n\n\n\n我们在这个项目中使用网关来实现接口调用次数。\n\n网关就当与在所有接口的入口前加了一层检票口，如图所示：\n\n![image-20230716015231451](https://cdn.jsdelivr.net/gh/wl2o2o/blogCdn/img/202307160152994.png)\n\n因为网关实现的有调用次数的统计，所以开发者可以通关网关来查看，而用户调用接口时直接输入请求参数、请求地址即可。\n\n### 网关：\n\n这里为什么写这么多理论呢？写代码不一定是最重要的，重要的是思想！逻辑思想明白之后，无非就是看文档、百度实现。\n\n> 什么是网关呢？就相当于车票检票口，统一去检票。\n>\n> 优点？统一去进行一些操作、处理一些问题。\n>\n> 作用？\n>\n> 1. 路由\n>\n> 2. 负载均衡\n>\n> 3. 统一鉴权\n>\n> 4. 统一处理跨域\n>\n> 5. 统一业务处理（缓存）\n>\n> 6. 访问控制\n>\n> 7. 发布控制（灰度发布，也就是慢慢控制接口的流量，不断开放给更多用户，然后达到升级接口的目的）\n>\n> 8. 流量染色（给流量添加一些标识，比如新的请求头信息）\n>\n> 9. 统一接口保护 \n>\n>    1. 限制请求\n>\n>    2. 信息脱敏（网关可以操作你的请求口，进而抹去敏感信息）\n>\n>    3. 降级（熔断，保险起见，接口下线后，可以返回一些提示信息）\n>\n>    4. 限流\n>\n>       （// TODO：学习令牌桶算法，学习露桶算法，学习一下）\n>\n>    5. RedislimitHandler\n>\n>    6. 超时时间\n>\n>    7. 重试（业务保护）\n>\n> 10. 统一日志\n>\n> 11. 统一文档（将下游项目的文档统一聚合，展示到一个页面）\n\n\n\n### 路由\n\n起到转发的作用，比如有接口A和接口B,网关会记录这些信息，根据用户访问的地址和参数，转发请求到对应的接口（服务器/集群）\n\n用户a调用接口A\n\n/a=>接口A /b=>接口B\n\nhttps://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#gateway-request-predicates-factories\n\n### 负载均衡 \n\n在路由的基础上可以转发到某一个服务器\n\n/c => 服务A/ 集群A（随机转发到其中的某一个机器）\n\nuri从固定地址改成b:xx\n\n### 统一鉴权 \n\n判断用户是否有权限进行操作，无论访问什么接口，我都统一去判断权限，不用重复写\n\n### 统一处理跨域 \n\n网关统一处理跨域，不用在每个项目单独处理\n\nhttps://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#cors-configuration\n\n### 统一业务处理 \n\n把每个项目中都要做的通用逻辑放到上层（网关），统一处理，比如本项目的次数统计\n\n### 访问控制 \n\n黑白名单，比如限制ddos ip\n\n### 发布控制 \n\n灰度发布，比如上线新接口，先给新接口分配 20%流量，老接口80% ,再慢慢调整比例\n\nhttps://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#the-weight-route-predicate- factory\n\n### 流量染色 \n\n区分用户来源\n\n给请求（流量）添加一些标识，一般是设置请求头中，添加新的请求头 https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#the-addrequestheader-gatewayfilter-factory\n\n全局染色：https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#default-filters\n\n### 接口保护 \n\n1 限制请求 https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#requestheadersiz-gatewayfilter-factory \n\n2 信息脱敏 https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#the-removerequestheader-gatewayfilter-factory \n\n3 降级（熔断） 进行兜底 https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#fallback-headers \n\n4 限流 https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#the-requestratelimiter-gatewayfilter-factory \n\n5 超时时间   超时就中断 https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#http-timeouts-configuration \n\n6 重试（业务保护）： https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#the-retry-gatewayfilter-factory \n\n### 统一日志 \n\n统一的请求，响应信息记录\n\n### 统一文档 \n\n将下游项目的文档进行聚合，在一个页面统一查看\n\n建议用：https://doc.xiaominfo.com/docs/middleware-sources/,aggregation-introduction\n\n\n### 网关的分类\n\n1. 全局网关（接入层网关）：作用是负载均衡、请求日志，不和业务逻辑绑定\n\n2. 业务网关（微服务网关：会有一些业务逻辑）：作用是根据不同的请求转发到不同的项目接口\n\n   参考文章：https://blog.csdn.net/qq21040559/article/,details/,122961395\n\n### 实现\n\n1. Nginx（推荐的全局型网关）\n\n2. Kong网关（适合API网关）--收费！！\n\n3. `Spring Cloud Gateway`（取代了Zuul，因为架构设计并不太好，并发量也有限）\n\n   > 优点：用到了NIO、多路复用、底层Netty、React模型；\n   >\n   > 最大的亮点：可以用Java代码写逻辑，其他网关都需要学习一些其他语言（Nginx需要学到一些Lua脚本）\n\n网关技术选型：https://zhuanlan.zhihu.com/p/500587132\n\n### Spring Cloud Gateway用法\n\n官网是最好的老是去看官网\n\n去看官网：https://spring.io/projects/spring-cloud-gateway\n\n官方文档：https://docs.spring.io/spring-cloud-gateway/docs/current/reference//html/\n\n\n\n\n\n### 创建一个Gateway项目\n\n小作业：完成官网的小demo（编程式demo）\n\n\n\n\n\n## Day05 把API网关应用到项目中\n\n任务：\n\n1. 完成统一的用户鉴权、统一的接口调用次数统计（API网关应用）\n2. 完善功能\n\n\n\n### 将用到的特性\n\n1. 路由（转发请求到模拟接口项目）\n\n2. ~~负载均衡（需要用到注册中心）~~\n3. 统一鉴权(accessKey，secretKey)\n4. 统一处理跨域\n5. 统一业务处理（每次请求接口后，接口调用次数+1）\n6. 访问控制（黑白名单）\n7. ~~发布控制~~\n8. 流量染色(记录请求是否为网关来的)\n9. ~~统一接口保护~~ \n   1. 限制请求\n   2. 信息脱敏\n   3. 降级（熔断）\n   4. 限流 学习令牌桶算法，学习露桶算法，学习一下RedislimitHandler\n   5. 超时时间\n   6. 重试（业务保护）\n10. 统一日志(记录每次的请求和响应)\n11. ~~统一文档~~\n\n\n\n### 业务逻辑\n\n> 为什么会用到API网关？\n>\n> 结合架构图来说，简单来说也就是加一个检票口，同时也可以添加流量染色、链路追踪的功能、灰度发布等等。。。\n\n1. 用户发送请求到API网关（请求转发）\n2. *请求日志*\n3. *黑白名单*\n4. 用户鉴权（如何？判断ak、sk）\n5. 请求的模拟接口是否存在？\n6. 请求转发，调用模拟接口\n7. 响应日志\n8. 调用成功，接口调用次数 + 1\n9. 调用失败，返回规范错误码\n\n\n\n### 实现\n\n1. **请求转发**\n\n   [使用前缀匹配断言](https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#the-path-route-predicate-factory)\n\n   所有路径为：`/api/**` 的请求转发，转发到http://localhost:8123/api/**\n\n   比如：\n\n   请求于http://localhost:8090/api/name/get?/name=wlei224\n\n   转发到http://localhost:8123/api/name/get?/name=wlei224\n\n```yaml\nspring:\n  cloud:\n    gateway:\n      routes:\n      - id: path_route\n        uri: https://example.org\n        predicates:\n        - Path=/red/{segment},/blue/{segment}\n```\n\n2. 其他业务逻辑\n\n> ​\ttodo：Spring注解\t  @component\n\n​\t使用Spring Cloud Gateway中的GlobalFilter实现请求拦截处理（类似于AOP）\n\n​\t![image-20230725194819206](https://cdn.jsdelivr.net/gh/wl2o2o/blogCdn/img/202307251948339.png)\n\n​\t[GlobalFilter](https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#gateway-combined-global-filter-and-gatewayfilter-ordering)直接复制代码到网关项目的全局异常类中。\n\n​\t验证通过√\n\n2. 正式开始写业务逻辑\n\n> 1. 用户发送请求到API网关（请求转发）√\n>\n>    代码能运行到这个controller业务逻辑层，就说明用户已经发送了请求\n>\n> 2. *请求日志*\n>\n>    ![image-20230728115938432](https://cdn.jsdelivr.net/gh/wl2o2o/blogCdn/img/202307281159504.png)\n>\n>    我们发现请求参数中含有一个交换机，于是可以试着从这里找到request请求，拿到请求头中的信息；\n>\n>    添加`@Slf4j`注解，用log.info在控制台输出请求头日志；\n>\n> 3. *黑白名单*\n>\n>    在权限管理业务中一般设置的是白名单，这样只有允许的才可以进行访问，更加安全！\n>\n>    在IDEA中直接敲`prsf`写一个白名单常量。\n>\n>    ```Java\n>    // 2. 访问控制 -- 设置黑白名单（可以用设置响应状态码来实现）\n>    ServerHttpResponse response = exchange.getResponse();\n>    if(!IP_WHITE_LIST.contains(sourceAdress)) {\n>        // handleNoAuth(response);\n>        response.setStatusCode(HttpStatus.FORBIDDEN);\n>    \treturn response.setComplete();\n>    }\n>    ```\n>\n>    \n>\n> 4. 用户鉴权（如何？判断ak、sk）\n>\n>    ```java\n>    //  用户鉴权（如何？判断ak、sk）\n>    HttpHeaders headers = request.getHeaders();\n>    String accessKey = headers.getFirst(\"accessKey\");\n>    String nonce = headers.getFirst(\"nonce\");\n>    String timeStamp = headers.getFirst(\"timeStamp\");\n>    String sign = headers.getFirst(\"sign\");\n>    String body = headers.getFirst(\"body\");\n>    // TODO 要去数据库中查询\n>    // 为了方便进行校验，直接进行判断数据，正规来说应该从数据库中进行校验数据\n>    if (!\"wl\".equals(accessKey)){\n>        // throw new RuntimeException(\"无权限！\");\n>        // 封装了一个方法，专门用于处理异常请求\n>        return handleNoAuth(response);\n>    }\n>    if (Long.parseLong(nonce) > 10000L){\n>    \treturn handleNoAuth(response);\n>    }\n>                                                                                                                   \n>    //  时间戳校验自己实现，时间和当前时间不能超过5min\n>    Long currentTime = System.currentTimeMillis() / 1000;\n>    Long FIVE_MINUTES = 60 * 5L;\n>    if ((currentTime-Long.parseLong(timeStamp)) >= FIVE_MINUTES) {\n>    \treturn handleNoAuth(response);\n>    }\n>                                                                                                                   \n>    // TODO 要去数据库中查询\n>    String serverSign = SignUtils.getSign(body, \"abcdefgh\");\n>    if (!serverSign.equals(sign)) {\n>    \tthrow new RuntimeException(\"无权限！\");\n>    }\n>    ```\n>\n>    \n>\n> 5. 请求的模拟接口是否存在？\n>\n>    // TODO 从数据库中进行查询接口是否存在，以及请求方法是否匹配（严格的话可以再校验一下请求参数，但是业务层面的请求参数不建议放到全局请求网关里面）\n>    // 因为数据库的访问方法已经再backend中已经写过，操作较为复杂的话不建议重复写，所以我们可以采用远程调用的方式（也就是可以说是微服务，这个项目完全可以写成微服务：`OpenFeigh`，目前项目的定位还是`分布式项目`结合微服务的远程调用，避免重复写业务逻辑）\n>\n>    \n>\n> 6. 请求转发，调用模拟接口\n>\n>    ```java\n>    Mono<Void> filter = chain.filter(exchange);\n>    ```\n>\n>    \n>\n> 7. 响应日志\n>\n>    ```java\n>    log.info(\"响应：\" + response.getStatusCode());\n>    ```\n>\n>    \n>\n> 8. 调用成功，接口调用次数 + 1\n>\n>    ```java\n>    // TODO invokeCount\n>    ```\n>\n> 9. 调用失败，返回规范错误码\n>\n>    ```Java\n>    // 用户鉴权异常\n>        public Mono<Void> handleNoAuth(ServerHttpResponse response) {\n>            response.setStatusCode(HttpStatus.FORBIDDEN);\n>            return response.setComplete();\n>        }\n>        // 自定义错误异常\n>        public Mono<Void> handleInvokeError(ServerHttpResponse response) {\n>            response.setStatusCode(HttpStatus.INTERNAL_SERVER_ERROR);\n>            return response.setComplete();\n>        }\n>    ```\n>\n>    \n>\n\n* 为了方便进行业务逻辑的编写，我们可以向上面一样，将提前编写好的业务流程粘贴到类文件中。\n\n\n\n### 测试\n\n通过测试我们发现，通过http://127.0.0.1:8090/api/name/get?name=wl进行访问时，还是会遭到拒绝，为什么呢？此时不是请求头丢失，而是我们根本就没写请求头，跑通这个逻辑的话，可以从前端进行调用测试。\n\n![image-20230803025109861](https://cdn.jsdelivr.net/gh/wl2o2o/blogCdn/img/202308030251719.png)\n\n### 🧑‍💻业务逻辑预期结果：\n\n等模拟接口调用完成，才记录响应日志、统计调用次数。\n\n### 存在问题：\n\n> 虽然上述代码可以跑通，但是还存在一个问题，我们通过debug模式可以看到，代码在执行到请求转发的`Mono<Void> filter = chain.filter(exchange);`方法后，并没有进入到方法中，反而是继续执行下面的代码，直到`chain.filter`方法之后才进入模拟接口方法中。\n>\n> `原因：`\n>\n> chain.filter是个异步操作，可以理解为前端的promise\n>\n> `解决方案：`\n>\n> 利用Spring Cloud Gateway提供的自定义响应装饰器中的response装饰者，以次增强原有response的处理能力\n>\n> 引申：什么叫装饰者设计模式？\n>\n> ​\t作用就是：在原本类的基础上对原有类的能力的增强，也就可以理解为给response买了一件装备，拥有了更多的能力。解释成代码语言意思就是，增写response部分代码，实现需要的功能。\n>\n> `参考博客：` \n>\n> https://blog.csdn.net/qq_19636353/article/details/126759522  (以这个为主) \n>\n> `其他参考：` \n>\n> https://blog.csdn.net/m0_67595943/article/details/124667975 \n>\n> https://blog.csdn.net/weixin_43933728/article/details/121359727?spm=1001.2014.3001.5501 \n>\n> https://blog.csdn.net/zx156955/article/details/121670681 https://blog.csdn.net/qq_39529562/article/details/108911983\n\n```java\npublic Mono<Void> handleResponse(ServerWebExchange exchange, GatewayFilterChain chain){  \n\n    try {  \n        //从交换寄拿响应对象  \n        ServerHttpResponse originalResponse = exchange.getResponse();  \n        //缓冲区工厂，拿到缓存数据  \n        DataBufferFactory bufferFactory = originalResponse.bufferFactory();  \n        //拿到响应码  \n        HttpStatus statusCode = originalResponse.getStatusCode();  \n        if(statusCode == HttpStatus.OK){  \n            //装饰，增强能力  \n            ServerHttpResponseDecorator decoratedResponse = new ServerHttpResponseDecorator(originalResponse) {  \n            //等调用完转发的接口后才会执行\n                @Override  \n                public Mono<Void> writeWith(Publisher<? extends DataBuffer> body) {  \n                    log.info(\"body instanceof Flux: {}\", (body instanceof Flux));  \n                    //对象是响应式的  \n                    if (body instanceof Flux) {  \n                        //我们拿到真正的body  \n                        Flux<? extends DataBuffer> fluxBody = Flux.from(body); \n                        //往返回值里面写数据  \n                        //拼接字符串  \n                        return super.writeWith(fluxBody.map(dataBuffer -> { \n                            // 7. TODO 调用成功，接口调用次数 + 1 invokeCount\n                            byte[] content = new byte[dataBuffer.readableByteCount()];  \n                            dataBuffer.read(content);  \n                            DataBufferUtils.release(dataBuffer);//释放掉内存  \n                            // 构建日志  \n                            StringBuilder sb2 = new StringBuilder(200);  \n                            sb2.append(\"<--- {} {} \\n\");  \n                            List<Object> rspArgs = new ArrayList<>();  \n                            rspArgs.add(originalResponse.getStatusCode());  \n                            //rspArgs.add(requestUrl);  \n                            String data = new String(content, StandardCharsets.UTF_8);//data \n                            sb2.append(data);  \n                            log.info(sb2.toString(), rspArgs.toArray());//log.info(\"<-- {} {}\\n\", originalResponse.getStatusCode(), data);  \n                           return bufferFactory.wrap(content);  \n                        }));  \n                    } else {  \n                        // 8. 调用失败，fan'hui一个规范的\n                        log.error(\"<--- {} 响应code异常\", getStatusCode());  \n                    }  \n                    return super.writeWith(body);  \n                }  \n            };  \n            //设置 response 对象为装饰过的  \n            return chain.filter(exchange.mutate().response(decoratedResponse).build());  \n        }  \n        return chain.filter(exchange);//降级处理返回数据  \n    }catch (Exception e){\n        log.error(\"gateway log exception.\\n\" + e);  \n        return chain.filter(exchange);\n    }\n}\n```\n\n## Day06 完善网关的业务逻辑\n\n### 今日计划\n\n1. 补充完整网关的业务逻辑（如何操作数据库?如何服用之前写过的方法？RPC）\n2. 完善系统的TODO和其他功能，并开发一个管理员的监控统计功能\n\n\n\n### 网关业务逻辑\n\n问题：之前的项目已经写过了调用数据库的那些mybatis的业务逻辑，复制粘贴太麻烦\n\n解决：用一个可以直接调用的解决方法：RPC\n\n\n\n### 如何调用其他项目的方法\n\n1. 复制粘贴代码和相关依赖\n2. HTTP请求（提供接口，供其他项目进行调用）\n3. jar包调用\n4. 把公共代码达成jar包，其他项目直接引用\n\n### HTTP请求怎么调用\n\n1. 提供方开发一个接口（地址、请求方法、参数、返回值）\n2. 调用方使用`HTTP Client`之类的代码取发送HTTP请求\n\n\n\n### RPC（remote produce call）\n\n**作用：像调用本地方法一样去调用远程方法**\n\n优点：\n\n\t1. 对开发者更加透明，减少了调用见的沟通成本\n\t1. RPC向远程服务器发送请求时，未必要使用HTTP协议，比如：TCP/IP、或者自己封装的协议。（内部服务更加适用）\n\n### `Feign && RPC`\n\n> Feign底层用的HTTP协议，虽然也可以很方便的进行调用，但是区别在于Feign只是让请求过程更加精简,HTTP请求其实可以做到和RPC一样的事情，但是还有区别：RPC向远程服务器发送请求时，未必要使用HTTP协议，比如：TCP/IP、或者自己封装的协议。\n\nHTTP协议是一个7层协议，如果想要接口的性能更高，可以使用TCP/IP协议，更加原生的协议。\n\n一般来说微服务项目内部的接口，用`RPC`的性能可能会更加高一点，协议可选项更加多一点。\n\n`工作流程图：`\n\n![image-20230729232829504](https://cdn.jsdelivr.net/gh/wl2o2o/blogCdn/img/202307292328515.png)\n\n🆗，现在模型已经搭建好了，那么如何进行实现呢？使用Dubbo框架（如何学习？看官方文档）\n\n### Dubbo框架（RPC实现）（阿里公司的）\n\n其它类似的框架还有`GRPC`（Google公司的）、`TRPC`（腾讯公司的）\n\n最好的学习方式：[阅读官方文档！](https://cn.dubbo.apache.org/zh-cn/overview/mannual/java-sdk/quick-start/spring-boot/)\n\n\n\n### 两种使用方式\n\n1. Spring Boot代码（注解+编程式）：写Java接口，服务提供者和消费者都去引用这个接口 偏程导\n\n2. IDL(接口调用语言)：创建一个公共的接口定义文件，服务提供者和消费者读取这个文件。\n\n   优点：\n\n   * 跨语言，所有的框架都认识\n\n   * 底层是Triple（自定义封装协议，优点见[官文](https://cn.dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/protocol/triple/)）\n\n     ![image-20230730003800623](https://cdn.jsdelivr.net/gh/wl2o2o/blogCdn/img/202307300038465.png)\n\n### 示例项目学习\n\n```\ngit clone -b master https://github.com/apache/dubbo-samples.git\n```\n\nzookeeper注册中心：通过内嵌的方式运行，更方便\n\n最先启动注册中心，先启动服务提供者，再启动服务消费者\n\n### 整合应用\n\n1. 服务提供者：backend\n\n   a. 实际情况应该是去数据库中查是否已分配给用户\n\n   b. 从数据库中查询模拟接口是否存在，以及请求方法是否匹配（还可以校验请求参数）\n\n   c. 调用成功，接口调用次数+1 invokeCount\n\n2. gateway项日作为服务调用者，调用这3个方法\n\n\n\n> 整合步骤：\n>\n> 1. 依赖引入  视频事件：`00:52`\n>\n>    ```\n>                                                                                                                \n>    ```\n>\n>    \n>\n> 2. 将官方示例代码中的privider包粘到backend中\n\n\n\n\n\n\n\n\n\n## Day07 完善网关业务与上线\n\n### 今日计划\n\n1. 完善网关的业务\n2. 开发管理员的分析功能\n3. 项目上线\n\n\n\n### 整合nacos\n\n> 遇到一个`nocos`小BUG：\n>\n> Dubbo整合nocos的时候，提供者与消费者的包名不一样，这时，提供者将接口的信息注册到nacos文档时，用到的是provider的包名路径，如果出现消费者的包名路径与提供者的包名不同的时候，这时消费者就会报错找不到提供者的Service服务，如图：\n>\n> ![image-20230731193204173](https://cdn.jsdelivr.net/gh/wl2o2o/blogCdn/img/202307311932647.png)\n\n\n\n### 重新梳理网关的业务逻辑\n\n1. 实际情况应该是去数据库中查是否已分配给用户\n\n   a 先根据 accessKey 判断用户是否存在，查到 secretKey\n   b 对比 secretKey 和用户传的加密后的 secretKey 是否一致\n\n2. 从数据库中查询模拟接口是否存在，以及请求方法是否匹配（还可以校验请求参数）\n\n3. 调用成功，接口调用次数+1 invokeCount\n\n\n\n### 公共服务\n\n> 目的是让方法、实体在多个项目中进行复用，避免重复编写\n\n* 业务分析\n\n  * 1. 数据库中是否已分配给用户密钥（accesskey、secretkey，返回用户信息，为空表示不存在）√\n    2. 从数据库中查询模拟接口是否存在（请求路径、请求方法、请求参数，返回接口信息，为空表示不存在）\n    3. 接口调用次数 + 1 `invokeCount`（ak、sk、请求接口路径）√\n\n\n\n\n* 使用步骤：\n  * 1. 新建干净的 maven 项目，只保留必要的公共依赖\n  \n  * 2. 抽取 service 和实体类\n  \n  * 3. install 本地 maven 包\n  \n  * 4. 让服务提供者引入 common 包，测试是否正常运行（出现Bug，backend包中的实现类一直报错：\n  \n       > `'getBaseMapper()' in 'com.baomidou.mybatisplus.extension.service.impl.ServiceImpl' clashes with 'getBaseMapper()' in 'com.baomidou.mybatisplus.extension.service.IService'; attempting to use incompatible return type`\n       >\n       > 原因是`UserInterfaceInfoMapper`类中，忘记更改引入的实体类路径。\n       >\n       > 小技巧：![image-20230803051309362](https://cdn.jsdelivr.net/gh/wl2o2o/blogCdn/img/202308030513641.png)\n       >\n       > 可以通过这种方式快速实现外部提供的的接口。\n  \n  * 5. 让服务消费者引入 common 包\n\n* 业务流程\n\n  * 1. 新建干净的 maven 项目，只保留必要的公共依赖\n\n  * 2. 抽取 service 和实体类\n\n  * 3. install 本地 maven 包\n  \n  * 4. 让服务提供者引入 common 包，测试是否正常运行，加上@DubboService，以便供其它类使用\n\n    ```java\n    // mybatisplus真好用！业务crud手到擒来！\n    /**\n     * @author WLei224\n     * @create 2023/8/3 5:15\n     */\n    public class InnerInterfaceInfoServiceImpl implements InnerInterfaceInfoService {\n        @Resource\n        private InterfaceInfoMapper interfaceInfoMapper;\n        @Override\n        public InterfaceInfo getInterfaceInfo(String url, String method) {\n            if (StringUtils.isAnyBlank(url,method)){\n                throw new BusinessException(ErrorCode.PARAMS_ERROR);\n            }\n            QueryWrapper<InterfaceInfo> queryWrapper = new QueryWrapper<>();\n            queryWrapper.eq(\"url\",url);\n            queryWrapper.eq(\"method\",method);\n            return interfaceInfoMapper.selectOne(queryWrapper);\n        }\n    }\n    ```\n\n   * 5. 让服务消费者引入 common 包\n  \n     > 1. API网关项目中引入 common 依赖\n     >\n     > 2. 使用服务提供者提供的服务（@DubboService和@DubboReference）\n     >\n     >    通过@DubboReference注入公共模块中编写好的三个服务\n     >\n     > 3. 完善网关中的todo标签，完善业务逻辑\n  \n  ### 问题\n  \n  ​\t项目调试中存在一个问题：需要手动对接口的调用次数进行分配，这里考虑可以增加一个管理调用次数的接口。\n\n### 统计分析功能\n\n#### 需求\n\n各个接口的总调用次数的占比图（饼图），取调用次数最多的三个接口，从而进行分析出哪个接口还没有人进行调用，进而对其降低资源或者下线，高频接口（增加资源、提高收费）\n\n#### 实现\n\n* **前端**\n\n  * 强烈推荐使用现成的库\n\n    * Echarts：https://echarts.apache.org/zh/index.html（推荐）\n\n    * AntV：https://antv.vision/zh（推荐）\n\n    * BizCharts\n\n    * 如果是 React 项目，用这个库：https://github.com/hustcc/echarts-for-react\n\n    * > 怎么用？\n      >\n      > 1. 看官网\n      > 2. 找到快速入门、按文档去引入库\n      > 3. 进入示例页面\n      > 4. 找到你要的图\n      > 5. 在线调试\n      > 6. 复制代码\n      > 7. 改为真实数据\n\n* **后端**\n\n  * 写一个接口，得到下列示例数据：\n    接口 A：2次\n    接口 B：3次\n\n  * 步骤：\n\n    1. SQL 查询调用数据：\n\n       ```sql\n       select interfaceInfoId, sum(totalNum) as totalNum from user_interface_info group by interfaceInfoId order by totalNum desc limit 3;\n       ```\n\n    2. 业务层去关联查询接口信息。\n    \n       `controller`:（就不写Service了，直接写业务逻辑）\n    \n       ```java\n       /**\n        * 分析控制器\n        * @author yupi\n        */\n       @RestController\n       @RequestMapping(\"/analysis\")\n       @Slf4j\n       public class AnalysisController {\n       \n           @Resource\n           private UserInterfaceInfoMapper userInterfaceInfoMapper;\n       \n           @Resource\n           private InterfaceInfoService interfaceInfoService;\n       \n           @GetMapping(\"/top/interface/invoke\")\n           @AuthCheck(mustRole = \"admin\")\n           public BaseResponse<List<InterfaceInfoVO>> listTopInvokeInterfaceInfo() {\n               List<UserInterfaceInfo> userInterfaceInfoList = userInterfaceInfoMapper.listTopInvokeInterfaceInfo(3);\n       \n               Map<Long, List<UserInterfaceInfo>> interfaceInfoIdObjMap = userInterfaceInfoList.stream()\n                       .collect(Collectors.groupingBy(UserInterfaceInfo::getInterfaceInfoId));\n       \n               QueryWrapper<InterfaceInfo> queryWrapper = new QueryWrapper<>();\n               queryWrapper.in(\"id\", interfaceInfoIdObjMap.keySet());\n               List<InterfaceInfo> list = interfaceInfoService.list(queryWrapper);\n       \n               if (CollectionUtils.isEmpty(list)) {\n                   throw new BusinessException(ErrorCode.SYSTEM_ERROR);\n               }\n               List<InterfaceInfoVO> interfaceInfoVOList = list.stream().map(interfaceInfo -> {\n                   InterfaceInfoVO interfaceInfoVO = new InterfaceInfoVO();\n                   BeanUtils.copyProperties(interfaceInfo, interfaceInfoVO);\n                   int totalNum = interfaceInfoIdObjMap.get(interfaceInfo.getId()).get(0).getTotalNum();\n                   interfaceInfoVO.setTotalNum(totalNum);\n                   return interfaceInfoVO;\n               }).collect(Collectors.toList());\n               return ResultUtils.success(interfaceInfoVOList);\n           }\n       }\n       ```\n    \n       `封装类`：\n    \n       ```java\n       /**\n        * 接口信息封装视图\n        * @TableName product\n        */\n       @EqualsAndHashCode(callSuper = true)\n       @Data\n       public class InterfaceInfoVO extends InterfaceInfo {\n       \n           /**\n            * 调用次数\n            */\n           private Integer totalNum;\n       \n           private static final long serialVersionUID = 1L;\n       }\n       ```\n    \n       `UserInterfaceInfoMapper`:\n    \n       ```java\n       /**\n        * @Entity com.wl.smartapicommon.model.entity.UserInterfaceInfo\n        */\n       public interface UserInterfaceInfoMapper extends BaseMapper<UserInterfaceInfo> {\n       \n           // 获取前几个调用次数最多的接口\n           List<UserInterfaceInfo> listTopInvokeInterfaceInfo(int limit);\n       \n       }\n       ```\n    \n       `xml中添加sql语句`：\n    \n       ```xml\n       <select id=\"listTopInvokeInterfaceInfo\" resultType=\"com.wl.smartapicommon.model.entity.UserInterfaceInfo\">\n           select interfaceInfoId, sum(totalNum) as totalNum\n           from user_interface_info\n           group by interfaceInfoId\n           order by totalNum\n           desc limit #{limit};\n       </select>\n       ```\n    \n\n## 上线计划\n\n* 前端：参考之前用户中心或伙伴匹配系统的上线方式\n* 后端：\n  * backend 项目：web 项目，部署 spring boot 的 jar 包（对外的）\n  * gateway 网关项目：web 项目，部署 spring boot 的 jar 包（对外的）\n  * interface 模拟接口项目：web 项目，部署 spring boot 的 jar 包（不建议对外暴露的）\n\n***关键：网络必须要连通***\n\n>如果自己学习用：单个服务器部署这三个项目就足够。\n>如果你是搞大事，多个服务器建议在 同一内网 ，内网交互会更快、且更安全。\n\n\n\n#### 上线环境准备\n\n1. docker安装\n\n   ```shell\n   curl -fsSL https://get.docker.com | bash -s docker --mirror Aliyun\n   systemctl start docker \n   systemctl enable docker\n   systenctl restart docker\n   ```\n\n2. 宝塔面板\n\n   ```shell\n   # 安装命令\n   yum install -y wget && wget -O install.sh http://download.bt.cn/install/install_6.0.sh && sh install.sh\n   # 卸载命令\n   systemct stop bt\n   rm -rf /www/server/panel\n   rm -f /etc/init.d/bt\n   \n   rm -rf /root/.pyenv/versions/3.7.0/envs/btpanel/lib/python3.7/site-packages/pycache\n   rm -rf /root/.pyenv/versions/3.7.0/envs/btpanel/lib/python3.7/site-packages/btpanel/__pycache__\n   rm -rf /root/.pyenv/versions/3.7.0/envs/btpanel/lib/python3.7/site-packages/panelApp/__pycache__\n   \n   rm -rf /www/server/panel/logs/*\n   ```\n\n3. [Docker 安装 Nginx](https://blog.csdn.net/u010148813/article/details/126172372)\n\n   ```shell\n   # 拉取官方的最新版本的镜像\n   $ docker pull nginx\n   \n   # 使用以下命令来运行 nginx 容器\n   $ docker run --name nginx -p 80:80 -d nginx\n   \n   # 在宿主机家目录创建用于放配置文件的文件夹\n   $ mkdir -p /root/docker-nginx/{conf,html,logs}\n   \n   # 从容器nginx中复制nginx.conf文件到宿主机\n   $ docker cp nginx:/etc/nginx/nginx.conf /root/docker-nginx       \n   $ docker cp nginx:/etc/nginx/conf.d/default.conf /root/docker-nginx/conf/\n   $ docker cp nginx:/usr/share/nginx/html/ /root/docker-nginx/\n   \n   \n   ----------------------------------------------\n   说明：\n   宿主机：就是你的云服务器或者虚拟机。\n   ~ 目录，也就是我们常说的家目录/home/your_username.(如果是云服务器，且没有创建普通用户，那么家目录就是 /root 了，也就是我们说的管理员用户，拥有最高权限，所以命令就不用加上 sudo 了)\n   \n   刚才的操作是把你在docker中拉取的 Nginx 的镜像配置文件复制了一份到家目录，这样可以便于后续对 nginx 的配置，say Why?，因为我们接下来会通过映射，将我们复制到宿主机的配置文件直接映射到 docker 容器中的 Nginx 中，是不是很方便，下次若需要配置，就可以直接在宿主机中进行配置了，否则还需要通过 `$ docker exec -it nginx bash` 命令进入到 Nginx 的镜像之中。\n   ```\n   \n   \n   \n   - 打包一下复制好的配置文件（备份，以免操作失误可补救）\n   \n   ```shell\n   # 删掉 nginx 容器\n   $ docker stop nginx\n   $ docker rm nginx\n   \n   # 重新运行容器，并加上配置文件的映射\n   $ docker run -p 80:80 \\\n   -v /root/docker-nginx/nginx.conf:/etc/nginx/nginx.conf \\\n   -v /root/docker-nginx/logs:/var/log/nginx \\\n   -v /root/docker-nginx/html:/usr/share/nginx/html \\\n   -v /root/docker-nginx/conf:/etc/nginx/conf.d \\\n   --name nginx \\\n   --privileged=true \\\n   --restart=always \\\n   -d nginx\n   \n   ----------------------------------------------\n   终于完成！如遇到403或者无法访问此网站等其他问题，首先去你购买的云服务器的安全组新增 80 端口，如果你开了代理，试着重启或者注销电脑。\n   参考链接：https://blog.csdn.net/l123lgx/article/details/122619851\n   \n   server {\n       listen 80;\n       server_name localhost;\n       #charset koi8-r;\n       #access_log logs/host.access.log main;\n       location / {\n           root html;\n           index index.html index.htm;\n   \t}\n       #error_page 404 /404.html;\n       # redirect server error pages to the static page /50x.html\n       #\n       error_page 500 502 503 504 /50x.html;\n       location = /50x.html {\n       \troot html;\n       }\n       # proxy the PHP scripts to Apache listening on 127.0.0.1:80\n       #\n       #location ~ \\.php$ {\n       # proxy_pass http://127.0.0.1;\n       #}\n       # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000\n       #\n       #location ~ \\.php$ {\n       # root html;\n       # fastcgi_pass 127.0.0.1:9000;\n       # fastcgi_index index.php;\n       # fastcgi_param SCRIPT_FILENAME /scripts$fastcgi_script_name;\n       # include fastcgi_params;\n       #}\n       # deny access to .htaccess files, if Apache's document root\n       # concurs with nginx's one\n       #\n       #location ~ /\\.ht {\n       # deny all;\n       #}\n   }\n       # another virtual host using mix of IP-, name-, and port-based configuration\n       #\n       #server {\n       # listen 8000;\n       # listen somename:8080;\n       # server_name somename alias another.alias;\n       # location / {\n       # root html;\n       # index index.html index.htm;\n       # }\n       #}\n       # HTTPS server\n       #\n       #server {\n       # listen 443 ssl;\n       # server_name localhost;\n       # ssl_certificate cert.pem;\n       # ssl_certificate_key cert.key;\n       # ssl_session_cache shared:SSL:1m;\n       # ssl_session_timeout 5m;\n       # ssl_ciphers HIGH:!aNULL:!MD5;\n       # ssl_prefer_server_ciphers on;\n       # location / {\n       # root html;\n       # index index.html index.htm;\n       # }\n       #}\n   \n   ```\n   \n   复习一下`tar`命令的用法：\n   \n   <img src=\"https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202308260050797.png\" alt=\"image-20230826005051120\" style=\"zoom:50%;\" />\n   \n   解压的话亦是同理：\n   \n   > 解压 tar 存档文件的常用命令是 `tar -xzvf`。下面是对这些参数的解释：\n   >\n   > - `-x`：表示从存档文件中提取（解压）文件。\n   > - `-z`：表示使用 gzip 压缩算法进行解压缩。使用此参数可以解压被 gzip 压缩的 tar 存档文件。\n   > - `-v`：表示在命令执行过程中显示详细信息，即显示提取的文件列表。\n   > - `-f`：指定要提取的存档文件的名称。紧跟在 `-f` 参数后面的是存档文件的名称。\n   \n   4. `docker`安装`MySQL`\n   \n      ```shell\n      docker pull mysql\n      \n      # 在宿主机家目录创建用于放配置文件的文件夹\n      $ mkdir -p /root/docker-mysql/{conf,data,log}\n      \n      # 在配置文件目录:/root/docker-mysql/conf新建一个my.cnf配置文件，写入下面内容，设置客户端和mysql服务器端编码都为utf8\n      [client]\n      default_character_set=utf8\n      [mysqld]\n      collation_server=utf8_general_ci\n      character_set_server=utf8\n      \n      docker run -p 3306:3306 \\\n      --privileged=true \\\n      -v /root/docker-mysql/log:/var/log/mysql \\\n      -v /root/docker-mysql/data:/var/lib/mysql \\\n      -v /root/docker-mysql/conf:/etc/mysql/conf.d \\\n      -e MYSQL_ROOT_PASSWORD=你的MySQL密码 \\\n      --name mysql \\\n      -d mysql\n      \n      docker exec -it mysql bash\n      \n      mysql -u root -p\n      \n      如果遇到`Navicat`连接不上的问题，请看下面的链接。\n      ```\n   \n      记录一个大坑，宝塔面板添加3306端口号，被腾讯云服务器拦截了，无语了，还是通过云服务器控制台（推荐✨）或者防火墙命令来添加端口吧。\n   \n      参考链接：https://www.cnblogs.com/--eric/p/17145834.html\n   \n   \n   \n   5. `JDK`安装\n   \n      ```shell\n      # yum 安装免环境变量的配置\n      $ yum install -y java-1.8.0-openjdk*\n      ```\n   \n   6. `maven`安装\n   \n      ```shell\n      通过以下命令获取安装包或者通过本地浏览器下载到主机，然后通过 ftp 传输到 Linux 服务器\n      curl -O https://dlcdn.apache.org/maven/maven-3/3.8.8/binaries/apache-maven-3.8.8-bin.tar.gz\n      \n      tar -zxvf apache-maven-3.8.8-bin.tar.gz\n      \n      vim /etc/profile\n      \n      文件空白处增加两行内容：\n      export MAVEN_HOME=/root/services/apache-maven-3.8.8\n      export PATH=$MAVEN_HOME/bin:$PATH\n      \n      source /etc/profile\n      \n      mvn --version\n      \n      ```\n   \n      \n   \n   7. `redis`安装\n   \n      ```shell\n      docker pull redis\n      \n      mkdir -p /root/docker-redis/conf\n      \n      # 入redis配置文件夹\n      cd /root/docker-redis/conf  \n      \n      # 下载redis配置文件\n      wget http://download.redis.io/redis-stable/redis.conf   \n      \n      vim redis.conf  // 修改配置文件\n      1. appendonly yes    启动Redis持久化功能 (默认 no , 所有信息都存储在内存 [重启丢失] 。设置为 yes , 将存储在硬盘 [重启还在])\n      2. protected-mode no    关闭protected-mode模式，此时外部网络可以直接访问\n      3. bind 0.0.0.0    设置所有IP都可以访问\n      4. requirepass 密码    设置密码\n      如果你设置了密码,需要通过如下命令进入Redis控制台\n      ## 进入Redis容器\n              docker exec -it redis bash\n      ## 通过密码进入Redis控制台\n              redis-cli -h 127.0.0.1 -p 6379 -a [你的密码]\n              \n      mkdir -p /root/docker-redis/data\n      \n      docker run -p 6379:6379 \\\n      -v /root/docker-redis/conf/redis.conf:/etc/redis/redis.conf \\\n      -v /root/docker-redis/data:/data \\\n      -e REDIS_ROOT_PASSWORD=你的Redis密码 \\\n      --restart=always \\\n      --name redis \\\n      -d redis\n      \n      \n      不要忘记打开防火墙6379端口，通过宝塔面板或者命令，或者云服务器控制台\n      ```\n   \n      \n   \n   8. `nacos`安装\n   \n      ```shell\n      docker pull nacos/nacos-server\n      \n      # 在宿主机家目录创建用于放配置文件的文件夹\n      $ mkdir -p /root/docker-nacos/nacos/{init.d,logs}\n      \n      vim /root/docker-nacos/nacos/init.d/application.properties \n      \n      server.contextPath=/nacos\n      server.servlet.contextPath=/nacos\n      server.port=8848\n       \n      spring.datasource.platform=mysql\n      db.num=1\n      db.url.0=jdbc:mysql://xx.xx.xx.x:3306/nacos_devtest_prod?characterEncoding=utf8&connectTimeout=1000&socketTimeout=3000&autoReconnect=true\n      db.user=user\n      db.password=pass\n       \n      nacos.cmdb.dumpTaskInterval=3600\n      nacos.cmdb.eventTaskInterval=10\n      nacos.cmdb.labelTaskInterval=300\n      nacos.cmdb.loadDataAtStart=false\n      management.metrics.export.elastic.enabled=false\n      management.metrics.export.influx.enabled=false\n      server.tomcat.accesslog.enabled=true\n      server.tomcat.accesslog.pattern=%h %l %u %t \"%r\" %s %b %D %{User-Agent}i\n      nacos.security.ignore.urls=/,/**/*.css,/**/*.js,/**/*.html,/**/*.map,/**/*.svg,/**/*.png,/**/*.ico,/console-fe/public/**,/v1/auth/login,/v1/console/health/**,/v1/cs/**,/v1/ns/**,/v1/cmdb/**,/actuator/**,/v1/console/server/**\n      nacos.naming.distro.taskDispatchThreadCount=1\n      nacos.naming.distro.taskDispatchPeriod=200\n      nacos.naming.distro.batchSyncKeyCount=1000\n      nacos.naming.distro.initDataRatio=0.9\n      nacos.naming.distro.syncRetryDelay=5000\n      nacos.naming.data.warmup=true\n      nacos.naming.expireInstance=true\n      \n      \n      docker run -p 8848:8848 \\\n      -e JVM_XMS=256m \\\n      -e JVM_XMX=256m \\\n      -e MODE=standalone \\\n      -e PREFER_HOST_MODE=hostname \\\n      -v /root/docker-nacos/nacos/logs:/home/nacos/logs \\\n      -v /root/docker-nacos/nacos/init.d/application.properties:/home/nacos/init.d/application.properties \\\n      --name nacos \\\n      --privileged=true \\\n      --restart=always \\\n      -d nacos/nacos-server\n      ```\n   \n      参考链接：https://blog.csdn.net/yexiaomodemo/article/details/123355202\n   \n      \n   \n   9. `rabbitmq`安装\n   \n      ```shell\n      docker pull rabbitmq\n      \n      docker run -p 5672:5672 -p 15672:15672 \\\n      -v /root/docker-rabbitmq/config/:/etc/rabbitmq/ \\\n      -e RABBITMQ_DEFAULT_USER=admin \\\n      -e RABBITMQ_DEFAULT_PASS=admin \\\n      --hostname myRabbit \\\n      --name rabbitmq \\\n      --restart=always \\\n      -d rabbitmq\n      \n      docker exec -it rabbitmq bash\n      \n      # 启动可视化插件\n      rabbitmq-plugins enable rabbitmq_management\n      \n      使用浏览器打开web管理端：http://Server-IP:15672 \n      ```\n   \n\n  \t参考链接：\n\n​\t  https://blog.csdn.net/qq_42977003/article/details/128107521\n​\t  https://blog.csdn.net/feritylamb/article/details/128434465\n\n#### 一、原始部署\n\n​\t缺点：需要一个个配置环境，安装必须软件\n\n#### 二、宝塔面板部署\n\n​\t优点：可视化安装与配置\n\n#### 三、docker部署\n\n> Docker是一种开源的容器化平台，用于构建、发布和运行应用程序。通过使用Docker，您可以将应用程序及其依赖项打包到一个称为容器的独立单元中，以便在任何环境中运行，而无需担心环境差异或依赖问题。\n>\n> 以下是一些与Docker相关的常用概念和命令：\n>\n> 1. 镜像（Image）：镜像是Docker容器的基础，它包含了运行应用程序所需的一切，包括代码、运行时环境、库和依赖项。您可以通过构建自定义镜像或从Docker Hub等镜像仓库中获取现有的镜像。\n> 2. 容器（Container）：容器是基于镜像创建的运行实例，它是一个独立、隔离的执行环境。容器可以启动、停止、重启和删除，每个容器都具有自己的文件系统、进程空间和网络接口。\n> 3. Dockerfile：Dockerfile是用于定义镜像构建过程的文本文件。它包含一系列指令，用于指定基础镜像、安装软件、复制文件、设置环境变量等。\n> 4. Docker Compose：Docker Compose是一个用于定义和运行多个容器应用的工具。它使用一个YAML文件来定义各个服务及其依赖关系，并可以一键启动、停止和管理整个应用程序的容器群。\n>\n> 一些常用的Docker命令包括：\n>\n> - `docker build`：根据Dockerfile构建镜像。\n> - `docker run`：创建并运行一个新的容器。\n> - `docker stop`：停止一个正在运行的容器。\n> - `docker start`：启动已经停止的容器。\n> - `docker rm`：删除一个或多个容器。\n> - `docker images`：列出本地已下载的镜像。\n> - `docker pull`：从镜像仓库下载镜像。\n> - `docker push`：将本地镜像推送到镜像仓库。\n>\n> 这只是Docker的一小部分功能和命令，Docker还提供了许多其他功能，如网络配置、数据卷、容器编排等。如果您想更深入了解Docker的使用，请参考官方文档或相关教程。\n>\n> \n>\n> docker如何打包一个镜像，命令是什么?\n>\n> \n>\n> 要打包一个Docker镜像，您需要编写一个Dockerfile，其中包含构建镜像所需的指令和配置。然后，使用`docker build`命令来构建镜像。以下是基本的步骤和相应的命令：\n>\n> 1. 创建一个Dockerfile：在您的项目目录中创建一个名为`Dockerfile`的文本文件，可以使用任何文本编辑器打开并编辑它。\n>\n> 2. 在Dockerfile中定义镜像构建过程：Dockerfile包含一系列指令，用于指定基础镜像、安装软件、复制文件、设置环境变量等。根据您的应用程序需求，编写适当的指令。\n>\n>    以下是一个简单的Dockerfile示例：\n>\n>    ```dockerfile\n>    # 使用官方的 Node.js 作为基础镜像\n>    FROM node:14\n>\n>    # 设置工作目录\n>    WORKDIR /app\n>\n>    # 复制应用程序代码到容器中\n>    COPY . .\n>\n>    # 安装应用程序依赖\n>    RUN npm install\n>\n>    # 暴露应用程序的端口\n>    EXPOSE 3000\n>\n>    # 定义启动容器时运行的命令\n>    CMD [\"npm\", \"start\"]\n>\n>    这个示例中，我们使用了官方的Node.js 14镜像作为基础镜像，将应用程序代码复制到容器中，安装依赖项，暴露端口3000，并在容器启动时运行`npm start`命令。\n>    ```\n>\n> 3. 构建镜像：在终端中，切换到包含Dockerfile的目录，并运行以下命令来构建镜像：\n>\n>    ```\n>    docker build -t image_name:tag .\n>    ```\n>\n>    - `-t`参数用于指定镜像的名称和标签。您可以根据需要自定义名称和标签。\n>    - `.`表示Dockerfile所在的当前目录。确保在运行命令之前，您已经切换到正确的目录。\n>\n>    例如，要构建一个名为`myapp`的镜像，标签为`v1.0`，可以运行以下命令：\n>\n>    ```\n>    docker build -t myapp:v1.0 .\n>    ```\n>\n> 4. 等待构建完成：Docker将执行Dockerfile中的每个指令，并构建镜像。这可能需要一些时间，取决于您的镜像大小和复杂性。\n>\n> 5. 查看构建的镜像：构建完成后，可以使用以下命令查看本地的镜像列表：\n>\n>    ```\n>    docker images\n>    ```\n>\n>    您将看到刚刚构建的镜像以及其名称、标签和大小等信息。\n>\n> 通过以上步骤，您就可以使用Dockerfile和`docker build`命令来打包构建自己的Docker镜像。请根据您的应用程序需求和环境配置适当地编辑Dockerfile。\n\n##### 前端部署例子：\n\n`dockerfile`文件：\n\n```dockerfile\nFROM nginx\n\nWORKDIR /usr/share/nginx/html/\nUSER root\n\nCOPY ./docker/nginx.conf /etc/nginx/conf.d/default.conf\n\nCOPY ./dist  /usr/share/nginx/html/\n\nEXPOSE 80\n\nCMD [\"nginx\", \"-g\", \"daemon off;\"]\n```\n\n`nginx.conf`文件：\n\n```nginx\nserver {\n    listen 80;\n\n    # gzip config\n    gzip on;\n    gzip_min_length 1k;\n    gzip_comp_level 9;\n    gzip_types text/plain text/css text/javascript application/json application/javascript application/x-javascript application/xml;\n    gzip_vary on;\n    gzip_disable \"MSIE [1-6]\\.\";\n\n    root /usr/share/nginx/html;\n    include /etc/nginx/mime.types;\n\n    location / {\n        try_files $uri /index.html;\n    }\n\n}\n```\n\n\n\n### 项目扩展思路\n\n1. 用户自己可以申请更换签名\n\n2. 怎么让其他用户也能上传接口？\n\n   > * 需要提供一个机制（一个页面），让用户来输入自己的接口host（都武器的地址）、接口信息、将接口写入数据库；\n   > * 可以在interfaceInfo表中加个host字段，以次区分服务器地址，让接口提供者更灵活的接入系统；\n   > * 将接口信息入库前，要对接口进行校验，比如检查地址是否遵循规则、是否可以正常调用,并遵循甲方要求（使用SDK）\n\n3. 网关校验是否还有调用次数\n\n   需要考虑并发的问题，防止瞬间调用超频。\n\n4. 网关优化\n\n   比如增加限流、降级保护、提高性能等。还可以考虑搭配Nginx网关使用。\n\n5. 功能增强\n\n   可以针对不同的请求头或者接口类型来设计前端界面和表单，百年与用户进行调用，增强体验。\n\n   （可以参考swagger、postman、kniffj的界面）\n\n\n\n## 项目优化\n\n### 扩展思路\n\n 1. 用户可以申请更换签名\n 2. 怎么让其他用户也上传接口？ \n需要提供一个机制（界面），让用户输入自己的接口 host（服务器地址）、接口信息，将接口信息写入数据库。\n可以在 interfaceInfo 表里加个 host 字段，区分服务器地址，让接口提供者更灵活地接入系统。\n将接口信息写入数据库之前，要对接口进行校验（比如检查他的地址是否遵循规则，测试调用），保证他是正常的。\n将接口信息写入数据库之前遵循咱们的要求（并且使用咱们的 sdk），\n在接入时，平台需要测试调用这个接口，保证他是正常的。\n 3. 网关校验是否还有调用次数 \n需要考虑并发问题，防止瞬间调用超额。\n 4. 网关优化 \n比如增加限流 / 降级保护，提高性能等。还可以考虑搭配 Nginx 网关使用。\n 5. 功能增强 \n可以针对不同的请求头或者接口类型来设计前端界面和表单，便于用户调用，获得更好的体验。\n可以参考 swagger、postman、knife4j 的页面。","slug":"api","published":1,"updated":"2023-11-15T08:35:44.831Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clpkiczj2001tfkfofb7o26a3","content":"<h1 id=\"API开放平台\"><a href=\"#API开放平台\" class=\"headerlink\" title=\"API开放平台\"></a>API开放平台</h1><blockquote>\n<p>写在最前面：</p>\n<p>​    学到的知识与收到的建议：</p>\n<pre><code class=\"hljs\">1. 把自己所有的数据库建表语句总结到一起，后续有用；\n1. 记录Bug文档\n1. 多记录一些需求的解决方案、提高自己的架构能力\n</code></pre>\n</blockquote>\n<h2 id=\"项目介绍\"><a href=\"#项目介绍\" class=\"headerlink\" title=\"项目介绍\"></a>项目介绍</h2><blockquote>\n<p>前端开发的时候有有时会需要后端的接口，如果此时有一个API接口可以使用，那么就无需后端借口了</p>\n</blockquote>\n<p>一个提供API接口调用的平台，用户可以注册与登录，开通接口的调用权限，用户可以使用接口，每次调用会进行次数统计。管理院可以发布接口、下线接口、接入接口，以及可视化接口的调用情况。</p>\n<p>一个API接口平台：</p>\n<ol>\n<li>防止攻击</li>\n<li>使用限制</li>\n<li>统计调用次数</li>\n<li>计费</li>\n<li>流量保护</li>\n<li>API接入</li>\n</ol>\n<h2 id=\"预计完成时间\"><a href=\"#预计完成时间\" class=\"headerlink\" title=\"预计完成时间\"></a>预计完成时间</h2><p>5-6周</p>\n<h2 id=\"业务流程\"><a href=\"#业务流程\" class=\"headerlink\" title=\"业务流程\"></a>业务流程</h2><p>前台、SDK、API网关、模拟接口、后台    共五个子模块</p>\n<p><strong>难点</strong>：思想</p>\n<h2 id=\"技术选型\"><a href=\"#技术选型\" class=\"headerlink\" title=\"技术选型\"></a>技术选型</h2><ul>\n<li>前端<ul>\n<li>Ant Design Pro</li>\n<li>React</li>\n<li>Ant Design Pro Components</li>\n<li>Umi</li>\n<li>Umi Request（Axios的封装）–请求库（前后端联调）</li>\n</ul>\n</li>\n<li>后端<ul>\n<li>Spring Boot</li>\n<li>Spring Boot Stater（SDK开发）–可以发布到maven仓库—-<strong>简历亮点</strong></li>\n<li>？？？？？？（网关、限流、日志实现）</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"项目计划\"><a href=\"#项目计划\" class=\"headerlink\" title=\"项目计划\"></a>项目计划</h2><h3 id=\"Day01–项目初始化\"><a href=\"#Day01–项目初始化\" class=\"headerlink\" title=\"Day01–项目初始化\"></a>Day01–项目初始化</h3><p>项目介绍、设计、技术选型</p>\n<p>基础项目的搭建</p>\n<p>接口管理</p>\n<p>用户查看接口的权限</p>\n<h3 id=\"Day02–接口调用\"><a href=\"#Day02–接口调用\" class=\"headerlink\" title=\"Day02–接口调用\"></a>Day02–接口调用</h3><ol>\n<li>继续开发接口管理前端页面 15min</li>\n<li>开发模拟API接口 5min</li>\n<li>开发调用接口的代码 10-20min</li>\n<li>保证调用的安全性（API签名认证） 15min</li>\n<li>客户端SDK的开发 15min</li>\n<li>管理员接口的发布与调用 15min</li>\n<li>接口文档的展示、接口在线调用 15min</li>\n</ol>\n<h3 id=\"Day03–接口计费与保护\"><a href=\"#Day03–接口计费与保护\" class=\"headerlink\" title=\"Day03–接口计费与保护\"></a>Day03–接口计费与保护</h3><p>统计用户调用次数</p>\n<p>限流</p>\n<p>计费</p>\n<p>日志</p>\n<p>开通</p>\n<h3 id=\"Day04–管理员统计分析\"><a href=\"#Day04–管理员统计分析\" class=\"headerlink\" title=\"Day04–管理员统计分析\"></a>Day04–管理员统计分析</h3><p>提供可视化平台，展示所有接口的调用情况，便于管理价格</p>\n<p>接口预警</p>\n<h2 id=\"Day01-需求分析\"><a href=\"#Day01-需求分析\" class=\"headerlink\" title=\"Day01 需求分析\"></a>Day01 需求分析</h2><ol>\n<li><p>管理员可以对接口信息进行增删改查</p>\n</li>\n<li><p>用户可以访问前台，查看接口信息</p>\n</li>\n</ol>\n<h3 id=\"今日计划\"><a href=\"#今日计划\" class=\"headerlink\" title=\"今日计划\"></a>今日计划</h3><ol>\n<li>项目脚手架搭建（初始化项目）10分钟前端、5-10分钟后端 </li>\n<li>管理员可以对接口信息进行增删改查</li>\n<li>用户可以访问前台，查看接口的信息</li>\n</ol>\n<h3 id=\"项目初始化（前后端）\"><a href=\"#项目初始化（前后端）\" class=\"headerlink\" title=\"项目初始化（前后端）\"></a>项目初始化（前后端）</h3><ul>\n<li><h3 id=\"前端\"><a href=\"#前端\" class=\"headerlink\" title=\"前端\"></a>前端</h3></li>\n</ul>\n<ol>\n<li><p>使用Ant Design Pro提供的<code>pro-cli</code>来快速的初始化脚手架。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># 查看node和npm版本</span><br>建议16和8<br><span class=\"hljs-comment\"># 使用 npm</span><br>npm i @ant-design/pro-cli -g<br>pro create myapi-frontend<br><span class=\"hljs-comment\"># 下载项目所需要的依赖</span><br>yarn<br>此时可能会遇到node版本要求的问题，因为版本更新迭代的原因，我当时要求的是使用16.14.0的node版本，<br>如果感觉切换node版本麻烦的话，这里推荐使用nvm（node的版本管理工具），使用方法自行百度<br></code></pre></td></tr></table></figure></li>\n<li><p>项目瘦身</p>\n<p> 遇到了一个大坑，星球的球友们也都遇到了，下面是球友的解决方法，亲测有效。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># 关闭ESLint中与Prettier重复的规则，确保代码格式化的一致性</span><br>yarn add eslint-config-prettier --dev<br><span class=\"hljs-comment\"># 用于检查和修复JavaScript代码中的常见问题</span><br>yarn add eslint-plugin-unicorn --dev<br></code></pre></td></tr></table></figure>\n<h3 id=\"项目去除国际化存在问题的解决方法\"><a href=\"#项目去除国际化存在问题的解决方法\" class=\"headerlink\" title=\"项目去除国际化存在问题的解决方法\"></a>项目去除国际化存在问题的解决方法</h3></li>\n</ol>\n<p><img src=\"https://cdn.jsdelivr.net/gh/wl2o2o/blogCdn/img/202307010940465.png\" alt=\"image-20230630231124235\"></p>\n<p>​    jest脚本命令中有<code>jest</code>不知道是否需要删掉，鱼皮的文件中没有出现，可能是跟某些版本有关，奇奇妙妙，记录一下</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/wl2o2o/blogCdn/img/202307010940466.png\" alt=\"image-20230630233743871\"></p>\n<ul>\n<li><h3 id=\"后端\"><a href=\"#后端\" class=\"headerlink\" title=\"后端\"></a>后端</h3></li>\n</ul>\n<ol start=\"3\">\n<li>后端项目初始化</li>\n</ol>\n<p>​    直接使用鱼总提供的万能模板<code>springboot-init</code>,改成项目的名字，然后全局搜索关键字进行替换</p>\n<p>​    连接数据库</p>\n<p>​    测试运行</p>\n<ol start=\"4\">\n<li>数据库库表设计</li>\n</ol>\n<p>​    <strong>接口信息表</strong></p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"># 数据库初始化<br># <span class=\"hljs-variable\">@author</span> <span class=\"hljs-operator\">&lt;</span>a href<span class=\"hljs-operator\">=</span>&quot;https://github.com/liyupi&quot;<span class=\"hljs-operator\">&gt;</span>程序员鱼皮<span class=\"hljs-operator\">&lt;</span><span class=\"hljs-operator\">/</span>a<span class=\"hljs-operator\">&gt;</span><br># <span class=\"hljs-variable\">@from</span> <span class=\"hljs-operator\">&lt;</span>a href<span class=\"hljs-operator\">=</span>&quot;https://yupi.icu&quot;<span class=\"hljs-operator\">&gt;</span>编程导航知识星球<span class=\"hljs-operator\">&lt;</span><span class=\"hljs-operator\">/</span>a<span class=\"hljs-operator\">&gt;</span><br><span class=\"hljs-comment\">-- 创建库</span><br><span class=\"hljs-keyword\">create</span> database if <span class=\"hljs-keyword\">not</span> <span class=\"hljs-keyword\">exists</span> myapi;<br><br><span class=\"hljs-comment\">-- 切换库</span><br>use myapi;<br><br><span class=\"hljs-comment\">-- 用户表</span><br><span class=\"hljs-keyword\">create</span> <span class=\"hljs-keyword\">table</span> if <span class=\"hljs-keyword\">not</span> <span class=\"hljs-keyword\">exists</span> <span class=\"hljs-keyword\">user</span><br>(<br>    id           <span class=\"hljs-type\">bigint</span> auto_increment comment <span class=\"hljs-string\">&#x27;id&#x27;</span> <span class=\"hljs-keyword\">primary</span> key,<br>    userName     <span class=\"hljs-type\">varchar</span>(<span class=\"hljs-number\">256</span>)                           <span class=\"hljs-keyword\">null</span> comment <span class=\"hljs-string\">&#x27;用户昵称&#x27;</span>,<br>    userAccount  <span class=\"hljs-type\">varchar</span>(<span class=\"hljs-number\">256</span>)                           <span class=\"hljs-keyword\">not</span> <span class=\"hljs-keyword\">null</span> comment <span class=\"hljs-string\">&#x27;账号&#x27;</span>,<br>    userAvatar   <span class=\"hljs-type\">varchar</span>(<span class=\"hljs-number\">1024</span>)                          <span class=\"hljs-keyword\">null</span> comment <span class=\"hljs-string\">&#x27;用户头像&#x27;</span>,<br>    gender       tinyint                                <span class=\"hljs-keyword\">null</span> comment <span class=\"hljs-string\">&#x27;性别&#x27;</span>,<br>    userRole     <span class=\"hljs-type\">varchar</span>(<span class=\"hljs-number\">256</span>) <span class=\"hljs-keyword\">default</span> <span class=\"hljs-string\">&#x27;user&#x27;</span>            <span class=\"hljs-keyword\">not</span> <span class=\"hljs-keyword\">null</span> comment <span class=\"hljs-string\">&#x27;用户角色：user / admin&#x27;</span>,<br>    userPassword <span class=\"hljs-type\">varchar</span>(<span class=\"hljs-number\">512</span>)                           <span class=\"hljs-keyword\">not</span> <span class=\"hljs-keyword\">null</span> comment <span class=\"hljs-string\">&#x27;密码&#x27;</span>,<br>    `accessKey` <span class=\"hljs-type\">varchar</span>(<span class=\"hljs-number\">512</span>) <span class=\"hljs-keyword\">not</span> <span class=\"hljs-keyword\">null</span> comment <span class=\"hljs-string\">&#x27;accessKey&#x27;</span>,<br>    `secretKey` <span class=\"hljs-type\">varchar</span>(<span class=\"hljs-number\">512</span>) <span class=\"hljs-keyword\">not</span> <span class=\"hljs-keyword\">null</span> comment <span class=\"hljs-string\">&#x27;secretKey&#x27;</span>,<br>    createTime   datetime     <span class=\"hljs-keyword\">default</span> <span class=\"hljs-built_in\">CURRENT_TIMESTAMP</span> <span class=\"hljs-keyword\">not</span> <span class=\"hljs-keyword\">null</span> comment <span class=\"hljs-string\">&#x27;创建时间&#x27;</span>,<br>    updateTime   datetime     <span class=\"hljs-keyword\">default</span> <span class=\"hljs-built_in\">CURRENT_TIMESTAMP</span> <span class=\"hljs-keyword\">not</span> <span class=\"hljs-keyword\">null</span> <span class=\"hljs-keyword\">on</span> <span class=\"hljs-keyword\">update</span> <span class=\"hljs-built_in\">CURRENT_TIMESTAMP</span> comment <span class=\"hljs-string\">&#x27;更新时间&#x27;</span>,<br>    isDelete     tinyint      <span class=\"hljs-keyword\">default</span> <span class=\"hljs-number\">0</span>                 <span class=\"hljs-keyword\">not</span> <span class=\"hljs-keyword\">null</span> comment <span class=\"hljs-string\">&#x27;是否删除&#x27;</span>,<br>    <span class=\"hljs-keyword\">constraint</span> uni_userAccount<br>        <span class=\"hljs-keyword\">unique</span> (userAccount)<br>) comment <span class=\"hljs-string\">&#x27;用户&#x27;</span>;<br><br><span class=\"hljs-comment\">-- 接口信息</span><br><span class=\"hljs-keyword\">create</span> <span class=\"hljs-keyword\">table</span> if <span class=\"hljs-keyword\">not</span> <span class=\"hljs-keyword\">exists</span> myapi.`interface_info`<br>(<br>    `id` <span class=\"hljs-type\">bigint</span> <span class=\"hljs-keyword\">not</span> <span class=\"hljs-keyword\">null</span> auto_increment comment <span class=\"hljs-string\">&#x27;主键&#x27;</span> <span class=\"hljs-keyword\">primary</span> key,<br>    `name` <span class=\"hljs-type\">varchar</span>(<span class=\"hljs-number\">256</span>) <span class=\"hljs-keyword\">not</span> <span class=\"hljs-keyword\">null</span> comment <span class=\"hljs-string\">&#x27;名称&#x27;</span>,<br>    `description` <span class=\"hljs-type\">varchar</span>(<span class=\"hljs-number\">256</span>) <span class=\"hljs-keyword\">null</span> comment <span class=\"hljs-string\">&#x27;描述&#x27;</span>,<br>    `url` <span class=\"hljs-type\">varchar</span>(<span class=\"hljs-number\">512</span>) <span class=\"hljs-keyword\">not</span> <span class=\"hljs-keyword\">null</span> comment <span class=\"hljs-string\">&#x27;接口地址&#x27;</span>,<br>    `requestHeader` text <span class=\"hljs-keyword\">null</span> comment <span class=\"hljs-string\">&#x27;请求头&#x27;</span>,<br>    `responseHeader` text <span class=\"hljs-keyword\">null</span> comment <span class=\"hljs-string\">&#x27;响应头&#x27;</span>,<br>    `status` <span class=\"hljs-type\">int</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-number\">0</span> <span class=\"hljs-keyword\">not</span> <span class=\"hljs-keyword\">null</span> comment <span class=\"hljs-string\">&#x27;接口状态（0-关闭，1-开启）&#x27;</span>,<br>    `<span class=\"hljs-keyword\">method</span>` <span class=\"hljs-type\">varchar</span>(<span class=\"hljs-number\">256</span>) <span class=\"hljs-keyword\">not</span> <span class=\"hljs-keyword\">null</span> comment <span class=\"hljs-string\">&#x27;请求类型&#x27;</span>,<br>    `userId` <span class=\"hljs-type\">bigint</span> <span class=\"hljs-keyword\">not</span> <span class=\"hljs-keyword\">null</span> comment <span class=\"hljs-string\">&#x27;创建人&#x27;</span>,<br>    `createTime` datetime <span class=\"hljs-keyword\">default</span> <span class=\"hljs-built_in\">CURRENT_TIMESTAMP</span> <span class=\"hljs-keyword\">not</span> <span class=\"hljs-keyword\">null</span> comment <span class=\"hljs-string\">&#x27;创建时间&#x27;</span>,<br>    `updateTime` datetime <span class=\"hljs-keyword\">default</span> <span class=\"hljs-built_in\">CURRENT_TIMESTAMP</span> <span class=\"hljs-keyword\">not</span> <span class=\"hljs-keyword\">null</span> <span class=\"hljs-keyword\">on</span> <span class=\"hljs-keyword\">update</span> <span class=\"hljs-built_in\">CURRENT_TIMESTAMP</span> comment <span class=\"hljs-string\">&#x27;更新时间&#x27;</span>,<br>    `isDelete` tinyint <span class=\"hljs-keyword\">default</span> <span class=\"hljs-number\">0</span> <span class=\"hljs-keyword\">not</span> <span class=\"hljs-keyword\">null</span> comment <span class=\"hljs-string\">&#x27;是否删除(0-未删, 1-已删)&#x27;</span><br>) comment  <span class=\"hljs-string\">&#x27;接口信息&#x27;</span>;<br><br><span class=\"hljs-comment\">-- 用户调用接口关系表</span><br><span class=\"hljs-keyword\">create</span> <span class=\"hljs-keyword\">table</span> if <span class=\"hljs-keyword\">not</span> <span class=\"hljs-keyword\">exists</span> myapi.`user_interface_info`<br>(<br>    `id` <span class=\"hljs-type\">bigint</span> <span class=\"hljs-keyword\">not</span> <span class=\"hljs-keyword\">null</span> auto_increment comment <span class=\"hljs-string\">&#x27;主键&#x27;</span> <span class=\"hljs-keyword\">primary</span> key,<br>    `userId` <span class=\"hljs-type\">bigint</span> <span class=\"hljs-keyword\">not</span> <span class=\"hljs-keyword\">null</span> comment <span class=\"hljs-string\">&#x27;调用用户 id&#x27;</span>,<br>    `interfaceInfoId` <span class=\"hljs-type\">bigint</span> <span class=\"hljs-keyword\">not</span> <span class=\"hljs-keyword\">null</span> comment <span class=\"hljs-string\">&#x27;接口 id&#x27;</span>,<br>    `totalNum` <span class=\"hljs-type\">int</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-number\">0</span> <span class=\"hljs-keyword\">not</span> <span class=\"hljs-keyword\">null</span> comment <span class=\"hljs-string\">&#x27;总调用次数&#x27;</span>,<br>    `leftNum` <span class=\"hljs-type\">int</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-number\">0</span> <span class=\"hljs-keyword\">not</span> <span class=\"hljs-keyword\">null</span> comment <span class=\"hljs-string\">&#x27;剩余调用次数&#x27;</span>,<br>    `status` <span class=\"hljs-type\">int</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-number\">0</span> <span class=\"hljs-keyword\">not</span> <span class=\"hljs-keyword\">null</span> comment <span class=\"hljs-string\">&#x27;0-正常，1-禁用&#x27;</span>,<br>    `createTime` datetime <span class=\"hljs-keyword\">default</span> <span class=\"hljs-built_in\">CURRENT_TIMESTAMP</span> <span class=\"hljs-keyword\">not</span> <span class=\"hljs-keyword\">null</span> comment <span class=\"hljs-string\">&#x27;创建时间&#x27;</span>,<br>    `updateTime` datetime <span class=\"hljs-keyword\">default</span> <span class=\"hljs-built_in\">CURRENT_TIMESTAMP</span> <span class=\"hljs-keyword\">not</span> <span class=\"hljs-keyword\">null</span> <span class=\"hljs-keyword\">on</span> <span class=\"hljs-keyword\">update</span> <span class=\"hljs-built_in\">CURRENT_TIMESTAMP</span> comment <span class=\"hljs-string\">&#x27;更新时间&#x27;</span>,<br>    `isDelete` tinyint <span class=\"hljs-keyword\">default</span> <span class=\"hljs-number\">0</span> <span class=\"hljs-keyword\">not</span> <span class=\"hljs-keyword\">null</span> comment <span class=\"hljs-string\">&#x27;是否删除(0-未删, 1-已删)&#x27;</span><br>) comment <span class=\"hljs-string\">&#x27;用户调用接口关系&#x27;</span>;<br><br><span class=\"hljs-keyword\">insert</span> <span class=\"hljs-keyword\">into</span> myapi.`interface_info` (`name`, `description`, `url`, `requestHeader`, `responseHeader`, `status`, `<span class=\"hljs-keyword\">method</span>`, `userId`) <span class=\"hljs-keyword\">values</span> (<span class=\"hljs-string\">&#x27;许擎宇&#x27;</span>, <span class=\"hljs-string\">&#x27;薛聪健&#x27;</span>, <span class=\"hljs-string\">&#x27;www.cary-king.net&#x27;</span>, <span class=\"hljs-string\">&#x27;潘博涛&#x27;</span>, <span class=\"hljs-string\">&#x27;谭聪健&#x27;</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-string\">&#x27;石炫明&#x27;</span>, <span class=\"hljs-number\">9500534531</span>);<br><span class=\"hljs-keyword\">insert</span> <span class=\"hljs-keyword\">into</span> myapi.`interface_info` (`name`, `description`, `url`, `requestHeader`, `responseHeader`, `status`, `<span class=\"hljs-keyword\">method</span>`, `userId`) <span class=\"hljs-keyword\">values</span> (<span class=\"hljs-string\">&#x27;陆弘文&#x27;</span>, <span class=\"hljs-string\">&#x27;白志强&#x27;</span>, <span class=\"hljs-string\">&#x27;www.leslee-kuhn.net&#x27;</span>, <span class=\"hljs-string\">&#x27;潘懿轩&#x27;</span>, <span class=\"hljs-string\">&#x27;马鸿涛&#x27;</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-string\">&#x27;陈峻熙&#x27;</span>, <span class=\"hljs-number\">3982575846</span>);<br><span class=\"hljs-keyword\">insert</span> <span class=\"hljs-keyword\">into</span> myapi.`interface_info` (`name`, `description`, `url`, `requestHeader`, `responseHeader`, `status`, `<span class=\"hljs-keyword\">method</span>`, `userId`) <span class=\"hljs-keyword\">values</span> (<span class=\"hljs-string\">&#x27;毛建辉&#x27;</span>, <span class=\"hljs-string\">&#x27;罗文&#x27;</span>, <span class=\"hljs-string\">&#x27;www.rosaria-kilback.io&#x27;</span>, <span class=\"hljs-string\">&#x27;冯子默&#x27;</span>, <span class=\"hljs-string\">&#x27;彭哲瀚&#x27;</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-string\">&#x27;赵远航&#x27;</span>, <span class=\"hljs-number\">121776355</span>);<br><span class=\"hljs-keyword\">insert</span> <span class=\"hljs-keyword\">into</span> myapi.`interface_info` (`name`, `description`, `url`, `requestHeader`, `responseHeader`, `status`, `<span class=\"hljs-keyword\">method</span>`, `userId`) <span class=\"hljs-keyword\">values</span> (<span class=\"hljs-string\">&#x27;彭雨泽&#x27;</span>, <span class=\"hljs-string\">&#x27;蔡煜祺&#x27;</span>, <span class=\"hljs-string\">&#x27;www.norris-bergstrom.biz&#x27;</span>, <span class=\"hljs-string\">&#x27;董思源&#x27;</span>, <span class=\"hljs-string\">&#x27;田晓博&#x27;</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-string\">&#x27;潘擎宇&#x27;</span>, <span class=\"hljs-number\">740</span>);<br><span class=\"hljs-keyword\">insert</span> <span class=\"hljs-keyword\">into</span> myapi.`interface_info` (`name`, `description`, `url`, `requestHeader`, `responseHeader`, `status`, `<span class=\"hljs-keyword\">method</span>`, `userId`) <span class=\"hljs-keyword\">values</span> (<span class=\"hljs-string\">&#x27;傅志强&#x27;</span>, <span class=\"hljs-string\">&#x27;陈梓晨&#x27;</span>, <span class=\"hljs-string\">&#x27;www.jordan-reinger.com&#x27;</span>, <span class=\"hljs-string\">&#x27;金志强&#x27;</span>, <span class=\"hljs-string\">&#x27;熊锦程&#x27;</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-string\">&#x27;邓睿渊&#x27;</span>, <span class=\"hljs-number\">35542559</span>);<br><span class=\"hljs-keyword\">insert</span> <span class=\"hljs-keyword\">into</span> myapi.`interface_info` (`name`, `description`, `url`, `requestHeader`, `responseHeader`, `status`, `<span class=\"hljs-keyword\">method</span>`, `userId`) <span class=\"hljs-keyword\">values</span> (<span class=\"hljs-string\">&#x27;吕黎昕&#x27;</span>, <span class=\"hljs-string\">&#x27;孔越彬&#x27;</span>, <span class=\"hljs-string\">&#x27;www.fe-okon.info&#x27;</span>, <span class=\"hljs-string\">&#x27;万伟宸&#x27;</span>, <span class=\"hljs-string\">&#x27;林昊然&#x27;</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-string\">&#x27;孟荣轩&#x27;</span>, <span class=\"hljs-number\">1445</span>);<br><span class=\"hljs-keyword\">insert</span> <span class=\"hljs-keyword\">into</span> myapi.`interface_info` (`name`, `description`, `url`, `requestHeader`, `responseHeader`, `status`, `<span class=\"hljs-keyword\">method</span>`, `userId`) <span class=\"hljs-keyword\">values</span> (<span class=\"hljs-string\">&#x27;夏雪松&#x27;</span>, <span class=\"hljs-string\">&#x27;许子骞&#x27;</span>, <span class=\"hljs-string\">&#x27;www.lashawna-legros.co&#x27;</span>, <span class=\"hljs-string\">&#x27;蔡昊然&#x27;</span>, <span class=\"hljs-string\">&#x27;胡鹏涛&#x27;</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-string\">&#x27;钟立辉&#x27;</span>, <span class=\"hljs-number\">34075514</span>);<br><span class=\"hljs-keyword\">insert</span> <span class=\"hljs-keyword\">into</span> myapi.`interface_info` (`name`, `description`, `url`, `requestHeader`, `responseHeader`, `status`, `<span class=\"hljs-keyword\">method</span>`, `userId`) <span class=\"hljs-keyword\">values</span> (<span class=\"hljs-string\">&#x27;严钰轩&#x27;</span>, <span class=\"hljs-string\">&#x27;阎志泽&#x27;</span>, <span class=\"hljs-string\">&#x27;www.kay-funk.biz&#x27;</span>, <span class=\"hljs-string\">&#x27;莫皓轩&#x27;</span>, <span class=\"hljs-string\">&#x27;郭黎昕&#x27;</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-string\">&#x27;龚天宇&#x27;</span>, <span class=\"hljs-number\">70956</span>);<br><span class=\"hljs-keyword\">insert</span> <span class=\"hljs-keyword\">into</span> myapi.`interface_info` (`name`, `description`, `url`, `requestHeader`, `responseHeader`, `status`, `<span class=\"hljs-keyword\">method</span>`, `userId`) <span class=\"hljs-keyword\">values</span> (<span class=\"hljs-string\">&#x27;萧嘉懿&#x27;</span>, <span class=\"hljs-string\">&#x27;曹熠彤&#x27;</span>, <span class=\"hljs-string\">&#x27;www.margarette-lindgren.biz&#x27;</span>, <span class=\"hljs-string\">&#x27;田泽洋&#x27;</span>, <span class=\"hljs-string\">&#x27;邓睿渊&#x27;</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-string\">&#x27;梁志强&#x27;</span>, <span class=\"hljs-number\">98</span>);<br><span class=\"hljs-keyword\">insert</span> <span class=\"hljs-keyword\">into</span> myapi.`interface_info` (`name`, `description`, `url`, `requestHeader`, `responseHeader`, `status`, `<span class=\"hljs-keyword\">method</span>`, `userId`) <span class=\"hljs-keyword\">values</span> (<span class=\"hljs-string\">&#x27;杜驰&#x27;</span>, <span class=\"hljs-string\">&#x27;冯思源&#x27;</span>, <span class=\"hljs-string\">&#x27;www.vashti-auer.org&#x27;</span>, <span class=\"hljs-string\">&#x27;黎健柏&#x27;</span>, <span class=\"hljs-string\">&#x27;武博文&#x27;</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-string\">&#x27;李伟宸&#x27;</span>, <span class=\"hljs-number\">9</span>);<br><span class=\"hljs-keyword\">insert</span> <span class=\"hljs-keyword\">into</span> myapi.`interface_info` (`name`, `description`, `url`, `requestHeader`, `responseHeader`, `status`, `<span class=\"hljs-keyword\">method</span>`, `userId`) <span class=\"hljs-keyword\">values</span> (<span class=\"hljs-string\">&#x27;史金鑫&#x27;</span>, <span class=\"hljs-string\">&#x27;蔡鹏涛&#x27;</span>, <span class=\"hljs-string\">&#x27;www.diann-keebler.org&#x27;</span>, <span class=\"hljs-string\">&#x27;徐烨霖&#x27;</span>, <span class=\"hljs-string\">&#x27;阎建辉&#x27;</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-string\">&#x27;李烨伟&#x27;</span>, <span class=\"hljs-number\">125</span>);<br><span class=\"hljs-keyword\">insert</span> <span class=\"hljs-keyword\">into</span> myapi.`interface_info` (`name`, `description`, `url`, `requestHeader`, `responseHeader`, `status`, `<span class=\"hljs-keyword\">method</span>`, `userId`) <span class=\"hljs-keyword\">values</span> (<span class=\"hljs-string\">&#x27;林炫明&#x27;</span>, <span class=\"hljs-string\">&#x27;贾旭尧&#x27;</span>, <span class=\"hljs-string\">&#x27;www.dotty-kuvalis.io&#x27;</span>, <span class=\"hljs-string\">&#x27;梁雨泽&#x27;</span>, <span class=\"hljs-string\">&#x27;龙伟泽&#x27;</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-string\">&#x27;许智渊&#x27;</span>, <span class=\"hljs-number\">79998</span>);<br><span class=\"hljs-keyword\">insert</span> <span class=\"hljs-keyword\">into</span> myapi.`interface_info` (`name`, `description`, `url`, `requestHeader`, `responseHeader`, `status`, `<span class=\"hljs-keyword\">method</span>`, `userId`) <span class=\"hljs-keyword\">values</span> (<span class=\"hljs-string\">&#x27;何钰轩&#x27;</span>, <span class=\"hljs-string\">&#x27;赖智宸&#x27;</span>, <span class=\"hljs-string\">&#x27;www.andy-adams.net&#x27;</span>, <span class=\"hljs-string\">&#x27;崔思淼&#x27;</span>, <span class=\"hljs-string\">&#x27;白鸿煊&#x27;</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-string\">&#x27;邵振家&#x27;</span>, <span class=\"hljs-number\">7167482751</span>);<br><span class=\"hljs-keyword\">insert</span> <span class=\"hljs-keyword\">into</span> myapi.`interface_info` (`name`, `description`, `url`, `requestHeader`, `responseHeader`, `status`, `<span class=\"hljs-keyword\">method</span>`, `userId`) <span class=\"hljs-keyword\">values</span> (<span class=\"hljs-string\">&#x27;魏志强&#x27;</span>, <span class=\"hljs-string\">&#x27;于立诚&#x27;</span>, <span class=\"hljs-string\">&#x27;www.ione-aufderhar.biz&#x27;</span>, <span class=\"hljs-string\">&#x27;朱懿轩&#x27;</span>, <span class=\"hljs-string\">&#x27;万智渊&#x27;</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-string\">&#x27;唐昊强&#x27;</span>, <span class=\"hljs-number\">741098</span>);<br><span class=\"hljs-keyword\">insert</span> <span class=\"hljs-keyword\">into</span> myapi.`interface_info` (`name`, `description`, `url`, `requestHeader`, `responseHeader`, `status`, `<span class=\"hljs-keyword\">method</span>`, `userId`) <span class=\"hljs-keyword\">values</span> (<span class=\"hljs-string\">&#x27;严君浩&#x27;</span>, <span class=\"hljs-string\">&#x27;金胤祥&#x27;</span>, <span class=\"hljs-string\">&#x27;www.duane-boyle.org&#x27;</span>, <span class=\"hljs-string\">&#x27;雷昊焱&#x27;</span>, <span class=\"hljs-string\">&#x27;侯思聪&#x27;</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-string\">&#x27;郝思&#x27;</span>, <span class=\"hljs-number\">580514</span>);<br><span class=\"hljs-keyword\">insert</span> <span class=\"hljs-keyword\">into</span> myapi.`interface_info` (`name`, `description`, `url`, `requestHeader`, `responseHeader`, `status`, `<span class=\"hljs-keyword\">method</span>`, `userId`) <span class=\"hljs-keyword\">values</span> (<span class=\"hljs-string\">&#x27;姚皓轩&#x27;</span>, <span class=\"hljs-string\">&#x27;金鹏&#x27;</span>, <span class=\"hljs-string\">&#x27;www.lyda-klein.biz&#x27;</span>, <span class=\"hljs-string\">&#x27;杜昊强&#x27;</span>, <span class=\"hljs-string\">&#x27;邵志泽&#x27;</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-string\">&#x27;冯鸿涛&#x27;</span>, <span class=\"hljs-number\">6546</span>);<br><span class=\"hljs-keyword\">insert</span> <span class=\"hljs-keyword\">into</span> myapi.`interface_info` (`name`, `description`, `url`, `requestHeader`, `responseHeader`, `status`, `<span class=\"hljs-keyword\">method</span>`, `userId`) <span class=\"hljs-keyword\">values</span> (<span class=\"hljs-string\">&#x27;廖驰&#x27;</span>, <span class=\"hljs-string\">&#x27;沈泽洋&#x27;</span>, <span class=\"hljs-string\">&#x27;www.consuelo-sipes.info&#x27;</span>, <span class=\"hljs-string\">&#x27;彭昊然&#x27;</span>, <span class=\"hljs-string\">&#x27;邓耀杰&#x27;</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-string\">&#x27;周彬&#x27;</span>, <span class=\"hljs-number\">7761037</span>);<br><span class=\"hljs-keyword\">insert</span> <span class=\"hljs-keyword\">into</span> myapi.`interface_info` (`name`, `description`, `url`, `requestHeader`, `responseHeader`, `status`, `<span class=\"hljs-keyword\">method</span>`, `userId`) <span class=\"hljs-keyword\">values</span> (<span class=\"hljs-string\">&#x27;赖智渊&#x27;</span>, <span class=\"hljs-string\">&#x27;邓志泽&#x27;</span>, <span class=\"hljs-string\">&#x27;www.emerson-mann.co&#x27;</span>, <span class=\"hljs-string\">&#x27;熊明哲&#x27;</span>, <span class=\"hljs-string\">&#x27;贺哲瀚&#x27;</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-string\">&#x27;田鹏&#x27;</span>, <span class=\"hljs-number\">381422</span>);<br><span class=\"hljs-keyword\">insert</span> <span class=\"hljs-keyword\">into</span> myapi.`interface_info` (`name`, `description`, `url`, `requestHeader`, `responseHeader`, `status`, `<span class=\"hljs-keyword\">method</span>`, `userId`) <span class=\"hljs-keyword\">values</span> (<span class=\"hljs-string\">&#x27;许涛&#x27;</span>, <span class=\"hljs-string\">&#x27;陆致远&#x27;</span>, <span class=\"hljs-string\">&#x27;www.vella-ankunding.name&#x27;</span>, <span class=\"hljs-string\">&#x27;贾哲瀚&#x27;</span>, <span class=\"hljs-string\">&#x27;莫昊焱&#x27;</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-string\">&#x27;袁越彬&#x27;</span>, <span class=\"hljs-number\">4218096</span>);<br><span class=\"hljs-keyword\">insert</span> <span class=\"hljs-keyword\">into</span> myapi.`interface_info` (`name`, `description`, `url`, `requestHeader`, `responseHeader`, `status`, `<span class=\"hljs-keyword\">method</span>`, `userId`) <span class=\"hljs-keyword\">values</span> (<span class=\"hljs-string\">&#x27;吕峻熙&#x27;</span>, <span class=\"hljs-string\">&#x27;沈鹏飞&#x27;</span>, <span class=\"hljs-string\">&#x27;www.shari-reichel.org&#x27;</span>, <span class=\"hljs-string\">&#x27;郭鸿煊&#x27;</span>, <span class=\"hljs-string\">&#x27;覃烨霖&#x27;</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-string\">&#x27;熊黎昕&#x27;</span>, <span class=\"hljs-number\">493</span>);<br><br></code></pre></td></tr></table></figure>\n\n\n\n<blockquote>\n<p>留一个小bug，数据库建表语句直接套用的最终建表语句，user表中涉及到两个关于key的字段，手动改成了可以为空，若有问题，后续再做出更改</p>\n</blockquote>\n<blockquote>\n<p>利用<code>MyBatisX</code>插件生成接口管理的增删改查代码</p>\n</blockquote>\n<p>将生成的代码逻辑复制到项目的dao、service、mapper包里，</p>\n<p>然后还剩一个controller层，直接复制一份模板中的controller层的代码，进行复用</p>\n<p>注意此时模糊查询使用的字段不是content，而是description，进行相应的更改。</p>\n<p>此时，增删改查操作已完成，就这么简单 </p>\n<p>跑通后端</p>\n<ul>\n<li><h3 id=\"前端-1\"><a href=\"#前端-1\" class=\"headerlink\" title=\"前端\"></a>前端</h3></li>\n</ul>\n<p>使用oneapi插件自动生成（openapi规范）</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/wl2o2o/blogCdn/img/202307012353984.png\" alt=\"image-20230701235258820\"></p>\n<blockquote>\n<p>先前，我们登陆时是采用的start假数据进行登录，此时使用dev，登陆页面是存在问题的，因为脚手架自动生成的页面会强制要求登录，此时的登录接口与我们oneapi自动生成的接口对应不上，需要手动进行更改User》》Login》》index.tsx</p>\n</blockquote>\n<p>因为没有开发注册页面，可以从注册中心项目中复制一个过来</p>\n<p>为了便捷的进行开发，先从swagger注册一个账号，然后登录发现没有进行跳转，通过分析得出，是因为前端没有记录用户的登录状态，所以要进一步进行完善，在typings.d.ts中进行定义全局登录态</p>\n<p>改造页面，将前端展示的表格，用来展示自己的数据</p>\n<h2 id=\"Day02-接口调用开发（前端）\"><a href=\"#Day02-接口调用开发（前端）\" class=\"headerlink\" title=\"Day02 接口调用开发（前端）\"></a>Day02 接口调用开发（前端）</h2><blockquote>\n<p>首先发现一个问题，使用后端swagger进行user密码更改的时候，密码没有进行加密，会导致前端进行校验的时候返回用户名或者密码不正确的信息</p>\n</blockquote>\n<ul>\n<li><h3 id=\"优化前端展示页面（改路由，先不删）\"><a href=\"#优化前端展示页面（改路由，先不删）\" class=\"headerlink\" title=\"优化前端展示页面（改路由，先不删）\"></a>优化前端展示页面（改路由，先不删）</h3><ul>\n<li>保持前后端组件名一致</li>\n<li>优化页面代码</li>\n<li>首页没有页面，后续进行开发一个非管理员用户可以看到的页面</li>\n<li>调整导航栏的位置，可以先使用antDesignPro框架提供的切换导航布局小设置</li>\n</ul>\n</li>\n<li><h3 id=\"新建模态框的编写真的很搞心态，最后的原因竟然是因为一个小的错误（静下心来）（血泪教训，做完项目过一遍react）\"><a href=\"#新建模态框的编写真的很搞心态，最后的原因竟然是因为一个小的错误（静下心来）（血泪教训，做完项目过一遍react）\" class=\"headerlink\" title=\"新建模态框的编写真的很搞心态，最后的原因竟然是因为一个小的错误（静下心来）（血泪教训，做完项目过一遍react）\"></a>新建模态框的编写真的很搞心态，最后的原因竟然是因为一个小的错误（静下心来）（血泪教训，做完项目过一遍react）</h3></li>\n<li><h3 id=\"完善修改框\"><a href=\"#完善修改框\" class=\"headerlink\" title=\"完善修改框\"></a>完善修改框</h3><ul>\n<li><p>此处设计到React的核心知识点，也是重中之重（useEffect、useRef）</p>\n</li>\n<li><p>```tsx<br>const formRef = useRef<ProFormInstance>();</p>\n<p>useEffect(() =&gt; {<br>  if(formRef){</p>\n<pre><code class=\"hljs\">formRef.current?.setFieldsValue(values);\n</code></pre>\n<p>  }<br>}, [values])</p>\n<p>return (</p>\n<pre><code class=\"hljs\">&lt;Modal visible=&#123;visible&#125; footer=&#123;null&#125; onCancel=&#123;() =&gt; onCancel?.()&#125;&gt;\n  &lt;ProTable\n    type=&quot;form&quot;\n    columns=&#123;columns&#125;\n    // 因为这里使用的form组件，只会初始化一次，所以会造成点击修改按钮进行修改的话，数据是不会变的\n    // form=&#123;&#123;\n            //   initialValues: values\n            // &#125;&#125;\n    \n    // 所以此处用到了监听\n    formRef=&#123;formRef&#125;\n    \n    onSubmit=&#123;async (value) =&gt; &#123;\n      onSubmit?.(value);\n    &#125;&#125;\n  /&gt;\n&lt;/Modal&gt;\n</code></pre>\n<p>  );</p>\n<figure class=\"highlight node-repl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br><span class=\"line\">212</span><br><span class=\"line\">213</span><br><span class=\"line\">214</span><br><span class=\"line\">215</span><br><span class=\"line\">216</span><br><span class=\"line\">217</span><br><span class=\"line\">218</span><br><span class=\"line\">219</span><br><span class=\"line\">220</span><br><span class=\"line\">221</span><br><span class=\"line\">222</span><br><span class=\"line\">223</span><br><span class=\"line\">224</span><br><span class=\"line\">225</span><br><span class=\"line\">226</span><br><span class=\"line\">227</span><br><span class=\"line\">228</span><br><span class=\"line\">229</span><br><span class=\"line\">230</span><br><span class=\"line\">231</span><br><span class=\"line\">232</span><br><span class=\"line\">233</span><br><span class=\"line\">234</span><br><span class=\"line\">235</span><br><span class=\"line\">236</span><br><span class=\"line\">237</span><br><span class=\"line\">238</span><br><span class=\"line\">239</span><br><span class=\"line\">240</span><br><span class=\"line\">241</span><br><span class=\"line\">242</span><br><span class=\"line\">243</span><br><span class=\"line\">244</span><br><span class=\"line\">245</span><br><span class=\"line\">246</span><br><span class=\"line\">247</span><br><span class=\"line\">248</span><br><span class=\"line\">249</span><br><span class=\"line\">250</span><br><span class=\"line\">251</span><br><span class=\"line\">252</span><br><span class=\"line\">253</span><br><span class=\"line\">254</span><br><span class=\"line\">255</span><br><span class=\"line\">256</span><br><span class=\"line\">257</span><br><span class=\"line\">258</span><br><span class=\"line\">259</span><br><span class=\"line\">260</span><br><span class=\"line\">261</span><br><span class=\"line\">262</span><br><span class=\"line\">263</span><br><span class=\"line\">264</span><br><span class=\"line\">265</span><br><span class=\"line\">266</span><br><span class=\"line\">267</span><br><span class=\"line\">268</span><br><span class=\"line\">269</span><br><span class=\"line\">270</span><br><span class=\"line\">271</span><br><span class=\"line\">272</span><br><span class=\"line\">273</span><br><span class=\"line\">274</span><br><span class=\"line\">275</span><br><span class=\"line\">276</span><br><span class=\"line\">277</span><br><span class=\"line\">278</span><br><span class=\"line\">279</span><br><span class=\"line\">280</span><br><span class=\"line\">281</span><br><span class=\"line\">282</span><br><span class=\"line\">283</span><br><span class=\"line\">284</span><br><span class=\"line\">285</span><br><span class=\"line\">286</span><br><span class=\"line\">287</span><br><span class=\"line\">288</span><br><span class=\"line\">289</span><br><span class=\"line\">290</span><br><span class=\"line\">291</span><br><span class=\"line\">292</span><br><span class=\"line\">293</span><br><span class=\"line\">294</span><br><span class=\"line\">295</span><br><span class=\"line\">296</span><br><span class=\"line\">297</span><br><span class=\"line\">298</span><br><span class=\"line\">299</span><br><span class=\"line\">300</span><br><span class=\"line\">301</span><br><span class=\"line\">302</span><br><span class=\"line\">303</span><br><span class=\"line\">304</span><br><span class=\"line\">305</span><br><span class=\"line\">306</span><br><span class=\"line\">307</span><br><span class=\"line\">308</span><br><span class=\"line\">309</span><br><span class=\"line\">310</span><br><span class=\"line\">311</span><br><span class=\"line\">312</span><br><span class=\"line\">313</span><br><span class=\"line\">314</span><br><span class=\"line\">315</span><br><span class=\"line\">316</span><br><span class=\"line\">317</span><br><span class=\"line\">318</span><br><span class=\"line\">319</span><br><span class=\"line\">320</span><br><span class=\"line\">321</span><br><span class=\"line\">322</span><br><span class=\"line\">323</span><br><span class=\"line\">324</span><br><span class=\"line\">325</span><br><span class=\"line\">326</span><br><span class=\"line\">327</span><br><span class=\"line\">328</span><br><span class=\"line\">329</span><br><span class=\"line\">330</span><br><span class=\"line\">331</span><br><span class=\"line\">332</span><br><span class=\"line\">333</span><br><span class=\"line\">334</span><br><span class=\"line\">335</span><br><span class=\"line\">336</span><br><span class=\"line\">337</span><br><span class=\"line\">338</span><br><span class=\"line\">339</span><br><span class=\"line\">340</span><br><span class=\"line\">341</span><br><span class=\"line\">342</span><br><span class=\"line\">343</span><br><span class=\"line\">344</span><br><span class=\"line\">345</span><br><span class=\"line\">346</span><br><span class=\"line\">347</span><br><span class=\"line\">348</span><br><span class=\"line\">349</span><br><span class=\"line\">350</span><br><span class=\"line\">351</span><br><span class=\"line\">352</span><br><span class=\"line\">353</span><br><span class=\"line\">354</span><br><span class=\"line\">355</span><br><span class=\"line\">356</span><br><span class=\"line\">357</span><br><span class=\"line\">358</span><br><span class=\"line\">359</span><br><span class=\"line\">360</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs node-repl\"><br>  * &gt; 此处有Bug，后端报空指针<br><br><br>* ### 完善删除框<br><br>  * 仿照以上步骤完成<br><br>  * &gt; 此时发现进行相关操作之后数据不会自动更新，所以我们引入actionRef，它可以拿到proTable的控制权，使用actionRef.current?.reload()<br><br><br><br><br><br>### 模拟接口项目（smartapi-interface）（后端）<br><br>提供三个模拟接口<br><br>1. GET接口<br>2. POST接口（url传参）<br>3. POST接口（Restful）<br><br><br><br><br><br>### 开始开发模拟接口项目部分<br><br>采用创建几个controller控制层小接口，前端传参进行调用，但是这样不符合逻辑，所以我们要通过后端来进行传参！<br><br><br><br>### 开发调用接口<br><br>几种HTTP调用方式<br><br>\t1. HttpClient<br>\t1. RestTemplete<br>\t1. 工具（OKHttp、HuTool）<br><br>这里我们使用HuTool来进行调用[HuTool](https://hutool.cn/docs/#/)<br><br><br><br>参考文档是一个好东西，利用好<br><br><br><br>那么现在已经开发好调用接口了，但是用户调用你的接口，或者黑客黑你的接口，所以需要对调用者进行一个调用限制，那么如何加以限制？<br><br>这时可以联想一下我们平时调用第三方接口时，都会有一些key<br><br><br><br>### API 签名认证（客户端与服务端有点迷惑，后续捋顺）<br><br><br><br>**本质：**<br><br>1. 签发签名<br><br>\t2. 使用签名(校验签名)<br><br><br><br>**为什么需要？**<br><br>1. 保证安全性，不能随便一个人就可以调用<br><br><br><br>**怎么实现？（复杂、无序、无规律）**<br><br>通过http request header头传递参数。<br><br>参数1：assesKey：调用的标识（一串无规则字符串） User A、B<br><br>参数2：secretKey：相当于密码<br><br>也就是用户名和密钥，区别就是ak、sk是无状态的<br><br>在服务端数据库表中新增以上两个字段，用户客户端进行校验。<br><br><br><br><br><br>但是这样的方法时容易被拦截的，不能把密钥直接在服务器之间进行传递，要进行加密。所以要对密码进一步进行加密。<br><br><br><br>参数3：用户请求参数（更严格）<br><br><br><br>参数4：sign<br><br>加密方式：对称机密、非对称加密、不可解密加密（MD5）<br><br><br><br>用户参数 + 密钥 ==》 **签名生成算法** ==》不可解密的值<br><br>wl + abcdefgh ==》afdasfafszv（通过签名算法加密）<br><br>那么如何知道这个签名是否正确？<br><br>**服务端会通过用一摸一样的参数和算法去生成签名，只要和用户才能属的签名一致，则正确!**<br><br><br><br><br><br>**怎么防重放？**<br><br>参数5：加nonce随机数，保证只能用一次，但是服务端也要保存随机数<br><br>参数6：timestamp时间戳（加上时间戳可以保证随机数可以清除）<br><br>**API签名认证是一个很灵活的设计，具体要有哪些参数、参数名一定要根据实际场景来（比如userId、appId、version、固定值等）**<br><br><br><br>思考：难道开发者每次调用接口都需要自己来写签名算法吗？<br><br><br><br><br><br><br><br><br><br>### 开发一个简单易用的SDK<br><br><br><br>理想情况：开发者只需要关心调用哪些接口、传递哪些参数，就跟调用自己的代码一样简单。<br><br><br><br>开发stater的好处：<br><br>1. 开发者引入之后，可以直接在application.yml中写配置，自动创建客户端。<br><br><br><br>### 创建SDK项目（开发starter）（简历亮点）<br><br>引入依赖：<br><br>1. lombook<br>2. Spring Configuration Processor（自动生成配置文件写代码的提示）<br><br><br><br>改造pom依赖，一定要删掉build标签内的代码，因为我们在进行构建依赖包，不是要直接运行的jar的项目<br><br><br><br><br><br>尝试把打好的包发布到maven中<br><br><br><br><br><br><br><br><br><br>## Day03 接口保护与优化<br><br><br><br><span class=\"hljs-meta prompt_\">&gt;</span> <span class=\"language-javascript\">此时，我们发现鱼总的后端项目模块中已经包含前面单独创建好的<span class=\"hljs-variable constant_\">SDK</span>和interface模拟接口项目了，那么我们如何把这两个添加到后端的项目中呢？</span><br><span class=\"hljs-meta prompt_\">&gt;</span><br><span class=\"hljs-meta prompt_\">&gt;</span> <span class=\"language-javascript\">方案一：</span><br><span class=\"hljs-meta prompt_\">&gt;</span><br><span class=\"hljs-meta prompt_\">&gt;</span> <span class=\"language-javascript\">​\t受尚医通项目的影响，我想应该可以通过增加子模块的方法拉进行添加，但是添加之后好像是不太行，跟鱼总的不一样，这种方法应该是可以使多个项目在同一个窗口中打开（解决了之前我的疑虑）</span><br><span class=\"hljs-meta prompt_\">&gt;</span><br><span class=\"hljs-meta prompt_\">&gt;</span> <span class=\"language-javascript\">方案二：</span><br><span class=\"hljs-meta prompt_\">&gt;</span><br><span class=\"hljs-meta prompt_\">&gt;</span> <span class=\"language-javascript\">​\t我们看到鱼总的后端项目中，另外两个项目（<span class=\"hljs-variable constant_\">SDK</span>和interface）是两个目录的标识，于是我就直接复制粘贴到后端项目的文件夹中了，然后<span class=\"hljs-title class_\">Java</span>源文件会变成红J，可以通过右键rsc下main下的<span class=\"hljs-title class_\">Java</span>文件夹，然后mark <span class=\"hljs-title class_\">Directory</span> <span class=\"hljs-keyword\">as</span>--》<span class=\"hljs-title class_\">Sources</span> <span class=\"hljs-title class_\">Root</span>，将<span class=\"hljs-title class_\">Java</span>文件夹标记为源码根目录，如图所示：</span><br><span class=\"hljs-meta prompt_\">&gt;</span><br><span class=\"hljs-meta prompt_\">&gt;</span> <span class=\"language-javascript\">![image-<span class=\"hljs-number\">20230708205543307</span>](<span class=\"hljs-attr\">https</span>:<span class=\"hljs-comment\">//cdn.jsdelivr.net/gh/wl2o2o/blogCdn/img/202307092023528.png)</span></span><br><span class=\"hljs-meta prompt_\">&gt;</span><br><span class=\"hljs-meta prompt_\">&gt;</span> <span class=\"language-javascript\">然后我们发现maven的pom依赖文件的图标也不对，也通过桐言的方法，右键--》add maven project标记为maven项目，大功告成！</span><br><br>1.开发接口发布/下线的功能（管理员）<br><br>2.前端浏览接口，查看 接口文档，申请签名（注册）<br><br>3.在线测试（用户）<br><br>4.统一用户调用接口次数<br><br>5.优化系统-API网关<br><br>### 开发接口发布/下线的功能（仅管理员） <br><br><span class=\"hljs-meta prompt_\">&gt;</span> <span class=\"language-javascript\">此处又涉及到了一个待学知识点：</span><br><span class=\"hljs-meta prompt_\">&gt;</span><br><span class=\"hljs-meta prompt_\">&gt;</span> <span class=\"language-javascript\"><span class=\"hljs-title class_\">Spring</span>的<span class=\"hljs-variable constant_\">AOP</span>切面应用</span><br><span class=\"hljs-meta prompt_\">&gt;</span><br><span class=\"hljs-meta prompt_\">&gt;</span> <span class=\"language-javascript\">可以用来通过注解的方式进行权限管理。</span><br><br>### 后端接口： <br><br>**发布接口**（仅管理员） <br><br>1.校验该接口是否存在<br><br>2.判断接口是否可以被调用<br><br>​\t利用开发好的SDK，通过调用接口看是否能够进行调用的通<br><br>​\t第一步：启动smartapi-interface项目<br><br>​\t第二步：在smartapi-backend中引入SDK的依赖<br><br>​\t第三步：在application.yml中写入ak、sk<br><br>​\t第四步：在接口中引入客户端的实例<br><br>​\t\t\t@Resource<br><br>​\t\t\tprivate SmartApiClient smartapiclient<br><br><span class=\"hljs-meta prompt_\">&gt;</span> <span class=\"language-javascript\"><span class=\"hljs-attr\">TODO</span>:</span><br><span class=\"hljs-meta prompt_\">&gt;</span><br><span class=\"hljs-meta prompt_\">&gt;</span> <span class=\"language-javascript\">&gt; &gt;  <span class=\"hljs-number\">1.</span> 判断接口是否可以调用时，由固定方法名改为可以根据测试地址进行调用</span><br><span class=\"hljs-meta prompt_\">&gt;</span> <span class=\"language-javascript\">&gt; &gt;  <span class=\"hljs-number\">2.</span> 用户测试接口判断接口是否可以调用时，由固定方法名改为可以根据测试地址进行调用</span><br><br>3.修改数据库接口字段为1<br><br>**下线接口**（仅管理员） <br><br>1.校验该接口是否存在<br><br>2.修改数据库接口字段为 0<br><br>按钮已添加并完善。测试中出现一个经典问题，如图所示：<br><br>![image-20230710000821503](https://cdn.jsdelivr.net/gh/wl2o2o/blogCdn/img/202307100008989.png)<br><br><br><br><span class=\"hljs-meta prompt_\">&gt;</span> <span class=\"language-javascript\">待办事件：</span><br><span class=\"hljs-meta prompt_\">&gt;</span><br><span class=\"hljs-meta prompt_\">&gt;</span> <span class=\"language-javascript\">流程：</span><br><span class=\"hljs-meta prompt_\">&gt;</span><br><span class=\"hljs-meta prompt_\">&gt;</span> <br><span class=\"hljs-meta prompt_\">&gt;</span><br><span class=\"hljs-meta prompt_\">&gt;</span> <span class=\"language-javascript\">**前端**添加上线、下线按钮、√、增加用户浏览页面、查看接口文档、申请签名</span><br><span class=\"hljs-meta prompt_\">&gt;</span><br><span class=\"hljs-meta prompt_\">&gt;</span> <span class=\"language-javascript\">**后端**申请签名（更改完善数据库写生成签名的算法）</span><br><span class=\"hljs-meta prompt_\">&gt;</span><br><span class=\"hljs-meta prompt_\">&gt;</span> <span class=\"language-javascript\">**前端**</span><br><span class=\"hljs-meta prompt_\">&gt;</span><br><span class=\"hljs-meta prompt_\">&gt;</span> <span class=\"language-javascript\">新增在线调用的按钮</span><br><span class=\"hljs-meta prompt_\">&gt;</span><br><span class=\"hljs-meta prompt_\">&gt;</span> <span class=\"language-javascript\">**后端**</span><br><span class=\"hljs-meta prompt_\">&gt;</span><br><span class=\"hljs-meta prompt_\">&gt;</span> <span class=\"language-javascript\">开发在线调用的接口</span><br><span class=\"hljs-meta prompt_\">&gt;</span><br><span class=\"hljs-meta prompt_\">&gt;</span> <br><br><br><br><br><br><br><br>### 前端浏览接口<br><br>```react<br>import &#123; PageContainer &#125; from &#x27;@ant-design/pro-components&#x27;;<br>import React, &#123;useEffect, useState&#125; from &#x27;react&#x27;;<br>import &#123;List, message&#125; from &quot;antd&quot;;<br>import &#123;<br>  listInterfaceInfoByPageUsingGET<br>&#125; from &quot;@/services/smartapi-backend/interfaceInfoController&quot;;<br><br><br>/**<br> * 主页<br> * @constructor<br> */<br>const Index: React.FC = () =&gt; &#123;<br><br>  const [loading, setLoading] = useState(false);<br>  const [list, setList] = useState&lt;API.InterfaceInfo[]&gt;([]);<br>  const [total ,setTotal] = useState&lt;number&gt;(0);<br><br>  const loadData = async (current=1 , pageSize = 8 ) =&gt;&#123;<br>    setLoading(true);<br>    try &#123;<br>      const res = await listInterfaceInfoByPageUsingGET(&#123;<br>        current,pageSize<br>      &#125;);<br>      setList(res?.data?.records ?? []);<br>      setTotal(res?.data?.total ?? 0);<br><br>    &#125; catch (error: any) &#123;<br><br>      message.error(&#x27;请求失败,&#x27;+error.message);<br>      return false;<br>    &#125;<br>    setLoading(false);<br>  &#125;<br>  useEffect(() =&gt; &#123;<br>    loadData();<br>  &#125;,[])<br><br><br>  return (<br>    &lt;PageContainer title=&quot;在线接口开放平台&quot;&gt;<br>      &lt;List<br>        className=&quot;my-list&quot;<br>        loading=&#123;loading&#125;<br>        itemLayout=&quot;horizontal&quot;<br>        dataSource=&#123;list&#125;<br>        renderItem=&#123;item =&gt; &#123;<br><br>          const apiLink =`/interface_info/$&#123;item.id&#125;`;<br>          return(<br>            &lt;List.Item<br>              actions=&#123;[&lt;a key=&#123;item.id&#125; href=&#123;apiLink&#125;&gt;查看&lt;/a&gt;]&#125;<br>            &gt;<br>              &lt;List.Item.Meta<br>                title=&#123;&lt;a href=&#123;apiLink&#125;&gt;&#123;item.name&#125;&lt;/a&gt;&#125;<br>                description=&#123;item.description&#125;<br>              /&gt;<br>            &lt;/List.Item&gt;<br>          )<br>        &#125;<br><br>        &#125;<br>        pagination =&#123;<br>          &#123;<br>            // eslint-disable-next-line @typescript-eslint/no-shadow<br>            showTotal(total: number)&#123;<br>              return &#x27;总数：&#x27; +total;<br>            &#125;,<br>            pageSize: 8,<br>            total,<br>            onChange(page,pageSize)&#123;<br>              loadData(page,pageSize);<br>            &#125;<br>          &#125;<br>        &#125;<br>      /&gt;<br>    &lt;/PageContainer&gt;<br>  );<br>&#125;;<br><br>export default Index;<br></code></pre></td></tr></table></figure></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"查看接口文档\"><a href=\"#查看接口文档\" class=\"headerlink\" title=\"查看接口文档\"></a>查看接口文档</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs react\">import &#123; PageContainer &#125; from &#x27;@ant-design/pro-components&#x27;;<br>import React, &#123;useEffect, useState&#125; from &#x27;react&#x27;;<br>import &#123;Card, Descriptions, message&#125; from &quot;antd&quot;;<br>import &#123;<br>  getInterfaceInfoByIdUsingGET,<br><br>&#125; from &quot;@/services/smartapi-backend/interfaceInfoController&quot;;<br>import &#123; useParams&#125; from &quot;@@/exports&quot;;<br><br><br>/**<br> * 主页<br> * @constructor<br> */<br>const Index: React.FC = () =&gt; &#123;<br><br>  const [loading, setLoading] = useState(false);<br>  const [data, setData] = useState&lt;API.InterfaceInfo&gt;();<br>  const params  = useParams();<br><br>  const loadData = async () =&gt;&#123;<br>    if (!params.id)&#123;<br>      message.error(&#x27;参数不存在&#x27;);<br>      return ;<br>    &#125;<br>    setLoading(true);<br>    try &#123;<br>      const res = await getInterfaceInfoByIdUsingGET(&#123;<br>        id: Number(params.id)<br>      &#125;);<br>      setData(res.data);<br><br>    &#125; catch (error: any) &#123;<br><br>      message.error(&#x27;请求失败,&#x27;+error.message);<br>      return false;<br>    &#125;<br>    setLoading(false);<br>  &#125;<br>  useEffect(() =&gt; &#123;<br>    loadData();<br>  &#125;,[])<br><br>  return (<br>    &lt;PageContainer title=&quot;查看接口文档&quot;&gt;<br>      &lt;Card&gt;<br>        &#123;<br>          data?(<br>            &lt;Descriptions title=&#123;data.name&#125; column=&#123;1&#125;&gt;<br>              &lt;Descriptions.Item label=&quot;描述&quot;&gt;&#123;data.description&#125;&lt;/Descriptions.Item&gt;<br>              &lt;Descriptions.Item label=&quot;接口状态&quot;&gt;&#123;data.status? &#x27;正常&#x27;: &#x27;关闭&#x27;&#125;&lt;/Descriptions.Item&gt;<br>              &lt;Descriptions.Item label=&quot;请求地址&quot;&gt;&#123;data.url&#125;&lt;/Descriptions.Item&gt;<br>              &lt;Descriptions.Item label=&quot;请求方法&quot;&gt;&#123;data.method&#125;&lt;/Descriptions.Item&gt;<br>              &lt;Descriptions.Item label=&quot;请求头&quot;&gt;&#123;data.requestHeader&#125;&lt;/Descriptions.Item&gt;<br>              &lt;Descriptions.Item label=&quot;响应头&quot;&gt;&#123;data.responseHeader&#125;&lt;/Descriptions.Item&gt;<br>              &lt;Descriptions.Item label=&quot;创建时间&quot;&gt;&#123;data.createTime&#125;&lt;/Descriptions.Item&gt;<br>              &lt;Descriptions.Item label=&quot;更新时间&quot;&gt;&#123;data.updateTime&#125;&lt;/Descriptions.Item&gt;<br>            &lt;/Descriptions&gt;<br>          ):(<br>            &lt;&gt;接口不存在&lt;/&gt;<br>          )&#125;<br>      &lt;/Card&gt;<br>    &lt;/PageContainer&gt;<br>  );<br>&#125;;<br><br>export default Index;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"申请签名（注册）\"><a href=\"#申请签名（注册）\" class=\"headerlink\" title=\"申请签名（注册）\"></a>申请签名（注册）</h3><p>通过数据库新增字段、更改用户注册的逻辑（使用DigestUtil加密算法生成ak、sk，然后加入数据库）</p>\n<blockquote>\n<p>留一个小作业:</p>\n<p>新增一个小拓展功能：用户可以手动更改自己的ak、sk</p>\n</blockquote>\n<h3 id=\"新建真实数据（前端）\"><a href=\"#新建真实数据（前端）\" class=\"headerlink\" title=\"新建真实数据（前端）\"></a>新建真实数据（前端）</h3><p><strong>新建这些真实的数据</strong></p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs text\">getUsernameByPost,<br><br>获取用户名,<br><br>http://localhost:8123/name/user,<br><br>&#123;”Content-Type“: ”application/json“&#125;,<br><br>&#123;”Content-Type“: ”application/json“&#125;,<br><br></code></pre></td></tr></table></figure>\n\n<p>oh my god，此时发现遗忘了一个重要的请求参数字段，于是通过建表语句、IDEA客户端modify table，来增加这么一个字段。</p>\n<p>修改相应的model实体包中的字段信息以及向mybatisplus.xml中添加这个字段。</p>\n<p>重启项目—》前端重新使用openai插件生成接口</p>\n<p>前端也需要完善修改组件的表单列名，新增一个requestParams</p>\n<p>完成！</p>\n<p><strong>完善接口信息的请求参数信息</strong></p>\n<p><strong>在线调用</strong></p>\n<p>前端界面的编写，通过ant design组件库利用现成的表单组件来完成在线按钮的添加与请求参数的基本表单。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/wl2o2o/blogCdn/img/202307100238354.png\" alt=\"image-20230710023831281\"></p>\n<p>请求参数的类型（JSON类型）</p>\n<blockquote>\n<p>又一个小作业：</p>\n<p>在线调用的扩展点：</p>\n<p>先跑通整个流程，然后根据请求头和请求类型的不同设计不同的表单和界面，增强用户体验</p>\n</blockquote>\n<h3 id=\"后端调用流程\"><a href=\"#后端调用流程\" class=\"headerlink\" title=\"后端调用流程\"></a>后端调用流程</h3><p><img src=\"https://cdn.jsdelivr.net/gh/wl2o2o/blogCdn/img/202307100242406.png\" alt=\"image-20230710024253445\"></p>\n<p>按照标准的企业开发流程来说：</p>\n<p>一定会选择第一种开发方式，不然后期的网关与计费就毫无作用，</p>\n<p>第二种方式可以用来自己调用测试。</p>\n<p>流程：</p>\n<ol>\n<li>前端将用户输入的请求参数与要进行测试的接口id发给平台后端</li>\n<li>在调用前进行一些校验</li>\n<li>平台后端去调用模拟接口</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Java\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">     * 测试调用</span><br><span class=\"hljs-comment\">     *</span><br><span class=\"hljs-comment\">     * <span class=\"hljs-doctag\">@param</span> interfaceInfoInvokeRequest</span><br><span class=\"hljs-comment\">     * <span class=\"hljs-doctag\">@param</span> request</span><br><span class=\"hljs-comment\">     * <span class=\"hljs-doctag\">@return</span></span><br><span class=\"hljs-comment\">     */</span><br>    <span class=\"hljs-meta\">@PostMapping(&quot;/invoke&quot;)</span><br>    <span class=\"hljs-keyword\">public</span> BaseResponse&lt;Object&gt; <span class=\"hljs-title function_\">invokeInterfaceInfo</span><span class=\"hljs-params\">(<span class=\"hljs-meta\">@RequestBody</span> InterfaceInfoInvokeRequest interfaceInfoInvokeRequest,</span><br><span class=\"hljs-params\">                                                    HttpServletRequest request)</span> &#123;<br>        <span class=\"hljs-keyword\">if</span> (interfaceInfoInvokeRequest == <span class=\"hljs-literal\">null</span> || interfaceInfoInvokeRequest.getId() &lt;= <span class=\"hljs-number\">0</span>) &#123;<br>            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">BusinessException</span>(ErrorCode.PARAMS_ERROR);<br>        &#125;<br>        <span class=\"hljs-type\">long</span> <span class=\"hljs-variable\">id</span> <span class=\"hljs-operator\">=</span> interfaceInfoInvokeRequest.getId();<br>        <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">userRequestParams</span> <span class=\"hljs-operator\">=</span> interfaceInfoInvokeRequest.getUserRequestParams();<br>        <span class=\"hljs-comment\">// 判断是否存在</span><br>        <span class=\"hljs-type\">InterfaceInfo</span> <span class=\"hljs-variable\">oldInterfaceInfo</span> <span class=\"hljs-operator\">=</span> interfaceInfoService.getById(id);<br>        <span class=\"hljs-keyword\">if</span> (oldInterfaceInfo == <span class=\"hljs-literal\">null</span>) &#123;<br>            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">BusinessException</span>(ErrorCode.NOT_FOUND_ERROR);<br>        &#125;<br>        <span class=\"hljs-keyword\">if</span> (oldInterfaceInfo.getStatus() == InterfaceInfoStatusEnum.OFFLINE.getValue()) &#123;<br>            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">BusinessException</span>(ErrorCode.PARAMS_ERROR, <span class=\"hljs-string\">&quot;接口已关闭&quot;</span>);<br>        &#125;<br>        <span class=\"hljs-type\">User</span> <span class=\"hljs-variable\">loginUser</span> <span class=\"hljs-operator\">=</span> userService.getLoginUser(request);<br>        <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">accessKey</span> <span class=\"hljs-operator\">=</span> loginUser.getAccessKey();<br>        <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">secretKey</span> <span class=\"hljs-operator\">=</span> loginUser.getSecretKey();<br>        <span class=\"hljs-type\">MyClient</span> <span class=\"hljs-variable\">tempClient</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">MyClient</span>(accessKey, secretKey);<br>        <span class=\"hljs-type\">Gson</span> <span class=\"hljs-variable\">gson</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Gson</span>();<br>        com.wl.smartapiclientsdk.model.<span class=\"hljs-type\">User</span> <span class=\"hljs-variable\">user</span> <span class=\"hljs-operator\">=</span> gson.fromJson(userRequestParams, com.wl.smartapiclientsdk.model.User.class);<br>        <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">usernameByPost</span> <span class=\"hljs-operator\">=</span> tempClient.getUserNameByPost(user);<br>        <span class=\"hljs-keyword\">return</span> ResultUtils.success(usernameByPost);<br>    &#125;<br></code></pre></td></tr></table></figure>\n\n<p>后端调用逻辑已完成</p>\n<p>现在继续完善前端的接口，将前端点击调用按钮后改为我们刚才通过后端实现的真实的功能。</p>\n<figure class=\"highlight xquery\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs xquery\">const onFinish = (values: any) =&gt; &#123;<br>    <span class=\"hljs-keyword\">if</span> (!params<span class=\"hljs-built_in\">.id</span>)&#123;<br>      message<span class=\"hljs-built_in\">.error</span>(<span class=\"hljs-string\">&#x27;接口不存在&#x27;</span>);<br>      <span class=\"hljs-keyword\">return</span> ;<br>    &#125;<br>    <span class=\"hljs-keyword\">try</span> &#123;<br>      invokeInterfaceInfoUsingPOST(&#123;<br>       <span class=\"hljs-built_in\"> id</span>: params<span class=\"hljs-built_in\">.id</span>,<br>        ...values<br>      &#125;)<br>      message.success(<span class=\"hljs-string\">&#x27;请求成功&#x27;</span>);<br>      <span class=\"hljs-keyword\">return</span><span class=\"hljs-built_in\"> true</span>;<br>    &#125; <span class=\"hljs-keyword\">catch</span> <span class=\"hljs-built_in\">(error</span>: any) &#123;<br>      message<span class=\"hljs-built_in\">.error</span>(<span class=\"hljs-string\">&#x27;请求失败，&#x27;</span> +<span class=\"hljs-built_in\"> error</span>.message);<br>    &#125;<br>  &#125;;<br></code></pre></td></tr></table></figure>\n\n<p>逻辑打通之后还要进行回显数据：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs typescript\"><span class=\"hljs-comment\">// async 是设置同步的意思</span><br><br> <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">onFinish</span> = <span class=\"hljs-keyword\">async</span> (<span class=\"hljs-params\">values: <span class=\"hljs-built_in\">any</span></span>) =&gt; &#123;<br>    <span class=\"hljs-keyword\">if</span> (!params.<span class=\"hljs-property\">id</span>)&#123;<br>      message.<span class=\"hljs-title function_\">error</span>(<span class=\"hljs-string\">&#x27;接口不存在&#x27;</span>);<br>      <span class=\"hljs-keyword\">return</span> ;<br>    &#125;<br>    <span class=\"hljs-keyword\">try</span> &#123;<br><span class=\"hljs-comment\">// 等待</span><br><br>      <span class=\"hljs-keyword\">const</span> res = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title function_\">invokeInterfaceInfoUsingPOST</span>(&#123;<br>        <span class=\"hljs-attr\">id</span>: params.<span class=\"hljs-property\">id</span>,<br>        ...values<br>      &#125;)<br><span class=\"hljs-comment\">// 将res.data赋给setInvokeRes</span><br><br>      <span class=\"hljs-title function_\">setInvokeRes</span>(res.<span class=\"hljs-property\">data</span>);<br>      message.<span class=\"hljs-title function_\">success</span>(<span class=\"hljs-string\">&#x27;请求成功&#x27;</span>);<br>      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;<br>    &#125; <span class=\"hljs-keyword\">catch</span> (<span class=\"hljs-attr\">error</span>: <span class=\"hljs-built_in\">any</span>) &#123;<br>      message.<span class=\"hljs-title function_\">error</span>(<span class=\"hljs-string\">&#x27;请求失败，&#x27;</span> + error.<span class=\"hljs-property\">message</span>);<br>    &#125;<br>  &#125;;<br></code></pre></td></tr></table></figure>\n\n<p>然后在表单处新增一个卡片，用于接收invokeRes进行数据回显。</p>\n<p>已完成，测试通过！</p>\n<p>并且完善了一个缓冲显示的loading</p>\n<p>TODO:</p>\n<blockquote>\n<blockquote>\n<ol>\n<li>判断接口是否可以调用时，由固定方法名改为可以根据测试地址进行调用</li>\n<li>用户测试接口判断接口是否可以调用时，由固定方法名改为可以根据测试地址进行调用</li>\n<li>此时任何人调用模拟接口都是可以的，因为我们的SDK是写死在配置文件中的，所以后续再进行完善，从数据库中进行校验！</li>\n</ol>\n</blockquote>\n</blockquote>\n<p>over！</p>\n<p>下面我们的网关用Spring Cloud GateWay实现</p>\n<h2 id=\"Day04\"><a href=\"#Day04\" class=\"headerlink\" title=\"Day04\"></a>Day04</h2><ol>\n<li><p>开发接口调用次数统计  20min</p>\n</li>\n<li><p>优化系统的架构—学习架构设计、接触应用场景==&gt;面对一个需求就会自然而然地提高开发效率。 60min</p>\n<p>（怎么把一个项目的架构设计做的更加合理，涉及到API网关的知识）</p>\n<ul>\n<li>网关是什么？</li>\n<li>网关的作用？</li>\n<li>网关的应用场景以及实现？</li>\n<li>结合业务去应用网关</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"接口调用次数统计\"><a href=\"#接口调用次数统计\" class=\"headerlink\" title=\"接口调用次数统计\"></a>接口调用次数统计</h3><p>需求：</p>\n<pre><code class=\"hljs\">1. 用户每次调用接口成功，次数加1（或者设定一定的调用次数，每次减1）\n1. 给用户分配或者用户自助申请接口调用次数\n</code></pre>\n<blockquote>\n<p>业务流程：</p>\n<ol>\n<li>用户调用接口（之前已完成）</li>\n<li>修改数据库，调用次数（加1或者减1）</li>\n</ol>\n</blockquote>\n<p>设计库表：</p>\n<blockquote>\n<p>哪个用户？哪个接口？</p>\n<p>用户 =&gt; 接口（多对多）</p>\n</blockquote>\n<p>用户接口关系表：</p>\n<figure class=\"highlight pgsql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs pgsql\"><span class=\"hljs-comment\">-- 用户调用接口关系表</span><br><span class=\"hljs-keyword\">create</span> <span class=\"hljs-keyword\">table</span> <span class=\"hljs-keyword\">if</span> <span class=\"hljs-keyword\">not</span> <span class=\"hljs-keyword\">exists</span> smartapi.`user_interface_info`<br>(<br>    `id` <span class=\"hljs-type\">bigint</span> <span class=\"hljs-keyword\">not</span> <span class=\"hljs-keyword\">null</span> auto_increment <span class=\"hljs-keyword\">comment</span> <span class=\"hljs-string\">&#x27;主键&#x27;</span> <span class=\"hljs-keyword\">primary key</span>,<br>    `userId` <span class=\"hljs-type\">bigint</span> <span class=\"hljs-keyword\">not</span> <span class=\"hljs-keyword\">null</span> <span class=\"hljs-keyword\">comment</span> <span class=\"hljs-string\">&#x27;调用用户 id&#x27;</span>,<br>    `interfaceInfoId` <span class=\"hljs-type\">bigint</span> <span class=\"hljs-keyword\">not</span> <span class=\"hljs-keyword\">null</span> <span class=\"hljs-keyword\">comment</span> <span class=\"hljs-string\">&#x27;接口 id&#x27;</span>,<br>    `totalNum` <span class=\"hljs-type\">int</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-number\">0</span> <span class=\"hljs-keyword\">not</span> <span class=\"hljs-keyword\">null</span> <span class=\"hljs-keyword\">comment</span> <span class=\"hljs-string\">&#x27;总调用次数&#x27;</span>,<br>    `leftNum` <span class=\"hljs-type\">int</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-number\">0</span> <span class=\"hljs-keyword\">not</span> <span class=\"hljs-keyword\">null</span> <span class=\"hljs-keyword\">comment</span> <span class=\"hljs-string\">&#x27;剩余调用次数&#x27;</span>,<br>    `status` <span class=\"hljs-type\">int</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-number\">0</span> <span class=\"hljs-keyword\">not</span> <span class=\"hljs-keyword\">null</span> <span class=\"hljs-keyword\">comment</span> <span class=\"hljs-string\">&#x27;0-正常，1-禁用&#x27;</span>,<br>    `createTime` datetime <span class=\"hljs-keyword\">default</span> <span class=\"hljs-built_in\">CURRENT_TIMESTAMP</span> <span class=\"hljs-keyword\">not</span> <span class=\"hljs-keyword\">null</span> <span class=\"hljs-keyword\">comment</span> <span class=\"hljs-string\">&#x27;创建时间&#x27;</span>,<br>    `updateTime` datetime <span class=\"hljs-keyword\">default</span> <span class=\"hljs-built_in\">CURRENT_TIMESTAMP</span> <span class=\"hljs-keyword\">not</span> <span class=\"hljs-keyword\">null</span> <span class=\"hljs-keyword\">on</span> <span class=\"hljs-keyword\">update</span> <span class=\"hljs-built_in\">CURRENT_TIMESTAMP</span> <span class=\"hljs-keyword\">comment</span> <span class=\"hljs-string\">&#x27;更新时间&#x27;</span>,<br>    `isDelete` tinyint <span class=\"hljs-keyword\">default</span> <span class=\"hljs-number\">0</span> <span class=\"hljs-keyword\">not</span> <span class=\"hljs-keyword\">null</span> <span class=\"hljs-keyword\">comment</span> <span class=\"hljs-string\">&#x27;是否删除(0-未删, 1-已删)&#x27;</span><br>) <span class=\"hljs-keyword\">comment</span> <span class=\"hljs-string\">&#x27;用户调用接口关系&#x27;</span>;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"步骤：\"><a href=\"#步骤：\" class=\"headerlink\" title=\"步骤：\"></a>步骤：</h3><ol>\n<li><p>开发基本的增删改查（给管理员使用）</p>\n<blockquote>\n<p>直接使用Mybatis-X生成相关的实体类（注意在删除字段上米娜加上逻辑删除@TableLogic）、mapper、service实现类没然后移动到项目对应的包中。</p>\n<p>复制写好的Controller，改那些增删改查！ 完成√</p>\n</blockquote>\n</li>\n<li><p>开发用户调用接口次数加1（或者减1）</p>\n<p>问：如果每个接口的方法，都写调用次数 + 1，是不是比较麻烦，如果在本项目中，将这个调用次数+ 1，封装成一个方法，也是可以的，但是<code>代码侵入性很强！</code></p>\n<p>致命问题是：接口开发者需要自己进行调用！</p>\n<p>解决方法：</p>\n<ol>\n<li>Spring中的AOP（推荐，是Spring的一个核心特性）</li>\n<li>Servelet中的拦截器、过滤器（Fillter）</li>\n<li>通用的方法（缺点：代码侵入性强，需要自己调用）</li>\n<li>网关</li>\n</ol>\n</li>\n</ol>\n<p>简单说一下AOP切面的基本过程：</p>\n<blockquote>\n<p>先说一下AOP切面的作用：</p>\n<p>就相当于在接口或者方法调用前或者调用之后帮你做一些事情，其底层的原理就是动态代理。</p>\n<p>使用AOP切面的</p>\n<p>优点：</p>\n<p>独立于接口，在每个接口调用前后加 1</p>\n<p>缺点：</p>\n<p>只存在于单个项目中，如果每个团队都要写一个自己的切面</p>\n<p>// TODO：下去看一下AOP的流程，熟悉一下</p>\n</blockquote>\n<p>我们在这个项目中使用网关来实现接口调用次数。</p>\n<p>网关就当与在所有接口的入口前加了一层检票口，如图所示：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/wl2o2o/blogCdn/img/202307160152994.png\" alt=\"image-20230716015231451\"></p>\n<p>因为网关实现的有调用次数的统计，所以开发者可以通关网关来查看，而用户调用接口时直接输入请求参数、请求地址即可。</p>\n<h3 id=\"网关：\"><a href=\"#网关：\" class=\"headerlink\" title=\"网关：\"></a>网关：</h3><p>这里为什么写这么多理论呢？写代码不一定是最重要的，重要的是思想！逻辑思想明白之后，无非就是看文档、百度实现。</p>\n<blockquote>\n<p>什么是网关呢？就相当于车票检票口，统一去检票。</p>\n<p>优点？统一去进行一些操作、处理一些问题。</p>\n<p>作用？</p>\n<ol>\n<li><p>路由</p>\n</li>\n<li><p>负载均衡</p>\n</li>\n<li><p>统一鉴权</p>\n</li>\n<li><p>统一处理跨域</p>\n</li>\n<li><p>统一业务处理（缓存）</p>\n</li>\n<li><p>访问控制</p>\n</li>\n<li><p>发布控制（灰度发布，也就是慢慢控制接口的流量，不断开放给更多用户，然后达到升级接口的目的）</p>\n</li>\n<li><p>流量染色（给流量添加一些标识，比如新的请求头信息）</p>\n</li>\n<li><p>统一接口保护 </p>\n<ol>\n<li><p>限制请求</p>\n</li>\n<li><p>信息脱敏（网关可以操作你的请求口，进而抹去敏感信息）</p>\n</li>\n<li><p>降级（熔断，保险起见，接口下线后，可以返回一些提示信息）</p>\n</li>\n<li><p>限流</p>\n<p>（// TODO：学习令牌桶算法，学习露桶算法，学习一下）</p>\n</li>\n<li><p>RedislimitHandler</p>\n</li>\n<li><p>超时时间</p>\n</li>\n<li><p>重试（业务保护）</p>\n</li>\n</ol>\n</li>\n<li><p>统一日志</p>\n</li>\n<li><p>统一文档（将下游项目的文档统一聚合，展示到一个页面）</p>\n</li>\n</ol>\n</blockquote>\n<h3 id=\"路由\"><a href=\"#路由\" class=\"headerlink\" title=\"路由\"></a>路由</h3><p>起到转发的作用，比如有接口A和接口B,网关会记录这些信息，根据用户访问的地址和参数，转发请求到对应的接口（服务器/集群）</p>\n<p>用户a调用接口A</p>\n<p>/a=&gt;接口A /b=&gt;接口B</p>\n<p><a href=\"https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#gateway-request-predicates-factories\">https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#gateway-request-predicates-factories</a></p>\n<h3 id=\"负载均衡\"><a href=\"#负载均衡\" class=\"headerlink\" title=\"负载均衡\"></a>负载均衡</h3><p>在路由的基础上可以转发到某一个服务器</p>\n<p>/c =&gt; 服务A/ 集群A（随机转发到其中的某一个机器）</p>\n<p>uri从固定地址改成b:xx</p>\n<h3 id=\"统一鉴权\"><a href=\"#统一鉴权\" class=\"headerlink\" title=\"统一鉴权\"></a>统一鉴权</h3><p>判断用户是否有权限进行操作，无论访问什么接口，我都统一去判断权限，不用重复写</p>\n<h3 id=\"统一处理跨域\"><a href=\"#统一处理跨域\" class=\"headerlink\" title=\"统一处理跨域\"></a>统一处理跨域</h3><p>网关统一处理跨域，不用在每个项目单独处理</p>\n<p><a href=\"https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#cors-configuration\">https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#cors-configuration</a></p>\n<h3 id=\"统一业务处理\"><a href=\"#统一业务处理\" class=\"headerlink\" title=\"统一业务处理\"></a>统一业务处理</h3><p>把每个项目中都要做的通用逻辑放到上层（网关），统一处理，比如本项目的次数统计</p>\n<h3 id=\"访问控制\"><a href=\"#访问控制\" class=\"headerlink\" title=\"访问控制\"></a>访问控制</h3><p>黑白名单，比如限制ddos ip</p>\n<h3 id=\"发布控制\"><a href=\"#发布控制\" class=\"headerlink\" title=\"发布控制\"></a>发布控制</h3><p>灰度发布，比如上线新接口，先给新接口分配 20%流量，老接口80% ,再慢慢调整比例</p>\n<p><a href=\"https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#the-weight-route-predicate-\">https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#the-weight-route-predicate-</a> factory</p>\n<h3 id=\"流量染色\"><a href=\"#流量染色\" class=\"headerlink\" title=\"流量染色\"></a>流量染色</h3><p>区分用户来源</p>\n<p>给请求（流量）添加一些标识，一般是设置请求头中，添加新的请求头 <a href=\"https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#the-addrequestheader-gatewayfilter-factory\">https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#the-addrequestheader-gatewayfilter-factory</a></p>\n<p>全局染色：<a href=\"https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#default-filters\">https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#default-filters</a></p>\n<h3 id=\"接口保护\"><a href=\"#接口保护\" class=\"headerlink\" title=\"接口保护\"></a>接口保护</h3><p>1 限制请求 <a href=\"https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#requestheadersiz-gatewayfilter-factory\">https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#requestheadersiz-gatewayfilter-factory</a> </p>\n<p>2 信息脱敏 <a href=\"https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#the-removerequestheader-gatewayfilter-factory\">https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#the-removerequestheader-gatewayfilter-factory</a> </p>\n<p>3 降级（熔断） 进行兜底 <a href=\"https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#fallback-headers\">https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#fallback-headers</a> </p>\n<p>4 限流 <a href=\"https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#the-requestratelimiter-gatewayfilter-factory\">https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#the-requestratelimiter-gatewayfilter-factory</a> </p>\n<p>5 超时时间   超时就中断 <a href=\"https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#http-timeouts-configuration\">https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#http-timeouts-configuration</a> </p>\n<p>6 重试（业务保护）： <a href=\"https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#the-retry-gatewayfilter-factory\">https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#the-retry-gatewayfilter-factory</a> </p>\n<h3 id=\"统一日志\"><a href=\"#统一日志\" class=\"headerlink\" title=\"统一日志\"></a>统一日志</h3><p>统一的请求，响应信息记录</p>\n<h3 id=\"统一文档\"><a href=\"#统一文档\" class=\"headerlink\" title=\"统一文档\"></a>统一文档</h3><p>将下游项目的文档进行聚合，在一个页面统一查看</p>\n<p>建议用：<a href=\"https://doc.xiaominfo.com/docs/middleware-sources/,aggregation-introduction\">https://doc.xiaominfo.com/docs/middleware-sources/,aggregation-introduction</a></p>\n<h3 id=\"网关的分类\"><a href=\"#网关的分类\" class=\"headerlink\" title=\"网关的分类\"></a>网关的分类</h3><ol>\n<li><p>全局网关（接入层网关）：作用是负载均衡、请求日志，不和业务逻辑绑定</p>\n</li>\n<li><p>业务网关（微服务网关：会有一些业务逻辑）：作用是根据不同的请求转发到不同的项目接口</p>\n<p>参考文章：<a href=\"https://blog.csdn.net/qq21040559/article/,details/,122961395\">https://blog.csdn.net/qq21040559/article/,details/,122961395</a></p>\n</li>\n</ol>\n<h3 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h3><ol>\n<li><p>Nginx（推荐的全局型网关）</p>\n</li>\n<li><p>Kong网关（适合API网关）–收费！！</p>\n</li>\n<li><p><code>Spring Cloud Gateway</code>（取代了Zuul，因为架构设计并不太好，并发量也有限）</p>\n<blockquote>\n<p>优点：用到了NIO、多路复用、底层Netty、React模型；</p>\n<p>最大的亮点：可以用Java代码写逻辑，其他网关都需要学习一些其他语言（Nginx需要学到一些Lua脚本）</p>\n</blockquote>\n</li>\n</ol>\n<p>网关技术选型：<a href=\"https://zhuanlan.zhihu.com/p/500587132\">https://zhuanlan.zhihu.com/p/500587132</a></p>\n<h3 id=\"Spring-Cloud-Gateway用法\"><a href=\"#Spring-Cloud-Gateway用法\" class=\"headerlink\" title=\"Spring Cloud Gateway用法\"></a>Spring Cloud Gateway用法</h3><p>官网是最好的老是去看官网</p>\n<p>去看官网：<a href=\"https://spring.io/projects/spring-cloud-gateway\">https://spring.io/projects/spring-cloud-gateway</a></p>\n<p>官方文档：<a href=\"https://docs.spring.io/spring-cloud-gateway/docs/current/reference//html/\">https://docs.spring.io/spring-cloud-gateway/docs/current/reference//html/</a></p>\n<h3 id=\"创建一个Gateway项目\"><a href=\"#创建一个Gateway项目\" class=\"headerlink\" title=\"创建一个Gateway项目\"></a>创建一个Gateway项目</h3><p>小作业：完成官网的小demo（编程式demo）</p>\n<h2 id=\"Day05-把API网关应用到项目中\"><a href=\"#Day05-把API网关应用到项目中\" class=\"headerlink\" title=\"Day05 把API网关应用到项目中\"></a>Day05 把API网关应用到项目中</h2><p>任务：</p>\n<ol>\n<li>完成统一的用户鉴权、统一的接口调用次数统计（API网关应用）</li>\n<li>完善功能</li>\n</ol>\n<h3 id=\"将用到的特性\"><a href=\"#将用到的特性\" class=\"headerlink\" title=\"将用到的特性\"></a>将用到的特性</h3><ol>\n<li><p>路由（转发请求到模拟接口项目）</p>\n</li>\n<li><p><del>负载均衡（需要用到注册中心）</del></p>\n</li>\n<li><p>统一鉴权(accessKey，secretKey)</p>\n</li>\n<li><p>统一处理跨域</p>\n</li>\n<li><p>统一业务处理（每次请求接口后，接口调用次数+1）</p>\n</li>\n<li><p>访问控制（黑白名单）</p>\n</li>\n<li><p><del>发布控制</del></p>\n</li>\n<li><p>流量染色(记录请求是否为网关来的)</p>\n</li>\n<li><p><del>统一接口保护</del> </p>\n<ol>\n<li>限制请求</li>\n<li>信息脱敏</li>\n<li>降级（熔断）</li>\n<li>限流 学习令牌桶算法，学习露桶算法，学习一下RedislimitHandler</li>\n<li>超时时间</li>\n<li>重试（业务保护）</li>\n</ol>\n</li>\n<li><p>统一日志(记录每次的请求和响应)</p>\n</li>\n<li><p><del>统一文档</del></p>\n</li>\n</ol>\n<h3 id=\"业务逻辑\"><a href=\"#业务逻辑\" class=\"headerlink\" title=\"业务逻辑\"></a>业务逻辑</h3><blockquote>\n<p>为什么会用到API网关？</p>\n<p>结合架构图来说，简单来说也就是加一个检票口，同时也可以添加流量染色、链路追踪的功能、灰度发布等等。。。</p>\n</blockquote>\n<ol>\n<li>用户发送请求到API网关（请求转发）</li>\n<li><em>请求日志</em></li>\n<li><em>黑白名单</em></li>\n<li>用户鉴权（如何？判断ak、sk）</li>\n<li>请求的模拟接口是否存在？</li>\n<li>请求转发，调用模拟接口</li>\n<li>响应日志</li>\n<li>调用成功，接口调用次数 + 1</li>\n<li>调用失败，返回规范错误码</li>\n</ol>\n<h3 id=\"实现-1\"><a href=\"#实现-1\" class=\"headerlink\" title=\"实现\"></a>实现</h3><ol>\n<li><p><strong>请求转发</strong></p>\n<p><a href=\"https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#the-path-route-predicate-factory\">使用前缀匹配断言</a></p>\n<p>所有路径为：<code>/api/**</code> 的请求转发，转发到<a href=\"http://localhost:8123/api/\">http://localhost:8123/api/</a>**</p>\n<p>比如：</p>\n<p>请求于<a href=\"http://localhost:8090/api/name/get?/name=wlei224\">http://localhost:8090/api/name/get?/name=wlei224</a></p>\n<p>转发到<a href=\"http://localhost:8123/api/name/get?/name=wlei224\">http://localhost:8123/api/name/get?/name=wlei224</a></p>\n</li>\n</ol>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs yaml\"><span class=\"hljs-attr\">spring:</span><br>  <span class=\"hljs-attr\">cloud:</span><br>    <span class=\"hljs-attr\">gateway:</span><br>      <span class=\"hljs-attr\">routes:</span><br>      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-attr\">id:</span> <span class=\"hljs-string\">path_route</span><br>        <span class=\"hljs-attr\">uri:</span> <span class=\"hljs-string\">https://example.org</span><br>        <span class=\"hljs-attr\">predicates:</span><br>        <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">Path=/red/&#123;segment&#125;,/blue/&#123;segment&#125;</span><br></code></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>其他业务逻辑</li>\n</ol>\n<blockquote>\n<p>​    todo：Spring注解      @component</p>\n</blockquote>\n<p>​    使用Spring Cloud Gateway中的GlobalFilter实现请求拦截处理（类似于AOP）</p>\n<p>​    <img src=\"https://cdn.jsdelivr.net/gh/wl2o2o/blogCdn/img/202307251948339.png\" alt=\"image-20230725194819206\"></p>\n<p>​    <a href=\"https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#gateway-combined-global-filter-and-gatewayfilter-ordering\">GlobalFilter</a>直接复制代码到网关项目的全局异常类中。</p>\n<p>​    验证通过√</p>\n<ol start=\"2\">\n<li>正式开始写业务逻辑</li>\n</ol>\n<blockquote>\n<ol>\n<li><p>用户发送请求到API网关（请求转发）√</p>\n<p>代码能运行到这个controller业务逻辑层，就说明用户已经发送了请求</p>\n</li>\n<li><p><em>请求日志</em></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/wl2o2o/blogCdn/img/202307281159504.png\" alt=\"image-20230728115938432\"></p>\n<p>我们发现请求参数中含有一个交换机，于是可以试着从这里找到request请求，拿到请求头中的信息；</p>\n<p>添加<code>@Slf4j</code>注解，用log.info在控制台输出请求头日志；</p>\n</li>\n<li><p><em>黑白名单</em></p>\n<p>在权限管理业务中一般设置的是白名单，这样只有允许的才可以进行访问，更加安全！</p>\n<p>在IDEA中直接敲<code>prsf</code>写一个白名单常量。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Java\"><span class=\"hljs-comment\">// 2. 访问控制 -- 设置黑白名单（可以用设置响应状态码来实现）</span><br><span class=\"hljs-type\">ServerHttpResponse</span> <span class=\"hljs-variable\">response</span> <span class=\"hljs-operator\">=</span> exchange.getResponse();<br><span class=\"hljs-keyword\">if</span>(!IP_WHITE_LIST.contains(sourceAdress)) &#123;<br>    <span class=\"hljs-comment\">// handleNoAuth(response);</span><br>    response.setStatusCode(HttpStatus.FORBIDDEN);<br>\t<span class=\"hljs-keyword\">return</span> response.setComplete();<br>&#125;<br></code></pre></td></tr></table></figure></li>\n<li><p>用户鉴权（如何？判断ak、sk）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">//  用户鉴权（如何？判断ak、sk）</span><br><span class=\"hljs-type\">HttpHeaders</span> <span class=\"hljs-variable\">headers</span> <span class=\"hljs-operator\">=</span> request.getHeaders();<br><span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">accessKey</span> <span class=\"hljs-operator\">=</span> headers.getFirst(<span class=\"hljs-string\">&quot;accessKey&quot;</span>);<br><span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">nonce</span> <span class=\"hljs-operator\">=</span> headers.getFirst(<span class=\"hljs-string\">&quot;nonce&quot;</span>);<br><span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">timeStamp</span> <span class=\"hljs-operator\">=</span> headers.getFirst(<span class=\"hljs-string\">&quot;timeStamp&quot;</span>);<br><span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">sign</span> <span class=\"hljs-operator\">=</span> headers.getFirst(<span class=\"hljs-string\">&quot;sign&quot;</span>);<br><span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">body</span> <span class=\"hljs-operator\">=</span> headers.getFirst(<span class=\"hljs-string\">&quot;body&quot;</span>);<br><span class=\"hljs-comment\">// TODO 要去数据库中查询</span><br><span class=\"hljs-comment\">// 为了方便进行校验，直接进行判断数据，正规来说应该从数据库中进行校验数据</span><br><span class=\"hljs-keyword\">if</span> (!<span class=\"hljs-string\">&quot;wl&quot;</span>.equals(accessKey))&#123;<br>    <span class=\"hljs-comment\">// throw new RuntimeException(&quot;无权限！&quot;);</span><br>    <span class=\"hljs-comment\">// 封装了一个方法，专门用于处理异常请求</span><br>    <span class=\"hljs-keyword\">return</span> handleNoAuth(response);<br>&#125;<br><span class=\"hljs-keyword\">if</span> (Long.parseLong(nonce) &gt; <span class=\"hljs-number\">10000L</span>)&#123;<br>\t<span class=\"hljs-keyword\">return</span> handleNoAuth(response);<br>&#125;<br>                                                                                                               <br><span class=\"hljs-comment\">//  时间戳校验自己实现，时间和当前时间不能超过5min</span><br><span class=\"hljs-type\">Long</span> <span class=\"hljs-variable\">currentTime</span> <span class=\"hljs-operator\">=</span> System.currentTimeMillis() / <span class=\"hljs-number\">1000</span>;<br><span class=\"hljs-type\">Long</span> <span class=\"hljs-variable\">FIVE_MINUTES</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">60</span> * <span class=\"hljs-number\">5L</span>;<br><span class=\"hljs-keyword\">if</span> ((currentTime-Long.parseLong(timeStamp)) &gt;= FIVE_MINUTES) &#123;<br>\t<span class=\"hljs-keyword\">return</span> handleNoAuth(response);<br>&#125;<br>                                                                                                               <br><span class=\"hljs-comment\">// TODO 要去数据库中查询</span><br><span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">serverSign</span> <span class=\"hljs-operator\">=</span> SignUtils.getSign(body, <span class=\"hljs-string\">&quot;abcdefgh&quot;</span>);<br><span class=\"hljs-keyword\">if</span> (!serverSign.equals(sign)) &#123;<br>\t<span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">RuntimeException</span>(<span class=\"hljs-string\">&quot;无权限！&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li>\n<li><p>请求的模拟接口是否存在？</p>\n<p>// TODO 从数据库中进行查询接口是否存在，以及请求方法是否匹配（严格的话可以再校验一下请求参数，但是业务层面的请求参数不建议放到全局请求网关里面）<br>// 因为数据库的访问方法已经再backend中已经写过，操作较为复杂的话不建议重复写，所以我们可以采用远程调用的方式（也就是可以说是微服务，这个项目完全可以写成微服务：<code>OpenFeigh</code>，目前项目的定位还是<code>分布式项目</code>结合微服务的远程调用，避免重复写业务逻辑）</p>\n</li>\n<li><p>请求转发，调用模拟接口</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">Mono&lt;Void&gt; filter = chain.filter(exchange);<br></code></pre></td></tr></table></figure></li>\n<li><p>响应日志</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">log.info(<span class=\"hljs-string\">&quot;响应：&quot;</span> + response.getStatusCode());<br></code></pre></td></tr></table></figure></li>\n<li><p>调用成功，接口调用次数 + 1</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">// TODO invokeCount</span><br></code></pre></td></tr></table></figure></li>\n<li><p>调用失败，返回规范错误码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Java\"><span class=\"hljs-comment\">// 用户鉴权异常</span><br>    <span class=\"hljs-keyword\">public</span> Mono&lt;Void&gt; <span class=\"hljs-title function_\">handleNoAuth</span><span class=\"hljs-params\">(ServerHttpResponse response)</span> &#123;<br>        response.setStatusCode(HttpStatus.FORBIDDEN);<br>        <span class=\"hljs-keyword\">return</span> response.setComplete();<br>    &#125;<br>    <span class=\"hljs-comment\">// 自定义错误异常</span><br>    <span class=\"hljs-keyword\">public</span> Mono&lt;Void&gt; <span class=\"hljs-title function_\">handleInvokeError</span><span class=\"hljs-params\">(ServerHttpResponse response)</span> &#123;<br>        response.setStatusCode(HttpStatus.INTERNAL_SERVER_ERROR);<br>        <span class=\"hljs-keyword\">return</span> response.setComplete();<br>    &#125;<br></code></pre></td></tr></table></figure></li>\n</ol>\n</blockquote>\n<ul>\n<li>为了方便进行业务逻辑的编写，我们可以向上面一样，将提前编写好的业务流程粘贴到类文件中。</li>\n</ul>\n<h3 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h3><p>通过测试我们发现，通过<a href=\"http://127.0.0.1:8090/api/name/get?name=wl%E8%BF%9B%E8%A1%8C%E8%AE%BF%E9%97%AE%E6%97%B6%EF%BC%8C%E8%BF%98%E6%98%AF%E4%BC%9A%E9%81%AD%E5%88%B0%E6%8B%92%E7%BB%9D%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E5%91%A2%EF%BC%9F%E6%AD%A4%E6%97%B6%E4%B8%8D%E6%98%AF%E8%AF%B7%E6%B1%82%E5%A4%B4%E4%B8%A2%E5%A4%B1%EF%BC%8C%E8%80%8C%E6%98%AF%E6%88%91%E4%BB%AC%E6%A0%B9%E6%9C%AC%E5%B0%B1%E6%B2%A1%E5%86%99%E8%AF%B7%E6%B1%82%E5%A4%B4%EF%BC%8C%E8%B7%91%E9%80%9A%E8%BF%99%E4%B8%AA%E9%80%BB%E8%BE%91%E7%9A%84%E8%AF%9D%EF%BC%8C%E5%8F%AF%E4%BB%A5%E4%BB%8E%E5%89%8D%E7%AB%AF%E8%BF%9B%E8%A1%8C%E8%B0%83%E7%94%A8%E6%B5%8B%E8%AF%95%E3%80%82\">http://127.0.0.1:8090/api/name/get?name=wl进行访问时，还是会遭到拒绝，为什么呢？此时不是请求头丢失，而是我们根本就没写请求头，跑通这个逻辑的话，可以从前端进行调用测试。</a></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/wl2o2o/blogCdn/img/202308030251719.png\" alt=\"image-20230803025109861\"></p>\n<h3 id=\"🧑‍💻业务逻辑预期结果：\"><a href=\"#🧑‍💻业务逻辑预期结果：\" class=\"headerlink\" title=\"🧑‍💻业务逻辑预期结果：\"></a>🧑‍💻业务逻辑预期结果：</h3><p>等模拟接口调用完成，才记录响应日志、统计调用次数。</p>\n<h3 id=\"存在问题：\"><a href=\"#存在问题：\" class=\"headerlink\" title=\"存在问题：\"></a>存在问题：</h3><blockquote>\n<p>虽然上述代码可以跑通，但是还存在一个问题，我们通过debug模式可以看到，代码在执行到请求转发的<code>Mono&lt;Void&gt; filter = chain.filter(exchange);</code>方法后，并没有进入到方法中，反而是继续执行下面的代码，直到<code>chain.filter</code>方法之后才进入模拟接口方法中。</p>\n<p><code>原因：</code></p>\n<p>chain.filter是个异步操作，可以理解为前端的promise</p>\n<p><code>解决方案：</code></p>\n<p>利用Spring Cloud Gateway提供的自定义响应装饰器中的response装饰者，以次增强原有response的处理能力</p>\n<p>引申：什么叫装饰者设计模式？</p>\n<p>​    作用就是：在原本类的基础上对原有类的能力的增强，也就可以理解为给response买了一件装备，拥有了更多的能力。解释成代码语言意思就是，增写response部分代码，实现需要的功能。</p>\n<p><code>参考博客：</code> </p>\n<p><a href=\"https://blog.csdn.net/qq_19636353/article/details/126759522\">https://blog.csdn.net/qq_19636353/article/details/126759522</a>  (以这个为主) </p>\n<p><code>其他参考：</code> </p>\n<p><a href=\"https://blog.csdn.net/m0_67595943/article/details/124667975\">https://blog.csdn.net/m0_67595943/article/details/124667975</a> </p>\n<p><a href=\"https://blog.csdn.net/weixin_43933728/article/details/121359727?spm=1001.2014.3001.5501\">https://blog.csdn.net/weixin_43933728/article/details/121359727?spm=1001.2014.3001.5501</a> </p>\n<p><a href=\"https://blog.csdn.net/zx156955/article/details/121670681\">https://blog.csdn.net/zx156955/article/details/121670681</a> <a href=\"https://blog.csdn.net/qq_39529562/article/details/108911983\">https://blog.csdn.net/qq_39529562/article/details/108911983</a></p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> Mono&lt;Void&gt; <span class=\"hljs-title function_\">handleResponse</span><span class=\"hljs-params\">(ServerWebExchange exchange, GatewayFilterChain chain)</span>&#123;  <br><br>    <span class=\"hljs-keyword\">try</span> &#123;  <br>        <span class=\"hljs-comment\">//从交换寄拿响应对象  </span><br>        <span class=\"hljs-type\">ServerHttpResponse</span> <span class=\"hljs-variable\">originalResponse</span> <span class=\"hljs-operator\">=</span> exchange.getResponse();  <br>        <span class=\"hljs-comment\">//缓冲区工厂，拿到缓存数据  </span><br>        <span class=\"hljs-type\">DataBufferFactory</span> <span class=\"hljs-variable\">bufferFactory</span> <span class=\"hljs-operator\">=</span> originalResponse.bufferFactory();  <br>        <span class=\"hljs-comment\">//拿到响应码  </span><br>        <span class=\"hljs-type\">HttpStatus</span> <span class=\"hljs-variable\">statusCode</span> <span class=\"hljs-operator\">=</span> originalResponse.getStatusCode();  <br>        <span class=\"hljs-keyword\">if</span>(statusCode == HttpStatus.OK)&#123;  <br>            <span class=\"hljs-comment\">//装饰，增强能力  </span><br>            <span class=\"hljs-type\">ServerHttpResponseDecorator</span> <span class=\"hljs-variable\">decoratedResponse</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ServerHttpResponseDecorator</span>(originalResponse) &#123;  <br>            <span class=\"hljs-comment\">//等调用完转发的接口后才会执行</span><br>                <span class=\"hljs-meta\">@Override</span>  <br>                <span class=\"hljs-keyword\">public</span> Mono&lt;Void&gt; <span class=\"hljs-title function_\">writeWith</span><span class=\"hljs-params\">(Publisher&lt;? extends DataBuffer&gt; body)</span> &#123;  <br>                    log.info(<span class=\"hljs-string\">&quot;body instanceof Flux: &#123;&#125;&quot;</span>, (body <span class=\"hljs-keyword\">instanceof</span> Flux));  <br>                    <span class=\"hljs-comment\">//对象是响应式的  </span><br>                    <span class=\"hljs-keyword\">if</span> (body <span class=\"hljs-keyword\">instanceof</span> Flux) &#123;  <br>                        <span class=\"hljs-comment\">//我们拿到真正的body  </span><br>                        Flux&lt;? <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">DataBuffer</span>&gt; fluxBody = Flux.from(body); <br>                        <span class=\"hljs-comment\">//往返回值里面写数据  </span><br>                        <span class=\"hljs-comment\">//拼接字符串  </span><br>                        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">super</span>.writeWith(fluxBody.map(dataBuffer -&gt; &#123; <br>                            <span class=\"hljs-comment\">// 7. TODO 调用成功，接口调用次数 + 1 invokeCount</span><br>                            <span class=\"hljs-type\">byte</span>[] content = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">byte</span>[dataBuffer.readableByteCount()];  <br>                            dataBuffer.read(content);  <br>                            DataBufferUtils.release(dataBuffer);<span class=\"hljs-comment\">//释放掉内存  </span><br>                            <span class=\"hljs-comment\">// 构建日志  </span><br>                            <span class=\"hljs-type\">StringBuilder</span> <span class=\"hljs-variable\">sb2</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">StringBuilder</span>(<span class=\"hljs-number\">200</span>);  <br>                            sb2.append(<span class=\"hljs-string\">&quot;&lt;--- &#123;&#125; &#123;&#125; \\n&quot;</span>);  <br>                            List&lt;Object&gt; rspArgs = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ArrayList</span>&lt;&gt;();  <br>                            rspArgs.add(originalResponse.getStatusCode());  <br>                            <span class=\"hljs-comment\">//rspArgs.add(requestUrl);  </span><br>                            <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">data</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">String</span>(content, StandardCharsets.UTF_8);<span class=\"hljs-comment\">//data </span><br>                            sb2.append(data);  <br>                            log.info(sb2.toString(), rspArgs.toArray());<span class=\"hljs-comment\">//log.info(&quot;&lt;-- &#123;&#125; &#123;&#125;\\n&quot;, originalResponse.getStatusCode(), data);  </span><br>                           <span class=\"hljs-keyword\">return</span> bufferFactory.wrap(content);  <br>                        &#125;));  <br>                    &#125; <span class=\"hljs-keyword\">else</span> &#123;  <br>                        <span class=\"hljs-comment\">// 8. 调用失败，fan&#x27;hui一个规范的</span><br>                        log.error(<span class=\"hljs-string\">&quot;&lt;--- &#123;&#125; 响应code异常&quot;</span>, getStatusCode());  <br>                    &#125;  <br>                    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">super</span>.writeWith(body);  <br>                &#125;  <br>            &#125;;  <br>            <span class=\"hljs-comment\">//设置 response 对象为装饰过的  </span><br>            <span class=\"hljs-keyword\">return</span> chain.filter(exchange.mutate().response(decoratedResponse).build());  <br>        &#125;  <br>        <span class=\"hljs-keyword\">return</span> chain.filter(exchange);<span class=\"hljs-comment\">//降级处理返回数据  </span><br>    &#125;<span class=\"hljs-keyword\">catch</span> (Exception e)&#123;<br>        log.error(<span class=\"hljs-string\">&quot;gateway log exception.\\n&quot;</span> + e);  <br>        <span class=\"hljs-keyword\">return</span> chain.filter(exchange);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"Day06-完善网关的业务逻辑\"><a href=\"#Day06-完善网关的业务逻辑\" class=\"headerlink\" title=\"Day06 完善网关的业务逻辑\"></a>Day06 完善网关的业务逻辑</h2><h3 id=\"今日计划-1\"><a href=\"#今日计划-1\" class=\"headerlink\" title=\"今日计划\"></a>今日计划</h3><ol>\n<li>补充完整网关的业务逻辑（如何操作数据库?如何服用之前写过的方法？RPC）</li>\n<li>完善系统的TODO和其他功能，并开发一个管理员的监控统计功能</li>\n</ol>\n<h3 id=\"网关业务逻辑\"><a href=\"#网关业务逻辑\" class=\"headerlink\" title=\"网关业务逻辑\"></a>网关业务逻辑</h3><p>问题：之前的项目已经写过了调用数据库的那些mybatis的业务逻辑，复制粘贴太麻烦</p>\n<p>解决：用一个可以直接调用的解决方法：RPC</p>\n<h3 id=\"如何调用其他项目的方法\"><a href=\"#如何调用其他项目的方法\" class=\"headerlink\" title=\"如何调用其他项目的方法\"></a>如何调用其他项目的方法</h3><ol>\n<li>复制粘贴代码和相关依赖</li>\n<li>HTTP请求（提供接口，供其他项目进行调用）</li>\n<li>jar包调用</li>\n<li>把公共代码达成jar包，其他项目直接引用</li>\n</ol>\n<h3 id=\"HTTP请求怎么调用\"><a href=\"#HTTP请求怎么调用\" class=\"headerlink\" title=\"HTTP请求怎么调用\"></a>HTTP请求怎么调用</h3><ol>\n<li>提供方开发一个接口（地址、请求方法、参数、返回值）</li>\n<li>调用方使用<code>HTTP Client</code>之类的代码取发送HTTP请求</li>\n</ol>\n<h3 id=\"RPC（remote-produce-call）\"><a href=\"#RPC（remote-produce-call）\" class=\"headerlink\" title=\"RPC（remote produce call）\"></a>RPC（remote produce call）</h3><p><strong>作用：像调用本地方法一样去调用远程方法</strong></p>\n<p>优点：</p>\n<pre><code class=\"hljs\">1. 对开发者更加透明，减少了调用见的沟通成本\n1. RPC向远程服务器发送请求时，未必要使用HTTP协议，比如：TCP/IP、或者自己封装的协议。（内部服务更加适用）\n</code></pre>\n<h3 id=\"Feign-amp-amp-RPC\"><a href=\"#Feign-amp-amp-RPC\" class=\"headerlink\" title=\"Feign &amp;&amp; RPC\"></a><code>Feign &amp;&amp; RPC</code></h3><blockquote>\n<p>Feign底层用的HTTP协议，虽然也可以很方便的进行调用，但是区别在于Feign只是让请求过程更加精简,HTTP请求其实可以做到和RPC一样的事情，但是还有区别：RPC向远程服务器发送请求时，未必要使用HTTP协议，比如：TCP/IP、或者自己封装的协议。</p>\n</blockquote>\n<p>HTTP协议是一个7层协议，如果想要接口的性能更高，可以使用TCP/IP协议，更加原生的协议。</p>\n<p>一般来说微服务项目内部的接口，用<code>RPC</code>的性能可能会更加高一点，协议可选项更加多一点。</p>\n<p><code>工作流程图：</code></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/wl2o2o/blogCdn/img/202307292328515.png\" alt=\"image-20230729232829504\"></p>\n<p>🆗，现在模型已经搭建好了，那么如何进行实现呢？使用Dubbo框架（如何学习？看官方文档）</p>\n<h3 id=\"Dubbo框架（RPC实现）（阿里公司的）\"><a href=\"#Dubbo框架（RPC实现）（阿里公司的）\" class=\"headerlink\" title=\"Dubbo框架（RPC实现）（阿里公司的）\"></a>Dubbo框架（RPC实现）（阿里公司的）</h3><p>其它类似的框架还有<code>GRPC</code>（Google公司的）、<code>TRPC</code>（腾讯公司的）</p>\n<p>最好的学习方式：<a href=\"https://cn.dubbo.apache.org/zh-cn/overview/mannual/java-sdk/quick-start/spring-boot/\">阅读官方文档！</a></p>\n<h3 id=\"两种使用方式\"><a href=\"#两种使用方式\" class=\"headerlink\" title=\"两种使用方式\"></a>两种使用方式</h3><ol>\n<li><p>Spring Boot代码（注解+编程式）：写Java接口，服务提供者和消费者都去引用这个接口 偏程导</p>\n</li>\n<li><p>IDL(接口调用语言)：创建一个公共的接口定义文件，服务提供者和消费者读取这个文件。</p>\n<p>优点：</p>\n<ul>\n<li><p>跨语言，所有的框架都认识</p>\n</li>\n<li><p>底层是Triple（自定义封装协议，优点见<a href=\"https://cn.dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/protocol/triple/\">官文</a>）</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/wl2o2o/blogCdn/img/202307300038465.png\" alt=\"image-20230730003800623\"></p>\n</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"示例项目学习\"><a href=\"#示例项目学习\" class=\"headerlink\" title=\"示例项目学习\"></a>示例项目学习</h3><figure class=\"highlight crmsh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs crmsh\">git <span class=\"hljs-keyword\">clone</span> <span class=\"hljs-title\">-b</span> <span class=\"hljs-keyword\">master</span> <span class=\"hljs-title\">https</span>://github.com/apache/dubbo-samples.git<br></code></pre></td></tr></table></figure>\n\n<p>zookeeper注册中心：通过内嵌的方式运行，更方便</p>\n<p>最先启动注册中心，先启动服务提供者，再启动服务消费者</p>\n<h3 id=\"整合应用\"><a href=\"#整合应用\" class=\"headerlink\" title=\"整合应用\"></a>整合应用</h3><ol>\n<li><p>服务提供者：backend</p>\n<p>a. 实际情况应该是去数据库中查是否已分配给用户</p>\n<p>b. 从数据库中查询模拟接口是否存在，以及请求方法是否匹配（还可以校验请求参数）</p>\n<p>c. 调用成功，接口调用次数+1 invokeCount</p>\n</li>\n<li><p>gateway项日作为服务调用者，调用这3个方法</p>\n</li>\n</ol>\n<blockquote>\n<p>整合步骤：</p>\n<ol>\n<li><p>依赖引入  视频事件：<code>00:52</code></p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs\">                                                                                                               <br></code></pre></td></tr></table></figure></li>\n<li><p>将官方示例代码中的privider包粘到backend中</p>\n</li>\n</ol>\n</blockquote>\n<h2 id=\"Day07-完善网关业务与上线\"><a href=\"#Day07-完善网关业务与上线\" class=\"headerlink\" title=\"Day07 完善网关业务与上线\"></a>Day07 完善网关业务与上线</h2><h3 id=\"今日计划-2\"><a href=\"#今日计划-2\" class=\"headerlink\" title=\"今日计划\"></a>今日计划</h3><ol>\n<li>完善网关的业务</li>\n<li>开发管理员的分析功能</li>\n<li>项目上线</li>\n</ol>\n<h3 id=\"整合nacos\"><a href=\"#整合nacos\" class=\"headerlink\" title=\"整合nacos\"></a>整合nacos</h3><blockquote>\n<p>遇到一个<code>nocos</code>小BUG：</p>\n<p>Dubbo整合nocos的时候，提供者与消费者的包名不一样，这时，提供者将接口的信息注册到nacos文档时，用到的是provider的包名路径，如果出现消费者的包名路径与提供者的包名不同的时候，这时消费者就会报错找不到提供者的Service服务，如图：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/wl2o2o/blogCdn/img/202307311932647.png\" alt=\"image-20230731193204173\"></p>\n</blockquote>\n<h3 id=\"重新梳理网关的业务逻辑\"><a href=\"#重新梳理网关的业务逻辑\" class=\"headerlink\" title=\"重新梳理网关的业务逻辑\"></a>重新梳理网关的业务逻辑</h3><ol>\n<li><p>实际情况应该是去数据库中查是否已分配给用户</p>\n<p>a 先根据 accessKey 判断用户是否存在，查到 secretKey<br>b 对比 secretKey 和用户传的加密后的 secretKey 是否一致</p>\n</li>\n<li><p>从数据库中查询模拟接口是否存在，以及请求方法是否匹配（还可以校验请求参数）</p>\n</li>\n<li><p>调用成功，接口调用次数+1 invokeCount</p>\n</li>\n</ol>\n<h3 id=\"公共服务\"><a href=\"#公共服务\" class=\"headerlink\" title=\"公共服务\"></a>公共服务</h3><blockquote>\n<p>目的是让方法、实体在多个项目中进行复用，避免重复编写</p>\n</blockquote>\n<ul>\n<li><p>业务分析</p>\n<ul>\n<li><ol>\n<li>数据库中是否已分配给用户密钥（accesskey、secretkey，返回用户信息，为空表示不存在）√</li>\n<li>从数据库中查询模拟接口是否存在（请求路径、请求方法、请求参数，返回接口信息，为空表示不存在）</li>\n<li>接口调用次数 + 1 <code>invokeCount</code>（ak、sk、请求接口路径）√</li>\n</ol>\n</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><p>使用步骤：</p>\n<ul>\n<li><ol>\n<li>新建干净的 maven 项目，只保留必要的公共依赖</li>\n</ol>\n</li>\n<li><ol start=\"2\">\n<li>抽取 service 和实体类</li>\n</ol>\n</li>\n<li><ol start=\"3\">\n<li>install 本地 maven 包</li>\n</ol>\n</li>\n<li><ol start=\"4\">\n<li><p>让服务提供者引入 common 包，测试是否正常运行（出现Bug，backend包中的实现类一直报错：</p>\n<blockquote>\n<p><code>&#39;getBaseMapper()&#39; in &#39;com.baomidou.mybatisplus.extension.service.impl.ServiceImpl&#39; clashes with &#39;getBaseMapper()&#39; in &#39;com.baomidou.mybatisplus.extension.service.IService&#39;; attempting to use incompatible return type</code></p>\n<p>原因是<code>UserInterfaceInfoMapper</code>类中，忘记更改引入的实体类路径。</p>\n<p>小技巧：<img src=\"https://cdn.jsdelivr.net/gh/wl2o2o/blogCdn/img/202308030513641.png\" alt=\"image-20230803051309362\"></p>\n<p>可以通过这种方式快速实现外部提供的的接口。</p>\n</blockquote>\n</li>\n</ol>\n</li>\n<li><ol start=\"5\">\n<li>让服务消费者引入 common 包</li>\n</ol>\n</li>\n</ul>\n</li>\n<li><p>业务流程</p>\n<ul>\n<li><ol>\n<li>新建干净的 maven 项目，只保留必要的公共依赖</li>\n</ol>\n</li>\n<li><ol start=\"2\">\n<li>抽取 service 和实体类</li>\n</ol>\n</li>\n<li><ol start=\"3\">\n<li>install 本地 maven 包</li>\n</ol>\n</li>\n<li><ol start=\"4\">\n<li>让服务提供者引入 common 包，测试是否正常运行，加上@DubboService，以便供其它类使用</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">// mybatisplus真好用！业务crud手到擒来！</span><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * <span class=\"hljs-doctag\">@author</span> WLei224</span><br><span class=\"hljs-comment\"> * <span class=\"hljs-doctag\">@create</span> 2023/8/3 5:15</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">InnerInterfaceInfoServiceImpl</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title class_\">InnerInterfaceInfoService</span> &#123;<br>    <span class=\"hljs-meta\">@Resource</span><br>    <span class=\"hljs-keyword\">private</span> InterfaceInfoMapper interfaceInfoMapper;<br>    <span class=\"hljs-meta\">@Override</span><br>    <span class=\"hljs-keyword\">public</span> InterfaceInfo <span class=\"hljs-title function_\">getInterfaceInfo</span><span class=\"hljs-params\">(String url, String method)</span> &#123;<br>        <span class=\"hljs-keyword\">if</span> (StringUtils.isAnyBlank(url,method))&#123;<br>            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">BusinessException</span>(ErrorCode.PARAMS_ERROR);<br>        &#125;<br>        QueryWrapper&lt;InterfaceInfo&gt; queryWrapper = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">QueryWrapper</span>&lt;&gt;();<br>        queryWrapper.eq(<span class=\"hljs-string\">&quot;url&quot;</span>,url);<br>        queryWrapper.eq(<span class=\"hljs-string\">&quot;method&quot;</span>,method);<br>        <span class=\"hljs-keyword\">return</span> interfaceInfoMapper.selectOne(queryWrapper);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>\n<li><ol start=\"5\">\n<li>让服务消费者引入 common 包</li>\n</ol>\n<blockquote>\n<ol>\n<li><p>API网关项目中引入 common 依赖</p>\n</li>\n<li><p>使用服务提供者提供的服务（@DubboService和@DubboReference）</p>\n<p>通过@DubboReference注入公共模块中编写好的三个服务</p>\n</li>\n<li><p>完善网关中的todo标签，完善业务逻辑</p>\n</li>\n</ol>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h3><p>​    项目调试中存在一个问题：需要手动对接口的调用次数进行分配，这里考虑可以增加一个管理调用次数的接口。</p>\n</li>\n</ul>\n<h3 id=\"统计分析功能\"><a href=\"#统计分析功能\" class=\"headerlink\" title=\"统计分析功能\"></a>统计分析功能</h3><h4 id=\"需求\"><a href=\"#需求\" class=\"headerlink\" title=\"需求\"></a>需求</h4><p>各个接口的总调用次数的占比图（饼图），取调用次数最多的三个接口，从而进行分析出哪个接口还没有人进行调用，进而对其降低资源或者下线，高频接口（增加资源、提高收费）</p>\n<h4 id=\"实现-2\"><a href=\"#实现-2\" class=\"headerlink\" title=\"实现\"></a>实现</h4><ul>\n<li><p><strong>前端</strong></p>\n<ul>\n<li><p>强烈推荐使用现成的库</p>\n<ul>\n<li><p>Echarts：<a href=\"https://echarts.apache.org/zh/index.html%EF%BC%88%E6%8E%A8%E8%8D%90%EF%BC%89\">https://echarts.apache.org/zh/index.html（推荐）</a></p>\n</li>\n<li><p>AntV：<a href=\"https://antv.vision/zh%EF%BC%88%E6%8E%A8%E8%8D%90%EF%BC%89\">https://antv.vision/zh（推荐）</a></p>\n</li>\n<li><p>BizCharts</p>\n</li>\n<li><p>如果是 React 项目，用这个库：<a href=\"https://github.com/hustcc/echarts-for-react\">https://github.com/hustcc/echarts-for-react</a></p>\n</li>\n<li><blockquote>\n<p>怎么用？</p>\n<ol>\n<li>看官网</li>\n<li>找到快速入门、按文档去引入库</li>\n<li>进入示例页面</li>\n<li>找到你要的图</li>\n<li>在线调试</li>\n<li>复制代码</li>\n<li>改为真实数据</li>\n</ol>\n</blockquote>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>后端</strong></p>\n<ul>\n<li><p>写一个接口，得到下列示例数据：<br>接口 A：2次<br>接口 B：3次</p>\n</li>\n<li><p>步骤：</p>\n<ol>\n<li><p>SQL 查询调用数据：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">select</span> interfaceInfoId, <span class=\"hljs-built_in\">sum</span>(totalNum) <span class=\"hljs-keyword\">as</span> totalNum <span class=\"hljs-keyword\">from</span> user_interface_info <span class=\"hljs-keyword\">group</span> <span class=\"hljs-keyword\">by</span> interfaceInfoId <span class=\"hljs-keyword\">order</span> <span class=\"hljs-keyword\">by</span> totalNum <span class=\"hljs-keyword\">desc</span> limit <span class=\"hljs-number\">3</span>;<br></code></pre></td></tr></table></figure></li>\n<li><p>业务层去关联查询接口信息。</p>\n<p><code>controller</code>:（就不写Service了，直接写业务逻辑）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 分析控制器</span><br><span class=\"hljs-comment\"> * <span class=\"hljs-doctag\">@author</span> yupi</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-meta\">@RestController</span><br><span class=\"hljs-meta\">@RequestMapping(&quot;/analysis&quot;)</span><br><span class=\"hljs-meta\">@Slf4j</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">AnalysisController</span> &#123;<br><br>    <span class=\"hljs-meta\">@Resource</span><br>    <span class=\"hljs-keyword\">private</span> UserInterfaceInfoMapper userInterfaceInfoMapper;<br><br>    <span class=\"hljs-meta\">@Resource</span><br>    <span class=\"hljs-keyword\">private</span> InterfaceInfoService interfaceInfoService;<br><br>    <span class=\"hljs-meta\">@GetMapping(&quot;/top/interface/invoke&quot;)</span><br>    <span class=\"hljs-meta\">@AuthCheck(mustRole = &quot;admin&quot;)</span><br>    <span class=\"hljs-keyword\">public</span> BaseResponse&lt;List&lt;InterfaceInfoVO&gt;&gt; <span class=\"hljs-title function_\">listTopInvokeInterfaceInfo</span><span class=\"hljs-params\">()</span> &#123;<br>        List&lt;UserInterfaceInfo&gt; userInterfaceInfoList = userInterfaceInfoMapper.listTopInvokeInterfaceInfo(<span class=\"hljs-number\">3</span>);<br><br>        Map&lt;Long, List&lt;UserInterfaceInfo&gt;&gt; interfaceInfoIdObjMap = userInterfaceInfoList.stream()<br>                .collect(Collectors.groupingBy(UserInterfaceInfo::getInterfaceInfoId));<br><br>        QueryWrapper&lt;InterfaceInfo&gt; queryWrapper = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">QueryWrapper</span>&lt;&gt;();<br>        queryWrapper.in(<span class=\"hljs-string\">&quot;id&quot;</span>, interfaceInfoIdObjMap.keySet());<br>        List&lt;InterfaceInfo&gt; list = interfaceInfoService.list(queryWrapper);<br><br>        <span class=\"hljs-keyword\">if</span> (CollectionUtils.isEmpty(list)) &#123;<br>            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">BusinessException</span>(ErrorCode.SYSTEM_ERROR);<br>        &#125;<br>        List&lt;InterfaceInfoVO&gt; interfaceInfoVOList = list.stream().map(interfaceInfo -&gt; &#123;<br>            <span class=\"hljs-type\">InterfaceInfoVO</span> <span class=\"hljs-variable\">interfaceInfoVO</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">InterfaceInfoVO</span>();<br>            BeanUtils.copyProperties(interfaceInfo, interfaceInfoVO);<br>            <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">totalNum</span> <span class=\"hljs-operator\">=</span> interfaceInfoIdObjMap.get(interfaceInfo.getId()).get(<span class=\"hljs-number\">0</span>).getTotalNum();<br>            interfaceInfoVO.setTotalNum(totalNum);<br>            <span class=\"hljs-keyword\">return</span> interfaceInfoVO;<br>        &#125;).collect(Collectors.toList());<br>        <span class=\"hljs-keyword\">return</span> ResultUtils.success(interfaceInfoVOList);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><code>封装类</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 接口信息封装视图</span><br><span class=\"hljs-comment\"> * <span class=\"hljs-doctag\">@TableName</span> product</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-meta\">@EqualsAndHashCode(callSuper = true)</span><br><span class=\"hljs-meta\">@Data</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">InterfaceInfoVO</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">InterfaceInfo</span> &#123;<br><br>    <span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">     * 调用次数</span><br><span class=\"hljs-comment\">     */</span><br>    <span class=\"hljs-keyword\">private</span> Integer totalNum;<br><br>    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-type\">long</span> <span class=\"hljs-variable\">serialVersionUID</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">1L</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><code>UserInterfaceInfoMapper</code>:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * <span class=\"hljs-doctag\">@Entity</span> com.wl.smartapicommon.model.entity.UserInterfaceInfo</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">UserInterfaceInfoMapper</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">BaseMapper</span>&lt;UserInterfaceInfo&gt; &#123;<br><br>    <span class=\"hljs-comment\">// 获取前几个调用次数最多的接口</span><br>    List&lt;UserInterfaceInfo&gt; <span class=\"hljs-title function_\">listTopInvokeInterfaceInfo</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> limit)</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><code>xml中添加sql语句</code>：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">select</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;listTopInvokeInterfaceInfo&quot;</span> <span class=\"hljs-attr\">resultType</span>=<span class=\"hljs-string\">&quot;com.wl.smartapicommon.model.entity.UserInterfaceInfo&quot;</span>&gt;</span><br>    select interfaceInfoId, sum(totalNum) as totalNum<br>    from user_interface_info<br>    group by interfaceInfoId<br>    order by totalNum<br>    desc limit #&#123;limit&#125;;<br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">select</span>&gt;</span><br></code></pre></td></tr></table></figure></li>\n</ol>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"上线计划\"><a href=\"#上线计划\" class=\"headerlink\" title=\"上线计划\"></a>上线计划</h2><ul>\n<li>前端：参考之前用户中心或伙伴匹配系统的上线方式</li>\n<li>后端：<ul>\n<li>backend 项目：web 项目，部署 spring boot 的 jar 包（对外的）</li>\n<li>gateway 网关项目：web 项目，部署 spring boot 的 jar 包（对外的）</li>\n<li>interface 模拟接口项目：web 项目，部署 spring boot 的 jar 包（不建议对外暴露的）</li>\n</ul>\n</li>\n</ul>\n<p><em><strong>关键：网络必须要连通</strong></em></p>\n<blockquote>\n<p>如果自己学习用：单个服务器部署这三个项目就足够。<br>如果你是搞大事，多个服务器建议在 同一内网 ，内网交互会更快、且更安全。</p>\n</blockquote>\n<h4 id=\"上线环境准备\"><a href=\"#上线环境准备\" class=\"headerlink\" title=\"上线环境准备\"></a>上线环境准备</h4><ol>\n<li><p>docker安装</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">curl -fsSL https://get.docker.com | bash -s docker --mirror Aliyun<br>systemctl start docker <br>systemctl enable docker<br>systenctl restart docker<br></code></pre></td></tr></table></figure></li>\n<li><p>宝塔面板</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\"><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">安装命令</span><br>yum install -y wget &amp;&amp; wget -O install.sh http://download.bt.cn/install/install_6.0.sh &amp;&amp; sh install.sh<br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">卸载命令</span><br>systemct stop bt<br>rm -rf /www/server/panel<br>rm -f /etc/init.d/bt<br><br>rm -rf /root/.pyenv/versions/3.7.0/envs/btpanel/lib/python3.7/site-packages/pycache<br>rm -rf /root/.pyenv/versions/3.7.0/envs/btpanel/lib/python3.7/site-packages/btpanel/__pycache__<br>rm -rf /root/.pyenv/versions/3.7.0/envs/btpanel/lib/python3.7/site-packages/panelApp/__pycache__<br><br>rm -rf /www/server/panel/logs/*<br></code></pre></td></tr></table></figure></li>\n<li><p><a href=\"https://blog.csdn.net/u010148813/article/details/126172372\">Docker 安装 Nginx</a></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\"><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">拉取官方的最新版本的镜像</span><br><span class=\"hljs-meta prompt_\">$ </span><span class=\"language-bash\">docker pull nginx</span><br><span class=\"hljs-meta prompt_\"></span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">使用以下命令来运行 nginx 容器</span><br><span class=\"hljs-meta prompt_\">$ </span><span class=\"language-bash\">docker run --name nginx -p 80:80 -d nginx</span><br><span class=\"hljs-meta prompt_\"></span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">在宿主机家目录创建用于放配置文件的文件夹</span><br><span class=\"hljs-meta prompt_\">$ </span><span class=\"language-bash\"><span class=\"hljs-built_in\">mkdir</span> -p /root/docker-nginx/&#123;conf,html,logs&#125;</span><br><span class=\"hljs-meta prompt_\"></span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">从容器nginx中复制nginx.conf文件到宿主机</span><br><span class=\"hljs-meta prompt_\">$ </span><span class=\"language-bash\">docker <span class=\"hljs-built_in\">cp</span> nginx:/etc/nginx/nginx.conf /root/docker-nginx</span>       <br><span class=\"hljs-meta prompt_\">$ </span><span class=\"language-bash\">docker <span class=\"hljs-built_in\">cp</span> nginx:/etc/nginx/conf.d/default.conf /root/docker-nginx/conf/</span><br><span class=\"hljs-meta prompt_\">$ </span><span class=\"language-bash\">docker <span class=\"hljs-built_in\">cp</span> nginx:/usr/share/nginx/html/ /root/docker-nginx/</span><br><br><br>----------------------------------------------<br>说明：<br>宿主机：就是你的云服务器或者虚拟机。<br>~ 目录，也就是我们常说的家目录/home/your_username.(如果是云服务器，且没有创建普通用户，那么家目录就是 /root 了，也就是我们说的管理员用户，拥有最高权限，所以命令就不用加上 sudo 了)<br><br>刚才的操作是把你在docker中拉取的 Nginx 的镜像配置文件复制了一份到家目录，这样可以便于后续对 nginx 的配置，say Why?，因为我们接下来会通过映射，将我们复制到宿主机的配置文件直接映射到 docker 容器中的 Nginx 中，是不是很方便，下次若需要配置，就可以直接在宿主机中进行配置了，否则还需要通过 `$ docker exec -it nginx bash` 命令进入到 Nginx 的镜像之中。<br></code></pre></td></tr></table></figure>\n\n\n\n<ul>\n<li>打包一下复制好的配置文件（备份，以免操作失误可补救）</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\"><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">删掉 nginx 容器</span><br><span class=\"hljs-meta prompt_\">$ </span><span class=\"language-bash\">docker stop nginx</span><br><span class=\"hljs-meta prompt_\">$ </span><span class=\"language-bash\">docker <span class=\"hljs-built_in\">rm</span> nginx</span><br><span class=\"hljs-meta prompt_\"></span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">重新运行容器，并加上配置文件的映射</span><br><span class=\"hljs-meta prompt_\">$ </span><span class=\"language-bash\">docker run -p 80:80 \\</span><br><span class=\"language-bash\">-v /root/docker-nginx/nginx.conf:/etc/nginx/nginx.conf \\</span><br><span class=\"language-bash\">-v /root/docker-nginx/logs:/var/log/nginx \\</span><br><span class=\"language-bash\">-v /root/docker-nginx/html:/usr/share/nginx/html \\</span><br><span class=\"language-bash\">-v /root/docker-nginx/conf:/etc/nginx/conf.d \\</span><br><span class=\"language-bash\">--name nginx \\</span><br><span class=\"language-bash\">--privileged=<span class=\"hljs-literal\">true</span> \\</span><br><span class=\"language-bash\">--restart=always \\</span><br><span class=\"language-bash\">-d nginx</span><br><br>----------------------------------------------<br>终于完成！如遇到403或者无法访问此网站等其他问题，首先去你购买的云服务器的安全组新增 80 端口，如果你开了代理，试着重启或者注销电脑。<br>参考链接：https://blog.csdn.net/l123lgx/article/details/122619851<br><br>server &#123;<br>    listen 80;<br>    server_name localhost;<br>    #charset koi8-r;<br>    #access_log logs/host.access.log main;<br>    location / &#123;<br>        root html;<br>        index index.html index.htm;<br>\t&#125;<br>    #error_page 404 /404.html;<br>    # redirect server error pages to the static page /50x.html<br>    #<br>    error_page 500 502 503 504 /50x.html;<br>    location = /50x.html &#123;<br>    \troot html;<br>    &#125;<br>    # proxy the PHP scripts to Apache listening on 127.0.0.1:80<br>    #<br>    #location ~ \\.php$ &#123;<br>    # proxy_pass http://127.0.0.1;<br>    #&#125;<br>    # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000<br>    #<br>    #location ~ \\.php$ &#123;<br>    # root html;<br>    # fastcgi_pass 127.0.0.1:9000;<br>    # fastcgi_index index.php;<br>    # fastcgi_param SCRIPT_FILENAME /scripts$fastcgi_script_name;<br>    # include fastcgi_params;<br>    #&#125;<br>    # deny access to .htaccess files, if Apache&#x27;s document root<br>    # concurs with nginx&#x27;s one<br>    #<br>    #location ~ /\\.ht &#123;<br>    # deny all;<br>    #&#125;<br>&#125;<br>    # another virtual host using mix of IP-, name-, and port-based configuration<br>    #<br>    #server &#123;<br>    # listen 8000;<br>    # listen somename:8080;<br>    # server_name somename alias another.alias;<br>    # location / &#123;<br>    # root html;<br>    # index index.html index.htm;<br>    # &#125;<br>    #&#125;<br>    # HTTPS server<br>    #<br>    #server &#123;<br>    # listen 443 ssl;<br>    # server_name localhost;<br>    # ssl_certificate cert.pem;<br>    # ssl_certificate_key cert.key;<br>    # ssl_session_cache shared:SSL:1m;<br>    # ssl_session_timeout 5m;<br>    # ssl_ciphers HIGH:!aNULL:!MD5;<br>    # ssl_prefer_server_ciphers on;<br>    # location / &#123;<br>    # root html;<br>    # index index.html index.htm;<br>    # &#125;<br>    #&#125;<br><br></code></pre></td></tr></table></figure>\n\n<p>复习一下<code>tar</code>命令的用法：</p>\n<img src=\"https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202308260050797.png\" alt=\"image-20230826005051120\" style=\"zoom:50%;\" />\n\n<p>解压的话亦是同理：</p>\n<blockquote>\n<p>解压 tar 存档文件的常用命令是 <code>tar -xzvf</code>。下面是对这些参数的解释：</p>\n<ul>\n<li><code>-x</code>：表示从存档文件中提取（解压）文件。</li>\n<li><code>-z</code>：表示使用 gzip 压缩算法进行解压缩。使用此参数可以解压被 gzip 压缩的 tar 存档文件。</li>\n<li><code>-v</code>：表示在命令执行过程中显示详细信息，即显示提取的文件列表。</li>\n<li><code>-f</code>：指定要提取的存档文件的名称。紧跟在 <code>-f</code> 参数后面的是存档文件的名称。</li>\n</ul>\n</blockquote>\n<ol start=\"4\">\n<li><p><code>docker</code>安装<code>MySQL</code></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">docker pull mysql<br><span class=\"hljs-meta prompt_\"></span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">在宿主机家目录创建用于放配置文件的文件夹</span><br><span class=\"hljs-meta prompt_\">$ </span><span class=\"language-bash\"><span class=\"hljs-built_in\">mkdir</span> -p /root/docker-mysql/&#123;conf,data,<span class=\"hljs-built_in\">log</span>&#125;</span><br><span class=\"hljs-meta prompt_\"></span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">在配置文件目录:/root/docker-mysql/conf新建一个my.cnf配置文件，写入下面内容，设置客户端和mysql服务器端编码都为utf8</span><br>[client]<br>default_character_set=utf8<br>[mysqld]<br>collation_server=utf8_general_ci<br>character_set_server=utf8<br><br>docker run -p 3306:3306 \\<br>--privileged=true \\<br>-v /root/docker-mysql/log:/var/log/mysql \\<br>-v /root/docker-mysql/data:/var/lib/mysql \\<br>-v /root/docker-mysql/conf:/etc/mysql/conf.d \\<br>-e MYSQL_ROOT_PASSWORD=你的MySQL密码 \\<br>--name mysql \\<br>-d mysql<br><br>docker exec -it mysql bash<br><br>mysql -u root -p<br><br>如果遇到`Navicat`连接不上的问题，请看下面的链接。<br></code></pre></td></tr></table></figure>\n\n<p>记录一个大坑，宝塔面板添加3306端口号，被腾讯云服务器拦截了，无语了，还是通过云服务器控制台（推荐✨）或者防火墙命令来添加端口吧。</p>\n<p>参考链接：<a href=\"https://www.cnblogs.com/--eric/p/17145834.html\">https://www.cnblogs.com/--eric/p/17145834.html</a></p>\n</li>\n</ol>\n<ol start=\"5\">\n<li><p><code>JDK</code>安装</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\"><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">yum 安装免环境变量的配置</span><br><span class=\"hljs-meta prompt_\">$ </span><span class=\"language-bash\">yum install -y java-1.8.0-openjdk*</span><br></code></pre></td></tr></table></figure></li>\n<li><p><code>maven</code>安装</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">通过以下命令获取安装包或者通过本地浏览器下载到主机，然后通过 ftp 传输到 Linux 服务器<br>curl -O https://dlcdn.apache.org/maven/maven-3/3.8.8/binaries/apache-maven-3.8.8-bin.tar.gz<br><br>tar -zxvf apache-maven-3.8.8-bin.tar.gz<br><br>vim /etc/profile<br><br>文件空白处增加两行内容：<br>export MAVEN_HOME=/root/services/apache-maven-3.8.8<br>export PATH=$MAVEN_HOME/bin:$PATH<br><br>source /etc/profile<br><br>mvn --version<br><br></code></pre></td></tr></table></figure></li>\n<li><p><code>redis</code>安装</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">docker pull redis<br><br>mkdir -p /root/docker-redis/conf<br><span class=\"hljs-meta prompt_\"></span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">入redis配置文件夹</span><br>cd /root/docker-redis/conf  <br><span class=\"hljs-meta prompt_\"></span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">下载redis配置文件</span><br>wget http://download.redis.io/redis-stable/redis.conf   <br><br>vim redis.conf  // 修改配置文件<br>1. appendonly yes    启动Redis持久化功能 (默认 no , 所有信息都存储在内存 [重启丢失] 。设置为 yes , 将存储在硬盘 [重启还在])<br>2. protected-mode no    关闭protected-mode模式，此时外部网络可以直接访问<br>3. bind 0.0.0.0    设置所有IP都可以访问<br>4. requirepass 密码    设置密码<br>如果你设置了密码,需要通过如下命令进入Redis控制台<br><span class=\"hljs-meta prompt_\">#</span><span class=\"language-bash\"><span class=\"hljs-comment\"># 进入Redis容器</span></span><br>        docker exec -it redis bash<br><span class=\"hljs-meta prompt_\">#</span><span class=\"language-bash\"><span class=\"hljs-comment\"># 通过密码进入Redis控制台</span></span><br>        redis-cli -h 127.0.0.1 -p 6379 -a [你的密码]<br>        <br>mkdir -p /root/docker-redis/data<br><br>docker run -p 6379:6379 \\<br>-v /root/docker-redis/conf/redis.conf:/etc/redis/redis.conf \\<br>-v /root/docker-redis/data:/data \\<br>-e REDIS_ROOT_PASSWORD=你的Redis密码 \\<br>--restart=always \\<br>--name redis \\<br>-d redis<br><br><br>不要忘记打开防火墙6379端口，通过宝塔面板或者命令，或者云服务器控制台<br></code></pre></td></tr></table></figure></li>\n<li><p><code>nacos</code>安装</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">docker pull nacos/nacos-server<br><span class=\"hljs-meta prompt_\"></span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">在宿主机家目录创建用于放配置文件的文件夹</span><br><span class=\"hljs-meta prompt_\">$ </span><span class=\"language-bash\"><span class=\"hljs-built_in\">mkdir</span> -p /root/docker-nacos/nacos/&#123;init.d,logs&#125;</span><br><br>vim /root/docker-nacos/nacos/init.d/application.properties <br><br>server.contextPath=/nacos<br>server.servlet.contextPath=/nacos<br>server.port=8848<br> <br>spring.datasource.platform=mysql<br>db.num=1<br>db.url.0=jdbc:mysql://xx.xx.xx.x:3306/nacos_devtest_prod?characterEncoding=utf8&amp;connectTimeout=1000&amp;socketTimeout=3000&amp;autoReconnect=true<br>db.user=user<br>db.password=pass<br> <br>nacos.cmdb.dumpTaskInterval=3600<br>nacos.cmdb.eventTaskInterval=10<br>nacos.cmdb.labelTaskInterval=300<br>nacos.cmdb.loadDataAtStart=false<br>management.metrics.export.elastic.enabled=false<br>management.metrics.export.influx.enabled=false<br>server.tomcat.accesslog.enabled=true<br>server.tomcat.accesslog.pattern=%h %l %u %t &quot;%r&quot; %s %b %D %&#123;User-Agent&#125;i<br>nacos.security.ignore.urls=/,/**/*.css,/**/*.js,/**/*.html,/**/*.map,/**/*.svg,/**/*.png,/**/*.ico,/console-fe/public/**,/v1/auth/login,/v1/console/health/**,/v1/cs/**,/v1/ns/**,/v1/cmdb/**,/actuator/**,/v1/console/server/**<br>nacos.naming.distro.taskDispatchThreadCount=1<br>nacos.naming.distro.taskDispatchPeriod=200<br>nacos.naming.distro.batchSyncKeyCount=1000<br>nacos.naming.distro.initDataRatio=0.9<br>nacos.naming.distro.syncRetryDelay=5000<br>nacos.naming.data.warmup=true<br>nacos.naming.expireInstance=true<br><br><br>docker run -p 8848:8848 \\<br>-e JVM_XMS=256m \\<br>-e JVM_XMX=256m \\<br>-e MODE=standalone \\<br>-e PREFER_HOST_MODE=hostname \\<br>-v /root/docker-nacos/nacos/logs:/home/nacos/logs \\<br>-v /root/docker-nacos/nacos/init.d/application.properties:/home/nacos/init.d/application.properties \\<br>--name nacos \\<br>--privileged=true \\<br>--restart=always \\<br>-d nacos/nacos-server<br></code></pre></td></tr></table></figure>\n\n<p>参考链接：<a href=\"https://blog.csdn.net/yexiaomodemo/article/details/123355202\">https://blog.csdn.net/yexiaomodemo/article/details/123355202</a></p>\n</li>\n<li><p><code>rabbitmq</code>安装</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">docker pull rabbitmq<br><br>docker run -p 5672:5672 -p 15672:15672 \\<br>-v /root/docker-rabbitmq/config/:/etc/rabbitmq/ \\<br>-e RABBITMQ_DEFAULT_USER=admin \\<br>-e RABBITMQ_DEFAULT_PASS=admin \\<br>--hostname myRabbit \\<br>--name rabbitmq \\<br>--restart=always \\<br>-d rabbitmq<br><br>docker exec -it rabbitmq bash<br><span class=\"hljs-meta prompt_\"></span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">启动可视化插件</span><br>rabbitmq-plugins enable rabbitmq_management<br><br>使用浏览器打开web管理端：http://Server-IP:15672 <br></code></pre></td></tr></table></figure></li>\n</ol>\n<p>   参考链接：</p>\n</li>\n</ol>\n<p>​      <a href=\"https://blog.csdn.net/qq_42977003/article/details/128107521\">https://blog.csdn.net/qq_42977003/article/details/128107521</a><br>​      <a href=\"https://blog.csdn.net/feritylamb/article/details/128434465\">https://blog.csdn.net/feritylamb/article/details/128434465</a></p>\n<h4 id=\"一、原始部署\"><a href=\"#一、原始部署\" class=\"headerlink\" title=\"一、原始部署\"></a>一、原始部署</h4><p>​    缺点：需要一个个配置环境，安装必须软件</p>\n<h4 id=\"二、宝塔面板部署\"><a href=\"#二、宝塔面板部署\" class=\"headerlink\" title=\"二、宝塔面板部署\"></a>二、宝塔面板部署</h4><p>​    优点：可视化安装与配置</p>\n<h4 id=\"三、docker部署\"><a href=\"#三、docker部署\" class=\"headerlink\" title=\"三、docker部署\"></a>三、docker部署</h4><blockquote>\n<p>Docker是一种开源的容器化平台，用于构建、发布和运行应用程序。通过使用Docker，您可以将应用程序及其依赖项打包到一个称为容器的独立单元中，以便在任何环境中运行，而无需担心环境差异或依赖问题。</p>\n<p>以下是一些与Docker相关的常用概念和命令：</p>\n<ol>\n<li>镜像（Image）：镜像是Docker容器的基础，它包含了运行应用程序所需的一切，包括代码、运行时环境、库和依赖项。您可以通过构建自定义镜像或从Docker Hub等镜像仓库中获取现有的镜像。</li>\n<li>容器（Container）：容器是基于镜像创建的运行实例，它是一个独立、隔离的执行环境。容器可以启动、停止、重启和删除，每个容器都具有自己的文件系统、进程空间和网络接口。</li>\n<li>Dockerfile：Dockerfile是用于定义镜像构建过程的文本文件。它包含一系列指令，用于指定基础镜像、安装软件、复制文件、设置环境变量等。</li>\n<li>Docker Compose：Docker Compose是一个用于定义和运行多个容器应用的工具。它使用一个YAML文件来定义各个服务及其依赖关系，并可以一键启动、停止和管理整个应用程序的容器群。</li>\n</ol>\n<p>一些常用的Docker命令包括：</p>\n<ul>\n<li><code>docker build</code>：根据Dockerfile构建镜像。</li>\n<li><code>docker run</code>：创建并运行一个新的容器。</li>\n<li><code>docker stop</code>：停止一个正在运行的容器。</li>\n<li><code>docker start</code>：启动已经停止的容器。</li>\n<li><code>docker rm</code>：删除一个或多个容器。</li>\n<li><code>docker images</code>：列出本地已下载的镜像。</li>\n<li><code>docker pull</code>：从镜像仓库下载镜像。</li>\n<li><code>docker push</code>：将本地镜像推送到镜像仓库。</li>\n</ul>\n<p>这只是Docker的一小部分功能和命令，Docker还提供了许多其他功能，如网络配置、数据卷、容器编排等。如果您想更深入了解Docker的使用，请参考官方文档或相关教程。</p>\n<p>docker如何打包一个镜像，命令是什么?</p>\n<p>要打包一个Docker镜像，您需要编写一个Dockerfile，其中包含构建镜像所需的指令和配置。然后，使用<code>docker build</code>命令来构建镜像。以下是基本的步骤和相应的命令：</p>\n<ol>\n<li><p>创建一个Dockerfile：在您的项目目录中创建一个名为<code>Dockerfile</code>的文本文件，可以使用任何文本编辑器打开并编辑它。</p>\n</li>\n<li><p>在Dockerfile中定义镜像构建过程：Dockerfile包含一系列指令，用于指定基础镜像、安装软件、复制文件、设置环境变量等。根据您的应用程序需求，编写适当的指令。</p>\n<p>以下是一个简单的Dockerfile示例：</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs dockerfile\"><span class=\"hljs-comment\"># 使用官方的 Node.js 作为基础镜像</span><br><span class=\"hljs-keyword\">FROM</span> node:<span class=\"hljs-number\">14</span><br><br><span class=\"hljs-comment\"># 设置工作目录</span><br><span class=\"hljs-keyword\">WORKDIR</span><span class=\"language-bash\"> /app</span><br><br><span class=\"hljs-comment\"># 复制应用程序代码到容器中</span><br><span class=\"hljs-keyword\">COPY</span><span class=\"language-bash\"> . .</span><br><br><span class=\"hljs-comment\"># 安装应用程序依赖</span><br><span class=\"hljs-keyword\">RUN</span><span class=\"language-bash\"> npm install</span><br><br><span class=\"hljs-comment\"># 暴露应用程序的端口</span><br><span class=\"hljs-keyword\">EXPOSE</span> <span class=\"hljs-number\">3000</span><br><br><span class=\"hljs-comment\"># 定义启动容器时运行的命令</span><br><span class=\"hljs-keyword\">CMD</span><span class=\"language-bash\"> [<span class=\"hljs-string\">&quot;npm&quot;</span>, <span class=\"hljs-string\">&quot;start&quot;</span>]</span><br><br>这个示例中，我们使用了官方的Node.js <span class=\"hljs-number\">14</span>镜像作为基础镜像，将应用程序代码复制到容器中，安装依赖项，暴露端口<span class=\"hljs-number\">3000</span>，并在容器启动时运行`npm start`命令。<br></code></pre></td></tr></table></figure></li>\n<li><p>构建镜像：在终端中，切换到包含Dockerfile的目录，并运行以下命令来构建镜像：</p>\n<figure class=\"highlight crmsh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs crmsh\">docker build -t image_name:<span class=\"hljs-keyword\">tag</span> <span class=\"hljs-title\">.</span><br></code></pre></td></tr></table></figure>\n\n<ul>\n<li><code>-t</code>参数用于指定镜像的名称和标签。您可以根据需要自定义名称和标签。</li>\n<li><code>.</code>表示Dockerfile所在的当前目录。确保在运行命令之前，您已经切换到正确的目录。</li>\n</ul>\n<p>例如，要构建一个名为<code>myapp</code>的镜像，标签为<code>v1.0</code>，可以运行以下命令：</p>\n<figure class=\"highlight mipsasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mipsasm\">docker <span class=\"hljs-keyword\">build </span>-t myapp:<span class=\"hljs-built_in\">v1</span>.<span class=\"hljs-number\">0</span> .<br></code></pre></td></tr></table></figure></li>\n<li><p>等待构建完成：Docker将执行Dockerfile中的每个指令，并构建镜像。这可能需要一些时间，取决于您的镜像大小和复杂性。</p>\n</li>\n<li><p>查看构建的镜像：构建完成后，可以使用以下命令查看本地的镜像列表：</p>\n<figure class=\"highlight ebnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ebnf\"><span class=\"hljs-attribute\">docker images</span><br></code></pre></td></tr></table></figure>\n\n<p>您将看到刚刚构建的镜像以及其名称、标签和大小等信息。</p>\n</li>\n</ol>\n<p>通过以上步骤，您就可以使用Dockerfile和<code>docker build</code>命令来打包构建自己的Docker镜像。请根据您的应用程序需求和环境配置适当地编辑Dockerfile。</p>\n</blockquote>\n<h5 id=\"前端部署例子：\"><a href=\"#前端部署例子：\" class=\"headerlink\" title=\"前端部署例子：\"></a>前端部署例子：</h5><p><code>dockerfile</code>文件：</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs dockerfile\"><span class=\"hljs-keyword\">FROM</span> nginx<br><br><span class=\"hljs-keyword\">WORKDIR</span><span class=\"language-bash\"> /usr/share/nginx/html/</span><br><span class=\"hljs-keyword\">USER</span> root<br><br><span class=\"hljs-keyword\">COPY</span><span class=\"language-bash\"> ./docker/nginx.conf /etc/nginx/conf.d/default.conf</span><br><br><span class=\"hljs-keyword\">COPY</span><span class=\"language-bash\"> ./dist  /usr/share/nginx/html/</span><br><br><span class=\"hljs-keyword\">EXPOSE</span> <span class=\"hljs-number\">80</span><br><br><span class=\"hljs-keyword\">CMD</span><span class=\"language-bash\"> [<span class=\"hljs-string\">&quot;nginx&quot;</span>, <span class=\"hljs-string\">&quot;-g&quot;</span>, <span class=\"hljs-string\">&quot;daemon off;&quot;</span>]</span><br></code></pre></td></tr></table></figure>\n\n<p><code>nginx.conf</code>文件：</p>\n<figure class=\"highlight nginx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs nginx\"><span class=\"hljs-section\">server</span> &#123;<br>    <span class=\"hljs-attribute\">listen</span> <span class=\"hljs-number\">80</span>;<br><br>    <span class=\"hljs-comment\"># gzip config</span><br>    <span class=\"hljs-attribute\">gzip</span> <span class=\"hljs-literal\">on</span>;<br>    <span class=\"hljs-attribute\">gzip_min_length</span> <span class=\"hljs-number\">1k</span>;<br>    <span class=\"hljs-attribute\">gzip_comp_level</span> <span class=\"hljs-number\">9</span>;<br>    <span class=\"hljs-attribute\">gzip_types</span> text/plain text/css text/javascript application/json application/javascript application/x-javascript application/xml;<br>    <span class=\"hljs-attribute\">gzip_vary</span> <span class=\"hljs-literal\">on</span>;<br>    <span class=\"hljs-attribute\">gzip_disable</span> <span class=\"hljs-string\">&quot;MSIE [1-6]\\.&quot;</span>;<br><br>    <span class=\"hljs-attribute\">root</span> /usr/share/nginx/html;<br>    <span class=\"hljs-attribute\">include</span> /etc/nginx/mime.types;<br><br>    <span class=\"hljs-section\">location</span> / &#123;<br>        <span class=\"hljs-attribute\">try_files</span> <span class=\"hljs-variable\">$uri</span> /index.html;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"项目扩展思路\"><a href=\"#项目扩展思路\" class=\"headerlink\" title=\"项目扩展思路\"></a>项目扩展思路</h3><ol>\n<li><p>用户自己可以申请更换签名</p>\n</li>\n<li><p>怎么让其他用户也能上传接口？</p>\n<blockquote>\n<ul>\n<li>需要提供一个机制（一个页面），让用户来输入自己的接口host（都武器的地址）、接口信息、将接口写入数据库；</li>\n<li>可以在interfaceInfo表中加个host字段，以次区分服务器地址，让接口提供者更灵活的接入系统；</li>\n<li>将接口信息入库前，要对接口进行校验，比如检查地址是否遵循规则、是否可以正常调用,并遵循甲方要求（使用SDK）</li>\n</ul>\n</blockquote>\n</li>\n<li><p>网关校验是否还有调用次数</p>\n<p>需要考虑并发的问题，防止瞬间调用超频。</p>\n</li>\n<li><p>网关优化</p>\n<p>比如增加限流、降级保护、提高性能等。还可以考虑搭配Nginx网关使用。</p>\n</li>\n<li><p>功能增强</p>\n<p>可以针对不同的请求头或者接口类型来设计前端界面和表单，百年与用户进行调用，增强体验。</p>\n<p>（可以参考swagger、postman、kniffj的界面）</p>\n</li>\n</ol>\n<h2 id=\"项目优化\"><a href=\"#项目优化\" class=\"headerlink\" title=\"项目优化\"></a>项目优化</h2><h3 id=\"扩展思路\"><a href=\"#扩展思路\" class=\"headerlink\" title=\"扩展思路\"></a>扩展思路</h3><ol>\n<li>用户可以申请更换签名</li>\n<li>怎么让其他用户也上传接口？<br>需要提供一个机制（界面），让用户输入自己的接口 host（服务器地址）、接口信息，将接口信息写入数据库。<br>可以在 interfaceInfo 表里加个 host 字段，区分服务器地址，让接口提供者更灵活地接入系统。<br>将接口信息写入数据库之前，要对接口进行校验（比如检查他的地址是否遵循规则，测试调用），保证他是正常的。<br>将接口信息写入数据库之前遵循咱们的要求（并且使用咱们的 sdk），<br>在接入时，平台需要测试调用这个接口，保证他是正常的。</li>\n<li>网关校验是否还有调用次数<br>需要考虑并发问题，防止瞬间调用超额。</li>\n<li>网关优化<br>比如增加限流 / 降级保护，提高性能等。还可以考虑搭配 Nginx 网关使用。</li>\n<li>功能增强<br>可以针对不同的请求头或者接口类型来设计前端界面和表单，便于用户调用，获得更好的体验。<br>可以参考 swagger、postman、knife4j 的页面。</li>\n</ol>\n","site":{"data":{}},"more":"<h1 id=\"API开放平台\"><a href=\"#API开放平台\" class=\"headerlink\" title=\"API开放平台\"></a>API开放平台</h1><blockquote>\n<p>写在最前面：</p>\n<p>​    学到的知识与收到的建议：</p>\n<pre><code>1. 把自己所有的数据库建表语句总结到一起，后续有用；\n1. 记录Bug文档\n1. 多记录一些需求的解决方案、提高自己的架构能力\n</code></pre>\n</blockquote>\n<h2 id=\"项目介绍\"><a href=\"#项目介绍\" class=\"headerlink\" title=\"项目介绍\"></a>项目介绍</h2><blockquote>\n<p>前端开发的时候有有时会需要后端的接口，如果此时有一个API接口可以使用，那么就无需后端借口了</p>\n</blockquote>\n<p>一个提供API接口调用的平台，用户可以注册与登录，开通接口的调用权限，用户可以使用接口，每次调用会进行次数统计。管理院可以发布接口、下线接口、接入接口，以及可视化接口的调用情况。</p>\n<p>一个API接口平台：</p>\n<ol>\n<li>防止攻击</li>\n<li>使用限制</li>\n<li>统计调用次数</li>\n<li>计费</li>\n<li>流量保护</li>\n<li>API接入</li>\n</ol>\n<h2 id=\"预计完成时间\"><a href=\"#预计完成时间\" class=\"headerlink\" title=\"预计完成时间\"></a>预计完成时间</h2><p>5-6周</p>\n<h2 id=\"业务流程\"><a href=\"#业务流程\" class=\"headerlink\" title=\"业务流程\"></a>业务流程</h2><p>前台、SDK、API网关、模拟接口、后台    共五个子模块</p>\n<p><strong>难点</strong>：思想</p>\n<h2 id=\"技术选型\"><a href=\"#技术选型\" class=\"headerlink\" title=\"技术选型\"></a>技术选型</h2><ul>\n<li>前端<ul>\n<li>Ant Design Pro</li>\n<li>React</li>\n<li>Ant Design Pro Components</li>\n<li>Umi</li>\n<li>Umi Request（Axios的封装）–请求库（前后端联调）</li>\n</ul>\n</li>\n<li>后端<ul>\n<li>Spring Boot</li>\n<li>Spring Boot Stater（SDK开发）–可以发布到maven仓库—-<strong>简历亮点</strong></li>\n<li>？？？？？？（网关、限流、日志实现）</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"项目计划\"><a href=\"#项目计划\" class=\"headerlink\" title=\"项目计划\"></a>项目计划</h2><h3 id=\"Day01–项目初始化\"><a href=\"#Day01–项目初始化\" class=\"headerlink\" title=\"Day01–项目初始化\"></a>Day01–项目初始化</h3><p>项目介绍、设计、技术选型</p>\n<p>基础项目的搭建</p>\n<p>接口管理</p>\n<p>用户查看接口的权限</p>\n<h3 id=\"Day02–接口调用\"><a href=\"#Day02–接口调用\" class=\"headerlink\" title=\"Day02–接口调用\"></a>Day02–接口调用</h3><ol>\n<li>继续开发接口管理前端页面 15min</li>\n<li>开发模拟API接口 5min</li>\n<li>开发调用接口的代码 10-20min</li>\n<li>保证调用的安全性（API签名认证） 15min</li>\n<li>客户端SDK的开发 15min</li>\n<li>管理员接口的发布与调用 15min</li>\n<li>接口文档的展示、接口在线调用 15min</li>\n</ol>\n<h3 id=\"Day03–接口计费与保护\"><a href=\"#Day03–接口计费与保护\" class=\"headerlink\" title=\"Day03–接口计费与保护\"></a>Day03–接口计费与保护</h3><p>统计用户调用次数</p>\n<p>限流</p>\n<p>计费</p>\n<p>日志</p>\n<p>开通</p>\n<h3 id=\"Day04–管理员统计分析\"><a href=\"#Day04–管理员统计分析\" class=\"headerlink\" title=\"Day04–管理员统计分析\"></a>Day04–管理员统计分析</h3><p>提供可视化平台，展示所有接口的调用情况，便于管理价格</p>\n<p>接口预警</p>\n<h2 id=\"Day01-需求分析\"><a href=\"#Day01-需求分析\" class=\"headerlink\" title=\"Day01 需求分析\"></a>Day01 需求分析</h2><ol>\n<li><p>管理员可以对接口信息进行增删改查</p>\n</li>\n<li><p>用户可以访问前台，查看接口信息</p>\n</li>\n</ol>\n<h3 id=\"今日计划\"><a href=\"#今日计划\" class=\"headerlink\" title=\"今日计划\"></a>今日计划</h3><ol>\n<li>项目脚手架搭建（初始化项目）10分钟前端、5-10分钟后端 </li>\n<li>管理员可以对接口信息进行增删改查</li>\n<li>用户可以访问前台，查看接口的信息</li>\n</ol>\n<h3 id=\"项目初始化（前后端）\"><a href=\"#项目初始化（前后端）\" class=\"headerlink\" title=\"项目初始化（前后端）\"></a>项目初始化（前后端）</h3><ul>\n<li><h3 id=\"前端\"><a href=\"#前端\" class=\"headerlink\" title=\"前端\"></a>前端</h3></li>\n</ul>\n<ol>\n<li><p>使用Ant Design Pro提供的<code>pro-cli</code>来快速的初始化脚手架。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># 查看node和npm版本</span><br>建议16和8<br><span class=\"hljs-comment\"># 使用 npm</span><br>npm i @ant-design/pro-cli -g<br>pro create myapi-frontend<br><span class=\"hljs-comment\"># 下载项目所需要的依赖</span><br>yarn<br>此时可能会遇到node版本要求的问题，因为版本更新迭代的原因，我当时要求的是使用16.14.0的node版本，<br>如果感觉切换node版本麻烦的话，这里推荐使用nvm（node的版本管理工具），使用方法自行百度<br></code></pre></td></tr></table></figure></li>\n<li><p>项目瘦身</p>\n<p> 遇到了一个大坑，星球的球友们也都遇到了，下面是球友的解决方法，亲测有效。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># 关闭ESLint中与Prettier重复的规则，确保代码格式化的一致性</span><br>yarn add eslint-config-prettier --dev<br><span class=\"hljs-comment\"># 用于检查和修复JavaScript代码中的常见问题</span><br>yarn add eslint-plugin-unicorn --dev<br></code></pre></td></tr></table></figure>\n<h3 id=\"项目去除国际化存在问题的解决方法\"><a href=\"#项目去除国际化存在问题的解决方法\" class=\"headerlink\" title=\"项目去除国际化存在问题的解决方法\"></a>项目去除国际化存在问题的解决方法</h3></li>\n</ol>\n<p><img src=\"https://cdn.jsdelivr.net/gh/wl2o2o/blogCdn/img/202307010940465.png\" alt=\"image-20230630231124235\"></p>\n<p>​    jest脚本命令中有<code>jest</code>不知道是否需要删掉，鱼皮的文件中没有出现，可能是跟某些版本有关，奇奇妙妙，记录一下</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/wl2o2o/blogCdn/img/202307010940466.png\" alt=\"image-20230630233743871\"></p>\n<ul>\n<li><h3 id=\"后端\"><a href=\"#后端\" class=\"headerlink\" title=\"后端\"></a>后端</h3></li>\n</ul>\n<ol start=\"3\">\n<li>后端项目初始化</li>\n</ol>\n<p>​    直接使用鱼总提供的万能模板<code>springboot-init</code>,改成项目的名字，然后全局搜索关键字进行替换</p>\n<p>​    连接数据库</p>\n<p>​    测试运行</p>\n<ol start=\"4\">\n<li>数据库库表设计</li>\n</ol>\n<p>​    <strong>接口信息表</strong></p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"># 数据库初始化<br># <span class=\"hljs-variable\">@author</span> <span class=\"hljs-operator\">&lt;</span>a href<span class=\"hljs-operator\">=</span>&quot;https://github.com/liyupi&quot;<span class=\"hljs-operator\">&gt;</span>程序员鱼皮<span class=\"hljs-operator\">&lt;</span><span class=\"hljs-operator\">/</span>a<span class=\"hljs-operator\">&gt;</span><br># <span class=\"hljs-variable\">@from</span> <span class=\"hljs-operator\">&lt;</span>a href<span class=\"hljs-operator\">=</span>&quot;https://yupi.icu&quot;<span class=\"hljs-operator\">&gt;</span>编程导航知识星球<span class=\"hljs-operator\">&lt;</span><span class=\"hljs-operator\">/</span>a<span class=\"hljs-operator\">&gt;</span><br><span class=\"hljs-comment\">-- 创建库</span><br><span class=\"hljs-keyword\">create</span> database if <span class=\"hljs-keyword\">not</span> <span class=\"hljs-keyword\">exists</span> myapi;<br><br><span class=\"hljs-comment\">-- 切换库</span><br>use myapi;<br><br><span class=\"hljs-comment\">-- 用户表</span><br><span class=\"hljs-keyword\">create</span> <span class=\"hljs-keyword\">table</span> if <span class=\"hljs-keyword\">not</span> <span class=\"hljs-keyword\">exists</span> <span class=\"hljs-keyword\">user</span><br>(<br>    id           <span class=\"hljs-type\">bigint</span> auto_increment comment <span class=\"hljs-string\">&#x27;id&#x27;</span> <span class=\"hljs-keyword\">primary</span> key,<br>    userName     <span class=\"hljs-type\">varchar</span>(<span class=\"hljs-number\">256</span>)                           <span class=\"hljs-keyword\">null</span> comment <span class=\"hljs-string\">&#x27;用户昵称&#x27;</span>,<br>    userAccount  <span class=\"hljs-type\">varchar</span>(<span class=\"hljs-number\">256</span>)                           <span class=\"hljs-keyword\">not</span> <span class=\"hljs-keyword\">null</span> comment <span class=\"hljs-string\">&#x27;账号&#x27;</span>,<br>    userAvatar   <span class=\"hljs-type\">varchar</span>(<span class=\"hljs-number\">1024</span>)                          <span class=\"hljs-keyword\">null</span> comment <span class=\"hljs-string\">&#x27;用户头像&#x27;</span>,<br>    gender       tinyint                                <span class=\"hljs-keyword\">null</span> comment <span class=\"hljs-string\">&#x27;性别&#x27;</span>,<br>    userRole     <span class=\"hljs-type\">varchar</span>(<span class=\"hljs-number\">256</span>) <span class=\"hljs-keyword\">default</span> <span class=\"hljs-string\">&#x27;user&#x27;</span>            <span class=\"hljs-keyword\">not</span> <span class=\"hljs-keyword\">null</span> comment <span class=\"hljs-string\">&#x27;用户角色：user / admin&#x27;</span>,<br>    userPassword <span class=\"hljs-type\">varchar</span>(<span class=\"hljs-number\">512</span>)                           <span class=\"hljs-keyword\">not</span> <span class=\"hljs-keyword\">null</span> comment <span class=\"hljs-string\">&#x27;密码&#x27;</span>,<br>    `accessKey` <span class=\"hljs-type\">varchar</span>(<span class=\"hljs-number\">512</span>) <span class=\"hljs-keyword\">not</span> <span class=\"hljs-keyword\">null</span> comment <span class=\"hljs-string\">&#x27;accessKey&#x27;</span>,<br>    `secretKey` <span class=\"hljs-type\">varchar</span>(<span class=\"hljs-number\">512</span>) <span class=\"hljs-keyword\">not</span> <span class=\"hljs-keyword\">null</span> comment <span class=\"hljs-string\">&#x27;secretKey&#x27;</span>,<br>    createTime   datetime     <span class=\"hljs-keyword\">default</span> <span class=\"hljs-built_in\">CURRENT_TIMESTAMP</span> <span class=\"hljs-keyword\">not</span> <span class=\"hljs-keyword\">null</span> comment <span class=\"hljs-string\">&#x27;创建时间&#x27;</span>,<br>    updateTime   datetime     <span class=\"hljs-keyword\">default</span> <span class=\"hljs-built_in\">CURRENT_TIMESTAMP</span> <span class=\"hljs-keyword\">not</span> <span class=\"hljs-keyword\">null</span> <span class=\"hljs-keyword\">on</span> <span class=\"hljs-keyword\">update</span> <span class=\"hljs-built_in\">CURRENT_TIMESTAMP</span> comment <span class=\"hljs-string\">&#x27;更新时间&#x27;</span>,<br>    isDelete     tinyint      <span class=\"hljs-keyword\">default</span> <span class=\"hljs-number\">0</span>                 <span class=\"hljs-keyword\">not</span> <span class=\"hljs-keyword\">null</span> comment <span class=\"hljs-string\">&#x27;是否删除&#x27;</span>,<br>    <span class=\"hljs-keyword\">constraint</span> uni_userAccount<br>        <span class=\"hljs-keyword\">unique</span> (userAccount)<br>) comment <span class=\"hljs-string\">&#x27;用户&#x27;</span>;<br><br><span class=\"hljs-comment\">-- 接口信息</span><br><span class=\"hljs-keyword\">create</span> <span class=\"hljs-keyword\">table</span> if <span class=\"hljs-keyword\">not</span> <span class=\"hljs-keyword\">exists</span> myapi.`interface_info`<br>(<br>    `id` <span class=\"hljs-type\">bigint</span> <span class=\"hljs-keyword\">not</span> <span class=\"hljs-keyword\">null</span> auto_increment comment <span class=\"hljs-string\">&#x27;主键&#x27;</span> <span class=\"hljs-keyword\">primary</span> key,<br>    `name` <span class=\"hljs-type\">varchar</span>(<span class=\"hljs-number\">256</span>) <span class=\"hljs-keyword\">not</span> <span class=\"hljs-keyword\">null</span> comment <span class=\"hljs-string\">&#x27;名称&#x27;</span>,<br>    `description` <span class=\"hljs-type\">varchar</span>(<span class=\"hljs-number\">256</span>) <span class=\"hljs-keyword\">null</span> comment <span class=\"hljs-string\">&#x27;描述&#x27;</span>,<br>    `url` <span class=\"hljs-type\">varchar</span>(<span class=\"hljs-number\">512</span>) <span class=\"hljs-keyword\">not</span> <span class=\"hljs-keyword\">null</span> comment <span class=\"hljs-string\">&#x27;接口地址&#x27;</span>,<br>    `requestHeader` text <span class=\"hljs-keyword\">null</span> comment <span class=\"hljs-string\">&#x27;请求头&#x27;</span>,<br>    `responseHeader` text <span class=\"hljs-keyword\">null</span> comment <span class=\"hljs-string\">&#x27;响应头&#x27;</span>,<br>    `status` <span class=\"hljs-type\">int</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-number\">0</span> <span class=\"hljs-keyword\">not</span> <span class=\"hljs-keyword\">null</span> comment <span class=\"hljs-string\">&#x27;接口状态（0-关闭，1-开启）&#x27;</span>,<br>    `<span class=\"hljs-keyword\">method</span>` <span class=\"hljs-type\">varchar</span>(<span class=\"hljs-number\">256</span>) <span class=\"hljs-keyword\">not</span> <span class=\"hljs-keyword\">null</span> comment <span class=\"hljs-string\">&#x27;请求类型&#x27;</span>,<br>    `userId` <span class=\"hljs-type\">bigint</span> <span class=\"hljs-keyword\">not</span> <span class=\"hljs-keyword\">null</span> comment <span class=\"hljs-string\">&#x27;创建人&#x27;</span>,<br>    `createTime` datetime <span class=\"hljs-keyword\">default</span> <span class=\"hljs-built_in\">CURRENT_TIMESTAMP</span> <span class=\"hljs-keyword\">not</span> <span class=\"hljs-keyword\">null</span> comment <span class=\"hljs-string\">&#x27;创建时间&#x27;</span>,<br>    `updateTime` datetime <span class=\"hljs-keyword\">default</span> <span class=\"hljs-built_in\">CURRENT_TIMESTAMP</span> <span class=\"hljs-keyword\">not</span> <span class=\"hljs-keyword\">null</span> <span class=\"hljs-keyword\">on</span> <span class=\"hljs-keyword\">update</span> <span class=\"hljs-built_in\">CURRENT_TIMESTAMP</span> comment <span class=\"hljs-string\">&#x27;更新时间&#x27;</span>,<br>    `isDelete` tinyint <span class=\"hljs-keyword\">default</span> <span class=\"hljs-number\">0</span> <span class=\"hljs-keyword\">not</span> <span class=\"hljs-keyword\">null</span> comment <span class=\"hljs-string\">&#x27;是否删除(0-未删, 1-已删)&#x27;</span><br>) comment  <span class=\"hljs-string\">&#x27;接口信息&#x27;</span>;<br><br><span class=\"hljs-comment\">-- 用户调用接口关系表</span><br><span class=\"hljs-keyword\">create</span> <span class=\"hljs-keyword\">table</span> if <span class=\"hljs-keyword\">not</span> <span class=\"hljs-keyword\">exists</span> myapi.`user_interface_info`<br>(<br>    `id` <span class=\"hljs-type\">bigint</span> <span class=\"hljs-keyword\">not</span> <span class=\"hljs-keyword\">null</span> auto_increment comment <span class=\"hljs-string\">&#x27;主键&#x27;</span> <span class=\"hljs-keyword\">primary</span> key,<br>    `userId` <span class=\"hljs-type\">bigint</span> <span class=\"hljs-keyword\">not</span> <span class=\"hljs-keyword\">null</span> comment <span class=\"hljs-string\">&#x27;调用用户 id&#x27;</span>,<br>    `interfaceInfoId` <span class=\"hljs-type\">bigint</span> <span class=\"hljs-keyword\">not</span> <span class=\"hljs-keyword\">null</span> comment <span class=\"hljs-string\">&#x27;接口 id&#x27;</span>,<br>    `totalNum` <span class=\"hljs-type\">int</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-number\">0</span> <span class=\"hljs-keyword\">not</span> <span class=\"hljs-keyword\">null</span> comment <span class=\"hljs-string\">&#x27;总调用次数&#x27;</span>,<br>    `leftNum` <span class=\"hljs-type\">int</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-number\">0</span> <span class=\"hljs-keyword\">not</span> <span class=\"hljs-keyword\">null</span> comment <span class=\"hljs-string\">&#x27;剩余调用次数&#x27;</span>,<br>    `status` <span class=\"hljs-type\">int</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-number\">0</span> <span class=\"hljs-keyword\">not</span> <span class=\"hljs-keyword\">null</span> comment <span class=\"hljs-string\">&#x27;0-正常，1-禁用&#x27;</span>,<br>    `createTime` datetime <span class=\"hljs-keyword\">default</span> <span class=\"hljs-built_in\">CURRENT_TIMESTAMP</span> <span class=\"hljs-keyword\">not</span> <span class=\"hljs-keyword\">null</span> comment <span class=\"hljs-string\">&#x27;创建时间&#x27;</span>,<br>    `updateTime` datetime <span class=\"hljs-keyword\">default</span> <span class=\"hljs-built_in\">CURRENT_TIMESTAMP</span> <span class=\"hljs-keyword\">not</span> <span class=\"hljs-keyword\">null</span> <span class=\"hljs-keyword\">on</span> <span class=\"hljs-keyword\">update</span> <span class=\"hljs-built_in\">CURRENT_TIMESTAMP</span> comment <span class=\"hljs-string\">&#x27;更新时间&#x27;</span>,<br>    `isDelete` tinyint <span class=\"hljs-keyword\">default</span> <span class=\"hljs-number\">0</span> <span class=\"hljs-keyword\">not</span> <span class=\"hljs-keyword\">null</span> comment <span class=\"hljs-string\">&#x27;是否删除(0-未删, 1-已删)&#x27;</span><br>) comment <span class=\"hljs-string\">&#x27;用户调用接口关系&#x27;</span>;<br><br><span class=\"hljs-keyword\">insert</span> <span class=\"hljs-keyword\">into</span> myapi.`interface_info` (`name`, `description`, `url`, `requestHeader`, `responseHeader`, `status`, `<span class=\"hljs-keyword\">method</span>`, `userId`) <span class=\"hljs-keyword\">values</span> (<span class=\"hljs-string\">&#x27;许擎宇&#x27;</span>, <span class=\"hljs-string\">&#x27;薛聪健&#x27;</span>, <span class=\"hljs-string\">&#x27;www.cary-king.net&#x27;</span>, <span class=\"hljs-string\">&#x27;潘博涛&#x27;</span>, <span class=\"hljs-string\">&#x27;谭聪健&#x27;</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-string\">&#x27;石炫明&#x27;</span>, <span class=\"hljs-number\">9500534531</span>);<br><span class=\"hljs-keyword\">insert</span> <span class=\"hljs-keyword\">into</span> myapi.`interface_info` (`name`, `description`, `url`, `requestHeader`, `responseHeader`, `status`, `<span class=\"hljs-keyword\">method</span>`, `userId`) <span class=\"hljs-keyword\">values</span> (<span class=\"hljs-string\">&#x27;陆弘文&#x27;</span>, <span class=\"hljs-string\">&#x27;白志强&#x27;</span>, <span class=\"hljs-string\">&#x27;www.leslee-kuhn.net&#x27;</span>, <span class=\"hljs-string\">&#x27;潘懿轩&#x27;</span>, <span class=\"hljs-string\">&#x27;马鸿涛&#x27;</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-string\">&#x27;陈峻熙&#x27;</span>, <span class=\"hljs-number\">3982575846</span>);<br><span class=\"hljs-keyword\">insert</span> <span class=\"hljs-keyword\">into</span> myapi.`interface_info` (`name`, `description`, `url`, `requestHeader`, `responseHeader`, `status`, `<span class=\"hljs-keyword\">method</span>`, `userId`) <span class=\"hljs-keyword\">values</span> (<span class=\"hljs-string\">&#x27;毛建辉&#x27;</span>, <span class=\"hljs-string\">&#x27;罗文&#x27;</span>, <span class=\"hljs-string\">&#x27;www.rosaria-kilback.io&#x27;</span>, <span class=\"hljs-string\">&#x27;冯子默&#x27;</span>, <span class=\"hljs-string\">&#x27;彭哲瀚&#x27;</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-string\">&#x27;赵远航&#x27;</span>, <span class=\"hljs-number\">121776355</span>);<br><span class=\"hljs-keyword\">insert</span> <span class=\"hljs-keyword\">into</span> myapi.`interface_info` (`name`, `description`, `url`, `requestHeader`, `responseHeader`, `status`, `<span class=\"hljs-keyword\">method</span>`, `userId`) <span class=\"hljs-keyword\">values</span> (<span class=\"hljs-string\">&#x27;彭雨泽&#x27;</span>, <span class=\"hljs-string\">&#x27;蔡煜祺&#x27;</span>, <span class=\"hljs-string\">&#x27;www.norris-bergstrom.biz&#x27;</span>, <span class=\"hljs-string\">&#x27;董思源&#x27;</span>, <span class=\"hljs-string\">&#x27;田晓博&#x27;</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-string\">&#x27;潘擎宇&#x27;</span>, <span class=\"hljs-number\">740</span>);<br><span class=\"hljs-keyword\">insert</span> <span class=\"hljs-keyword\">into</span> myapi.`interface_info` (`name`, `description`, `url`, `requestHeader`, `responseHeader`, `status`, `<span class=\"hljs-keyword\">method</span>`, `userId`) <span class=\"hljs-keyword\">values</span> (<span class=\"hljs-string\">&#x27;傅志强&#x27;</span>, <span class=\"hljs-string\">&#x27;陈梓晨&#x27;</span>, <span class=\"hljs-string\">&#x27;www.jordan-reinger.com&#x27;</span>, <span class=\"hljs-string\">&#x27;金志强&#x27;</span>, <span class=\"hljs-string\">&#x27;熊锦程&#x27;</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-string\">&#x27;邓睿渊&#x27;</span>, <span class=\"hljs-number\">35542559</span>);<br><span class=\"hljs-keyword\">insert</span> <span class=\"hljs-keyword\">into</span> myapi.`interface_info` (`name`, `description`, `url`, `requestHeader`, `responseHeader`, `status`, `<span class=\"hljs-keyword\">method</span>`, `userId`) <span class=\"hljs-keyword\">values</span> (<span class=\"hljs-string\">&#x27;吕黎昕&#x27;</span>, <span class=\"hljs-string\">&#x27;孔越彬&#x27;</span>, <span class=\"hljs-string\">&#x27;www.fe-okon.info&#x27;</span>, <span class=\"hljs-string\">&#x27;万伟宸&#x27;</span>, <span class=\"hljs-string\">&#x27;林昊然&#x27;</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-string\">&#x27;孟荣轩&#x27;</span>, <span class=\"hljs-number\">1445</span>);<br><span class=\"hljs-keyword\">insert</span> <span class=\"hljs-keyword\">into</span> myapi.`interface_info` (`name`, `description`, `url`, `requestHeader`, `responseHeader`, `status`, `<span class=\"hljs-keyword\">method</span>`, `userId`) <span class=\"hljs-keyword\">values</span> (<span class=\"hljs-string\">&#x27;夏雪松&#x27;</span>, <span class=\"hljs-string\">&#x27;许子骞&#x27;</span>, <span class=\"hljs-string\">&#x27;www.lashawna-legros.co&#x27;</span>, <span class=\"hljs-string\">&#x27;蔡昊然&#x27;</span>, <span class=\"hljs-string\">&#x27;胡鹏涛&#x27;</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-string\">&#x27;钟立辉&#x27;</span>, <span class=\"hljs-number\">34075514</span>);<br><span class=\"hljs-keyword\">insert</span> <span class=\"hljs-keyword\">into</span> myapi.`interface_info` (`name`, `description`, `url`, `requestHeader`, `responseHeader`, `status`, `<span class=\"hljs-keyword\">method</span>`, `userId`) <span class=\"hljs-keyword\">values</span> (<span class=\"hljs-string\">&#x27;严钰轩&#x27;</span>, <span class=\"hljs-string\">&#x27;阎志泽&#x27;</span>, <span class=\"hljs-string\">&#x27;www.kay-funk.biz&#x27;</span>, <span class=\"hljs-string\">&#x27;莫皓轩&#x27;</span>, <span class=\"hljs-string\">&#x27;郭黎昕&#x27;</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-string\">&#x27;龚天宇&#x27;</span>, <span class=\"hljs-number\">70956</span>);<br><span class=\"hljs-keyword\">insert</span> <span class=\"hljs-keyword\">into</span> myapi.`interface_info` (`name`, `description`, `url`, `requestHeader`, `responseHeader`, `status`, `<span class=\"hljs-keyword\">method</span>`, `userId`) <span class=\"hljs-keyword\">values</span> (<span class=\"hljs-string\">&#x27;萧嘉懿&#x27;</span>, <span class=\"hljs-string\">&#x27;曹熠彤&#x27;</span>, <span class=\"hljs-string\">&#x27;www.margarette-lindgren.biz&#x27;</span>, <span class=\"hljs-string\">&#x27;田泽洋&#x27;</span>, <span class=\"hljs-string\">&#x27;邓睿渊&#x27;</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-string\">&#x27;梁志强&#x27;</span>, <span class=\"hljs-number\">98</span>);<br><span class=\"hljs-keyword\">insert</span> <span class=\"hljs-keyword\">into</span> myapi.`interface_info` (`name`, `description`, `url`, `requestHeader`, `responseHeader`, `status`, `<span class=\"hljs-keyword\">method</span>`, `userId`) <span class=\"hljs-keyword\">values</span> (<span class=\"hljs-string\">&#x27;杜驰&#x27;</span>, <span class=\"hljs-string\">&#x27;冯思源&#x27;</span>, <span class=\"hljs-string\">&#x27;www.vashti-auer.org&#x27;</span>, <span class=\"hljs-string\">&#x27;黎健柏&#x27;</span>, <span class=\"hljs-string\">&#x27;武博文&#x27;</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-string\">&#x27;李伟宸&#x27;</span>, <span class=\"hljs-number\">9</span>);<br><span class=\"hljs-keyword\">insert</span> <span class=\"hljs-keyword\">into</span> myapi.`interface_info` (`name`, `description`, `url`, `requestHeader`, `responseHeader`, `status`, `<span class=\"hljs-keyword\">method</span>`, `userId`) <span class=\"hljs-keyword\">values</span> (<span class=\"hljs-string\">&#x27;史金鑫&#x27;</span>, <span class=\"hljs-string\">&#x27;蔡鹏涛&#x27;</span>, <span class=\"hljs-string\">&#x27;www.diann-keebler.org&#x27;</span>, <span class=\"hljs-string\">&#x27;徐烨霖&#x27;</span>, <span class=\"hljs-string\">&#x27;阎建辉&#x27;</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-string\">&#x27;李烨伟&#x27;</span>, <span class=\"hljs-number\">125</span>);<br><span class=\"hljs-keyword\">insert</span> <span class=\"hljs-keyword\">into</span> myapi.`interface_info` (`name`, `description`, `url`, `requestHeader`, `responseHeader`, `status`, `<span class=\"hljs-keyword\">method</span>`, `userId`) <span class=\"hljs-keyword\">values</span> (<span class=\"hljs-string\">&#x27;林炫明&#x27;</span>, <span class=\"hljs-string\">&#x27;贾旭尧&#x27;</span>, <span class=\"hljs-string\">&#x27;www.dotty-kuvalis.io&#x27;</span>, <span class=\"hljs-string\">&#x27;梁雨泽&#x27;</span>, <span class=\"hljs-string\">&#x27;龙伟泽&#x27;</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-string\">&#x27;许智渊&#x27;</span>, <span class=\"hljs-number\">79998</span>);<br><span class=\"hljs-keyword\">insert</span> <span class=\"hljs-keyword\">into</span> myapi.`interface_info` (`name`, `description`, `url`, `requestHeader`, `responseHeader`, `status`, `<span class=\"hljs-keyword\">method</span>`, `userId`) <span class=\"hljs-keyword\">values</span> (<span class=\"hljs-string\">&#x27;何钰轩&#x27;</span>, <span class=\"hljs-string\">&#x27;赖智宸&#x27;</span>, <span class=\"hljs-string\">&#x27;www.andy-adams.net&#x27;</span>, <span class=\"hljs-string\">&#x27;崔思淼&#x27;</span>, <span class=\"hljs-string\">&#x27;白鸿煊&#x27;</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-string\">&#x27;邵振家&#x27;</span>, <span class=\"hljs-number\">7167482751</span>);<br><span class=\"hljs-keyword\">insert</span> <span class=\"hljs-keyword\">into</span> myapi.`interface_info` (`name`, `description`, `url`, `requestHeader`, `responseHeader`, `status`, `<span class=\"hljs-keyword\">method</span>`, `userId`) <span class=\"hljs-keyword\">values</span> (<span class=\"hljs-string\">&#x27;魏志强&#x27;</span>, <span class=\"hljs-string\">&#x27;于立诚&#x27;</span>, <span class=\"hljs-string\">&#x27;www.ione-aufderhar.biz&#x27;</span>, <span class=\"hljs-string\">&#x27;朱懿轩&#x27;</span>, <span class=\"hljs-string\">&#x27;万智渊&#x27;</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-string\">&#x27;唐昊强&#x27;</span>, <span class=\"hljs-number\">741098</span>);<br><span class=\"hljs-keyword\">insert</span> <span class=\"hljs-keyword\">into</span> myapi.`interface_info` (`name`, `description`, `url`, `requestHeader`, `responseHeader`, `status`, `<span class=\"hljs-keyword\">method</span>`, `userId`) <span class=\"hljs-keyword\">values</span> (<span class=\"hljs-string\">&#x27;严君浩&#x27;</span>, <span class=\"hljs-string\">&#x27;金胤祥&#x27;</span>, <span class=\"hljs-string\">&#x27;www.duane-boyle.org&#x27;</span>, <span class=\"hljs-string\">&#x27;雷昊焱&#x27;</span>, <span class=\"hljs-string\">&#x27;侯思聪&#x27;</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-string\">&#x27;郝思&#x27;</span>, <span class=\"hljs-number\">580514</span>);<br><span class=\"hljs-keyword\">insert</span> <span class=\"hljs-keyword\">into</span> myapi.`interface_info` (`name`, `description`, `url`, `requestHeader`, `responseHeader`, `status`, `<span class=\"hljs-keyword\">method</span>`, `userId`) <span class=\"hljs-keyword\">values</span> (<span class=\"hljs-string\">&#x27;姚皓轩&#x27;</span>, <span class=\"hljs-string\">&#x27;金鹏&#x27;</span>, <span class=\"hljs-string\">&#x27;www.lyda-klein.biz&#x27;</span>, <span class=\"hljs-string\">&#x27;杜昊强&#x27;</span>, <span class=\"hljs-string\">&#x27;邵志泽&#x27;</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-string\">&#x27;冯鸿涛&#x27;</span>, <span class=\"hljs-number\">6546</span>);<br><span class=\"hljs-keyword\">insert</span> <span class=\"hljs-keyword\">into</span> myapi.`interface_info` (`name`, `description`, `url`, `requestHeader`, `responseHeader`, `status`, `<span class=\"hljs-keyword\">method</span>`, `userId`) <span class=\"hljs-keyword\">values</span> (<span class=\"hljs-string\">&#x27;廖驰&#x27;</span>, <span class=\"hljs-string\">&#x27;沈泽洋&#x27;</span>, <span class=\"hljs-string\">&#x27;www.consuelo-sipes.info&#x27;</span>, <span class=\"hljs-string\">&#x27;彭昊然&#x27;</span>, <span class=\"hljs-string\">&#x27;邓耀杰&#x27;</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-string\">&#x27;周彬&#x27;</span>, <span class=\"hljs-number\">7761037</span>);<br><span class=\"hljs-keyword\">insert</span> <span class=\"hljs-keyword\">into</span> myapi.`interface_info` (`name`, `description`, `url`, `requestHeader`, `responseHeader`, `status`, `<span class=\"hljs-keyword\">method</span>`, `userId`) <span class=\"hljs-keyword\">values</span> (<span class=\"hljs-string\">&#x27;赖智渊&#x27;</span>, <span class=\"hljs-string\">&#x27;邓志泽&#x27;</span>, <span class=\"hljs-string\">&#x27;www.emerson-mann.co&#x27;</span>, <span class=\"hljs-string\">&#x27;熊明哲&#x27;</span>, <span class=\"hljs-string\">&#x27;贺哲瀚&#x27;</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-string\">&#x27;田鹏&#x27;</span>, <span class=\"hljs-number\">381422</span>);<br><span class=\"hljs-keyword\">insert</span> <span class=\"hljs-keyword\">into</span> myapi.`interface_info` (`name`, `description`, `url`, `requestHeader`, `responseHeader`, `status`, `<span class=\"hljs-keyword\">method</span>`, `userId`) <span class=\"hljs-keyword\">values</span> (<span class=\"hljs-string\">&#x27;许涛&#x27;</span>, <span class=\"hljs-string\">&#x27;陆致远&#x27;</span>, <span class=\"hljs-string\">&#x27;www.vella-ankunding.name&#x27;</span>, <span class=\"hljs-string\">&#x27;贾哲瀚&#x27;</span>, <span class=\"hljs-string\">&#x27;莫昊焱&#x27;</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-string\">&#x27;袁越彬&#x27;</span>, <span class=\"hljs-number\">4218096</span>);<br><span class=\"hljs-keyword\">insert</span> <span class=\"hljs-keyword\">into</span> myapi.`interface_info` (`name`, `description`, `url`, `requestHeader`, `responseHeader`, `status`, `<span class=\"hljs-keyword\">method</span>`, `userId`) <span class=\"hljs-keyword\">values</span> (<span class=\"hljs-string\">&#x27;吕峻熙&#x27;</span>, <span class=\"hljs-string\">&#x27;沈鹏飞&#x27;</span>, <span class=\"hljs-string\">&#x27;www.shari-reichel.org&#x27;</span>, <span class=\"hljs-string\">&#x27;郭鸿煊&#x27;</span>, <span class=\"hljs-string\">&#x27;覃烨霖&#x27;</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-string\">&#x27;熊黎昕&#x27;</span>, <span class=\"hljs-number\">493</span>);<br><br></code></pre></td></tr></table></figure>\n\n\n\n<blockquote>\n<p>留一个小bug，数据库建表语句直接套用的最终建表语句，user表中涉及到两个关于key的字段，手动改成了可以为空，若有问题，后续再做出更改</p>\n</blockquote>\n<blockquote>\n<p>利用<code>MyBatisX</code>插件生成接口管理的增删改查代码</p>\n</blockquote>\n<p>将生成的代码逻辑复制到项目的dao、service、mapper包里，</p>\n<p>然后还剩一个controller层，直接复制一份模板中的controller层的代码，进行复用</p>\n<p>注意此时模糊查询使用的字段不是content，而是description，进行相应的更改。</p>\n<p>此时，增删改查操作已完成，就这么简单 </p>\n<p>跑通后端</p>\n<ul>\n<li><h3 id=\"前端-1\"><a href=\"#前端-1\" class=\"headerlink\" title=\"前端\"></a>前端</h3></li>\n</ul>\n<p>使用oneapi插件自动生成（openapi规范）</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/wl2o2o/blogCdn/img/202307012353984.png\" alt=\"image-20230701235258820\"></p>\n<blockquote>\n<p>先前，我们登陆时是采用的start假数据进行登录，此时使用dev，登陆页面是存在问题的，因为脚手架自动生成的页面会强制要求登录，此时的登录接口与我们oneapi自动生成的接口对应不上，需要手动进行更改User》》Login》》index.tsx</p>\n</blockquote>\n<p>因为没有开发注册页面，可以从注册中心项目中复制一个过来</p>\n<p>为了便捷的进行开发，先从swagger注册一个账号，然后登录发现没有进行跳转，通过分析得出，是因为前端没有记录用户的登录状态，所以要进一步进行完善，在typings.d.ts中进行定义全局登录态</p>\n<p>改造页面，将前端展示的表格，用来展示自己的数据</p>\n<h2 id=\"Day02-接口调用开发（前端）\"><a href=\"#Day02-接口调用开发（前端）\" class=\"headerlink\" title=\"Day02 接口调用开发（前端）\"></a>Day02 接口调用开发（前端）</h2><blockquote>\n<p>首先发现一个问题，使用后端swagger进行user密码更改的时候，密码没有进行加密，会导致前端进行校验的时候返回用户名或者密码不正确的信息</p>\n</blockquote>\n<ul>\n<li><h3 id=\"优化前端展示页面（改路由，先不删）\"><a href=\"#优化前端展示页面（改路由，先不删）\" class=\"headerlink\" title=\"优化前端展示页面（改路由，先不删）\"></a>优化前端展示页面（改路由，先不删）</h3><ul>\n<li>保持前后端组件名一致</li>\n<li>优化页面代码</li>\n<li>首页没有页面，后续进行开发一个非管理员用户可以看到的页面</li>\n<li>调整导航栏的位置，可以先使用antDesignPro框架提供的切换导航布局小设置</li>\n</ul>\n</li>\n<li><h3 id=\"新建模态框的编写真的很搞心态，最后的原因竟然是因为一个小的错误（静下心来）（血泪教训，做完项目过一遍react）\"><a href=\"#新建模态框的编写真的很搞心态，最后的原因竟然是因为一个小的错误（静下心来）（血泪教训，做完项目过一遍react）\" class=\"headerlink\" title=\"新建模态框的编写真的很搞心态，最后的原因竟然是因为一个小的错误（静下心来）（血泪教训，做完项目过一遍react）\"></a>新建模态框的编写真的很搞心态，最后的原因竟然是因为一个小的错误（静下心来）（血泪教训，做完项目过一遍react）</h3></li>\n<li><h3 id=\"完善修改框\"><a href=\"#完善修改框\" class=\"headerlink\" title=\"完善修改框\"></a>完善修改框</h3><ul>\n<li><p>此处设计到React的核心知识点，也是重中之重（useEffect、useRef）</p>\n</li>\n<li><p>```tsx<br>const formRef = useRef<ProFormInstance>();</p>\n<p>useEffect(() =&gt; {<br>  if(formRef){</p>\n<pre><code>formRef.current?.setFieldsValue(values);\n</code></pre>\n<p>  }<br>}, [values])</p>\n<p>return (</p>\n<pre><code>&lt;Modal visible=&#123;visible&#125; footer=&#123;null&#125; onCancel=&#123;() =&gt; onCancel?.()&#125;&gt;\n  &lt;ProTable\n    type=&quot;form&quot;\n    columns=&#123;columns&#125;\n    // 因为这里使用的form组件，只会初始化一次，所以会造成点击修改按钮进行修改的话，数据是不会变的\n    // form=&#123;&#123;\n            //   initialValues: values\n            // &#125;&#125;\n    \n    // 所以此处用到了监听\n    formRef=&#123;formRef&#125;\n    \n    onSubmit=&#123;async (value) =&gt; &#123;\n      onSubmit?.(value);\n    &#125;&#125;\n  /&gt;\n&lt;/Modal&gt;\n</code></pre>\n<p>  );</p>\n<figure class=\"highlight node-repl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br><span class=\"line\">212</span><br><span class=\"line\">213</span><br><span class=\"line\">214</span><br><span class=\"line\">215</span><br><span class=\"line\">216</span><br><span class=\"line\">217</span><br><span class=\"line\">218</span><br><span class=\"line\">219</span><br><span class=\"line\">220</span><br><span class=\"line\">221</span><br><span class=\"line\">222</span><br><span class=\"line\">223</span><br><span class=\"line\">224</span><br><span class=\"line\">225</span><br><span class=\"line\">226</span><br><span class=\"line\">227</span><br><span class=\"line\">228</span><br><span class=\"line\">229</span><br><span class=\"line\">230</span><br><span class=\"line\">231</span><br><span class=\"line\">232</span><br><span class=\"line\">233</span><br><span class=\"line\">234</span><br><span class=\"line\">235</span><br><span class=\"line\">236</span><br><span class=\"line\">237</span><br><span class=\"line\">238</span><br><span class=\"line\">239</span><br><span class=\"line\">240</span><br><span class=\"line\">241</span><br><span class=\"line\">242</span><br><span class=\"line\">243</span><br><span class=\"line\">244</span><br><span class=\"line\">245</span><br><span class=\"line\">246</span><br><span class=\"line\">247</span><br><span class=\"line\">248</span><br><span class=\"line\">249</span><br><span class=\"line\">250</span><br><span class=\"line\">251</span><br><span class=\"line\">252</span><br><span class=\"line\">253</span><br><span class=\"line\">254</span><br><span class=\"line\">255</span><br><span class=\"line\">256</span><br><span class=\"line\">257</span><br><span class=\"line\">258</span><br><span class=\"line\">259</span><br><span class=\"line\">260</span><br><span class=\"line\">261</span><br><span class=\"line\">262</span><br><span class=\"line\">263</span><br><span class=\"line\">264</span><br><span class=\"line\">265</span><br><span class=\"line\">266</span><br><span class=\"line\">267</span><br><span class=\"line\">268</span><br><span class=\"line\">269</span><br><span class=\"line\">270</span><br><span class=\"line\">271</span><br><span class=\"line\">272</span><br><span class=\"line\">273</span><br><span class=\"line\">274</span><br><span class=\"line\">275</span><br><span class=\"line\">276</span><br><span class=\"line\">277</span><br><span class=\"line\">278</span><br><span class=\"line\">279</span><br><span class=\"line\">280</span><br><span class=\"line\">281</span><br><span class=\"line\">282</span><br><span class=\"line\">283</span><br><span class=\"line\">284</span><br><span class=\"line\">285</span><br><span class=\"line\">286</span><br><span class=\"line\">287</span><br><span class=\"line\">288</span><br><span class=\"line\">289</span><br><span class=\"line\">290</span><br><span class=\"line\">291</span><br><span class=\"line\">292</span><br><span class=\"line\">293</span><br><span class=\"line\">294</span><br><span class=\"line\">295</span><br><span class=\"line\">296</span><br><span class=\"line\">297</span><br><span class=\"line\">298</span><br><span class=\"line\">299</span><br><span class=\"line\">300</span><br><span class=\"line\">301</span><br><span class=\"line\">302</span><br><span class=\"line\">303</span><br><span class=\"line\">304</span><br><span class=\"line\">305</span><br><span class=\"line\">306</span><br><span class=\"line\">307</span><br><span class=\"line\">308</span><br><span class=\"line\">309</span><br><span class=\"line\">310</span><br><span class=\"line\">311</span><br><span class=\"line\">312</span><br><span class=\"line\">313</span><br><span class=\"line\">314</span><br><span class=\"line\">315</span><br><span class=\"line\">316</span><br><span class=\"line\">317</span><br><span class=\"line\">318</span><br><span class=\"line\">319</span><br><span class=\"line\">320</span><br><span class=\"line\">321</span><br><span class=\"line\">322</span><br><span class=\"line\">323</span><br><span class=\"line\">324</span><br><span class=\"line\">325</span><br><span class=\"line\">326</span><br><span class=\"line\">327</span><br><span class=\"line\">328</span><br><span class=\"line\">329</span><br><span class=\"line\">330</span><br><span class=\"line\">331</span><br><span class=\"line\">332</span><br><span class=\"line\">333</span><br><span class=\"line\">334</span><br><span class=\"line\">335</span><br><span class=\"line\">336</span><br><span class=\"line\">337</span><br><span class=\"line\">338</span><br><span class=\"line\">339</span><br><span class=\"line\">340</span><br><span class=\"line\">341</span><br><span class=\"line\">342</span><br><span class=\"line\">343</span><br><span class=\"line\">344</span><br><span class=\"line\">345</span><br><span class=\"line\">346</span><br><span class=\"line\">347</span><br><span class=\"line\">348</span><br><span class=\"line\">349</span><br><span class=\"line\">350</span><br><span class=\"line\">351</span><br><span class=\"line\">352</span><br><span class=\"line\">353</span><br><span class=\"line\">354</span><br><span class=\"line\">355</span><br><span class=\"line\">356</span><br><span class=\"line\">357</span><br><span class=\"line\">358</span><br><span class=\"line\">359</span><br><span class=\"line\">360</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs node-repl\"><br>  * &gt; 此处有Bug，后端报空指针<br><br><br>* ### 完善删除框<br><br>  * 仿照以上步骤完成<br><br>  * &gt; 此时发现进行相关操作之后数据不会自动更新，所以我们引入actionRef，它可以拿到proTable的控制权，使用actionRef.current?.reload()<br><br><br><br><br><br>### 模拟接口项目（smartapi-interface）（后端）<br><br>提供三个模拟接口<br><br>1. GET接口<br>2. POST接口（url传参）<br>3. POST接口（Restful）<br><br><br><br><br><br>### 开始开发模拟接口项目部分<br><br>采用创建几个controller控制层小接口，前端传参进行调用，但是这样不符合逻辑，所以我们要通过后端来进行传参！<br><br><br><br>### 开发调用接口<br><br>几种HTTP调用方式<br><br>\t1. HttpClient<br>\t1. RestTemplete<br>\t1. 工具（OKHttp、HuTool）<br><br>这里我们使用HuTool来进行调用[HuTool](https://hutool.cn/docs/#/)<br><br><br><br>参考文档是一个好东西，利用好<br><br><br><br>那么现在已经开发好调用接口了，但是用户调用你的接口，或者黑客黑你的接口，所以需要对调用者进行一个调用限制，那么如何加以限制？<br><br>这时可以联想一下我们平时调用第三方接口时，都会有一些key<br><br><br><br>### API 签名认证（客户端与服务端有点迷惑，后续捋顺）<br><br><br><br>**本质：**<br><br>1. 签发签名<br><br>\t2. 使用签名(校验签名)<br><br><br><br>**为什么需要？**<br><br>1. 保证安全性，不能随便一个人就可以调用<br><br><br><br>**怎么实现？（复杂、无序、无规律）**<br><br>通过http request header头传递参数。<br><br>参数1：assesKey：调用的标识（一串无规则字符串） User A、B<br><br>参数2：secretKey：相当于密码<br><br>也就是用户名和密钥，区别就是ak、sk是无状态的<br><br>在服务端数据库表中新增以上两个字段，用户客户端进行校验。<br><br><br><br><br><br>但是这样的方法时容易被拦截的，不能把密钥直接在服务器之间进行传递，要进行加密。所以要对密码进一步进行加密。<br><br><br><br>参数3：用户请求参数（更严格）<br><br><br><br>参数4：sign<br><br>加密方式：对称机密、非对称加密、不可解密加密（MD5）<br><br><br><br>用户参数 + 密钥 ==》 **签名生成算法** ==》不可解密的值<br><br>wl + abcdefgh ==》afdasfafszv（通过签名算法加密）<br><br>那么如何知道这个签名是否正确？<br><br>**服务端会通过用一摸一样的参数和算法去生成签名，只要和用户才能属的签名一致，则正确!**<br><br><br><br><br><br>**怎么防重放？**<br><br>参数5：加nonce随机数，保证只能用一次，但是服务端也要保存随机数<br><br>参数6：timestamp时间戳（加上时间戳可以保证随机数可以清除）<br><br>**API签名认证是一个很灵活的设计，具体要有哪些参数、参数名一定要根据实际场景来（比如userId、appId、version、固定值等）**<br><br><br><br>思考：难道开发者每次调用接口都需要自己来写签名算法吗？<br><br><br><br><br><br><br><br><br><br>### 开发一个简单易用的SDK<br><br><br><br>理想情况：开发者只需要关心调用哪些接口、传递哪些参数，就跟调用自己的代码一样简单。<br><br><br><br>开发stater的好处：<br><br>1. 开发者引入之后，可以直接在application.yml中写配置，自动创建客户端。<br><br><br><br>### 创建SDK项目（开发starter）（简历亮点）<br><br>引入依赖：<br><br>1. lombook<br>2. Spring Configuration Processor（自动生成配置文件写代码的提示）<br><br><br><br>改造pom依赖，一定要删掉build标签内的代码，因为我们在进行构建依赖包，不是要直接运行的jar的项目<br><br><br><br><br><br>尝试把打好的包发布到maven中<br><br><br><br><br><br><br><br><br><br>## Day03 接口保护与优化<br><br><br><br><span class=\"hljs-meta prompt_\">&gt;</span> <span class=\"language-javascript\">此时，我们发现鱼总的后端项目模块中已经包含前面单独创建好的<span class=\"hljs-variable constant_\">SDK</span>和interface模拟接口项目了，那么我们如何把这两个添加到后端的项目中呢？</span><br><span class=\"hljs-meta prompt_\">&gt;</span><br><span class=\"hljs-meta prompt_\">&gt;</span> <span class=\"language-javascript\">方案一：</span><br><span class=\"hljs-meta prompt_\">&gt;</span><br><span class=\"hljs-meta prompt_\">&gt;</span> <span class=\"language-javascript\">​\t受尚医通项目的影响，我想应该可以通过增加子模块的方法拉进行添加，但是添加之后好像是不太行，跟鱼总的不一样，这种方法应该是可以使多个项目在同一个窗口中打开（解决了之前我的疑虑）</span><br><span class=\"hljs-meta prompt_\">&gt;</span><br><span class=\"hljs-meta prompt_\">&gt;</span> <span class=\"language-javascript\">方案二：</span><br><span class=\"hljs-meta prompt_\">&gt;</span><br><span class=\"hljs-meta prompt_\">&gt;</span> <span class=\"language-javascript\">​\t我们看到鱼总的后端项目中，另外两个项目（<span class=\"hljs-variable constant_\">SDK</span>和interface）是两个目录的标识，于是我就直接复制粘贴到后端项目的文件夹中了，然后<span class=\"hljs-title class_\">Java</span>源文件会变成红J，可以通过右键rsc下main下的<span class=\"hljs-title class_\">Java</span>文件夹，然后mark <span class=\"hljs-title class_\">Directory</span> <span class=\"hljs-keyword\">as</span>--》<span class=\"hljs-title class_\">Sources</span> <span class=\"hljs-title class_\">Root</span>，将<span class=\"hljs-title class_\">Java</span>文件夹标记为源码根目录，如图所示：</span><br><span class=\"hljs-meta prompt_\">&gt;</span><br><span class=\"hljs-meta prompt_\">&gt;</span> <span class=\"language-javascript\">![image-<span class=\"hljs-number\">20230708205543307</span>](<span class=\"hljs-attr\">https</span>:<span class=\"hljs-comment\">//cdn.jsdelivr.net/gh/wl2o2o/blogCdn/img/202307092023528.png)</span></span><br><span class=\"hljs-meta prompt_\">&gt;</span><br><span class=\"hljs-meta prompt_\">&gt;</span> <span class=\"language-javascript\">然后我们发现maven的pom依赖文件的图标也不对，也通过桐言的方法，右键--》add maven project标记为maven项目，大功告成！</span><br><br>1.开发接口发布/下线的功能（管理员）<br><br>2.前端浏览接口，查看 接口文档，申请签名（注册）<br><br>3.在线测试（用户）<br><br>4.统一用户调用接口次数<br><br>5.优化系统-API网关<br><br>### 开发接口发布/下线的功能（仅管理员） <br><br><span class=\"hljs-meta prompt_\">&gt;</span> <span class=\"language-javascript\">此处又涉及到了一个待学知识点：</span><br><span class=\"hljs-meta prompt_\">&gt;</span><br><span class=\"hljs-meta prompt_\">&gt;</span> <span class=\"language-javascript\"><span class=\"hljs-title class_\">Spring</span>的<span class=\"hljs-variable constant_\">AOP</span>切面应用</span><br><span class=\"hljs-meta prompt_\">&gt;</span><br><span class=\"hljs-meta prompt_\">&gt;</span> <span class=\"language-javascript\">可以用来通过注解的方式进行权限管理。</span><br><br>### 后端接口： <br><br>**发布接口**（仅管理员） <br><br>1.校验该接口是否存在<br><br>2.判断接口是否可以被调用<br><br>​\t利用开发好的SDK，通过调用接口看是否能够进行调用的通<br><br>​\t第一步：启动smartapi-interface项目<br><br>​\t第二步：在smartapi-backend中引入SDK的依赖<br><br>​\t第三步：在application.yml中写入ak、sk<br><br>​\t第四步：在接口中引入客户端的实例<br><br>​\t\t\t@Resource<br><br>​\t\t\tprivate SmartApiClient smartapiclient<br><br><span class=\"hljs-meta prompt_\">&gt;</span> <span class=\"language-javascript\"><span class=\"hljs-attr\">TODO</span>:</span><br><span class=\"hljs-meta prompt_\">&gt;</span><br><span class=\"hljs-meta prompt_\">&gt;</span> <span class=\"language-javascript\">&gt; &gt;  <span class=\"hljs-number\">1.</span> 判断接口是否可以调用时，由固定方法名改为可以根据测试地址进行调用</span><br><span class=\"hljs-meta prompt_\">&gt;</span> <span class=\"language-javascript\">&gt; &gt;  <span class=\"hljs-number\">2.</span> 用户测试接口判断接口是否可以调用时，由固定方法名改为可以根据测试地址进行调用</span><br><br>3.修改数据库接口字段为1<br><br>**下线接口**（仅管理员） <br><br>1.校验该接口是否存在<br><br>2.修改数据库接口字段为 0<br><br>按钮已添加并完善。测试中出现一个经典问题，如图所示：<br><br>![image-20230710000821503](https://cdn.jsdelivr.net/gh/wl2o2o/blogCdn/img/202307100008989.png)<br><br><br><br><span class=\"hljs-meta prompt_\">&gt;</span> <span class=\"language-javascript\">待办事件：</span><br><span class=\"hljs-meta prompt_\">&gt;</span><br><span class=\"hljs-meta prompt_\">&gt;</span> <span class=\"language-javascript\">流程：</span><br><span class=\"hljs-meta prompt_\">&gt;</span><br><span class=\"hljs-meta prompt_\">&gt;</span> <br><span class=\"hljs-meta prompt_\">&gt;</span><br><span class=\"hljs-meta prompt_\">&gt;</span> <span class=\"language-javascript\">**前端**添加上线、下线按钮、√、增加用户浏览页面、查看接口文档、申请签名</span><br><span class=\"hljs-meta prompt_\">&gt;</span><br><span class=\"hljs-meta prompt_\">&gt;</span> <span class=\"language-javascript\">**后端**申请签名（更改完善数据库写生成签名的算法）</span><br><span class=\"hljs-meta prompt_\">&gt;</span><br><span class=\"hljs-meta prompt_\">&gt;</span> <span class=\"language-javascript\">**前端**</span><br><span class=\"hljs-meta prompt_\">&gt;</span><br><span class=\"hljs-meta prompt_\">&gt;</span> <span class=\"language-javascript\">新增在线调用的按钮</span><br><span class=\"hljs-meta prompt_\">&gt;</span><br><span class=\"hljs-meta prompt_\">&gt;</span> <span class=\"language-javascript\">**后端**</span><br><span class=\"hljs-meta prompt_\">&gt;</span><br><span class=\"hljs-meta prompt_\">&gt;</span> <span class=\"language-javascript\">开发在线调用的接口</span><br><span class=\"hljs-meta prompt_\">&gt;</span><br><span class=\"hljs-meta prompt_\">&gt;</span> <br><br><br><br><br><br><br><br>### 前端浏览接口<br><br>```react<br>import &#123; PageContainer &#125; from &#x27;@ant-design/pro-components&#x27;;<br>import React, &#123;useEffect, useState&#125; from &#x27;react&#x27;;<br>import &#123;List, message&#125; from &quot;antd&quot;;<br>import &#123;<br>  listInterfaceInfoByPageUsingGET<br>&#125; from &quot;@/services/smartapi-backend/interfaceInfoController&quot;;<br><br><br>/**<br> * 主页<br> * @constructor<br> */<br>const Index: React.FC = () =&gt; &#123;<br><br>  const [loading, setLoading] = useState(false);<br>  const [list, setList] = useState&lt;API.InterfaceInfo[]&gt;([]);<br>  const [total ,setTotal] = useState&lt;number&gt;(0);<br><br>  const loadData = async (current=1 , pageSize = 8 ) =&gt;&#123;<br>    setLoading(true);<br>    try &#123;<br>      const res = await listInterfaceInfoByPageUsingGET(&#123;<br>        current,pageSize<br>      &#125;);<br>      setList(res?.data?.records ?? []);<br>      setTotal(res?.data?.total ?? 0);<br><br>    &#125; catch (error: any) &#123;<br><br>      message.error(&#x27;请求失败,&#x27;+error.message);<br>      return false;<br>    &#125;<br>    setLoading(false);<br>  &#125;<br>  useEffect(() =&gt; &#123;<br>    loadData();<br>  &#125;,[])<br><br><br>  return (<br>    &lt;PageContainer title=&quot;在线接口开放平台&quot;&gt;<br>      &lt;List<br>        className=&quot;my-list&quot;<br>        loading=&#123;loading&#125;<br>        itemLayout=&quot;horizontal&quot;<br>        dataSource=&#123;list&#125;<br>        renderItem=&#123;item =&gt; &#123;<br><br>          const apiLink =`/interface_info/$&#123;item.id&#125;`;<br>          return(<br>            &lt;List.Item<br>              actions=&#123;[&lt;a key=&#123;item.id&#125; href=&#123;apiLink&#125;&gt;查看&lt;/a&gt;]&#125;<br>            &gt;<br>              &lt;List.Item.Meta<br>                title=&#123;&lt;a href=&#123;apiLink&#125;&gt;&#123;item.name&#125;&lt;/a&gt;&#125;<br>                description=&#123;item.description&#125;<br>              /&gt;<br>            &lt;/List.Item&gt;<br>          )<br>        &#125;<br><br>        &#125;<br>        pagination =&#123;<br>          &#123;<br>            // eslint-disable-next-line @typescript-eslint/no-shadow<br>            showTotal(total: number)&#123;<br>              return &#x27;总数：&#x27; +total;<br>            &#125;,<br>            pageSize: 8,<br>            total,<br>            onChange(page,pageSize)&#123;<br>              loadData(page,pageSize);<br>            &#125;<br>          &#125;<br>        &#125;<br>      /&gt;<br>    &lt;/PageContainer&gt;<br>  );<br>&#125;;<br><br>export default Index;<br></code></pre></td></tr></table></figure></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"查看接口文档\"><a href=\"#查看接口文档\" class=\"headerlink\" title=\"查看接口文档\"></a>查看接口文档</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs react\">import &#123; PageContainer &#125; from &#x27;@ant-design/pro-components&#x27;;<br>import React, &#123;useEffect, useState&#125; from &#x27;react&#x27;;<br>import &#123;Card, Descriptions, message&#125; from &quot;antd&quot;;<br>import &#123;<br>  getInterfaceInfoByIdUsingGET,<br><br>&#125; from &quot;@/services/smartapi-backend/interfaceInfoController&quot;;<br>import &#123; useParams&#125; from &quot;@@/exports&quot;;<br><br><br>/**<br> * 主页<br> * @constructor<br> */<br>const Index: React.FC = () =&gt; &#123;<br><br>  const [loading, setLoading] = useState(false);<br>  const [data, setData] = useState&lt;API.InterfaceInfo&gt;();<br>  const params  = useParams();<br><br>  const loadData = async () =&gt;&#123;<br>    if (!params.id)&#123;<br>      message.error(&#x27;参数不存在&#x27;);<br>      return ;<br>    &#125;<br>    setLoading(true);<br>    try &#123;<br>      const res = await getInterfaceInfoByIdUsingGET(&#123;<br>        id: Number(params.id)<br>      &#125;);<br>      setData(res.data);<br><br>    &#125; catch (error: any) &#123;<br><br>      message.error(&#x27;请求失败,&#x27;+error.message);<br>      return false;<br>    &#125;<br>    setLoading(false);<br>  &#125;<br>  useEffect(() =&gt; &#123;<br>    loadData();<br>  &#125;,[])<br><br>  return (<br>    &lt;PageContainer title=&quot;查看接口文档&quot;&gt;<br>      &lt;Card&gt;<br>        &#123;<br>          data?(<br>            &lt;Descriptions title=&#123;data.name&#125; column=&#123;1&#125;&gt;<br>              &lt;Descriptions.Item label=&quot;描述&quot;&gt;&#123;data.description&#125;&lt;/Descriptions.Item&gt;<br>              &lt;Descriptions.Item label=&quot;接口状态&quot;&gt;&#123;data.status? &#x27;正常&#x27;: &#x27;关闭&#x27;&#125;&lt;/Descriptions.Item&gt;<br>              &lt;Descriptions.Item label=&quot;请求地址&quot;&gt;&#123;data.url&#125;&lt;/Descriptions.Item&gt;<br>              &lt;Descriptions.Item label=&quot;请求方法&quot;&gt;&#123;data.method&#125;&lt;/Descriptions.Item&gt;<br>              &lt;Descriptions.Item label=&quot;请求头&quot;&gt;&#123;data.requestHeader&#125;&lt;/Descriptions.Item&gt;<br>              &lt;Descriptions.Item label=&quot;响应头&quot;&gt;&#123;data.responseHeader&#125;&lt;/Descriptions.Item&gt;<br>              &lt;Descriptions.Item label=&quot;创建时间&quot;&gt;&#123;data.createTime&#125;&lt;/Descriptions.Item&gt;<br>              &lt;Descriptions.Item label=&quot;更新时间&quot;&gt;&#123;data.updateTime&#125;&lt;/Descriptions.Item&gt;<br>            &lt;/Descriptions&gt;<br>          ):(<br>            &lt;&gt;接口不存在&lt;/&gt;<br>          )&#125;<br>      &lt;/Card&gt;<br>    &lt;/PageContainer&gt;<br>  );<br>&#125;;<br><br>export default Index;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"申请签名（注册）\"><a href=\"#申请签名（注册）\" class=\"headerlink\" title=\"申请签名（注册）\"></a>申请签名（注册）</h3><p>通过数据库新增字段、更改用户注册的逻辑（使用DigestUtil加密算法生成ak、sk，然后加入数据库）</p>\n<blockquote>\n<p>留一个小作业:</p>\n<p>新增一个小拓展功能：用户可以手动更改自己的ak、sk</p>\n</blockquote>\n<h3 id=\"新建真实数据（前端）\"><a href=\"#新建真实数据（前端）\" class=\"headerlink\" title=\"新建真实数据（前端）\"></a>新建真实数据（前端）</h3><p><strong>新建这些真实的数据</strong></p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs text\">getUsernameByPost,<br><br>获取用户名,<br><br>http://localhost:8123/name/user,<br><br>&#123;”Content-Type“: ”application/json“&#125;,<br><br>&#123;”Content-Type“: ”application/json“&#125;,<br><br></code></pre></td></tr></table></figure>\n\n<p>oh my god，此时发现遗忘了一个重要的请求参数字段，于是通过建表语句、IDEA客户端modify table，来增加这么一个字段。</p>\n<p>修改相应的model实体包中的字段信息以及向mybatisplus.xml中添加这个字段。</p>\n<p>重启项目—》前端重新使用openai插件生成接口</p>\n<p>前端也需要完善修改组件的表单列名，新增一个requestParams</p>\n<p>完成！</p>\n<p><strong>完善接口信息的请求参数信息</strong></p>\n<p><strong>在线调用</strong></p>\n<p>前端界面的编写，通过ant design组件库利用现成的表单组件来完成在线按钮的添加与请求参数的基本表单。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/wl2o2o/blogCdn/img/202307100238354.png\" alt=\"image-20230710023831281\"></p>\n<p>请求参数的类型（JSON类型）</p>\n<blockquote>\n<p>又一个小作业：</p>\n<p>在线调用的扩展点：</p>\n<p>先跑通整个流程，然后根据请求头和请求类型的不同设计不同的表单和界面，增强用户体验</p>\n</blockquote>\n<h3 id=\"后端调用流程\"><a href=\"#后端调用流程\" class=\"headerlink\" title=\"后端调用流程\"></a>后端调用流程</h3><p><img src=\"https://cdn.jsdelivr.net/gh/wl2o2o/blogCdn/img/202307100242406.png\" alt=\"image-20230710024253445\"></p>\n<p>按照标准的企业开发流程来说：</p>\n<p>一定会选择第一种开发方式，不然后期的网关与计费就毫无作用，</p>\n<p>第二种方式可以用来自己调用测试。</p>\n<p>流程：</p>\n<ol>\n<li>前端将用户输入的请求参数与要进行测试的接口id发给平台后端</li>\n<li>在调用前进行一些校验</li>\n<li>平台后端去调用模拟接口</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Java\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">     * 测试调用</span><br><span class=\"hljs-comment\">     *</span><br><span class=\"hljs-comment\">     * <span class=\"hljs-doctag\">@param</span> interfaceInfoInvokeRequest</span><br><span class=\"hljs-comment\">     * <span class=\"hljs-doctag\">@param</span> request</span><br><span class=\"hljs-comment\">     * <span class=\"hljs-doctag\">@return</span></span><br><span class=\"hljs-comment\">     */</span><br>    <span class=\"hljs-meta\">@PostMapping(&quot;/invoke&quot;)</span><br>    <span class=\"hljs-keyword\">public</span> BaseResponse&lt;Object&gt; <span class=\"hljs-title function_\">invokeInterfaceInfo</span><span class=\"hljs-params\">(<span class=\"hljs-meta\">@RequestBody</span> InterfaceInfoInvokeRequest interfaceInfoInvokeRequest,</span><br><span class=\"hljs-params\">                                                    HttpServletRequest request)</span> &#123;<br>        <span class=\"hljs-keyword\">if</span> (interfaceInfoInvokeRequest == <span class=\"hljs-literal\">null</span> || interfaceInfoInvokeRequest.getId() &lt;= <span class=\"hljs-number\">0</span>) &#123;<br>            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">BusinessException</span>(ErrorCode.PARAMS_ERROR);<br>        &#125;<br>        <span class=\"hljs-type\">long</span> <span class=\"hljs-variable\">id</span> <span class=\"hljs-operator\">=</span> interfaceInfoInvokeRequest.getId();<br>        <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">userRequestParams</span> <span class=\"hljs-operator\">=</span> interfaceInfoInvokeRequest.getUserRequestParams();<br>        <span class=\"hljs-comment\">// 判断是否存在</span><br>        <span class=\"hljs-type\">InterfaceInfo</span> <span class=\"hljs-variable\">oldInterfaceInfo</span> <span class=\"hljs-operator\">=</span> interfaceInfoService.getById(id);<br>        <span class=\"hljs-keyword\">if</span> (oldInterfaceInfo == <span class=\"hljs-literal\">null</span>) &#123;<br>            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">BusinessException</span>(ErrorCode.NOT_FOUND_ERROR);<br>        &#125;<br>        <span class=\"hljs-keyword\">if</span> (oldInterfaceInfo.getStatus() == InterfaceInfoStatusEnum.OFFLINE.getValue()) &#123;<br>            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">BusinessException</span>(ErrorCode.PARAMS_ERROR, <span class=\"hljs-string\">&quot;接口已关闭&quot;</span>);<br>        &#125;<br>        <span class=\"hljs-type\">User</span> <span class=\"hljs-variable\">loginUser</span> <span class=\"hljs-operator\">=</span> userService.getLoginUser(request);<br>        <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">accessKey</span> <span class=\"hljs-operator\">=</span> loginUser.getAccessKey();<br>        <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">secretKey</span> <span class=\"hljs-operator\">=</span> loginUser.getSecretKey();<br>        <span class=\"hljs-type\">MyClient</span> <span class=\"hljs-variable\">tempClient</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">MyClient</span>(accessKey, secretKey);<br>        <span class=\"hljs-type\">Gson</span> <span class=\"hljs-variable\">gson</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Gson</span>();<br>        com.wl.smartapiclientsdk.model.<span class=\"hljs-type\">User</span> <span class=\"hljs-variable\">user</span> <span class=\"hljs-operator\">=</span> gson.fromJson(userRequestParams, com.wl.smartapiclientsdk.model.User.class);<br>        <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">usernameByPost</span> <span class=\"hljs-operator\">=</span> tempClient.getUserNameByPost(user);<br>        <span class=\"hljs-keyword\">return</span> ResultUtils.success(usernameByPost);<br>    &#125;<br></code></pre></td></tr></table></figure>\n\n<p>后端调用逻辑已完成</p>\n<p>现在继续完善前端的接口，将前端点击调用按钮后改为我们刚才通过后端实现的真实的功能。</p>\n<figure class=\"highlight xquery\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs xquery\">const onFinish = (values: any) =&gt; &#123;<br>    <span class=\"hljs-keyword\">if</span> (!params<span class=\"hljs-built_in\">.id</span>)&#123;<br>      message<span class=\"hljs-built_in\">.error</span>(<span class=\"hljs-string\">&#x27;接口不存在&#x27;</span>);<br>      <span class=\"hljs-keyword\">return</span> ;<br>    &#125;<br>    <span class=\"hljs-keyword\">try</span> &#123;<br>      invokeInterfaceInfoUsingPOST(&#123;<br>       <span class=\"hljs-built_in\"> id</span>: params<span class=\"hljs-built_in\">.id</span>,<br>        ...values<br>      &#125;)<br>      message.success(<span class=\"hljs-string\">&#x27;请求成功&#x27;</span>);<br>      <span class=\"hljs-keyword\">return</span><span class=\"hljs-built_in\"> true</span>;<br>    &#125; <span class=\"hljs-keyword\">catch</span> <span class=\"hljs-built_in\">(error</span>: any) &#123;<br>      message<span class=\"hljs-built_in\">.error</span>(<span class=\"hljs-string\">&#x27;请求失败，&#x27;</span> +<span class=\"hljs-built_in\"> error</span>.message);<br>    &#125;<br>  &#125;;<br></code></pre></td></tr></table></figure>\n\n<p>逻辑打通之后还要进行回显数据：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs typescript\"><span class=\"hljs-comment\">// async 是设置同步的意思</span><br><br> <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">onFinish</span> = <span class=\"hljs-keyword\">async</span> (<span class=\"hljs-params\">values: <span class=\"hljs-built_in\">any</span></span>) =&gt; &#123;<br>    <span class=\"hljs-keyword\">if</span> (!params.<span class=\"hljs-property\">id</span>)&#123;<br>      message.<span class=\"hljs-title function_\">error</span>(<span class=\"hljs-string\">&#x27;接口不存在&#x27;</span>);<br>      <span class=\"hljs-keyword\">return</span> ;<br>    &#125;<br>    <span class=\"hljs-keyword\">try</span> &#123;<br><span class=\"hljs-comment\">// 等待</span><br><br>      <span class=\"hljs-keyword\">const</span> res = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title function_\">invokeInterfaceInfoUsingPOST</span>(&#123;<br>        <span class=\"hljs-attr\">id</span>: params.<span class=\"hljs-property\">id</span>,<br>        ...values<br>      &#125;)<br><span class=\"hljs-comment\">// 将res.data赋给setInvokeRes</span><br><br>      <span class=\"hljs-title function_\">setInvokeRes</span>(res.<span class=\"hljs-property\">data</span>);<br>      message.<span class=\"hljs-title function_\">success</span>(<span class=\"hljs-string\">&#x27;请求成功&#x27;</span>);<br>      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;<br>    &#125; <span class=\"hljs-keyword\">catch</span> (<span class=\"hljs-attr\">error</span>: <span class=\"hljs-built_in\">any</span>) &#123;<br>      message.<span class=\"hljs-title function_\">error</span>(<span class=\"hljs-string\">&#x27;请求失败，&#x27;</span> + error.<span class=\"hljs-property\">message</span>);<br>    &#125;<br>  &#125;;<br></code></pre></td></tr></table></figure>\n\n<p>然后在表单处新增一个卡片，用于接收invokeRes进行数据回显。</p>\n<p>已完成，测试通过！</p>\n<p>并且完善了一个缓冲显示的loading</p>\n<p>TODO:</p>\n<blockquote>\n<blockquote>\n<ol>\n<li>判断接口是否可以调用时，由固定方法名改为可以根据测试地址进行调用</li>\n<li>用户测试接口判断接口是否可以调用时，由固定方法名改为可以根据测试地址进行调用</li>\n<li>此时任何人调用模拟接口都是可以的，因为我们的SDK是写死在配置文件中的，所以后续再进行完善，从数据库中进行校验！</li>\n</ol>\n</blockquote>\n</blockquote>\n<p>over！</p>\n<p>下面我们的网关用Spring Cloud GateWay实现</p>\n<h2 id=\"Day04\"><a href=\"#Day04\" class=\"headerlink\" title=\"Day04\"></a>Day04</h2><ol>\n<li><p>开发接口调用次数统计  20min</p>\n</li>\n<li><p>优化系统的架构—学习架构设计、接触应用场景==&gt;面对一个需求就会自然而然地提高开发效率。 60min</p>\n<p>（怎么把一个项目的架构设计做的更加合理，涉及到API网关的知识）</p>\n<ul>\n<li>网关是什么？</li>\n<li>网关的作用？</li>\n<li>网关的应用场景以及实现？</li>\n<li>结合业务去应用网关</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"接口调用次数统计\"><a href=\"#接口调用次数统计\" class=\"headerlink\" title=\"接口调用次数统计\"></a>接口调用次数统计</h3><p>需求：</p>\n<pre><code>1. 用户每次调用接口成功，次数加1（或者设定一定的调用次数，每次减1）\n1. 给用户分配或者用户自助申请接口调用次数\n</code></pre>\n<blockquote>\n<p>业务流程：</p>\n<ol>\n<li>用户调用接口（之前已完成）</li>\n<li>修改数据库，调用次数（加1或者减1）</li>\n</ol>\n</blockquote>\n<p>设计库表：</p>\n<blockquote>\n<p>哪个用户？哪个接口？</p>\n<p>用户 =&gt; 接口（多对多）</p>\n</blockquote>\n<p>用户接口关系表：</p>\n<figure class=\"highlight pgsql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs pgsql\"><span class=\"hljs-comment\">-- 用户调用接口关系表</span><br><span class=\"hljs-keyword\">create</span> <span class=\"hljs-keyword\">table</span> <span class=\"hljs-keyword\">if</span> <span class=\"hljs-keyword\">not</span> <span class=\"hljs-keyword\">exists</span> smartapi.`user_interface_info`<br>(<br>    `id` <span class=\"hljs-type\">bigint</span> <span class=\"hljs-keyword\">not</span> <span class=\"hljs-keyword\">null</span> auto_increment <span class=\"hljs-keyword\">comment</span> <span class=\"hljs-string\">&#x27;主键&#x27;</span> <span class=\"hljs-keyword\">primary key</span>,<br>    `userId` <span class=\"hljs-type\">bigint</span> <span class=\"hljs-keyword\">not</span> <span class=\"hljs-keyword\">null</span> <span class=\"hljs-keyword\">comment</span> <span class=\"hljs-string\">&#x27;调用用户 id&#x27;</span>,<br>    `interfaceInfoId` <span class=\"hljs-type\">bigint</span> <span class=\"hljs-keyword\">not</span> <span class=\"hljs-keyword\">null</span> <span class=\"hljs-keyword\">comment</span> <span class=\"hljs-string\">&#x27;接口 id&#x27;</span>,<br>    `totalNum` <span class=\"hljs-type\">int</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-number\">0</span> <span class=\"hljs-keyword\">not</span> <span class=\"hljs-keyword\">null</span> <span class=\"hljs-keyword\">comment</span> <span class=\"hljs-string\">&#x27;总调用次数&#x27;</span>,<br>    `leftNum` <span class=\"hljs-type\">int</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-number\">0</span> <span class=\"hljs-keyword\">not</span> <span class=\"hljs-keyword\">null</span> <span class=\"hljs-keyword\">comment</span> <span class=\"hljs-string\">&#x27;剩余调用次数&#x27;</span>,<br>    `status` <span class=\"hljs-type\">int</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-number\">0</span> <span class=\"hljs-keyword\">not</span> <span class=\"hljs-keyword\">null</span> <span class=\"hljs-keyword\">comment</span> <span class=\"hljs-string\">&#x27;0-正常，1-禁用&#x27;</span>,<br>    `createTime` datetime <span class=\"hljs-keyword\">default</span> <span class=\"hljs-built_in\">CURRENT_TIMESTAMP</span> <span class=\"hljs-keyword\">not</span> <span class=\"hljs-keyword\">null</span> <span class=\"hljs-keyword\">comment</span> <span class=\"hljs-string\">&#x27;创建时间&#x27;</span>,<br>    `updateTime` datetime <span class=\"hljs-keyword\">default</span> <span class=\"hljs-built_in\">CURRENT_TIMESTAMP</span> <span class=\"hljs-keyword\">not</span> <span class=\"hljs-keyword\">null</span> <span class=\"hljs-keyword\">on</span> <span class=\"hljs-keyword\">update</span> <span class=\"hljs-built_in\">CURRENT_TIMESTAMP</span> <span class=\"hljs-keyword\">comment</span> <span class=\"hljs-string\">&#x27;更新时间&#x27;</span>,<br>    `isDelete` tinyint <span class=\"hljs-keyword\">default</span> <span class=\"hljs-number\">0</span> <span class=\"hljs-keyword\">not</span> <span class=\"hljs-keyword\">null</span> <span class=\"hljs-keyword\">comment</span> <span class=\"hljs-string\">&#x27;是否删除(0-未删, 1-已删)&#x27;</span><br>) <span class=\"hljs-keyword\">comment</span> <span class=\"hljs-string\">&#x27;用户调用接口关系&#x27;</span>;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"步骤：\"><a href=\"#步骤：\" class=\"headerlink\" title=\"步骤：\"></a>步骤：</h3><ol>\n<li><p>开发基本的增删改查（给管理员使用）</p>\n<blockquote>\n<p>直接使用Mybatis-X生成相关的实体类（注意在删除字段上米娜加上逻辑删除@TableLogic）、mapper、service实现类没然后移动到项目对应的包中。</p>\n<p>复制写好的Controller，改那些增删改查！ 完成√</p>\n</blockquote>\n</li>\n<li><p>开发用户调用接口次数加1（或者减1）</p>\n<p>问：如果每个接口的方法，都写调用次数 + 1，是不是比较麻烦，如果在本项目中，将这个调用次数+ 1，封装成一个方法，也是可以的，但是<code>代码侵入性很强！</code></p>\n<p>致命问题是：接口开发者需要自己进行调用！</p>\n<p>解决方法：</p>\n<ol>\n<li>Spring中的AOP（推荐，是Spring的一个核心特性）</li>\n<li>Servelet中的拦截器、过滤器（Fillter）</li>\n<li>通用的方法（缺点：代码侵入性强，需要自己调用）</li>\n<li>网关</li>\n</ol>\n</li>\n</ol>\n<p>简单说一下AOP切面的基本过程：</p>\n<blockquote>\n<p>先说一下AOP切面的作用：</p>\n<p>就相当于在接口或者方法调用前或者调用之后帮你做一些事情，其底层的原理就是动态代理。</p>\n<p>使用AOP切面的</p>\n<p>优点：</p>\n<p>独立于接口，在每个接口调用前后加 1</p>\n<p>缺点：</p>\n<p>只存在于单个项目中，如果每个团队都要写一个自己的切面</p>\n<p>// TODO：下去看一下AOP的流程，熟悉一下</p>\n</blockquote>\n<p>我们在这个项目中使用网关来实现接口调用次数。</p>\n<p>网关就当与在所有接口的入口前加了一层检票口，如图所示：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/wl2o2o/blogCdn/img/202307160152994.png\" alt=\"image-20230716015231451\"></p>\n<p>因为网关实现的有调用次数的统计，所以开发者可以通关网关来查看，而用户调用接口时直接输入请求参数、请求地址即可。</p>\n<h3 id=\"网关：\"><a href=\"#网关：\" class=\"headerlink\" title=\"网关：\"></a>网关：</h3><p>这里为什么写这么多理论呢？写代码不一定是最重要的，重要的是思想！逻辑思想明白之后，无非就是看文档、百度实现。</p>\n<blockquote>\n<p>什么是网关呢？就相当于车票检票口，统一去检票。</p>\n<p>优点？统一去进行一些操作、处理一些问题。</p>\n<p>作用？</p>\n<ol>\n<li><p>路由</p>\n</li>\n<li><p>负载均衡</p>\n</li>\n<li><p>统一鉴权</p>\n</li>\n<li><p>统一处理跨域</p>\n</li>\n<li><p>统一业务处理（缓存）</p>\n</li>\n<li><p>访问控制</p>\n</li>\n<li><p>发布控制（灰度发布，也就是慢慢控制接口的流量，不断开放给更多用户，然后达到升级接口的目的）</p>\n</li>\n<li><p>流量染色（给流量添加一些标识，比如新的请求头信息）</p>\n</li>\n<li><p>统一接口保护 </p>\n<ol>\n<li><p>限制请求</p>\n</li>\n<li><p>信息脱敏（网关可以操作你的请求口，进而抹去敏感信息）</p>\n</li>\n<li><p>降级（熔断，保险起见，接口下线后，可以返回一些提示信息）</p>\n</li>\n<li><p>限流</p>\n<p>（// TODO：学习令牌桶算法，学习露桶算法，学习一下）</p>\n</li>\n<li><p>RedislimitHandler</p>\n</li>\n<li><p>超时时间</p>\n</li>\n<li><p>重试（业务保护）</p>\n</li>\n</ol>\n</li>\n<li><p>统一日志</p>\n</li>\n<li><p>统一文档（将下游项目的文档统一聚合，展示到一个页面）</p>\n</li>\n</ol>\n</blockquote>\n<h3 id=\"路由\"><a href=\"#路由\" class=\"headerlink\" title=\"路由\"></a>路由</h3><p>起到转发的作用，比如有接口A和接口B,网关会记录这些信息，根据用户访问的地址和参数，转发请求到对应的接口（服务器/集群）</p>\n<p>用户a调用接口A</p>\n<p>/a=&gt;接口A /b=&gt;接口B</p>\n<p><a href=\"https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#gateway-request-predicates-factories\">https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#gateway-request-predicates-factories</a></p>\n<h3 id=\"负载均衡\"><a href=\"#负载均衡\" class=\"headerlink\" title=\"负载均衡\"></a>负载均衡</h3><p>在路由的基础上可以转发到某一个服务器</p>\n<p>/c =&gt; 服务A/ 集群A（随机转发到其中的某一个机器）</p>\n<p>uri从固定地址改成b:xx</p>\n<h3 id=\"统一鉴权\"><a href=\"#统一鉴权\" class=\"headerlink\" title=\"统一鉴权\"></a>统一鉴权</h3><p>判断用户是否有权限进行操作，无论访问什么接口，我都统一去判断权限，不用重复写</p>\n<h3 id=\"统一处理跨域\"><a href=\"#统一处理跨域\" class=\"headerlink\" title=\"统一处理跨域\"></a>统一处理跨域</h3><p>网关统一处理跨域，不用在每个项目单独处理</p>\n<p><a href=\"https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#cors-configuration\">https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#cors-configuration</a></p>\n<h3 id=\"统一业务处理\"><a href=\"#统一业务处理\" class=\"headerlink\" title=\"统一业务处理\"></a>统一业务处理</h3><p>把每个项目中都要做的通用逻辑放到上层（网关），统一处理，比如本项目的次数统计</p>\n<h3 id=\"访问控制\"><a href=\"#访问控制\" class=\"headerlink\" title=\"访问控制\"></a>访问控制</h3><p>黑白名单，比如限制ddos ip</p>\n<h3 id=\"发布控制\"><a href=\"#发布控制\" class=\"headerlink\" title=\"发布控制\"></a>发布控制</h3><p>灰度发布，比如上线新接口，先给新接口分配 20%流量，老接口80% ,再慢慢调整比例</p>\n<p><a href=\"https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#the-weight-route-predicate-\">https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#the-weight-route-predicate-</a> factory</p>\n<h3 id=\"流量染色\"><a href=\"#流量染色\" class=\"headerlink\" title=\"流量染色\"></a>流量染色</h3><p>区分用户来源</p>\n<p>给请求（流量）添加一些标识，一般是设置请求头中，添加新的请求头 <a href=\"https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#the-addrequestheader-gatewayfilter-factory\">https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#the-addrequestheader-gatewayfilter-factory</a></p>\n<p>全局染色：<a href=\"https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#default-filters\">https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#default-filters</a></p>\n<h3 id=\"接口保护\"><a href=\"#接口保护\" class=\"headerlink\" title=\"接口保护\"></a>接口保护</h3><p>1 限制请求 <a href=\"https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#requestheadersiz-gatewayfilter-factory\">https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#requestheadersiz-gatewayfilter-factory</a> </p>\n<p>2 信息脱敏 <a href=\"https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#the-removerequestheader-gatewayfilter-factory\">https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#the-removerequestheader-gatewayfilter-factory</a> </p>\n<p>3 降级（熔断） 进行兜底 <a href=\"https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#fallback-headers\">https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#fallback-headers</a> </p>\n<p>4 限流 <a href=\"https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#the-requestratelimiter-gatewayfilter-factory\">https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#the-requestratelimiter-gatewayfilter-factory</a> </p>\n<p>5 超时时间   超时就中断 <a href=\"https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#http-timeouts-configuration\">https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#http-timeouts-configuration</a> </p>\n<p>6 重试（业务保护）： <a href=\"https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#the-retry-gatewayfilter-factory\">https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#the-retry-gatewayfilter-factory</a> </p>\n<h3 id=\"统一日志\"><a href=\"#统一日志\" class=\"headerlink\" title=\"统一日志\"></a>统一日志</h3><p>统一的请求，响应信息记录</p>\n<h3 id=\"统一文档\"><a href=\"#统一文档\" class=\"headerlink\" title=\"统一文档\"></a>统一文档</h3><p>将下游项目的文档进行聚合，在一个页面统一查看</p>\n<p>建议用：<a href=\"https://doc.xiaominfo.com/docs/middleware-sources/,aggregation-introduction\">https://doc.xiaominfo.com/docs/middleware-sources/,aggregation-introduction</a></p>\n<h3 id=\"网关的分类\"><a href=\"#网关的分类\" class=\"headerlink\" title=\"网关的分类\"></a>网关的分类</h3><ol>\n<li><p>全局网关（接入层网关）：作用是负载均衡、请求日志，不和业务逻辑绑定</p>\n</li>\n<li><p>业务网关（微服务网关：会有一些业务逻辑）：作用是根据不同的请求转发到不同的项目接口</p>\n<p>参考文章：<a href=\"https://blog.csdn.net/qq21040559/article/,details/,122961395\">https://blog.csdn.net/qq21040559/article/,details/,122961395</a></p>\n</li>\n</ol>\n<h3 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h3><ol>\n<li><p>Nginx（推荐的全局型网关）</p>\n</li>\n<li><p>Kong网关（适合API网关）–收费！！</p>\n</li>\n<li><p><code>Spring Cloud Gateway</code>（取代了Zuul，因为架构设计并不太好，并发量也有限）</p>\n<blockquote>\n<p>优点：用到了NIO、多路复用、底层Netty、React模型；</p>\n<p>最大的亮点：可以用Java代码写逻辑，其他网关都需要学习一些其他语言（Nginx需要学到一些Lua脚本）</p>\n</blockquote>\n</li>\n</ol>\n<p>网关技术选型：<a href=\"https://zhuanlan.zhihu.com/p/500587132\">https://zhuanlan.zhihu.com/p/500587132</a></p>\n<h3 id=\"Spring-Cloud-Gateway用法\"><a href=\"#Spring-Cloud-Gateway用法\" class=\"headerlink\" title=\"Spring Cloud Gateway用法\"></a>Spring Cloud Gateway用法</h3><p>官网是最好的老是去看官网</p>\n<p>去看官网：<a href=\"https://spring.io/projects/spring-cloud-gateway\">https://spring.io/projects/spring-cloud-gateway</a></p>\n<p>官方文档：<a href=\"https://docs.spring.io/spring-cloud-gateway/docs/current/reference//html/\">https://docs.spring.io/spring-cloud-gateway/docs/current/reference//html/</a></p>\n<h3 id=\"创建一个Gateway项目\"><a href=\"#创建一个Gateway项目\" class=\"headerlink\" title=\"创建一个Gateway项目\"></a>创建一个Gateway项目</h3><p>小作业：完成官网的小demo（编程式demo）</p>\n<h2 id=\"Day05-把API网关应用到项目中\"><a href=\"#Day05-把API网关应用到项目中\" class=\"headerlink\" title=\"Day05 把API网关应用到项目中\"></a>Day05 把API网关应用到项目中</h2><p>任务：</p>\n<ol>\n<li>完成统一的用户鉴权、统一的接口调用次数统计（API网关应用）</li>\n<li>完善功能</li>\n</ol>\n<h3 id=\"将用到的特性\"><a href=\"#将用到的特性\" class=\"headerlink\" title=\"将用到的特性\"></a>将用到的特性</h3><ol>\n<li><p>路由（转发请求到模拟接口项目）</p>\n</li>\n<li><p><del>负载均衡（需要用到注册中心）</del></p>\n</li>\n<li><p>统一鉴权(accessKey，secretKey)</p>\n</li>\n<li><p>统一处理跨域</p>\n</li>\n<li><p>统一业务处理（每次请求接口后，接口调用次数+1）</p>\n</li>\n<li><p>访问控制（黑白名单）</p>\n</li>\n<li><p><del>发布控制</del></p>\n</li>\n<li><p>流量染色(记录请求是否为网关来的)</p>\n</li>\n<li><p><del>统一接口保护</del> </p>\n<ol>\n<li>限制请求</li>\n<li>信息脱敏</li>\n<li>降级（熔断）</li>\n<li>限流 学习令牌桶算法，学习露桶算法，学习一下RedislimitHandler</li>\n<li>超时时间</li>\n<li>重试（业务保护）</li>\n</ol>\n</li>\n<li><p>统一日志(记录每次的请求和响应)</p>\n</li>\n<li><p><del>统一文档</del></p>\n</li>\n</ol>\n<h3 id=\"业务逻辑\"><a href=\"#业务逻辑\" class=\"headerlink\" title=\"业务逻辑\"></a>业务逻辑</h3><blockquote>\n<p>为什么会用到API网关？</p>\n<p>结合架构图来说，简单来说也就是加一个检票口，同时也可以添加流量染色、链路追踪的功能、灰度发布等等。。。</p>\n</blockquote>\n<ol>\n<li>用户发送请求到API网关（请求转发）</li>\n<li><em>请求日志</em></li>\n<li><em>黑白名单</em></li>\n<li>用户鉴权（如何？判断ak、sk）</li>\n<li>请求的模拟接口是否存在？</li>\n<li>请求转发，调用模拟接口</li>\n<li>响应日志</li>\n<li>调用成功，接口调用次数 + 1</li>\n<li>调用失败，返回规范错误码</li>\n</ol>\n<h3 id=\"实现-1\"><a href=\"#实现-1\" class=\"headerlink\" title=\"实现\"></a>实现</h3><ol>\n<li><p><strong>请求转发</strong></p>\n<p><a href=\"https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#the-path-route-predicate-factory\">使用前缀匹配断言</a></p>\n<p>所有路径为：<code>/api/**</code> 的请求转发，转发到<a href=\"http://localhost:8123/api/\">http://localhost:8123/api/</a>**</p>\n<p>比如：</p>\n<p>请求于<a href=\"http://localhost:8090/api/name/get?/name=wlei224\">http://localhost:8090/api/name/get?/name=wlei224</a></p>\n<p>转发到<a href=\"http://localhost:8123/api/name/get?/name=wlei224\">http://localhost:8123/api/name/get?/name=wlei224</a></p>\n</li>\n</ol>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs yaml\"><span class=\"hljs-attr\">spring:</span><br>  <span class=\"hljs-attr\">cloud:</span><br>    <span class=\"hljs-attr\">gateway:</span><br>      <span class=\"hljs-attr\">routes:</span><br>      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-attr\">id:</span> <span class=\"hljs-string\">path_route</span><br>        <span class=\"hljs-attr\">uri:</span> <span class=\"hljs-string\">https://example.org</span><br>        <span class=\"hljs-attr\">predicates:</span><br>        <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">Path=/red/&#123;segment&#125;,/blue/&#123;segment&#125;</span><br></code></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>其他业务逻辑</li>\n</ol>\n<blockquote>\n<p>​    todo：Spring注解      @component</p>\n</blockquote>\n<p>​    使用Spring Cloud Gateway中的GlobalFilter实现请求拦截处理（类似于AOP）</p>\n<p>​    <img src=\"https://cdn.jsdelivr.net/gh/wl2o2o/blogCdn/img/202307251948339.png\" alt=\"image-20230725194819206\"></p>\n<p>​    <a href=\"https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#gateway-combined-global-filter-and-gatewayfilter-ordering\">GlobalFilter</a>直接复制代码到网关项目的全局异常类中。</p>\n<p>​    验证通过√</p>\n<ol start=\"2\">\n<li>正式开始写业务逻辑</li>\n</ol>\n<blockquote>\n<ol>\n<li><p>用户发送请求到API网关（请求转发）√</p>\n<p>代码能运行到这个controller业务逻辑层，就说明用户已经发送了请求</p>\n</li>\n<li><p><em>请求日志</em></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/wl2o2o/blogCdn/img/202307281159504.png\" alt=\"image-20230728115938432\"></p>\n<p>我们发现请求参数中含有一个交换机，于是可以试着从这里找到request请求，拿到请求头中的信息；</p>\n<p>添加<code>@Slf4j</code>注解，用log.info在控制台输出请求头日志；</p>\n</li>\n<li><p><em>黑白名单</em></p>\n<p>在权限管理业务中一般设置的是白名单，这样只有允许的才可以进行访问，更加安全！</p>\n<p>在IDEA中直接敲<code>prsf</code>写一个白名单常量。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Java\"><span class=\"hljs-comment\">// 2. 访问控制 -- 设置黑白名单（可以用设置响应状态码来实现）</span><br><span class=\"hljs-type\">ServerHttpResponse</span> <span class=\"hljs-variable\">response</span> <span class=\"hljs-operator\">=</span> exchange.getResponse();<br><span class=\"hljs-keyword\">if</span>(!IP_WHITE_LIST.contains(sourceAdress)) &#123;<br>    <span class=\"hljs-comment\">// handleNoAuth(response);</span><br>    response.setStatusCode(HttpStatus.FORBIDDEN);<br>\t<span class=\"hljs-keyword\">return</span> response.setComplete();<br>&#125;<br></code></pre></td></tr></table></figure></li>\n<li><p>用户鉴权（如何？判断ak、sk）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">//  用户鉴权（如何？判断ak、sk）</span><br><span class=\"hljs-type\">HttpHeaders</span> <span class=\"hljs-variable\">headers</span> <span class=\"hljs-operator\">=</span> request.getHeaders();<br><span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">accessKey</span> <span class=\"hljs-operator\">=</span> headers.getFirst(<span class=\"hljs-string\">&quot;accessKey&quot;</span>);<br><span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">nonce</span> <span class=\"hljs-operator\">=</span> headers.getFirst(<span class=\"hljs-string\">&quot;nonce&quot;</span>);<br><span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">timeStamp</span> <span class=\"hljs-operator\">=</span> headers.getFirst(<span class=\"hljs-string\">&quot;timeStamp&quot;</span>);<br><span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">sign</span> <span class=\"hljs-operator\">=</span> headers.getFirst(<span class=\"hljs-string\">&quot;sign&quot;</span>);<br><span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">body</span> <span class=\"hljs-operator\">=</span> headers.getFirst(<span class=\"hljs-string\">&quot;body&quot;</span>);<br><span class=\"hljs-comment\">// TODO 要去数据库中查询</span><br><span class=\"hljs-comment\">// 为了方便进行校验，直接进行判断数据，正规来说应该从数据库中进行校验数据</span><br><span class=\"hljs-keyword\">if</span> (!<span class=\"hljs-string\">&quot;wl&quot;</span>.equals(accessKey))&#123;<br>    <span class=\"hljs-comment\">// throw new RuntimeException(&quot;无权限！&quot;);</span><br>    <span class=\"hljs-comment\">// 封装了一个方法，专门用于处理异常请求</span><br>    <span class=\"hljs-keyword\">return</span> handleNoAuth(response);<br>&#125;<br><span class=\"hljs-keyword\">if</span> (Long.parseLong(nonce) &gt; <span class=\"hljs-number\">10000L</span>)&#123;<br>\t<span class=\"hljs-keyword\">return</span> handleNoAuth(response);<br>&#125;<br>                                                                                                               <br><span class=\"hljs-comment\">//  时间戳校验自己实现，时间和当前时间不能超过5min</span><br><span class=\"hljs-type\">Long</span> <span class=\"hljs-variable\">currentTime</span> <span class=\"hljs-operator\">=</span> System.currentTimeMillis() / <span class=\"hljs-number\">1000</span>;<br><span class=\"hljs-type\">Long</span> <span class=\"hljs-variable\">FIVE_MINUTES</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">60</span> * <span class=\"hljs-number\">5L</span>;<br><span class=\"hljs-keyword\">if</span> ((currentTime-Long.parseLong(timeStamp)) &gt;= FIVE_MINUTES) &#123;<br>\t<span class=\"hljs-keyword\">return</span> handleNoAuth(response);<br>&#125;<br>                                                                                                               <br><span class=\"hljs-comment\">// TODO 要去数据库中查询</span><br><span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">serverSign</span> <span class=\"hljs-operator\">=</span> SignUtils.getSign(body, <span class=\"hljs-string\">&quot;abcdefgh&quot;</span>);<br><span class=\"hljs-keyword\">if</span> (!serverSign.equals(sign)) &#123;<br>\t<span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">RuntimeException</span>(<span class=\"hljs-string\">&quot;无权限！&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li>\n<li><p>请求的模拟接口是否存在？</p>\n<p>// TODO 从数据库中进行查询接口是否存在，以及请求方法是否匹配（严格的话可以再校验一下请求参数，但是业务层面的请求参数不建议放到全局请求网关里面）<br>// 因为数据库的访问方法已经再backend中已经写过，操作较为复杂的话不建议重复写，所以我们可以采用远程调用的方式（也就是可以说是微服务，这个项目完全可以写成微服务：<code>OpenFeigh</code>，目前项目的定位还是<code>分布式项目</code>结合微服务的远程调用，避免重复写业务逻辑）</p>\n</li>\n<li><p>请求转发，调用模拟接口</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">Mono&lt;Void&gt; filter = chain.filter(exchange);<br></code></pre></td></tr></table></figure></li>\n<li><p>响应日志</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">log.info(<span class=\"hljs-string\">&quot;响应：&quot;</span> + response.getStatusCode());<br></code></pre></td></tr></table></figure></li>\n<li><p>调用成功，接口调用次数 + 1</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">// TODO invokeCount</span><br></code></pre></td></tr></table></figure></li>\n<li><p>调用失败，返回规范错误码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Java\"><span class=\"hljs-comment\">// 用户鉴权异常</span><br>    <span class=\"hljs-keyword\">public</span> Mono&lt;Void&gt; <span class=\"hljs-title function_\">handleNoAuth</span><span class=\"hljs-params\">(ServerHttpResponse response)</span> &#123;<br>        response.setStatusCode(HttpStatus.FORBIDDEN);<br>        <span class=\"hljs-keyword\">return</span> response.setComplete();<br>    &#125;<br>    <span class=\"hljs-comment\">// 自定义错误异常</span><br>    <span class=\"hljs-keyword\">public</span> Mono&lt;Void&gt; <span class=\"hljs-title function_\">handleInvokeError</span><span class=\"hljs-params\">(ServerHttpResponse response)</span> &#123;<br>        response.setStatusCode(HttpStatus.INTERNAL_SERVER_ERROR);<br>        <span class=\"hljs-keyword\">return</span> response.setComplete();<br>    &#125;<br></code></pre></td></tr></table></figure></li>\n</ol>\n</blockquote>\n<ul>\n<li>为了方便进行业务逻辑的编写，我们可以向上面一样，将提前编写好的业务流程粘贴到类文件中。</li>\n</ul>\n<h3 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h3><p>通过测试我们发现，通过<a href=\"http://127.0.0.1:8090/api/name/get?name=wl%E8%BF%9B%E8%A1%8C%E8%AE%BF%E9%97%AE%E6%97%B6%EF%BC%8C%E8%BF%98%E6%98%AF%E4%BC%9A%E9%81%AD%E5%88%B0%E6%8B%92%E7%BB%9D%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E5%91%A2%EF%BC%9F%E6%AD%A4%E6%97%B6%E4%B8%8D%E6%98%AF%E8%AF%B7%E6%B1%82%E5%A4%B4%E4%B8%A2%E5%A4%B1%EF%BC%8C%E8%80%8C%E6%98%AF%E6%88%91%E4%BB%AC%E6%A0%B9%E6%9C%AC%E5%B0%B1%E6%B2%A1%E5%86%99%E8%AF%B7%E6%B1%82%E5%A4%B4%EF%BC%8C%E8%B7%91%E9%80%9A%E8%BF%99%E4%B8%AA%E9%80%BB%E8%BE%91%E7%9A%84%E8%AF%9D%EF%BC%8C%E5%8F%AF%E4%BB%A5%E4%BB%8E%E5%89%8D%E7%AB%AF%E8%BF%9B%E8%A1%8C%E8%B0%83%E7%94%A8%E6%B5%8B%E8%AF%95%E3%80%82\">http://127.0.0.1:8090/api/name/get?name=wl进行访问时，还是会遭到拒绝，为什么呢？此时不是请求头丢失，而是我们根本就没写请求头，跑通这个逻辑的话，可以从前端进行调用测试。</a></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/wl2o2o/blogCdn/img/202308030251719.png\" alt=\"image-20230803025109861\"></p>\n<h3 id=\"🧑‍💻业务逻辑预期结果：\"><a href=\"#🧑‍💻业务逻辑预期结果：\" class=\"headerlink\" title=\"🧑‍💻业务逻辑预期结果：\"></a>🧑‍💻业务逻辑预期结果：</h3><p>等模拟接口调用完成，才记录响应日志、统计调用次数。</p>\n<h3 id=\"存在问题：\"><a href=\"#存在问题：\" class=\"headerlink\" title=\"存在问题：\"></a>存在问题：</h3><blockquote>\n<p>虽然上述代码可以跑通，但是还存在一个问题，我们通过debug模式可以看到，代码在执行到请求转发的<code>Mono&lt;Void&gt; filter = chain.filter(exchange);</code>方法后，并没有进入到方法中，反而是继续执行下面的代码，直到<code>chain.filter</code>方法之后才进入模拟接口方法中。</p>\n<p><code>原因：</code></p>\n<p>chain.filter是个异步操作，可以理解为前端的promise</p>\n<p><code>解决方案：</code></p>\n<p>利用Spring Cloud Gateway提供的自定义响应装饰器中的response装饰者，以次增强原有response的处理能力</p>\n<p>引申：什么叫装饰者设计模式？</p>\n<p>​    作用就是：在原本类的基础上对原有类的能力的增强，也就可以理解为给response买了一件装备，拥有了更多的能力。解释成代码语言意思就是，增写response部分代码，实现需要的功能。</p>\n<p><code>参考博客：</code> </p>\n<p><a href=\"https://blog.csdn.net/qq_19636353/article/details/126759522\">https://blog.csdn.net/qq_19636353/article/details/126759522</a>  (以这个为主) </p>\n<p><code>其他参考：</code> </p>\n<p><a href=\"https://blog.csdn.net/m0_67595943/article/details/124667975\">https://blog.csdn.net/m0_67595943/article/details/124667975</a> </p>\n<p><a href=\"https://blog.csdn.net/weixin_43933728/article/details/121359727?spm=1001.2014.3001.5501\">https://blog.csdn.net/weixin_43933728/article/details/121359727?spm=1001.2014.3001.5501</a> </p>\n<p><a href=\"https://blog.csdn.net/zx156955/article/details/121670681\">https://blog.csdn.net/zx156955/article/details/121670681</a> <a href=\"https://blog.csdn.net/qq_39529562/article/details/108911983\">https://blog.csdn.net/qq_39529562/article/details/108911983</a></p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> Mono&lt;Void&gt; <span class=\"hljs-title function_\">handleResponse</span><span class=\"hljs-params\">(ServerWebExchange exchange, GatewayFilterChain chain)</span>&#123;  <br><br>    <span class=\"hljs-keyword\">try</span> &#123;  <br>        <span class=\"hljs-comment\">//从交换寄拿响应对象  </span><br>        <span class=\"hljs-type\">ServerHttpResponse</span> <span class=\"hljs-variable\">originalResponse</span> <span class=\"hljs-operator\">=</span> exchange.getResponse();  <br>        <span class=\"hljs-comment\">//缓冲区工厂，拿到缓存数据  </span><br>        <span class=\"hljs-type\">DataBufferFactory</span> <span class=\"hljs-variable\">bufferFactory</span> <span class=\"hljs-operator\">=</span> originalResponse.bufferFactory();  <br>        <span class=\"hljs-comment\">//拿到响应码  </span><br>        <span class=\"hljs-type\">HttpStatus</span> <span class=\"hljs-variable\">statusCode</span> <span class=\"hljs-operator\">=</span> originalResponse.getStatusCode();  <br>        <span class=\"hljs-keyword\">if</span>(statusCode == HttpStatus.OK)&#123;  <br>            <span class=\"hljs-comment\">//装饰，增强能力  </span><br>            <span class=\"hljs-type\">ServerHttpResponseDecorator</span> <span class=\"hljs-variable\">decoratedResponse</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ServerHttpResponseDecorator</span>(originalResponse) &#123;  <br>            <span class=\"hljs-comment\">//等调用完转发的接口后才会执行</span><br>                <span class=\"hljs-meta\">@Override</span>  <br>                <span class=\"hljs-keyword\">public</span> Mono&lt;Void&gt; <span class=\"hljs-title function_\">writeWith</span><span class=\"hljs-params\">(Publisher&lt;? extends DataBuffer&gt; body)</span> &#123;  <br>                    log.info(<span class=\"hljs-string\">&quot;body instanceof Flux: &#123;&#125;&quot;</span>, (body <span class=\"hljs-keyword\">instanceof</span> Flux));  <br>                    <span class=\"hljs-comment\">//对象是响应式的  </span><br>                    <span class=\"hljs-keyword\">if</span> (body <span class=\"hljs-keyword\">instanceof</span> Flux) &#123;  <br>                        <span class=\"hljs-comment\">//我们拿到真正的body  </span><br>                        Flux&lt;? <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">DataBuffer</span>&gt; fluxBody = Flux.from(body); <br>                        <span class=\"hljs-comment\">//往返回值里面写数据  </span><br>                        <span class=\"hljs-comment\">//拼接字符串  </span><br>                        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">super</span>.writeWith(fluxBody.map(dataBuffer -&gt; &#123; <br>                            <span class=\"hljs-comment\">// 7. TODO 调用成功，接口调用次数 + 1 invokeCount</span><br>                            <span class=\"hljs-type\">byte</span>[] content = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">byte</span>[dataBuffer.readableByteCount()];  <br>                            dataBuffer.read(content);  <br>                            DataBufferUtils.release(dataBuffer);<span class=\"hljs-comment\">//释放掉内存  </span><br>                            <span class=\"hljs-comment\">// 构建日志  </span><br>                            <span class=\"hljs-type\">StringBuilder</span> <span class=\"hljs-variable\">sb2</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">StringBuilder</span>(<span class=\"hljs-number\">200</span>);  <br>                            sb2.append(<span class=\"hljs-string\">&quot;&lt;--- &#123;&#125; &#123;&#125; \\n&quot;</span>);  <br>                            List&lt;Object&gt; rspArgs = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ArrayList</span>&lt;&gt;();  <br>                            rspArgs.add(originalResponse.getStatusCode());  <br>                            <span class=\"hljs-comment\">//rspArgs.add(requestUrl);  </span><br>                            <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">data</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">String</span>(content, StandardCharsets.UTF_8);<span class=\"hljs-comment\">//data </span><br>                            sb2.append(data);  <br>                            log.info(sb2.toString(), rspArgs.toArray());<span class=\"hljs-comment\">//log.info(&quot;&lt;-- &#123;&#125; &#123;&#125;\\n&quot;, originalResponse.getStatusCode(), data);  </span><br>                           <span class=\"hljs-keyword\">return</span> bufferFactory.wrap(content);  <br>                        &#125;));  <br>                    &#125; <span class=\"hljs-keyword\">else</span> &#123;  <br>                        <span class=\"hljs-comment\">// 8. 调用失败，fan&#x27;hui一个规范的</span><br>                        log.error(<span class=\"hljs-string\">&quot;&lt;--- &#123;&#125; 响应code异常&quot;</span>, getStatusCode());  <br>                    &#125;  <br>                    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">super</span>.writeWith(body);  <br>                &#125;  <br>            &#125;;  <br>            <span class=\"hljs-comment\">//设置 response 对象为装饰过的  </span><br>            <span class=\"hljs-keyword\">return</span> chain.filter(exchange.mutate().response(decoratedResponse).build());  <br>        &#125;  <br>        <span class=\"hljs-keyword\">return</span> chain.filter(exchange);<span class=\"hljs-comment\">//降级处理返回数据  </span><br>    &#125;<span class=\"hljs-keyword\">catch</span> (Exception e)&#123;<br>        log.error(<span class=\"hljs-string\">&quot;gateway log exception.\\n&quot;</span> + e);  <br>        <span class=\"hljs-keyword\">return</span> chain.filter(exchange);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"Day06-完善网关的业务逻辑\"><a href=\"#Day06-完善网关的业务逻辑\" class=\"headerlink\" title=\"Day06 完善网关的业务逻辑\"></a>Day06 完善网关的业务逻辑</h2><h3 id=\"今日计划-1\"><a href=\"#今日计划-1\" class=\"headerlink\" title=\"今日计划\"></a>今日计划</h3><ol>\n<li>补充完整网关的业务逻辑（如何操作数据库?如何服用之前写过的方法？RPC）</li>\n<li>完善系统的TODO和其他功能，并开发一个管理员的监控统计功能</li>\n</ol>\n<h3 id=\"网关业务逻辑\"><a href=\"#网关业务逻辑\" class=\"headerlink\" title=\"网关业务逻辑\"></a>网关业务逻辑</h3><p>问题：之前的项目已经写过了调用数据库的那些mybatis的业务逻辑，复制粘贴太麻烦</p>\n<p>解决：用一个可以直接调用的解决方法：RPC</p>\n<h3 id=\"如何调用其他项目的方法\"><a href=\"#如何调用其他项目的方法\" class=\"headerlink\" title=\"如何调用其他项目的方法\"></a>如何调用其他项目的方法</h3><ol>\n<li>复制粘贴代码和相关依赖</li>\n<li>HTTP请求（提供接口，供其他项目进行调用）</li>\n<li>jar包调用</li>\n<li>把公共代码达成jar包，其他项目直接引用</li>\n</ol>\n<h3 id=\"HTTP请求怎么调用\"><a href=\"#HTTP请求怎么调用\" class=\"headerlink\" title=\"HTTP请求怎么调用\"></a>HTTP请求怎么调用</h3><ol>\n<li>提供方开发一个接口（地址、请求方法、参数、返回值）</li>\n<li>调用方使用<code>HTTP Client</code>之类的代码取发送HTTP请求</li>\n</ol>\n<h3 id=\"RPC（remote-produce-call）\"><a href=\"#RPC（remote-produce-call）\" class=\"headerlink\" title=\"RPC（remote produce call）\"></a>RPC（remote produce call）</h3><p><strong>作用：像调用本地方法一样去调用远程方法</strong></p>\n<p>优点：</p>\n<pre><code>1. 对开发者更加透明，减少了调用见的沟通成本\n1. RPC向远程服务器发送请求时，未必要使用HTTP协议，比如：TCP/IP、或者自己封装的协议。（内部服务更加适用）\n</code></pre>\n<h3 id=\"Feign-amp-amp-RPC\"><a href=\"#Feign-amp-amp-RPC\" class=\"headerlink\" title=\"Feign &amp;&amp; RPC\"></a><code>Feign &amp;&amp; RPC</code></h3><blockquote>\n<p>Feign底层用的HTTP协议，虽然也可以很方便的进行调用，但是区别在于Feign只是让请求过程更加精简,HTTP请求其实可以做到和RPC一样的事情，但是还有区别：RPC向远程服务器发送请求时，未必要使用HTTP协议，比如：TCP/IP、或者自己封装的协议。</p>\n</blockquote>\n<p>HTTP协议是一个7层协议，如果想要接口的性能更高，可以使用TCP/IP协议，更加原生的协议。</p>\n<p>一般来说微服务项目内部的接口，用<code>RPC</code>的性能可能会更加高一点，协议可选项更加多一点。</p>\n<p><code>工作流程图：</code></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/wl2o2o/blogCdn/img/202307292328515.png\" alt=\"image-20230729232829504\"></p>\n<p>🆗，现在模型已经搭建好了，那么如何进行实现呢？使用Dubbo框架（如何学习？看官方文档）</p>\n<h3 id=\"Dubbo框架（RPC实现）（阿里公司的）\"><a href=\"#Dubbo框架（RPC实现）（阿里公司的）\" class=\"headerlink\" title=\"Dubbo框架（RPC实现）（阿里公司的）\"></a>Dubbo框架（RPC实现）（阿里公司的）</h3><p>其它类似的框架还有<code>GRPC</code>（Google公司的）、<code>TRPC</code>（腾讯公司的）</p>\n<p>最好的学习方式：<a href=\"https://cn.dubbo.apache.org/zh-cn/overview/mannual/java-sdk/quick-start/spring-boot/\">阅读官方文档！</a></p>\n<h3 id=\"两种使用方式\"><a href=\"#两种使用方式\" class=\"headerlink\" title=\"两种使用方式\"></a>两种使用方式</h3><ol>\n<li><p>Spring Boot代码（注解+编程式）：写Java接口，服务提供者和消费者都去引用这个接口 偏程导</p>\n</li>\n<li><p>IDL(接口调用语言)：创建一个公共的接口定义文件，服务提供者和消费者读取这个文件。</p>\n<p>优点：</p>\n<ul>\n<li><p>跨语言，所有的框架都认识</p>\n</li>\n<li><p>底层是Triple（自定义封装协议，优点见<a href=\"https://cn.dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/protocol/triple/\">官文</a>）</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/wl2o2o/blogCdn/img/202307300038465.png\" alt=\"image-20230730003800623\"></p>\n</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"示例项目学习\"><a href=\"#示例项目学习\" class=\"headerlink\" title=\"示例项目学习\"></a>示例项目学习</h3><figure class=\"highlight crmsh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs crmsh\">git <span class=\"hljs-keyword\">clone</span> <span class=\"hljs-title\">-b</span> <span class=\"hljs-keyword\">master</span> <span class=\"hljs-title\">https</span>://github.com/apache/dubbo-samples.git<br></code></pre></td></tr></table></figure>\n\n<p>zookeeper注册中心：通过内嵌的方式运行，更方便</p>\n<p>最先启动注册中心，先启动服务提供者，再启动服务消费者</p>\n<h3 id=\"整合应用\"><a href=\"#整合应用\" class=\"headerlink\" title=\"整合应用\"></a>整合应用</h3><ol>\n<li><p>服务提供者：backend</p>\n<p>a. 实际情况应该是去数据库中查是否已分配给用户</p>\n<p>b. 从数据库中查询模拟接口是否存在，以及请求方法是否匹配（还可以校验请求参数）</p>\n<p>c. 调用成功，接口调用次数+1 invokeCount</p>\n</li>\n<li><p>gateway项日作为服务调用者，调用这3个方法</p>\n</li>\n</ol>\n<blockquote>\n<p>整合步骤：</p>\n<ol>\n<li><p>依赖引入  视频事件：<code>00:52</code></p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs\">                                                                                                               <br></code></pre></td></tr></table></figure></li>\n<li><p>将官方示例代码中的privider包粘到backend中</p>\n</li>\n</ol>\n</blockquote>\n<h2 id=\"Day07-完善网关业务与上线\"><a href=\"#Day07-完善网关业务与上线\" class=\"headerlink\" title=\"Day07 完善网关业务与上线\"></a>Day07 完善网关业务与上线</h2><h3 id=\"今日计划-2\"><a href=\"#今日计划-2\" class=\"headerlink\" title=\"今日计划\"></a>今日计划</h3><ol>\n<li>完善网关的业务</li>\n<li>开发管理员的分析功能</li>\n<li>项目上线</li>\n</ol>\n<h3 id=\"整合nacos\"><a href=\"#整合nacos\" class=\"headerlink\" title=\"整合nacos\"></a>整合nacos</h3><blockquote>\n<p>遇到一个<code>nocos</code>小BUG：</p>\n<p>Dubbo整合nocos的时候，提供者与消费者的包名不一样，这时，提供者将接口的信息注册到nacos文档时，用到的是provider的包名路径，如果出现消费者的包名路径与提供者的包名不同的时候，这时消费者就会报错找不到提供者的Service服务，如图：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/wl2o2o/blogCdn/img/202307311932647.png\" alt=\"image-20230731193204173\"></p>\n</blockquote>\n<h3 id=\"重新梳理网关的业务逻辑\"><a href=\"#重新梳理网关的业务逻辑\" class=\"headerlink\" title=\"重新梳理网关的业务逻辑\"></a>重新梳理网关的业务逻辑</h3><ol>\n<li><p>实际情况应该是去数据库中查是否已分配给用户</p>\n<p>a 先根据 accessKey 判断用户是否存在，查到 secretKey<br>b 对比 secretKey 和用户传的加密后的 secretKey 是否一致</p>\n</li>\n<li><p>从数据库中查询模拟接口是否存在，以及请求方法是否匹配（还可以校验请求参数）</p>\n</li>\n<li><p>调用成功，接口调用次数+1 invokeCount</p>\n</li>\n</ol>\n<h3 id=\"公共服务\"><a href=\"#公共服务\" class=\"headerlink\" title=\"公共服务\"></a>公共服务</h3><blockquote>\n<p>目的是让方法、实体在多个项目中进行复用，避免重复编写</p>\n</blockquote>\n<ul>\n<li><p>业务分析</p>\n<ul>\n<li><ol>\n<li>数据库中是否已分配给用户密钥（accesskey、secretkey，返回用户信息，为空表示不存在）√</li>\n<li>从数据库中查询模拟接口是否存在（请求路径、请求方法、请求参数，返回接口信息，为空表示不存在）</li>\n<li>接口调用次数 + 1 <code>invokeCount</code>（ak、sk、请求接口路径）√</li>\n</ol>\n</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><p>使用步骤：</p>\n<ul>\n<li><ol>\n<li>新建干净的 maven 项目，只保留必要的公共依赖</li>\n</ol>\n</li>\n<li><ol start=\"2\">\n<li>抽取 service 和实体类</li>\n</ol>\n</li>\n<li><ol start=\"3\">\n<li>install 本地 maven 包</li>\n</ol>\n</li>\n<li><ol start=\"4\">\n<li><p>让服务提供者引入 common 包，测试是否正常运行（出现Bug，backend包中的实现类一直报错：</p>\n<blockquote>\n<p><code>&#39;getBaseMapper()&#39; in &#39;com.baomidou.mybatisplus.extension.service.impl.ServiceImpl&#39; clashes with &#39;getBaseMapper()&#39; in &#39;com.baomidou.mybatisplus.extension.service.IService&#39;; attempting to use incompatible return type</code></p>\n<p>原因是<code>UserInterfaceInfoMapper</code>类中，忘记更改引入的实体类路径。</p>\n<p>小技巧：<img src=\"https://cdn.jsdelivr.net/gh/wl2o2o/blogCdn/img/202308030513641.png\" alt=\"image-20230803051309362\"></p>\n<p>可以通过这种方式快速实现外部提供的的接口。</p>\n</blockquote>\n</li>\n</ol>\n</li>\n<li><ol start=\"5\">\n<li>让服务消费者引入 common 包</li>\n</ol>\n</li>\n</ul>\n</li>\n<li><p>业务流程</p>\n<ul>\n<li><ol>\n<li>新建干净的 maven 项目，只保留必要的公共依赖</li>\n</ol>\n</li>\n<li><ol start=\"2\">\n<li>抽取 service 和实体类</li>\n</ol>\n</li>\n<li><ol start=\"3\">\n<li>install 本地 maven 包</li>\n</ol>\n</li>\n<li><ol start=\"4\">\n<li>让服务提供者引入 common 包，测试是否正常运行，加上@DubboService，以便供其它类使用</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">// mybatisplus真好用！业务crud手到擒来！</span><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * <span class=\"hljs-doctag\">@author</span> WLei224</span><br><span class=\"hljs-comment\"> * <span class=\"hljs-doctag\">@create</span> 2023/8/3 5:15</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">InnerInterfaceInfoServiceImpl</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title class_\">InnerInterfaceInfoService</span> &#123;<br>    <span class=\"hljs-meta\">@Resource</span><br>    <span class=\"hljs-keyword\">private</span> InterfaceInfoMapper interfaceInfoMapper;<br>    <span class=\"hljs-meta\">@Override</span><br>    <span class=\"hljs-keyword\">public</span> InterfaceInfo <span class=\"hljs-title function_\">getInterfaceInfo</span><span class=\"hljs-params\">(String url, String method)</span> &#123;<br>        <span class=\"hljs-keyword\">if</span> (StringUtils.isAnyBlank(url,method))&#123;<br>            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">BusinessException</span>(ErrorCode.PARAMS_ERROR);<br>        &#125;<br>        QueryWrapper&lt;InterfaceInfo&gt; queryWrapper = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">QueryWrapper</span>&lt;&gt;();<br>        queryWrapper.eq(<span class=\"hljs-string\">&quot;url&quot;</span>,url);<br>        queryWrapper.eq(<span class=\"hljs-string\">&quot;method&quot;</span>,method);<br>        <span class=\"hljs-keyword\">return</span> interfaceInfoMapper.selectOne(queryWrapper);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>\n<li><ol start=\"5\">\n<li>让服务消费者引入 common 包</li>\n</ol>\n<blockquote>\n<ol>\n<li><p>API网关项目中引入 common 依赖</p>\n</li>\n<li><p>使用服务提供者提供的服务（@DubboService和@DubboReference）</p>\n<p>通过@DubboReference注入公共模块中编写好的三个服务</p>\n</li>\n<li><p>完善网关中的todo标签，完善业务逻辑</p>\n</li>\n</ol>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h3><p>​    项目调试中存在一个问题：需要手动对接口的调用次数进行分配，这里考虑可以增加一个管理调用次数的接口。</p>\n</li>\n</ul>\n<h3 id=\"统计分析功能\"><a href=\"#统计分析功能\" class=\"headerlink\" title=\"统计分析功能\"></a>统计分析功能</h3><h4 id=\"需求\"><a href=\"#需求\" class=\"headerlink\" title=\"需求\"></a>需求</h4><p>各个接口的总调用次数的占比图（饼图），取调用次数最多的三个接口，从而进行分析出哪个接口还没有人进行调用，进而对其降低资源或者下线，高频接口（增加资源、提高收费）</p>\n<h4 id=\"实现-2\"><a href=\"#实现-2\" class=\"headerlink\" title=\"实现\"></a>实现</h4><ul>\n<li><p><strong>前端</strong></p>\n<ul>\n<li><p>强烈推荐使用现成的库</p>\n<ul>\n<li><p>Echarts：<a href=\"https://echarts.apache.org/zh/index.html%EF%BC%88%E6%8E%A8%E8%8D%90%EF%BC%89\">https://echarts.apache.org/zh/index.html（推荐）</a></p>\n</li>\n<li><p>AntV：<a href=\"https://antv.vision/zh%EF%BC%88%E6%8E%A8%E8%8D%90%EF%BC%89\">https://antv.vision/zh（推荐）</a></p>\n</li>\n<li><p>BizCharts</p>\n</li>\n<li><p>如果是 React 项目，用这个库：<a href=\"https://github.com/hustcc/echarts-for-react\">https://github.com/hustcc/echarts-for-react</a></p>\n</li>\n<li><blockquote>\n<p>怎么用？</p>\n<ol>\n<li>看官网</li>\n<li>找到快速入门、按文档去引入库</li>\n<li>进入示例页面</li>\n<li>找到你要的图</li>\n<li>在线调试</li>\n<li>复制代码</li>\n<li>改为真实数据</li>\n</ol>\n</blockquote>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>后端</strong></p>\n<ul>\n<li><p>写一个接口，得到下列示例数据：<br>接口 A：2次<br>接口 B：3次</p>\n</li>\n<li><p>步骤：</p>\n<ol>\n<li><p>SQL 查询调用数据：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">select</span> interfaceInfoId, <span class=\"hljs-built_in\">sum</span>(totalNum) <span class=\"hljs-keyword\">as</span> totalNum <span class=\"hljs-keyword\">from</span> user_interface_info <span class=\"hljs-keyword\">group</span> <span class=\"hljs-keyword\">by</span> interfaceInfoId <span class=\"hljs-keyword\">order</span> <span class=\"hljs-keyword\">by</span> totalNum <span class=\"hljs-keyword\">desc</span> limit <span class=\"hljs-number\">3</span>;<br></code></pre></td></tr></table></figure></li>\n<li><p>业务层去关联查询接口信息。</p>\n<p><code>controller</code>:（就不写Service了，直接写业务逻辑）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 分析控制器</span><br><span class=\"hljs-comment\"> * <span class=\"hljs-doctag\">@author</span> yupi</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-meta\">@RestController</span><br><span class=\"hljs-meta\">@RequestMapping(&quot;/analysis&quot;)</span><br><span class=\"hljs-meta\">@Slf4j</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">AnalysisController</span> &#123;<br><br>    <span class=\"hljs-meta\">@Resource</span><br>    <span class=\"hljs-keyword\">private</span> UserInterfaceInfoMapper userInterfaceInfoMapper;<br><br>    <span class=\"hljs-meta\">@Resource</span><br>    <span class=\"hljs-keyword\">private</span> InterfaceInfoService interfaceInfoService;<br><br>    <span class=\"hljs-meta\">@GetMapping(&quot;/top/interface/invoke&quot;)</span><br>    <span class=\"hljs-meta\">@AuthCheck(mustRole = &quot;admin&quot;)</span><br>    <span class=\"hljs-keyword\">public</span> BaseResponse&lt;List&lt;InterfaceInfoVO&gt;&gt; <span class=\"hljs-title function_\">listTopInvokeInterfaceInfo</span><span class=\"hljs-params\">()</span> &#123;<br>        List&lt;UserInterfaceInfo&gt; userInterfaceInfoList = userInterfaceInfoMapper.listTopInvokeInterfaceInfo(<span class=\"hljs-number\">3</span>);<br><br>        Map&lt;Long, List&lt;UserInterfaceInfo&gt;&gt; interfaceInfoIdObjMap = userInterfaceInfoList.stream()<br>                .collect(Collectors.groupingBy(UserInterfaceInfo::getInterfaceInfoId));<br><br>        QueryWrapper&lt;InterfaceInfo&gt; queryWrapper = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">QueryWrapper</span>&lt;&gt;();<br>        queryWrapper.in(<span class=\"hljs-string\">&quot;id&quot;</span>, interfaceInfoIdObjMap.keySet());<br>        List&lt;InterfaceInfo&gt; list = interfaceInfoService.list(queryWrapper);<br><br>        <span class=\"hljs-keyword\">if</span> (CollectionUtils.isEmpty(list)) &#123;<br>            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">BusinessException</span>(ErrorCode.SYSTEM_ERROR);<br>        &#125;<br>        List&lt;InterfaceInfoVO&gt; interfaceInfoVOList = list.stream().map(interfaceInfo -&gt; &#123;<br>            <span class=\"hljs-type\">InterfaceInfoVO</span> <span class=\"hljs-variable\">interfaceInfoVO</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">InterfaceInfoVO</span>();<br>            BeanUtils.copyProperties(interfaceInfo, interfaceInfoVO);<br>            <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">totalNum</span> <span class=\"hljs-operator\">=</span> interfaceInfoIdObjMap.get(interfaceInfo.getId()).get(<span class=\"hljs-number\">0</span>).getTotalNum();<br>            interfaceInfoVO.setTotalNum(totalNum);<br>            <span class=\"hljs-keyword\">return</span> interfaceInfoVO;<br>        &#125;).collect(Collectors.toList());<br>        <span class=\"hljs-keyword\">return</span> ResultUtils.success(interfaceInfoVOList);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><code>封装类</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 接口信息封装视图</span><br><span class=\"hljs-comment\"> * <span class=\"hljs-doctag\">@TableName</span> product</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-meta\">@EqualsAndHashCode(callSuper = true)</span><br><span class=\"hljs-meta\">@Data</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">InterfaceInfoVO</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">InterfaceInfo</span> &#123;<br><br>    <span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">     * 调用次数</span><br><span class=\"hljs-comment\">     */</span><br>    <span class=\"hljs-keyword\">private</span> Integer totalNum;<br><br>    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-type\">long</span> <span class=\"hljs-variable\">serialVersionUID</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">1L</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><code>UserInterfaceInfoMapper</code>:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * <span class=\"hljs-doctag\">@Entity</span> com.wl.smartapicommon.model.entity.UserInterfaceInfo</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">UserInterfaceInfoMapper</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">BaseMapper</span>&lt;UserInterfaceInfo&gt; &#123;<br><br>    <span class=\"hljs-comment\">// 获取前几个调用次数最多的接口</span><br>    List&lt;UserInterfaceInfo&gt; <span class=\"hljs-title function_\">listTopInvokeInterfaceInfo</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> limit)</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><code>xml中添加sql语句</code>：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">select</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;listTopInvokeInterfaceInfo&quot;</span> <span class=\"hljs-attr\">resultType</span>=<span class=\"hljs-string\">&quot;com.wl.smartapicommon.model.entity.UserInterfaceInfo&quot;</span>&gt;</span><br>    select interfaceInfoId, sum(totalNum) as totalNum<br>    from user_interface_info<br>    group by interfaceInfoId<br>    order by totalNum<br>    desc limit #&#123;limit&#125;;<br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">select</span>&gt;</span><br></code></pre></td></tr></table></figure></li>\n</ol>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"上线计划\"><a href=\"#上线计划\" class=\"headerlink\" title=\"上线计划\"></a>上线计划</h2><ul>\n<li>前端：参考之前用户中心或伙伴匹配系统的上线方式</li>\n<li>后端：<ul>\n<li>backend 项目：web 项目，部署 spring boot 的 jar 包（对外的）</li>\n<li>gateway 网关项目：web 项目，部署 spring boot 的 jar 包（对外的）</li>\n<li>interface 模拟接口项目：web 项目，部署 spring boot 的 jar 包（不建议对外暴露的）</li>\n</ul>\n</li>\n</ul>\n<p><em><strong>关键：网络必须要连通</strong></em></p>\n<blockquote>\n<p>如果自己学习用：单个服务器部署这三个项目就足够。<br>如果你是搞大事，多个服务器建议在 同一内网 ，内网交互会更快、且更安全。</p>\n</blockquote>\n<h4 id=\"上线环境准备\"><a href=\"#上线环境准备\" class=\"headerlink\" title=\"上线环境准备\"></a>上线环境准备</h4><ol>\n<li><p>docker安装</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">curl -fsSL https://get.docker.com | bash -s docker --mirror Aliyun<br>systemctl start docker <br>systemctl enable docker<br>systenctl restart docker<br></code></pre></td></tr></table></figure></li>\n<li><p>宝塔面板</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\"><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">安装命令</span><br>yum install -y wget &amp;&amp; wget -O install.sh http://download.bt.cn/install/install_6.0.sh &amp;&amp; sh install.sh<br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">卸载命令</span><br>systemct stop bt<br>rm -rf /www/server/panel<br>rm -f /etc/init.d/bt<br><br>rm -rf /root/.pyenv/versions/3.7.0/envs/btpanel/lib/python3.7/site-packages/pycache<br>rm -rf /root/.pyenv/versions/3.7.0/envs/btpanel/lib/python3.7/site-packages/btpanel/__pycache__<br>rm -rf /root/.pyenv/versions/3.7.0/envs/btpanel/lib/python3.7/site-packages/panelApp/__pycache__<br><br>rm -rf /www/server/panel/logs/*<br></code></pre></td></tr></table></figure></li>\n<li><p><a href=\"https://blog.csdn.net/u010148813/article/details/126172372\">Docker 安装 Nginx</a></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\"><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">拉取官方的最新版本的镜像</span><br><span class=\"hljs-meta prompt_\">$ </span><span class=\"language-bash\">docker pull nginx</span><br><span class=\"hljs-meta prompt_\"></span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">使用以下命令来运行 nginx 容器</span><br><span class=\"hljs-meta prompt_\">$ </span><span class=\"language-bash\">docker run --name nginx -p 80:80 -d nginx</span><br><span class=\"hljs-meta prompt_\"></span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">在宿主机家目录创建用于放配置文件的文件夹</span><br><span class=\"hljs-meta prompt_\">$ </span><span class=\"language-bash\"><span class=\"hljs-built_in\">mkdir</span> -p /root/docker-nginx/&#123;conf,html,logs&#125;</span><br><span class=\"hljs-meta prompt_\"></span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">从容器nginx中复制nginx.conf文件到宿主机</span><br><span class=\"hljs-meta prompt_\">$ </span><span class=\"language-bash\">docker <span class=\"hljs-built_in\">cp</span> nginx:/etc/nginx/nginx.conf /root/docker-nginx</span>       <br><span class=\"hljs-meta prompt_\">$ </span><span class=\"language-bash\">docker <span class=\"hljs-built_in\">cp</span> nginx:/etc/nginx/conf.d/default.conf /root/docker-nginx/conf/</span><br><span class=\"hljs-meta prompt_\">$ </span><span class=\"language-bash\">docker <span class=\"hljs-built_in\">cp</span> nginx:/usr/share/nginx/html/ /root/docker-nginx/</span><br><br><br>----------------------------------------------<br>说明：<br>宿主机：就是你的云服务器或者虚拟机。<br>~ 目录，也就是我们常说的家目录/home/your_username.(如果是云服务器，且没有创建普通用户，那么家目录就是 /root 了，也就是我们说的管理员用户，拥有最高权限，所以命令就不用加上 sudo 了)<br><br>刚才的操作是把你在docker中拉取的 Nginx 的镜像配置文件复制了一份到家目录，这样可以便于后续对 nginx 的配置，say Why?，因为我们接下来会通过映射，将我们复制到宿主机的配置文件直接映射到 docker 容器中的 Nginx 中，是不是很方便，下次若需要配置，就可以直接在宿主机中进行配置了，否则还需要通过 `$ docker exec -it nginx bash` 命令进入到 Nginx 的镜像之中。<br></code></pre></td></tr></table></figure>\n\n\n\n<ul>\n<li>打包一下复制好的配置文件（备份，以免操作失误可补救）</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\"><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">删掉 nginx 容器</span><br><span class=\"hljs-meta prompt_\">$ </span><span class=\"language-bash\">docker stop nginx</span><br><span class=\"hljs-meta prompt_\">$ </span><span class=\"language-bash\">docker <span class=\"hljs-built_in\">rm</span> nginx</span><br><span class=\"hljs-meta prompt_\"></span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">重新运行容器，并加上配置文件的映射</span><br><span class=\"hljs-meta prompt_\">$ </span><span class=\"language-bash\">docker run -p 80:80 \\</span><br><span class=\"language-bash\">-v /root/docker-nginx/nginx.conf:/etc/nginx/nginx.conf \\</span><br><span class=\"language-bash\">-v /root/docker-nginx/logs:/var/log/nginx \\</span><br><span class=\"language-bash\">-v /root/docker-nginx/html:/usr/share/nginx/html \\</span><br><span class=\"language-bash\">-v /root/docker-nginx/conf:/etc/nginx/conf.d \\</span><br><span class=\"language-bash\">--name nginx \\</span><br><span class=\"language-bash\">--privileged=<span class=\"hljs-literal\">true</span> \\</span><br><span class=\"language-bash\">--restart=always \\</span><br><span class=\"language-bash\">-d nginx</span><br><br>----------------------------------------------<br>终于完成！如遇到403或者无法访问此网站等其他问题，首先去你购买的云服务器的安全组新增 80 端口，如果你开了代理，试着重启或者注销电脑。<br>参考链接：https://blog.csdn.net/l123lgx/article/details/122619851<br><br>server &#123;<br>    listen 80;<br>    server_name localhost;<br>    #charset koi8-r;<br>    #access_log logs/host.access.log main;<br>    location / &#123;<br>        root html;<br>        index index.html index.htm;<br>\t&#125;<br>    #error_page 404 /404.html;<br>    # redirect server error pages to the static page /50x.html<br>    #<br>    error_page 500 502 503 504 /50x.html;<br>    location = /50x.html &#123;<br>    \troot html;<br>    &#125;<br>    # proxy the PHP scripts to Apache listening on 127.0.0.1:80<br>    #<br>    #location ~ \\.php$ &#123;<br>    # proxy_pass http://127.0.0.1;<br>    #&#125;<br>    # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000<br>    #<br>    #location ~ \\.php$ &#123;<br>    # root html;<br>    # fastcgi_pass 127.0.0.1:9000;<br>    # fastcgi_index index.php;<br>    # fastcgi_param SCRIPT_FILENAME /scripts$fastcgi_script_name;<br>    # include fastcgi_params;<br>    #&#125;<br>    # deny access to .htaccess files, if Apache&#x27;s document root<br>    # concurs with nginx&#x27;s one<br>    #<br>    #location ~ /\\.ht &#123;<br>    # deny all;<br>    #&#125;<br>&#125;<br>    # another virtual host using mix of IP-, name-, and port-based configuration<br>    #<br>    #server &#123;<br>    # listen 8000;<br>    # listen somename:8080;<br>    # server_name somename alias another.alias;<br>    # location / &#123;<br>    # root html;<br>    # index index.html index.htm;<br>    # &#125;<br>    #&#125;<br>    # HTTPS server<br>    #<br>    #server &#123;<br>    # listen 443 ssl;<br>    # server_name localhost;<br>    # ssl_certificate cert.pem;<br>    # ssl_certificate_key cert.key;<br>    # ssl_session_cache shared:SSL:1m;<br>    # ssl_session_timeout 5m;<br>    # ssl_ciphers HIGH:!aNULL:!MD5;<br>    # ssl_prefer_server_ciphers on;<br>    # location / &#123;<br>    # root html;<br>    # index index.html index.htm;<br>    # &#125;<br>    #&#125;<br><br></code></pre></td></tr></table></figure>\n\n<p>复习一下<code>tar</code>命令的用法：</p>\n<img src=\"https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202308260050797.png\" alt=\"image-20230826005051120\" style=\"zoom:50%;\" />\n\n<p>解压的话亦是同理：</p>\n<blockquote>\n<p>解压 tar 存档文件的常用命令是 <code>tar -xzvf</code>。下面是对这些参数的解释：</p>\n<ul>\n<li><code>-x</code>：表示从存档文件中提取（解压）文件。</li>\n<li><code>-z</code>：表示使用 gzip 压缩算法进行解压缩。使用此参数可以解压被 gzip 压缩的 tar 存档文件。</li>\n<li><code>-v</code>：表示在命令执行过程中显示详细信息，即显示提取的文件列表。</li>\n<li><code>-f</code>：指定要提取的存档文件的名称。紧跟在 <code>-f</code> 参数后面的是存档文件的名称。</li>\n</ul>\n</blockquote>\n<ol start=\"4\">\n<li><p><code>docker</code>安装<code>MySQL</code></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">docker pull mysql<br><span class=\"hljs-meta prompt_\"></span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">在宿主机家目录创建用于放配置文件的文件夹</span><br><span class=\"hljs-meta prompt_\">$ </span><span class=\"language-bash\"><span class=\"hljs-built_in\">mkdir</span> -p /root/docker-mysql/&#123;conf,data,<span class=\"hljs-built_in\">log</span>&#125;</span><br><span class=\"hljs-meta prompt_\"></span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">在配置文件目录:/root/docker-mysql/conf新建一个my.cnf配置文件，写入下面内容，设置客户端和mysql服务器端编码都为utf8</span><br>[client]<br>default_character_set=utf8<br>[mysqld]<br>collation_server=utf8_general_ci<br>character_set_server=utf8<br><br>docker run -p 3306:3306 \\<br>--privileged=true \\<br>-v /root/docker-mysql/log:/var/log/mysql \\<br>-v /root/docker-mysql/data:/var/lib/mysql \\<br>-v /root/docker-mysql/conf:/etc/mysql/conf.d \\<br>-e MYSQL_ROOT_PASSWORD=你的MySQL密码 \\<br>--name mysql \\<br>-d mysql<br><br>docker exec -it mysql bash<br><br>mysql -u root -p<br><br>如果遇到`Navicat`连接不上的问题，请看下面的链接。<br></code></pre></td></tr></table></figure>\n\n<p>记录一个大坑，宝塔面板添加3306端口号，被腾讯云服务器拦截了，无语了，还是通过云服务器控制台（推荐✨）或者防火墙命令来添加端口吧。</p>\n<p>参考链接：<a href=\"https://www.cnblogs.com/--eric/p/17145834.html\">https://www.cnblogs.com/--eric/p/17145834.html</a></p>\n</li>\n</ol>\n<ol start=\"5\">\n<li><p><code>JDK</code>安装</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\"><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">yum 安装免环境变量的配置</span><br><span class=\"hljs-meta prompt_\">$ </span><span class=\"language-bash\">yum install -y java-1.8.0-openjdk*</span><br></code></pre></td></tr></table></figure></li>\n<li><p><code>maven</code>安装</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">通过以下命令获取安装包或者通过本地浏览器下载到主机，然后通过 ftp 传输到 Linux 服务器<br>curl -O https://dlcdn.apache.org/maven/maven-3/3.8.8/binaries/apache-maven-3.8.8-bin.tar.gz<br><br>tar -zxvf apache-maven-3.8.8-bin.tar.gz<br><br>vim /etc/profile<br><br>文件空白处增加两行内容：<br>export MAVEN_HOME=/root/services/apache-maven-3.8.8<br>export PATH=$MAVEN_HOME/bin:$PATH<br><br>source /etc/profile<br><br>mvn --version<br><br></code></pre></td></tr></table></figure></li>\n<li><p><code>redis</code>安装</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">docker pull redis<br><br>mkdir -p /root/docker-redis/conf<br><span class=\"hljs-meta prompt_\"></span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">入redis配置文件夹</span><br>cd /root/docker-redis/conf  <br><span class=\"hljs-meta prompt_\"></span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">下载redis配置文件</span><br>wget http://download.redis.io/redis-stable/redis.conf   <br><br>vim redis.conf  // 修改配置文件<br>1. appendonly yes    启动Redis持久化功能 (默认 no , 所有信息都存储在内存 [重启丢失] 。设置为 yes , 将存储在硬盘 [重启还在])<br>2. protected-mode no    关闭protected-mode模式，此时外部网络可以直接访问<br>3. bind 0.0.0.0    设置所有IP都可以访问<br>4. requirepass 密码    设置密码<br>如果你设置了密码,需要通过如下命令进入Redis控制台<br><span class=\"hljs-meta prompt_\">#</span><span class=\"language-bash\"><span class=\"hljs-comment\"># 进入Redis容器</span></span><br>        docker exec -it redis bash<br><span class=\"hljs-meta prompt_\">#</span><span class=\"language-bash\"><span class=\"hljs-comment\"># 通过密码进入Redis控制台</span></span><br>        redis-cli -h 127.0.0.1 -p 6379 -a [你的密码]<br>        <br>mkdir -p /root/docker-redis/data<br><br>docker run -p 6379:6379 \\<br>-v /root/docker-redis/conf/redis.conf:/etc/redis/redis.conf \\<br>-v /root/docker-redis/data:/data \\<br>-e REDIS_ROOT_PASSWORD=你的Redis密码 \\<br>--restart=always \\<br>--name redis \\<br>-d redis<br><br><br>不要忘记打开防火墙6379端口，通过宝塔面板或者命令，或者云服务器控制台<br></code></pre></td></tr></table></figure></li>\n<li><p><code>nacos</code>安装</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">docker pull nacos/nacos-server<br><span class=\"hljs-meta prompt_\"></span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">在宿主机家目录创建用于放配置文件的文件夹</span><br><span class=\"hljs-meta prompt_\">$ </span><span class=\"language-bash\"><span class=\"hljs-built_in\">mkdir</span> -p /root/docker-nacos/nacos/&#123;init.d,logs&#125;</span><br><br>vim /root/docker-nacos/nacos/init.d/application.properties <br><br>server.contextPath=/nacos<br>server.servlet.contextPath=/nacos<br>server.port=8848<br> <br>spring.datasource.platform=mysql<br>db.num=1<br>db.url.0=jdbc:mysql://xx.xx.xx.x:3306/nacos_devtest_prod?characterEncoding=utf8&amp;connectTimeout=1000&amp;socketTimeout=3000&amp;autoReconnect=true<br>db.user=user<br>db.password=pass<br> <br>nacos.cmdb.dumpTaskInterval=3600<br>nacos.cmdb.eventTaskInterval=10<br>nacos.cmdb.labelTaskInterval=300<br>nacos.cmdb.loadDataAtStart=false<br>management.metrics.export.elastic.enabled=false<br>management.metrics.export.influx.enabled=false<br>server.tomcat.accesslog.enabled=true<br>server.tomcat.accesslog.pattern=%h %l %u %t &quot;%r&quot; %s %b %D %&#123;User-Agent&#125;i<br>nacos.security.ignore.urls=/,/**/*.css,/**/*.js,/**/*.html,/**/*.map,/**/*.svg,/**/*.png,/**/*.ico,/console-fe/public/**,/v1/auth/login,/v1/console/health/**,/v1/cs/**,/v1/ns/**,/v1/cmdb/**,/actuator/**,/v1/console/server/**<br>nacos.naming.distro.taskDispatchThreadCount=1<br>nacos.naming.distro.taskDispatchPeriod=200<br>nacos.naming.distro.batchSyncKeyCount=1000<br>nacos.naming.distro.initDataRatio=0.9<br>nacos.naming.distro.syncRetryDelay=5000<br>nacos.naming.data.warmup=true<br>nacos.naming.expireInstance=true<br><br><br>docker run -p 8848:8848 \\<br>-e JVM_XMS=256m \\<br>-e JVM_XMX=256m \\<br>-e MODE=standalone \\<br>-e PREFER_HOST_MODE=hostname \\<br>-v /root/docker-nacos/nacos/logs:/home/nacos/logs \\<br>-v /root/docker-nacos/nacos/init.d/application.properties:/home/nacos/init.d/application.properties \\<br>--name nacos \\<br>--privileged=true \\<br>--restart=always \\<br>-d nacos/nacos-server<br></code></pre></td></tr></table></figure>\n\n<p>参考链接：<a href=\"https://blog.csdn.net/yexiaomodemo/article/details/123355202\">https://blog.csdn.net/yexiaomodemo/article/details/123355202</a></p>\n</li>\n<li><p><code>rabbitmq</code>安装</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">docker pull rabbitmq<br><br>docker run -p 5672:5672 -p 15672:15672 \\<br>-v /root/docker-rabbitmq/config/:/etc/rabbitmq/ \\<br>-e RABBITMQ_DEFAULT_USER=admin \\<br>-e RABBITMQ_DEFAULT_PASS=admin \\<br>--hostname myRabbit \\<br>--name rabbitmq \\<br>--restart=always \\<br>-d rabbitmq<br><br>docker exec -it rabbitmq bash<br><span class=\"hljs-meta prompt_\"></span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">启动可视化插件</span><br>rabbitmq-plugins enable rabbitmq_management<br><br>使用浏览器打开web管理端：http://Server-IP:15672 <br></code></pre></td></tr></table></figure></li>\n</ol>\n<p>   参考链接：</p>\n</li>\n</ol>\n<p>​      <a href=\"https://blog.csdn.net/qq_42977003/article/details/128107521\">https://blog.csdn.net/qq_42977003/article/details/128107521</a><br>​      <a href=\"https://blog.csdn.net/feritylamb/article/details/128434465\">https://blog.csdn.net/feritylamb/article/details/128434465</a></p>\n<h4 id=\"一、原始部署\"><a href=\"#一、原始部署\" class=\"headerlink\" title=\"一、原始部署\"></a>一、原始部署</h4><p>​    缺点：需要一个个配置环境，安装必须软件</p>\n<h4 id=\"二、宝塔面板部署\"><a href=\"#二、宝塔面板部署\" class=\"headerlink\" title=\"二、宝塔面板部署\"></a>二、宝塔面板部署</h4><p>​    优点：可视化安装与配置</p>\n<h4 id=\"三、docker部署\"><a href=\"#三、docker部署\" class=\"headerlink\" title=\"三、docker部署\"></a>三、docker部署</h4><blockquote>\n<p>Docker是一种开源的容器化平台，用于构建、发布和运行应用程序。通过使用Docker，您可以将应用程序及其依赖项打包到一个称为容器的独立单元中，以便在任何环境中运行，而无需担心环境差异或依赖问题。</p>\n<p>以下是一些与Docker相关的常用概念和命令：</p>\n<ol>\n<li>镜像（Image）：镜像是Docker容器的基础，它包含了运行应用程序所需的一切，包括代码、运行时环境、库和依赖项。您可以通过构建自定义镜像或从Docker Hub等镜像仓库中获取现有的镜像。</li>\n<li>容器（Container）：容器是基于镜像创建的运行实例，它是一个独立、隔离的执行环境。容器可以启动、停止、重启和删除，每个容器都具有自己的文件系统、进程空间和网络接口。</li>\n<li>Dockerfile：Dockerfile是用于定义镜像构建过程的文本文件。它包含一系列指令，用于指定基础镜像、安装软件、复制文件、设置环境变量等。</li>\n<li>Docker Compose：Docker Compose是一个用于定义和运行多个容器应用的工具。它使用一个YAML文件来定义各个服务及其依赖关系，并可以一键启动、停止和管理整个应用程序的容器群。</li>\n</ol>\n<p>一些常用的Docker命令包括：</p>\n<ul>\n<li><code>docker build</code>：根据Dockerfile构建镜像。</li>\n<li><code>docker run</code>：创建并运行一个新的容器。</li>\n<li><code>docker stop</code>：停止一个正在运行的容器。</li>\n<li><code>docker start</code>：启动已经停止的容器。</li>\n<li><code>docker rm</code>：删除一个或多个容器。</li>\n<li><code>docker images</code>：列出本地已下载的镜像。</li>\n<li><code>docker pull</code>：从镜像仓库下载镜像。</li>\n<li><code>docker push</code>：将本地镜像推送到镜像仓库。</li>\n</ul>\n<p>这只是Docker的一小部分功能和命令，Docker还提供了许多其他功能，如网络配置、数据卷、容器编排等。如果您想更深入了解Docker的使用，请参考官方文档或相关教程。</p>\n<p>docker如何打包一个镜像，命令是什么?</p>\n<p>要打包一个Docker镜像，您需要编写一个Dockerfile，其中包含构建镜像所需的指令和配置。然后，使用<code>docker build</code>命令来构建镜像。以下是基本的步骤和相应的命令：</p>\n<ol>\n<li><p>创建一个Dockerfile：在您的项目目录中创建一个名为<code>Dockerfile</code>的文本文件，可以使用任何文本编辑器打开并编辑它。</p>\n</li>\n<li><p>在Dockerfile中定义镜像构建过程：Dockerfile包含一系列指令，用于指定基础镜像、安装软件、复制文件、设置环境变量等。根据您的应用程序需求，编写适当的指令。</p>\n<p>以下是一个简单的Dockerfile示例：</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs dockerfile\"><span class=\"hljs-comment\"># 使用官方的 Node.js 作为基础镜像</span><br><span class=\"hljs-keyword\">FROM</span> node:<span class=\"hljs-number\">14</span><br><br><span class=\"hljs-comment\"># 设置工作目录</span><br><span class=\"hljs-keyword\">WORKDIR</span><span class=\"language-bash\"> /app</span><br><br><span class=\"hljs-comment\"># 复制应用程序代码到容器中</span><br><span class=\"hljs-keyword\">COPY</span><span class=\"language-bash\"> . .</span><br><br><span class=\"hljs-comment\"># 安装应用程序依赖</span><br><span class=\"hljs-keyword\">RUN</span><span class=\"language-bash\"> npm install</span><br><br><span class=\"hljs-comment\"># 暴露应用程序的端口</span><br><span class=\"hljs-keyword\">EXPOSE</span> <span class=\"hljs-number\">3000</span><br><br><span class=\"hljs-comment\"># 定义启动容器时运行的命令</span><br><span class=\"hljs-keyword\">CMD</span><span class=\"language-bash\"> [<span class=\"hljs-string\">&quot;npm&quot;</span>, <span class=\"hljs-string\">&quot;start&quot;</span>]</span><br><br>这个示例中，我们使用了官方的Node.js <span class=\"hljs-number\">14</span>镜像作为基础镜像，将应用程序代码复制到容器中，安装依赖项，暴露端口<span class=\"hljs-number\">3000</span>，并在容器启动时运行`npm start`命令。<br></code></pre></td></tr></table></figure></li>\n<li><p>构建镜像：在终端中，切换到包含Dockerfile的目录，并运行以下命令来构建镜像：</p>\n<figure class=\"highlight crmsh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs crmsh\">docker build -t image_name:<span class=\"hljs-keyword\">tag</span> <span class=\"hljs-title\">.</span><br></code></pre></td></tr></table></figure>\n\n<ul>\n<li><code>-t</code>参数用于指定镜像的名称和标签。您可以根据需要自定义名称和标签。</li>\n<li><code>.</code>表示Dockerfile所在的当前目录。确保在运行命令之前，您已经切换到正确的目录。</li>\n</ul>\n<p>例如，要构建一个名为<code>myapp</code>的镜像，标签为<code>v1.0</code>，可以运行以下命令：</p>\n<figure class=\"highlight mipsasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mipsasm\">docker <span class=\"hljs-keyword\">build </span>-t myapp:<span class=\"hljs-built_in\">v1</span>.<span class=\"hljs-number\">0</span> .<br></code></pre></td></tr></table></figure></li>\n<li><p>等待构建完成：Docker将执行Dockerfile中的每个指令，并构建镜像。这可能需要一些时间，取决于您的镜像大小和复杂性。</p>\n</li>\n<li><p>查看构建的镜像：构建完成后，可以使用以下命令查看本地的镜像列表：</p>\n<figure class=\"highlight ebnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ebnf\"><span class=\"hljs-attribute\">docker images</span><br></code></pre></td></tr></table></figure>\n\n<p>您将看到刚刚构建的镜像以及其名称、标签和大小等信息。</p>\n</li>\n</ol>\n<p>通过以上步骤，您就可以使用Dockerfile和<code>docker build</code>命令来打包构建自己的Docker镜像。请根据您的应用程序需求和环境配置适当地编辑Dockerfile。</p>\n</blockquote>\n<h5 id=\"前端部署例子：\"><a href=\"#前端部署例子：\" class=\"headerlink\" title=\"前端部署例子：\"></a>前端部署例子：</h5><p><code>dockerfile</code>文件：</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs dockerfile\"><span class=\"hljs-keyword\">FROM</span> nginx<br><br><span class=\"hljs-keyword\">WORKDIR</span><span class=\"language-bash\"> /usr/share/nginx/html/</span><br><span class=\"hljs-keyword\">USER</span> root<br><br><span class=\"hljs-keyword\">COPY</span><span class=\"language-bash\"> ./docker/nginx.conf /etc/nginx/conf.d/default.conf</span><br><br><span class=\"hljs-keyword\">COPY</span><span class=\"language-bash\"> ./dist  /usr/share/nginx/html/</span><br><br><span class=\"hljs-keyword\">EXPOSE</span> <span class=\"hljs-number\">80</span><br><br><span class=\"hljs-keyword\">CMD</span><span class=\"language-bash\"> [<span class=\"hljs-string\">&quot;nginx&quot;</span>, <span class=\"hljs-string\">&quot;-g&quot;</span>, <span class=\"hljs-string\">&quot;daemon off;&quot;</span>]</span><br></code></pre></td></tr></table></figure>\n\n<p><code>nginx.conf</code>文件：</p>\n<figure class=\"highlight nginx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs nginx\"><span class=\"hljs-section\">server</span> &#123;<br>    <span class=\"hljs-attribute\">listen</span> <span class=\"hljs-number\">80</span>;<br><br>    <span class=\"hljs-comment\"># gzip config</span><br>    <span class=\"hljs-attribute\">gzip</span> <span class=\"hljs-literal\">on</span>;<br>    <span class=\"hljs-attribute\">gzip_min_length</span> <span class=\"hljs-number\">1k</span>;<br>    <span class=\"hljs-attribute\">gzip_comp_level</span> <span class=\"hljs-number\">9</span>;<br>    <span class=\"hljs-attribute\">gzip_types</span> text/plain text/css text/javascript application/json application/javascript application/x-javascript application/xml;<br>    <span class=\"hljs-attribute\">gzip_vary</span> <span class=\"hljs-literal\">on</span>;<br>    <span class=\"hljs-attribute\">gzip_disable</span> <span class=\"hljs-string\">&quot;MSIE [1-6]\\.&quot;</span>;<br><br>    <span class=\"hljs-attribute\">root</span> /usr/share/nginx/html;<br>    <span class=\"hljs-attribute\">include</span> /etc/nginx/mime.types;<br><br>    <span class=\"hljs-section\">location</span> / &#123;<br>        <span class=\"hljs-attribute\">try_files</span> <span class=\"hljs-variable\">$uri</span> /index.html;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"项目扩展思路\"><a href=\"#项目扩展思路\" class=\"headerlink\" title=\"项目扩展思路\"></a>项目扩展思路</h3><ol>\n<li><p>用户自己可以申请更换签名</p>\n</li>\n<li><p>怎么让其他用户也能上传接口？</p>\n<blockquote>\n<ul>\n<li>需要提供一个机制（一个页面），让用户来输入自己的接口host（都武器的地址）、接口信息、将接口写入数据库；</li>\n<li>可以在interfaceInfo表中加个host字段，以次区分服务器地址，让接口提供者更灵活的接入系统；</li>\n<li>将接口信息入库前，要对接口进行校验，比如检查地址是否遵循规则、是否可以正常调用,并遵循甲方要求（使用SDK）</li>\n</ul>\n</blockquote>\n</li>\n<li><p>网关校验是否还有调用次数</p>\n<p>需要考虑并发的问题，防止瞬间调用超频。</p>\n</li>\n<li><p>网关优化</p>\n<p>比如增加限流、降级保护、提高性能等。还可以考虑搭配Nginx网关使用。</p>\n</li>\n<li><p>功能增强</p>\n<p>可以针对不同的请求头或者接口类型来设计前端界面和表单，百年与用户进行调用，增强体验。</p>\n<p>（可以参考swagger、postman、kniffj的界面）</p>\n</li>\n</ol>\n<h2 id=\"项目优化\"><a href=\"#项目优化\" class=\"headerlink\" title=\"项目优化\"></a>项目优化</h2><h3 id=\"扩展思路\"><a href=\"#扩展思路\" class=\"headerlink\" title=\"扩展思路\"></a>扩展思路</h3><ol>\n<li>用户可以申请更换签名</li>\n<li>怎么让其他用户也上传接口？<br>需要提供一个机制（界面），让用户输入自己的接口 host（服务器地址）、接口信息，将接口信息写入数据库。<br>可以在 interfaceInfo 表里加个 host 字段，区分服务器地址，让接口提供者更灵活地接入系统。<br>将接口信息写入数据库之前，要对接口进行校验（比如检查他的地址是否遵循规则，测试调用），保证他是正常的。<br>将接口信息写入数据库之前遵循咱们的要求（并且使用咱们的 sdk），<br>在接入时，平台需要测试调用这个接口，保证他是正常的。</li>\n<li>网关校验是否还有调用次数<br>需要考虑并发问题，防止瞬间调用超额。</li>\n<li>网关优化<br>比如增加限流 / 降级保护，提高性能等。还可以考虑搭配 Nginx 网关使用。</li>\n<li>功能增强<br>可以针对不同的请求头或者接口类型来设计前端界面和表单，便于用户调用，获得更好的体验。<br>可以参考 swagger、postman、knife4j 的页面。</li>\n</ol>\n"},{"title":"css","index_img":"https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202309120849257.png","abbrlink":52116,"date":"2022-09-10T04:14:21.000Z","_content":"\n<div style=\"background-image: url('https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202308211955549.jpg'); background-position: center center; background-repeat: no-repeat; background-size: cover; padding: 20px; opacity: 0.7; color: purple; line-height: 2; margin-top: 20px; margin-bottom: 20px;font-size: 15px;\">    \n    <div style=\"text-align: right; color: purple; line-height: 1.5; font-size: 15px;\">\n        右对齐<br>\n        厉害了<br>\n        我是一个html代码段\n    </div>\n</div>\n\n\n\n\n\n<!DOCTYPE html>\n<html>\n<head>\n  <title>前端博客</title>\n  <style>\n    /* 设置整个页面的字体样式为 Arial 或 sans-serif */\n    body {\n      font-family: Arial, sans-serif;\n      /* 设置页面的背景颜色为 #f2f2f2 */\n      background-color: #f2f2f2;\n      /* 清除页面的默认边距 */\n      margin: 0;\n      /* 设置页面内容与边框的间距为 20px */\n      padding: 20px;\n    }\n    /* 设置标题文本的颜色为 #333 */\n    h1 {\n      color: #333;\n      /* 设置标题居中对齐 */\n      text-align: center;\n    }\n    /* CSS 样式 */\n    .article {\n      /* 设置文章容器的背景颜色为 #fff */\n      background-color: #fff;\n      /* 设置文章容器的边框为 1px 实线，颜色为 #ccc */\n      border: 1px solid #ccc;\n      /* 设置文章容器的圆角边框为 5px */\n      border-radius: 5px;\n      /* 设置文章容器的内边距为 20px */\n      padding: 20px;\n      /* 设置文章容器与下方元素的间距为 20px */\n      margin-bottom: 20px;\n    }\n    /* 设置文章标题文本的颜色为 #555 */\n    .article h2 {\n      color: #555;\n    }\n    /* 设置文章段落文本的颜色为 #777，行高为 1.5 */\n    .article p {\n      color: #777;\n      line-height: 1.5;\n    }\n    /* 设置作者文本的颜色为 #888，字体大小为 12px */\n    .article .author {\n      color: #888;\n      font-size: 12px;\n    }\n  </style>\n</head>\n<body>\n  <!-- 页面标题 -->\n  <h1>前端博客</h1>\n  <div class=\"article\">\n    <!-- 文章标题 -->\n    <h2>如何学习前端开发</h2>\n    <!-- 文章段落 -->\n    <p>前端开发是构建用户界面的过程，它涉及 HTML、CSS 和 JavaScript 的使用。要学习前端开发，你可以按照以下步骤进行：</p>\n    <ol>\n      <!-- 有序列表 -->\n      <li>学习 HTML：HTML 是用于创建网页结构的标记语言。</li>\n      <li>掌握 CSS：CSS 用于为网页添加样式和布局。</li>\n      <li>深入学习 JavaScript：JavaScript 为网页添加交互和动态功能。</li>\n    </ol>\n    <!-- 文章作者 -->\n    <p class=\"author\">作者：John Doe</p>\n  </div>\n  <div class=\"article\">\n    <h2>CSS 基础入门</h2>\n    <p>CSS 是层叠样式表的缩写，它用于为 HTML 元素添加样式。以下是一些 CSS 的基础概念：</p>\n    <ul>\n      <!-- 无序列表 -->\n      <li>选择器：用于选择要应用样式的 HTML 元素。</li>\n      <li>属性：用于定义元素的样式，如颜色、字体大小、边框等。</li>\n      <li>盒模型：指元素的内容、内边距、边框和外边距的组合。</li>\n    </ul>\n    <!-- 文章作者 -->\n    <p class=\"author\">作者：Jane Smith</p>\n  </div>\n</body>\n</html>\n\n\n<!DOCTYPE html>\n<html>\n<head>\n  <title>My Page</title>\n  <style>\n      .container {\n      width: 100%;\n      /* 清除浮动 */\n      overflow: hidden; \n      }\n    .box {\n      width: 50%;\n      float: left;\n      /* 计算边框在宽度内 */\n      box-sizing: border-box;\n      border: 1px solid black;\n      padding: 10px;\n      /* 设置圆角半径 */\n      border-radius: 10px; \n    }\n  </style>\n</head>\n<body>\n  <!-- HTML 内容 -->\n  <div class=\"container\">\n    <div class=\"box\">Box 1</div>\n    <div class=\"box\">Box 2</div>\n  </div>\n</body>\n</html>\n\n","source":"_posts/css.md","raw":"---\ntitle: css\nindex_img: >-\n  https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202309120849257.png\ncategories:\n  - 前端\ntags:\n  - CSS\nabbrlink: 52116\ndate: 2022-09-10 12:14:21\n---\n\n<div style=\"background-image: url('https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202308211955549.jpg'); background-position: center center; background-repeat: no-repeat; background-size: cover; padding: 20px; opacity: 0.7; color: purple; line-height: 2; margin-top: 20px; margin-bottom: 20px;font-size: 15px;\">    \n    <div style=\"text-align: right; color: purple; line-height: 1.5; font-size: 15px;\">\n        右对齐<br>\n        厉害了<br>\n        我是一个html代码段\n    </div>\n</div>\n\n\n\n\n\n<!DOCTYPE html>\n<html>\n<head>\n  <title>前端博客</title>\n  <style>\n    /* 设置整个页面的字体样式为 Arial 或 sans-serif */\n    body {\n      font-family: Arial, sans-serif;\n      /* 设置页面的背景颜色为 #f2f2f2 */\n      background-color: #f2f2f2;\n      /* 清除页面的默认边距 */\n      margin: 0;\n      /* 设置页面内容与边框的间距为 20px */\n      padding: 20px;\n    }\n    /* 设置标题文本的颜色为 #333 */\n    h1 {\n      color: #333;\n      /* 设置标题居中对齐 */\n      text-align: center;\n    }\n    /* CSS 样式 */\n    .article {\n      /* 设置文章容器的背景颜色为 #fff */\n      background-color: #fff;\n      /* 设置文章容器的边框为 1px 实线，颜色为 #ccc */\n      border: 1px solid #ccc;\n      /* 设置文章容器的圆角边框为 5px */\n      border-radius: 5px;\n      /* 设置文章容器的内边距为 20px */\n      padding: 20px;\n      /* 设置文章容器与下方元素的间距为 20px */\n      margin-bottom: 20px;\n    }\n    /* 设置文章标题文本的颜色为 #555 */\n    .article h2 {\n      color: #555;\n    }\n    /* 设置文章段落文本的颜色为 #777，行高为 1.5 */\n    .article p {\n      color: #777;\n      line-height: 1.5;\n    }\n    /* 设置作者文本的颜色为 #888，字体大小为 12px */\n    .article .author {\n      color: #888;\n      font-size: 12px;\n    }\n  </style>\n</head>\n<body>\n  <!-- 页面标题 -->\n  <h1>前端博客</h1>\n  <div class=\"article\">\n    <!-- 文章标题 -->\n    <h2>如何学习前端开发</h2>\n    <!-- 文章段落 -->\n    <p>前端开发是构建用户界面的过程，它涉及 HTML、CSS 和 JavaScript 的使用。要学习前端开发，你可以按照以下步骤进行：</p>\n    <ol>\n      <!-- 有序列表 -->\n      <li>学习 HTML：HTML 是用于创建网页结构的标记语言。</li>\n      <li>掌握 CSS：CSS 用于为网页添加样式和布局。</li>\n      <li>深入学习 JavaScript：JavaScript 为网页添加交互和动态功能。</li>\n    </ol>\n    <!-- 文章作者 -->\n    <p class=\"author\">作者：John Doe</p>\n  </div>\n  <div class=\"article\">\n    <h2>CSS 基础入门</h2>\n    <p>CSS 是层叠样式表的缩写，它用于为 HTML 元素添加样式。以下是一些 CSS 的基础概念：</p>\n    <ul>\n      <!-- 无序列表 -->\n      <li>选择器：用于选择要应用样式的 HTML 元素。</li>\n      <li>属性：用于定义元素的样式，如颜色、字体大小、边框等。</li>\n      <li>盒模型：指元素的内容、内边距、边框和外边距的组合。</li>\n    </ul>\n    <!-- 文章作者 -->\n    <p class=\"author\">作者：Jane Smith</p>\n  </div>\n</body>\n</html>\n\n\n<!DOCTYPE html>\n<html>\n<head>\n  <title>My Page</title>\n  <style>\n      .container {\n      width: 100%;\n      /* 清除浮动 */\n      overflow: hidden; \n      }\n    .box {\n      width: 50%;\n      float: left;\n      /* 计算边框在宽度内 */\n      box-sizing: border-box;\n      border: 1px solid black;\n      padding: 10px;\n      /* 设置圆角半径 */\n      border-radius: 10px; \n    }\n  </style>\n</head>\n<body>\n  <!-- HTML 内容 -->\n  <div class=\"container\">\n    <div class=\"box\">Box 1</div>\n    <div class=\"box\">Box 2</div>\n  </div>\n</body>\n</html>\n\n","slug":"css","published":1,"updated":"2023-10-16T06:58:59.279Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clpkiczj3001wfkfogw3029ne","content":"<div style=\"background-image: url('https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202308211955549.jpg'); background-position: center center; background-repeat: no-repeat; background-size: cover; padding: 20px; opacity: 0.7; color: purple; line-height: 2; margin-top: 20px; margin-bottom: 20px;font-size: 15px;\">    \n    <div style=\"text-align: right; color: purple; line-height: 1.5; font-size: 15px;\">\n        右对齐<br>\n        厉害了<br>\n        我是一个html代码段\n    </div>\n</div>\n\n\n\n\n\n<!DOCTYPE html>\n<html>\n<head>\n  <title>前端博客</title>\n  <style>\n    /* 设置整个页面的字体样式为 Arial 或 sans-serif */\n    body {\n      font-family: Arial, sans-serif;\n      /* 设置页面的背景颜色为 #f2f2f2 */\n      background-color: #f2f2f2;\n      /* 清除页面的默认边距 */\n      margin: 0;\n      /* 设置页面内容与边框的间距为 20px */\n      padding: 20px;\n    }\n    /* 设置标题文本的颜色为 #333 */\n    h1 {\n      color: #333;\n      /* 设置标题居中对齐 */\n      text-align: center;\n    }\n    /* CSS 样式 */\n    .article {\n      /* 设置文章容器的背景颜色为 #fff */\n      background-color: #fff;\n      /* 设置文章容器的边框为 1px 实线，颜色为 #ccc */\n      border: 1px solid #ccc;\n      /* 设置文章容器的圆角边框为 5px */\n      border-radius: 5px;\n      /* 设置文章容器的内边距为 20px */\n      padding: 20px;\n      /* 设置文章容器与下方元素的间距为 20px */\n      margin-bottom: 20px;\n    }\n    /* 设置文章标题文本的颜色为 #555 */\n    .article h2 {\n      color: #555;\n    }\n    /* 设置文章段落文本的颜色为 #777，行高为 1.5 */\n    .article p {\n      color: #777;\n      line-height: 1.5;\n    }\n    /* 设置作者文本的颜色为 #888，字体大小为 12px */\n    .article .author {\n      color: #888;\n      font-size: 12px;\n    }\n  </style>\n</head>\n<body>\n  <!-- 页面标题 -->\n  <h1>前端博客</h1>\n  <div class=\"article\">\n    <!-- 文章标题 -->\n    <h2>如何学习前端开发</h2>\n    <!-- 文章段落 -->\n    <p>前端开发是构建用户界面的过程，它涉及 HTML、CSS 和 JavaScript 的使用。要学习前端开发，你可以按照以下步骤进行：</p>\n    <ol>\n      <!-- 有序列表 -->\n      <li>学习 HTML：HTML 是用于创建网页结构的标记语言。</li>\n      <li>掌握 CSS：CSS 用于为网页添加样式和布局。</li>\n      <li>深入学习 JavaScript：JavaScript 为网页添加交互和动态功能。</li>\n    </ol>\n    <!-- 文章作者 -->\n    <p class=\"author\">作者：John Doe</p>\n  </div>\n  <div class=\"article\">\n    <h2>CSS 基础入门</h2>\n    <p>CSS 是层叠样式表的缩写，它用于为 HTML 元素添加样式。以下是一些 CSS 的基础概念：</p>\n    <ul>\n      <!-- 无序列表 -->\n      <li>选择器：用于选择要应用样式的 HTML 元素。</li>\n      <li>属性：用于定义元素的样式，如颜色、字体大小、边框等。</li>\n      <li>盒模型：指元素的内容、内边距、边框和外边距的组合。</li>\n    </ul>\n    <!-- 文章作者 -->\n    <p class=\"author\">作者：Jane Smith</p>\n  </div>\n</body>\n</html>\n\n\n<!DOCTYPE html>\n<html>\n<head>\n  <title>My Page</title>\n  <style>\n      .container {\n      width: 100%;\n      /* 清除浮动 */\n      overflow: hidden; \n      }\n    .box {\n      width: 50%;\n      float: left;\n      /* 计算边框在宽度内 */\n      box-sizing: border-box;\n      border: 1px solid black;\n      padding: 10px;\n      /* 设置圆角半径 */\n      border-radius: 10px; \n    }\n  </style>\n</head>\n<body>\n  <!-- HTML 内容 -->\n  <div class=\"container\">\n    <div class=\"box\">Box 1</div>\n    <div class=\"box\">Box 2</div>\n  </div>\n</body>\n</html>\n\n","site":{"data":{}},"excerpt":"","more":"<div style=\"background-image: url('https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202308211955549.jpg'); background-position: center center; background-repeat: no-repeat; background-size: cover; padding: 20px; opacity: 0.7; color: purple; line-height: 2; margin-top: 20px; margin-bottom: 20px;font-size: 15px;\">    \n    <div style=\"text-align: right; color: purple; line-height: 1.5; font-size: 15px;\">\n        右对齐<br>\n        厉害了<br>\n        我是一个html代码段\n    </div>\n</div>\n\n\n\n\n\n<!DOCTYPE html>\n<html>\n<head>\n  <title>前端博客</title>\n  <style>\n    /* 设置整个页面的字体样式为 Arial 或 sans-serif */\n    body {\n      font-family: Arial, sans-serif;\n      /* 设置页面的背景颜色为 #f2f2f2 */\n      background-color: #f2f2f2;\n      /* 清除页面的默认边距 */\n      margin: 0;\n      /* 设置页面内容与边框的间距为 20px */\n      padding: 20px;\n    }\n    /* 设置标题文本的颜色为 #333 */\n    h1 {\n      color: #333;\n      /* 设置标题居中对齐 */\n      text-align: center;\n    }\n    /* CSS 样式 */\n    .article {\n      /* 设置文章容器的背景颜色为 #fff */\n      background-color: #fff;\n      /* 设置文章容器的边框为 1px 实线，颜色为 #ccc */\n      border: 1px solid #ccc;\n      /* 设置文章容器的圆角边框为 5px */\n      border-radius: 5px;\n      /* 设置文章容器的内边距为 20px */\n      padding: 20px;\n      /* 设置文章容器与下方元素的间距为 20px */\n      margin-bottom: 20px;\n    }\n    /* 设置文章标题文本的颜色为 #555 */\n    .article h2 {\n      color: #555;\n    }\n    /* 设置文章段落文本的颜色为 #777，行高为 1.5 */\n    .article p {\n      color: #777;\n      line-height: 1.5;\n    }\n    /* 设置作者文本的颜色为 #888，字体大小为 12px */\n    .article .author {\n      color: #888;\n      font-size: 12px;\n    }\n  </style>\n</head>\n<body>\n  <!-- 页面标题 -->\n  <h1>前端博客</h1>\n  <div class=\"article\">\n    <!-- 文章标题 -->\n    <h2>如何学习前端开发</h2>\n    <!-- 文章段落 -->\n    <p>前端开发是构建用户界面的过程，它涉及 HTML、CSS 和 JavaScript 的使用。要学习前端开发，你可以按照以下步骤进行：</p>\n    <ol>\n      <!-- 有序列表 -->\n      <li>学习 HTML：HTML 是用于创建网页结构的标记语言。</li>\n      <li>掌握 CSS：CSS 用于为网页添加样式和布局。</li>\n      <li>深入学习 JavaScript：JavaScript 为网页添加交互和动态功能。</li>\n    </ol>\n    <!-- 文章作者 -->\n    <p class=\"author\">作者：John Doe</p>\n  </div>\n  <div class=\"article\">\n    <h2>CSS 基础入门</h2>\n    <p>CSS 是层叠样式表的缩写，它用于为 HTML 元素添加样式。以下是一些 CSS 的基础概念：</p>\n    <ul>\n      <!-- 无序列表 -->\n      <li>选择器：用于选择要应用样式的 HTML 元素。</li>\n      <li>属性：用于定义元素的样式，如颜色、字体大小、边框等。</li>\n      <li>盒模型：指元素的内容、内边距、边框和外边距的组合。</li>\n    </ul>\n    <!-- 文章作者 -->\n    <p class=\"author\">作者：Jane Smith</p>\n  </div>\n</body>\n</html>\n\n\n<!DOCTYPE html>\n<html>\n<head>\n  <title>My Page</title>\n  <style>\n      .container {\n      width: 100%;\n      /* 清除浮动 */\n      overflow: hidden; \n      }\n    .box {\n      width: 50%;\n      float: left;\n      /* 计算边框在宽度内 */\n      box-sizing: border-box;\n      border: 1px solid black;\n      padding: 10px;\n      /* 设置圆角半径 */\n      border-radius: 10px; \n    }\n  </style>\n</head>\n<body>\n  <!-- HTML 内容 -->\n  <div class=\"container\">\n    <div class=\"box\">Box 1</div>\n    <div class=\"box\">Box 2</div>\n  </div>\n</body>\n</html>\n\n"},{"title":"最常用的Git命令汇总","index_img":"https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202309120849258.png","abbrlink":19040,"date":"2022-10-07T00:58:32.000Z","_content":"# 常用 Git 命令清单\n\n> 整理：CS_GUIDER，作者：[阮一峰](http://www.ruanyifeng.com/)，戳[原文链接](https://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html)。\n\n我每天使用 Git ，但是很多命令记不住。\n\n一般来说，日常使用只要记住下图6个命令，就可以了。但是熟练使用，恐怕要记住60～100个命令。\n\n![img](http://www.ruanyifeng.com/blogimg/asset/2015/bg2015120901.png)\n\n下面是我整理的常用 Git 命令清单。几个专用名词的译名如下。\n\n> - Workspace：工作区\n> - Index / Stage：暂存区\n> - Repository：仓库区（或本地仓库）\n> - Remote：远程仓库\n\n## 一、新建代码库\n\n> ```bash\n> # 在当前目录新建一个Git代码库\n> $ git init\n> \n> # 新建一个目录，将其初始化为Git代码库\n> $ git init [project-name]\n> \n> # 下载一个项目和它的整个代码历史\n> $ git clone [url]\n> ```\n\n## 二、配置\n\nGit的设置文件为`.gitconfig`，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。\n\n> ```bash\n> # 显示当前的Git配置\n> $ git config --list\n> \n> # 编辑Git配置文件\n> $ git config -e [--global]\n> \n> # 设置提交代码时的用户信息\n> $ git config [--global] user.name \"[name]\"\n> $ git config [--global] user.email \"[email address]\"\n> \n> # usage: git config [<options>]\n> Config file location\n>     --global              use global config file\n>     --system              use system config file\n>     --local               use repository config file\n>     --worktree            use per-worktree config file\n>     -f, --file <file>     use given config file\n>     --blob <blob-id>      read config from given blob object\n> \n> Action\n>     --get                 get value: name [value-pattern]\n>     --get-all             get all values: key [value-pattern]\n>     --get-regexp          get values for regexp: name-regex [value-pattern]\n>     --get-urlmatch        get value specific for the URL: section[.var] URL\n>     --replace-all         replace all matching variables: name value [value-pattern]\n>     --add                 add a new variable: name value\n>     --unset               remove a variable: name [value-pattern]\n>     --unset-all           remove all matches: name [value-pattern]\n>     --rename-section      rename section: old-name new-name\n>     --remove-section      remove a section: name\n>     -l, --list            list all\n>     --fixed-value         use string equality when comparing values to 'value-pattern'\n>     -e, --edit            open an editor\n>     --get-color           find the color configured: slot [default]\n>     --get-colorbool       find the color setting: slot [stdout-is-tty]\n> \n> Type\n>     -t, --type <>         value is given this type\n>     --bool                value is \"true\" or \"false\"\n>     --int                 value is decimal number\n>     --bool-or-int         value is --bool or --int\n>     --bool-or-str         value is --bool or string\n>     --path                value is a path (file or directory name)\n>     --expiry-date         value is an expiry date\n> \n> Other\n>     -z, --null            terminate values with NUL byte\n>     --name-only           show variable names only\n>     --includes            respect include directives on lookup\n>     --show-origin         show origin of config (file, standard input, blob, command line)\n>     --show-scope          show scope of config (worktree, local, global, system, command)\n>     --default <value>     with --get, use default value when missing entry\n> \n> \n> ```\n\n## 三、增加/删除文件\n\n> ```bash\n> # 添加指定文件到暂存区\n> $ git add [file1] [file2] ...\n> \n> # 添加指定目录到暂存区，包括子目录\n> $ git add [dir]\n> \n> # 添加当前目录的所有文件到暂存区\n> $ git add .\n> \n> # 添加每个变化前，都会要求确认\n> # 对于同一个文件的多处变化，可以实现分次提交\n> $ git add -p\n> \n> # 删除工作区文件，并且将这次删除放入暂存区\n> $ git rm [file1] [file2] ...\n> \n> # 停止追踪指定文件，但该文件会保留在工作区\n> $ git rm --cached [file]\n> \n> # 改名文件，并且将这个改名放入暂存区\n> $ git mv [file-original] [file-renamed]\n> ```\n\n## 四、代码提交\n\n> ```bash\n> # 提交暂存区到仓库区\n> $ git commit -m [message]\n> \n> # 提交暂存区的指定文件到仓库区\n> $ git commit [file1] [file2] ... -m [message]\n> \n> # 提交工作区自上次commit之后的变化，直接到仓库区\n> $ git commit -a\n> \n> # 提交时显示所有diff信息\n> $ git commit -v\n> \n> # 使用一次新的commit，替代上一次提交\n> # 如果代码没有任何新变化，则用来改写上一次commit的提交信息\n> $ git commit --amend -m [message]\n> \n> # 重做上一次commit，并包括指定文件的新变化\n> $ git commit --amend [file1] [file2] ...\n> ```\n\n## 五、分支\n\n> ````bash\n> # 列出所有本地分支\n> $ git branch\n> \n> # 列出所有远程分支\n> $ git branch -r\n> \n> # 列出所有本地分支和远程分支\n> $ git branch -a\n> \n> # 新建一个分支，但依然停留在当前分支\n> $ git branch [branch-name]\n> \n> # 新建一个分支，并切换到该分支\n> $ git checkout -b [branch]\n> \n> # 新建一个分支，指向指定commit\n> $ git branch [branch] [commit]\n> \n> # 新建一个分支，与指定的远程分支建立追踪关系\n> $ git branch --track [branch] [remote-branch]\n> \n> # 切换到指定分支，并更新工作区\n> $ git checkout [branch-name]\n> \n> # 切换到上一个分支\n> $ git checkout -\n> \n> # 建立追踪关系，在现有分支与指定的远程分支之间\n> $ git branch --set-upstream [branch] [remote-branch]\n> $ 详细说明：\n> `--set-upstream`是`git push`命令的一个选项，它用于在将本地分支推送到远程仓库时，同时设置本地分支与远程分支的关联关系。\n> \n> 当您使用`git push`命令将本地分支推送到远程仓库时，Git会尝试将本地分支的更新推送到与之关联的远程分支。通常情况下，当您首次推送本地分支时，远程仓库可能还没有与之对应的远程分支。在这种情况下，如果您使用`--set-upstream`选项，Git会自动在远程仓库上创建一个与本地分支同名的分支，并将其与本地分支关联起来。\n> \n> 所以，当您执行以下命令时：\n> ```\n> git push --set-upstream origin hexo\n> ```\n> 它的含义是将当前分支（假设是`hexo`）的更新推送到名为`origin`的远程仓库，并在远程仓库上创建一个名为`hexo`的分支，并将其与本地分支进行关联。\n> \n> 通过使用`--set-upstream`选项，您可以方便地建立本地分支与远程分支之间的连接，使得后续的`git push`命令可以自动将本地分支的更新推送到正确的远程分支。\n> \n> # 合并指定分支到当前分支\n> $ git merge [branch]\n> \n> # 选择一个commit，合并进当前分支\n> $ git cherry-pick [commit]\n> \n> # 删除分支\n> $ git branch -d [branch-name]\n> \n> # 删除远程分支\n> $ git push origin --delete [branch-name]\n> $ git branch -dr [remote/branch]\n> ````\n\n## 六、标签\n\n> ```bash\n> # 列出所有tag\n> $ git tag\n> \n> # 新建一个tag在当前commit\n> $ git tag [tag]\n> \n> # 新建一个tag在指定commit\n> $ git tag [tag] [commit]\n> \n> # 删除本地tag\n> $ git tag -d [tag]\n> \n> # 删除远程tag\n> $ git push origin :refs/tags/[tagName]\n> \n> # 查看tag信息\n> $ git show [tag]\n> \n> # 提交指定tag\n> $ git push [remote] [tag]\n> \n> # 提交所有tag\n> $ git push [remote] --tags\n> \n> # 新建一个分支，指向某个tag\n> $ git checkout -b [branch] [tag]\n> ```\n\n## 七、查看信息\n\n> ```bash\n> # 显示有变更的文件\n> $ git status\n> \n> # 显示当前分支的版本历史\n> $ git log\n> \n> # 显示commit历史，以及每次commit发生变更的文件\n> $ git log --stat\n> \n> # 搜索提交历史，根据关键词\n> $ git log -S [keyword]\n> \n> # 显示某个commit之后的所有变动，每个commit占据一行\n> $ git log [tag] HEAD --pretty=format:%s\n> \n> # 显示某个commit之后的所有变动，其\"提交说明\"必须符合搜索条件\n> $ git log [tag] HEAD --grep feature\n> \n> # 显示某个文件的版本历史，包括文件改名\n> $ git log --follow [file]\n> $ git whatchanged [file]\n> \n> # 显示指定文件相关的每一次diff\n> $ git log -p [file]\n> \n> # 显示过去5次提交\n> $ git log -5 --pretty --oneline\n> \n> # 显示所有提交过的用户，按提交次数排序\n> $ git shortlog -sn\n> \n> # 显示指定文件是什么人在什么时间修改过\n> $ git blame [file]\n> \n> # 显示暂存区和工作区的差异\n> $ git diff\n> \n> # 显示暂存区和上一个commit的差异\n> $ git diff --cached [file]\n> \n> # 显示工作区与当前分支最新commit之间的差异\n> $ git diff HEAD\n> \n> # 显示两次提交之间的差异\n> $ git diff [first-branch]...[second-branch]\n> \n> # 显示今天你写了多少行代码\n> $ git diff --shortstat \"@{0 day ago}\"\n> \n> # 显示某次提交的元数据和内容变化\n> $ git show [commit]\n> \n> # 显示某次提交发生变化的文件\n> $ git show --name-only [commit]\n> \n> # 显示某次提交时，某个文件的内容\n> $ git show [commit]:[filename]\n> \n> # 显示当前分支的最近几次提交\n> $ git reflog\n> ```\n\n## 八、远程同步\n\n> ```bash\n> # 下载远程仓库的所有变动\n> $ git fetch [remote]\n> \n> # 显示所有远程仓库\n> $ git remote -v\n> \n> # 显示某个远程仓库的信息\n> $ git remote show [remote]\n> \n> # 增加一个新的远程仓库，并命名\n> $ git remote add [shortname] [url]\n> \n> # 取回远程仓库的变化，并与本地分支合并\n> $ git pull [remote] [branch]\n> \n> # 上传本地指定分支到远程仓库\n> $ git push [remote] [branch]\n> \n> # 强行推送当前分支到远程仓库，即使有冲突\n> $ git push [remote] --force\n> \n> # 推送所有分支到远程仓库\n> $ git push [remote] --all\n> ```\n\n## 九、撤销\n\n> ```bash\n> # 恢复暂存区的指定文件到工作区                                 误删文件，用于恢复add时的状态\n> $ git checkout [file]\n> \n> # 恢复某个commit的指定文件到暂存区和工作区\n> $ git checkout [commit] [file]\n> \n> # 恢复暂存区的所有文件到工作区\n> $ git checkout .\n> \n> # 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变      已暂存的内容不想提交，用于取消暂存de\n> $ git reset [file]\n> \n> # 重置暂存区与工作区，与上一次commit保持一致\n> $ git reset --hard\n> \n> # 如果想回滚的话，比如说回滚到上一个版本，可以执行以下两种命令：\n> \n> $ git reset --hard HEAD^         上上个版本就是 git reset --hard HEAD^^，以此类推。\n> \n> $ git reset --hard HEAD~100      如果回滚到前 100 个版本，用这个命令比上一个命令更方便。\n> \n> # 假如回滚错了，想恢复，不记得版本号了，可以先执行此命令查看版本号：\n> $ git reflog\n> \n> # 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变\n> $ git reset [commit]\n> \n> # 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致\n> $ git reset --hard [commit]\n> \n> # 重置当前HEAD为指定commit，但保持暂存区和工作区不变\n> $ git reset --keep [commit]\n> \n> # 新建一个commit，用来撤销指定commit\n> # 后者的所有变化都将被前者抵消，并且应用到当前分支\n> $ git revert [commit]\n> \n> # 暂时将未提交的变化移除，稍后再移入\n> $ git stash\n> $ git stash pop\n> ```\n\n## 十、其他\n\n> ```bash\n> # 生成一个可供发布的压缩包\n> $ git archive\n> ```\n> \n\n## 说说一个比较常见的问题：如何合并冲突？\n> 当我们在远仓直接更新内容时，下次如果是在本地准备提交上传，如果忘记拉取最新更新，\n> 那么在push时会拒绝我们推送，所以我们需要在提交前进行拉取远仓的最新变更，\n> 然后手动处理冲突，最后再提交\n\n拉取远程仓库变更：在本地仓库中运行 git pull 命令，将远程仓库中的最新变更拉取到本地。\n\n处理冲突（如果存在）：如果在远程仓库和本地仓库同时修改了相同的文件，可能会发生冲突。Git 会将冲突标记在文件中，你需要手动解决这些冲突。打开有冲突的文件，查找并解决冲突的部分。完成后保存文件。\n\n添加和提交变更：在本地仓库中使用 git add 命令将修改后的文件标记为已暂存，然后使用 git commit 命令提交这些变更。确保你提供了有意义的提交消息，以便于他人理解你所做的更改。\n\n推送到远程仓库：使用 git push 命令将本地仓库的变更推送到远程仓库。\n\n\n\n## 公司多分支仓库是怎么协作开发的？\n\n在Git中，每个人创建一个分支进行协作是一种常见的模式。在这种情况下，主分支通常被称为\"main\"，其他分支则用于个人或团队的工作。\n\n如果你想将主分支（main）的最新代码拉取到你的分支（github-wl）上，可以按照以下步骤进行操作：\n\n1. 首先，确保你已经在你的本地仓库中创建了一个名为\"github-wl\"的分支。你可以使用以下命令创建并切换到该分支：\n\n```shell\ngit checkout -b github-wl\n```\n\n2. 接下来，你需要将主分支（main）的最新代码拉取到你的本地仓库。可以使用以下命令从远程仓库中拉取最新代码：\n\n```shell\ngit fetch origin main\n```\n\n这将会获取主分支的最新更改，但不会自动合并到你的分支。\n\n3. 如果你想将这些更改合并到你的分支上，可以使用以下命令进行合并：\n\n```shell\ngit merge origin/main\n```\n\n这将把主分支的最新代码合并到你的当前分支（github-wl）上。\n\n4. 如果在合并过程中出现冲突，你需要手动解决冲突。Git会在冲突的文件中标记出冲突的部分，你需要打开这些文件并手动编辑以解决冲突。\n5. 一旦冲突解决完成，你可以使用以下命令将你的分支推送到远程仓库：\n\n```shell\ngit push origin github-wl\n```\n\n这将把你的分支（github-wl）的更改推送到远程仓库。\n\n通过以上步骤，你可以将主分支（main）的最新代码拉取到你的分支（github-wl）上，并在解决冲突后将更改推送到远程仓库。\n","source":"_posts/git.md","raw":"---\ntitle: 最常用的Git命令汇总\nindex_img: >-\n  https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202309120849258.png\ncategories:\n  - Git\ntags:\n  - Git\nabbrlink: 19040\ndate: 2022-10-07 08:58:32\n---\n# 常用 Git 命令清单\n\n> 整理：CS_GUIDER，作者：[阮一峰](http://www.ruanyifeng.com/)，戳[原文链接](https://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html)。\n\n我每天使用 Git ，但是很多命令记不住。\n\n一般来说，日常使用只要记住下图6个命令，就可以了。但是熟练使用，恐怕要记住60～100个命令。\n\n![img](http://www.ruanyifeng.com/blogimg/asset/2015/bg2015120901.png)\n\n下面是我整理的常用 Git 命令清单。几个专用名词的译名如下。\n\n> - Workspace：工作区\n> - Index / Stage：暂存区\n> - Repository：仓库区（或本地仓库）\n> - Remote：远程仓库\n\n## 一、新建代码库\n\n> ```bash\n> # 在当前目录新建一个Git代码库\n> $ git init\n> \n> # 新建一个目录，将其初始化为Git代码库\n> $ git init [project-name]\n> \n> # 下载一个项目和它的整个代码历史\n> $ git clone [url]\n> ```\n\n## 二、配置\n\nGit的设置文件为`.gitconfig`，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。\n\n> ```bash\n> # 显示当前的Git配置\n> $ git config --list\n> \n> # 编辑Git配置文件\n> $ git config -e [--global]\n> \n> # 设置提交代码时的用户信息\n> $ git config [--global] user.name \"[name]\"\n> $ git config [--global] user.email \"[email address]\"\n> \n> # usage: git config [<options>]\n> Config file location\n>     --global              use global config file\n>     --system              use system config file\n>     --local               use repository config file\n>     --worktree            use per-worktree config file\n>     -f, --file <file>     use given config file\n>     --blob <blob-id>      read config from given blob object\n> \n> Action\n>     --get                 get value: name [value-pattern]\n>     --get-all             get all values: key [value-pattern]\n>     --get-regexp          get values for regexp: name-regex [value-pattern]\n>     --get-urlmatch        get value specific for the URL: section[.var] URL\n>     --replace-all         replace all matching variables: name value [value-pattern]\n>     --add                 add a new variable: name value\n>     --unset               remove a variable: name [value-pattern]\n>     --unset-all           remove all matches: name [value-pattern]\n>     --rename-section      rename section: old-name new-name\n>     --remove-section      remove a section: name\n>     -l, --list            list all\n>     --fixed-value         use string equality when comparing values to 'value-pattern'\n>     -e, --edit            open an editor\n>     --get-color           find the color configured: slot [default]\n>     --get-colorbool       find the color setting: slot [stdout-is-tty]\n> \n> Type\n>     -t, --type <>         value is given this type\n>     --bool                value is \"true\" or \"false\"\n>     --int                 value is decimal number\n>     --bool-or-int         value is --bool or --int\n>     --bool-or-str         value is --bool or string\n>     --path                value is a path (file or directory name)\n>     --expiry-date         value is an expiry date\n> \n> Other\n>     -z, --null            terminate values with NUL byte\n>     --name-only           show variable names only\n>     --includes            respect include directives on lookup\n>     --show-origin         show origin of config (file, standard input, blob, command line)\n>     --show-scope          show scope of config (worktree, local, global, system, command)\n>     --default <value>     with --get, use default value when missing entry\n> \n> \n> ```\n\n## 三、增加/删除文件\n\n> ```bash\n> # 添加指定文件到暂存区\n> $ git add [file1] [file2] ...\n> \n> # 添加指定目录到暂存区，包括子目录\n> $ git add [dir]\n> \n> # 添加当前目录的所有文件到暂存区\n> $ git add .\n> \n> # 添加每个变化前，都会要求确认\n> # 对于同一个文件的多处变化，可以实现分次提交\n> $ git add -p\n> \n> # 删除工作区文件，并且将这次删除放入暂存区\n> $ git rm [file1] [file2] ...\n> \n> # 停止追踪指定文件，但该文件会保留在工作区\n> $ git rm --cached [file]\n> \n> # 改名文件，并且将这个改名放入暂存区\n> $ git mv [file-original] [file-renamed]\n> ```\n\n## 四、代码提交\n\n> ```bash\n> # 提交暂存区到仓库区\n> $ git commit -m [message]\n> \n> # 提交暂存区的指定文件到仓库区\n> $ git commit [file1] [file2] ... -m [message]\n> \n> # 提交工作区自上次commit之后的变化，直接到仓库区\n> $ git commit -a\n> \n> # 提交时显示所有diff信息\n> $ git commit -v\n> \n> # 使用一次新的commit，替代上一次提交\n> # 如果代码没有任何新变化，则用来改写上一次commit的提交信息\n> $ git commit --amend -m [message]\n> \n> # 重做上一次commit，并包括指定文件的新变化\n> $ git commit --amend [file1] [file2] ...\n> ```\n\n## 五、分支\n\n> ````bash\n> # 列出所有本地分支\n> $ git branch\n> \n> # 列出所有远程分支\n> $ git branch -r\n> \n> # 列出所有本地分支和远程分支\n> $ git branch -a\n> \n> # 新建一个分支，但依然停留在当前分支\n> $ git branch [branch-name]\n> \n> # 新建一个分支，并切换到该分支\n> $ git checkout -b [branch]\n> \n> # 新建一个分支，指向指定commit\n> $ git branch [branch] [commit]\n> \n> # 新建一个分支，与指定的远程分支建立追踪关系\n> $ git branch --track [branch] [remote-branch]\n> \n> # 切换到指定分支，并更新工作区\n> $ git checkout [branch-name]\n> \n> # 切换到上一个分支\n> $ git checkout -\n> \n> # 建立追踪关系，在现有分支与指定的远程分支之间\n> $ git branch --set-upstream [branch] [remote-branch]\n> $ 详细说明：\n> `--set-upstream`是`git push`命令的一个选项，它用于在将本地分支推送到远程仓库时，同时设置本地分支与远程分支的关联关系。\n> \n> 当您使用`git push`命令将本地分支推送到远程仓库时，Git会尝试将本地分支的更新推送到与之关联的远程分支。通常情况下，当您首次推送本地分支时，远程仓库可能还没有与之对应的远程分支。在这种情况下，如果您使用`--set-upstream`选项，Git会自动在远程仓库上创建一个与本地分支同名的分支，并将其与本地分支关联起来。\n> \n> 所以，当您执行以下命令时：\n> ```\n> git push --set-upstream origin hexo\n> ```\n> 它的含义是将当前分支（假设是`hexo`）的更新推送到名为`origin`的远程仓库，并在远程仓库上创建一个名为`hexo`的分支，并将其与本地分支进行关联。\n> \n> 通过使用`--set-upstream`选项，您可以方便地建立本地分支与远程分支之间的连接，使得后续的`git push`命令可以自动将本地分支的更新推送到正确的远程分支。\n> \n> # 合并指定分支到当前分支\n> $ git merge [branch]\n> \n> # 选择一个commit，合并进当前分支\n> $ git cherry-pick [commit]\n> \n> # 删除分支\n> $ git branch -d [branch-name]\n> \n> # 删除远程分支\n> $ git push origin --delete [branch-name]\n> $ git branch -dr [remote/branch]\n> ````\n\n## 六、标签\n\n> ```bash\n> # 列出所有tag\n> $ git tag\n> \n> # 新建一个tag在当前commit\n> $ git tag [tag]\n> \n> # 新建一个tag在指定commit\n> $ git tag [tag] [commit]\n> \n> # 删除本地tag\n> $ git tag -d [tag]\n> \n> # 删除远程tag\n> $ git push origin :refs/tags/[tagName]\n> \n> # 查看tag信息\n> $ git show [tag]\n> \n> # 提交指定tag\n> $ git push [remote] [tag]\n> \n> # 提交所有tag\n> $ git push [remote] --tags\n> \n> # 新建一个分支，指向某个tag\n> $ git checkout -b [branch] [tag]\n> ```\n\n## 七、查看信息\n\n> ```bash\n> # 显示有变更的文件\n> $ git status\n> \n> # 显示当前分支的版本历史\n> $ git log\n> \n> # 显示commit历史，以及每次commit发生变更的文件\n> $ git log --stat\n> \n> # 搜索提交历史，根据关键词\n> $ git log -S [keyword]\n> \n> # 显示某个commit之后的所有变动，每个commit占据一行\n> $ git log [tag] HEAD --pretty=format:%s\n> \n> # 显示某个commit之后的所有变动，其\"提交说明\"必须符合搜索条件\n> $ git log [tag] HEAD --grep feature\n> \n> # 显示某个文件的版本历史，包括文件改名\n> $ git log --follow [file]\n> $ git whatchanged [file]\n> \n> # 显示指定文件相关的每一次diff\n> $ git log -p [file]\n> \n> # 显示过去5次提交\n> $ git log -5 --pretty --oneline\n> \n> # 显示所有提交过的用户，按提交次数排序\n> $ git shortlog -sn\n> \n> # 显示指定文件是什么人在什么时间修改过\n> $ git blame [file]\n> \n> # 显示暂存区和工作区的差异\n> $ git diff\n> \n> # 显示暂存区和上一个commit的差异\n> $ git diff --cached [file]\n> \n> # 显示工作区与当前分支最新commit之间的差异\n> $ git diff HEAD\n> \n> # 显示两次提交之间的差异\n> $ git diff [first-branch]...[second-branch]\n> \n> # 显示今天你写了多少行代码\n> $ git diff --shortstat \"@{0 day ago}\"\n> \n> # 显示某次提交的元数据和内容变化\n> $ git show [commit]\n> \n> # 显示某次提交发生变化的文件\n> $ git show --name-only [commit]\n> \n> # 显示某次提交时，某个文件的内容\n> $ git show [commit]:[filename]\n> \n> # 显示当前分支的最近几次提交\n> $ git reflog\n> ```\n\n## 八、远程同步\n\n> ```bash\n> # 下载远程仓库的所有变动\n> $ git fetch [remote]\n> \n> # 显示所有远程仓库\n> $ git remote -v\n> \n> # 显示某个远程仓库的信息\n> $ git remote show [remote]\n> \n> # 增加一个新的远程仓库，并命名\n> $ git remote add [shortname] [url]\n> \n> # 取回远程仓库的变化，并与本地分支合并\n> $ git pull [remote] [branch]\n> \n> # 上传本地指定分支到远程仓库\n> $ git push [remote] [branch]\n> \n> # 强行推送当前分支到远程仓库，即使有冲突\n> $ git push [remote] --force\n> \n> # 推送所有分支到远程仓库\n> $ git push [remote] --all\n> ```\n\n## 九、撤销\n\n> ```bash\n> # 恢复暂存区的指定文件到工作区                                 误删文件，用于恢复add时的状态\n> $ git checkout [file]\n> \n> # 恢复某个commit的指定文件到暂存区和工作区\n> $ git checkout [commit] [file]\n> \n> # 恢复暂存区的所有文件到工作区\n> $ git checkout .\n> \n> # 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变      已暂存的内容不想提交，用于取消暂存de\n> $ git reset [file]\n> \n> # 重置暂存区与工作区，与上一次commit保持一致\n> $ git reset --hard\n> \n> # 如果想回滚的话，比如说回滚到上一个版本，可以执行以下两种命令：\n> \n> $ git reset --hard HEAD^         上上个版本就是 git reset --hard HEAD^^，以此类推。\n> \n> $ git reset --hard HEAD~100      如果回滚到前 100 个版本，用这个命令比上一个命令更方便。\n> \n> # 假如回滚错了，想恢复，不记得版本号了，可以先执行此命令查看版本号：\n> $ git reflog\n> \n> # 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变\n> $ git reset [commit]\n> \n> # 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致\n> $ git reset --hard [commit]\n> \n> # 重置当前HEAD为指定commit，但保持暂存区和工作区不变\n> $ git reset --keep [commit]\n> \n> # 新建一个commit，用来撤销指定commit\n> # 后者的所有变化都将被前者抵消，并且应用到当前分支\n> $ git revert [commit]\n> \n> # 暂时将未提交的变化移除，稍后再移入\n> $ git stash\n> $ git stash pop\n> ```\n\n## 十、其他\n\n> ```bash\n> # 生成一个可供发布的压缩包\n> $ git archive\n> ```\n> \n\n## 说说一个比较常见的问题：如何合并冲突？\n> 当我们在远仓直接更新内容时，下次如果是在本地准备提交上传，如果忘记拉取最新更新，\n> 那么在push时会拒绝我们推送，所以我们需要在提交前进行拉取远仓的最新变更，\n> 然后手动处理冲突，最后再提交\n\n拉取远程仓库变更：在本地仓库中运行 git pull 命令，将远程仓库中的最新变更拉取到本地。\n\n处理冲突（如果存在）：如果在远程仓库和本地仓库同时修改了相同的文件，可能会发生冲突。Git 会将冲突标记在文件中，你需要手动解决这些冲突。打开有冲突的文件，查找并解决冲突的部分。完成后保存文件。\n\n添加和提交变更：在本地仓库中使用 git add 命令将修改后的文件标记为已暂存，然后使用 git commit 命令提交这些变更。确保你提供了有意义的提交消息，以便于他人理解你所做的更改。\n\n推送到远程仓库：使用 git push 命令将本地仓库的变更推送到远程仓库。\n\n\n\n## 公司多分支仓库是怎么协作开发的？\n\n在Git中，每个人创建一个分支进行协作是一种常见的模式。在这种情况下，主分支通常被称为\"main\"，其他分支则用于个人或团队的工作。\n\n如果你想将主分支（main）的最新代码拉取到你的分支（github-wl）上，可以按照以下步骤进行操作：\n\n1. 首先，确保你已经在你的本地仓库中创建了一个名为\"github-wl\"的分支。你可以使用以下命令创建并切换到该分支：\n\n```shell\ngit checkout -b github-wl\n```\n\n2. 接下来，你需要将主分支（main）的最新代码拉取到你的本地仓库。可以使用以下命令从远程仓库中拉取最新代码：\n\n```shell\ngit fetch origin main\n```\n\n这将会获取主分支的最新更改，但不会自动合并到你的分支。\n\n3. 如果你想将这些更改合并到你的分支上，可以使用以下命令进行合并：\n\n```shell\ngit merge origin/main\n```\n\n这将把主分支的最新代码合并到你的当前分支（github-wl）上。\n\n4. 如果在合并过程中出现冲突，你需要手动解决冲突。Git会在冲突的文件中标记出冲突的部分，你需要打开这些文件并手动编辑以解决冲突。\n5. 一旦冲突解决完成，你可以使用以下命令将你的分支推送到远程仓库：\n\n```shell\ngit push origin github-wl\n```\n\n这将把你的分支（github-wl）的更改推送到远程仓库。\n\n通过以上步骤，你可以将主分支（main）的最新代码拉取到你的分支（github-wl）上，并在解决冲突后将更改推送到远程仓库。\n","slug":"git","published":1,"updated":"2023-11-26T08:03:30.925Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clpkiczj4001yfkfo5k4wflkj","content":"<h1 id=\"常用-Git-命令清单\"><a href=\"#常用-Git-命令清单\" class=\"headerlink\" title=\"常用 Git 命令清单\"></a>常用 Git 命令清单</h1><blockquote>\n<p>整理：CS_GUIDER，作者：<a href=\"http://www.ruanyifeng.com/\">阮一峰</a>，戳<a href=\"https://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html\">原文链接</a>。</p>\n</blockquote>\n<p>我每天使用 Git ，但是很多命令记不住。</p>\n<p>一般来说，日常使用只要记住下图6个命令，就可以了。但是熟练使用，恐怕要记住60～100个命令。</p>\n<p><img src=\"http://www.ruanyifeng.com/blogimg/asset/2015/bg2015120901.png\" alt=\"img\"></p>\n<p>下面是我整理的常用 Git 命令清单。几个专用名词的译名如下。</p>\n<blockquote>\n<ul>\n<li>Workspace：工作区</li>\n<li>Index / Stage：暂存区</li>\n<li>Repository：仓库区（或本地仓库）</li>\n<li>Remote：远程仓库</li>\n</ul>\n</blockquote>\n<h2 id=\"一、新建代码库\"><a href=\"#一、新建代码库\" class=\"headerlink\" title=\"一、新建代码库\"></a>一、新建代码库</h2><blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># 在当前目录新建一个Git代码库</span><br>$ git init<br><br><span class=\"hljs-comment\"># 新建一个目录，将其初始化为Git代码库</span><br>$ git init [project-name]<br><br><span class=\"hljs-comment\"># 下载一个项目和它的整个代码历史</span><br>$ git <span class=\"hljs-built_in\">clone</span> [url]<br></code></pre></td></tr></table></figure>\n</blockquote>\n<h2 id=\"二、配置\"><a href=\"#二、配置\" class=\"headerlink\" title=\"二、配置\"></a>二、配置</h2><p>Git的设置文件为<code>.gitconfig</code>，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。</p>\n<blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># 显示当前的Git配置</span><br>$ git config --list<br><br><span class=\"hljs-comment\"># 编辑Git配置文件</span><br>$ git config -e [--global]<br><br><span class=\"hljs-comment\"># 设置提交代码时的用户信息</span><br>$ git config [--global] user.name <span class=\"hljs-string\">&quot;[name]&quot;</span><br>$ git config [--global] user.email <span class=\"hljs-string\">&quot;[email address]&quot;</span><br><br><span class=\"hljs-comment\"># usage: git config [&lt;options&gt;]</span><br>Config file location<br>    --global              use global config file<br>    --system              use system config file<br>    --<span class=\"hljs-built_in\">local</span>               use repository config file<br>    --worktree            use per-worktree config file<br>    -f, --file &lt;file&gt;     use given config file<br>    --blob &lt;blob-id&gt;      <span class=\"hljs-built_in\">read</span> config from given blob object<br><br>Action<br>    --get                 get value: name [value-pattern]<br>    --get-all             get all values: key [value-pattern]<br>    --get-regexp          get values <span class=\"hljs-keyword\">for</span> regexp: name-regex [value-pattern]<br>    --get-urlmatch        get value specific <span class=\"hljs-keyword\">for</span> the URL: section[.var] URL<br>    --replace-all         replace all matching variables: name value [value-pattern]<br>    --add                 add a new variable: name value<br>    --<span class=\"hljs-built_in\">unset</span>               remove a variable: name [value-pattern]<br>    --unset-all           remove all matches: name [value-pattern]<br>    --rename-section      rename section: old-name new-name<br>    --remove-section      remove a section: name<br>    -l, --list            list all<br>    --fixed-value         use string equality when comparing values to <span class=\"hljs-string\">&#x27;value-pattern&#x27;</span><br>    -e, --edit            open an editor<br>    --get-color           find the color configured: slot [default]<br>    --get-colorbool       find the color setting: slot [stdout-is-tty]<br><br>Type<br>    -t, --<span class=\"hljs-built_in\">type</span> &lt;&gt;         value is given this <span class=\"hljs-built_in\">type</span><br>    --bool                value is <span class=\"hljs-string\">&quot;true&quot;</span> or <span class=\"hljs-string\">&quot;false&quot;</span><br>    --int                 value is decimal number<br>    --bool-or-int         value is --bool or --int<br>    --bool-or-str         value is --bool or string<br>    --path                value is a path (file or directory name)<br>    --expiry-date         value is an expiry <span class=\"hljs-built_in\">date</span><br><br>Other<br>    -z, --null            terminate values with NUL byte<br>    --name-only           show variable names only<br>    --includes            respect include directives on lookup<br>    --show-origin         show origin of config (file, standard input, blob, <span class=\"hljs-built_in\">command</span> line)<br>    --show-scope          show scope of config (worktree, <span class=\"hljs-built_in\">local</span>, global, system, <span class=\"hljs-built_in\">command</span>)<br>    --default &lt;value&gt;     with --get, use default value when missing entry<br><br><br></code></pre></td></tr></table></figure>\n</blockquote>\n<h2 id=\"三、增加-删除文件\"><a href=\"#三、增加-删除文件\" class=\"headerlink\" title=\"三、增加/删除文件\"></a>三、增加/删除文件</h2><blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># 添加指定文件到暂存区</span><br>$ git add [file1] [file2] ...<br><br><span class=\"hljs-comment\"># 添加指定目录到暂存区，包括子目录</span><br>$ git add [<span class=\"hljs-built_in\">dir</span>]<br><br><span class=\"hljs-comment\"># 添加当前目录的所有文件到暂存区</span><br>$ git add .<br><br><span class=\"hljs-comment\"># 添加每个变化前，都会要求确认</span><br><span class=\"hljs-comment\"># 对于同一个文件的多处变化，可以实现分次提交</span><br>$ git add -p<br><br><span class=\"hljs-comment\"># 删除工作区文件，并且将这次删除放入暂存区</span><br>$ git <span class=\"hljs-built_in\">rm</span> [file1] [file2] ...<br><br><span class=\"hljs-comment\"># 停止追踪指定文件，但该文件会保留在工作区</span><br>$ git <span class=\"hljs-built_in\">rm</span> --cached [file]<br><br><span class=\"hljs-comment\"># 改名文件，并且将这个改名放入暂存区</span><br>$ git <span class=\"hljs-built_in\">mv</span> [file-original] [file-renamed]<br></code></pre></td></tr></table></figure>\n</blockquote>\n<h2 id=\"四、代码提交\"><a href=\"#四、代码提交\" class=\"headerlink\" title=\"四、代码提交\"></a>四、代码提交</h2><blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># 提交暂存区到仓库区</span><br>$ git commit -m [message]<br><br><span class=\"hljs-comment\"># 提交暂存区的指定文件到仓库区</span><br>$ git commit [file1] [file2] ... -m [message]<br><br><span class=\"hljs-comment\"># 提交工作区自上次commit之后的变化，直接到仓库区</span><br>$ git commit -a<br><br><span class=\"hljs-comment\"># 提交时显示所有diff信息</span><br>$ git commit -v<br><br><span class=\"hljs-comment\"># 使用一次新的commit，替代上一次提交</span><br><span class=\"hljs-comment\"># 如果代码没有任何新变化，则用来改写上一次commit的提交信息</span><br>$ git commit --amend -m [message]<br><br><span class=\"hljs-comment\"># 重做上一次commit，并包括指定文件的新变化</span><br>$ git commit --amend [file1] [file2] ...<br></code></pre></td></tr></table></figure>\n</blockquote>\n<h2 id=\"五、分支\"><a href=\"#五、分支\" class=\"headerlink\" title=\"五、分支\"></a>五、分支</h2><blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># 列出所有本地分支</span><br>$ git branch<br><br><span class=\"hljs-comment\"># 列出所有远程分支</span><br>$ git branch -r<br><br><span class=\"hljs-comment\"># 列出所有本地分支和远程分支</span><br>$ git branch -a<br><br><span class=\"hljs-comment\"># 新建一个分支，但依然停留在当前分支</span><br>$ git branch [branch-name]<br><br><span class=\"hljs-comment\"># 新建一个分支，并切换到该分支</span><br>$ git checkout -b [branch]<br><br><span class=\"hljs-comment\"># 新建一个分支，指向指定commit</span><br>$ git branch [branch] [commit]<br><br><span class=\"hljs-comment\"># 新建一个分支，与指定的远程分支建立追踪关系</span><br>$ git branch --track [branch] [remote-branch]<br><br><span class=\"hljs-comment\"># 切换到指定分支，并更新工作区</span><br>$ git checkout [branch-name]<br><br><span class=\"hljs-comment\"># 切换到上一个分支</span><br>$ git checkout -<br><br><span class=\"hljs-comment\"># 建立追踪关系，在现有分支与指定的远程分支之间</span><br>$ git branch --set-upstream [branch] [remote-branch]<br>$ 详细说明：<br>`--set-upstream`是`git push`命令的一个选项，它用于在将本地分支推送到远程仓库时，同时设置本地分支与远程分支的关联关系。<br><br>当您使用`git push`命令将本地分支推送到远程仓库时，Git会尝试将本地分支的更新推送到与之关联的远程分支。通常情况下，当您首次推送本地分支时，远程仓库可能还没有与之对应的远程分支。在这种情况下，如果您使用`--set-upstream`选项，Git会自动在远程仓库上创建一个与本地分支同名的分支，并将其与本地分支关联起来。<br><br>所以，当您执行以下命令时：<br>```<br>git push --set-upstream origin hexo<br>```<br>它的含义是将当前分支（假设是`hexo`）的更新推送到名为`origin`的远程仓库，并在远程仓库上创建一个名为`hexo`的分支，并将其与本地分支进行关联。<br><br>通过使用`--set-upstream`选项，您可以方便地建立本地分支与远程分支之间的连接，使得后续的`git push`命令可以自动将本地分支的更新推送到正确的远程分支。<br><br><span class=\"hljs-comment\"># 合并指定分支到当前分支</span><br>$ git merge [branch]<br><br><span class=\"hljs-comment\"># 选择一个commit，合并进当前分支</span><br>$ git cherry-pick [commit]<br><br><span class=\"hljs-comment\"># 删除分支</span><br>$ git branch -d [branch-name]<br><br><span class=\"hljs-comment\"># 删除远程分支</span><br>$ git push origin --delete [branch-name]<br>$ git branch -dr [remote/branch]<br></code></pre></td></tr></table></figure>\n</blockquote>\n<h2 id=\"六、标签\"><a href=\"#六、标签\" class=\"headerlink\" title=\"六、标签\"></a>六、标签</h2><blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># 列出所有tag</span><br>$ git tag<br><br><span class=\"hljs-comment\"># 新建一个tag在当前commit</span><br>$ git tag [tag]<br><br><span class=\"hljs-comment\"># 新建一个tag在指定commit</span><br>$ git tag [tag] [commit]<br><br><span class=\"hljs-comment\"># 删除本地tag</span><br>$ git tag -d [tag]<br><br><span class=\"hljs-comment\"># 删除远程tag</span><br>$ git push origin :refs/tags/[tagName]<br><br><span class=\"hljs-comment\"># 查看tag信息</span><br>$ git show [tag]<br><br><span class=\"hljs-comment\"># 提交指定tag</span><br>$ git push [remote] [tag]<br><br><span class=\"hljs-comment\"># 提交所有tag</span><br>$ git push [remote] --tags<br><br><span class=\"hljs-comment\"># 新建一个分支，指向某个tag</span><br>$ git checkout -b [branch] [tag]<br></code></pre></td></tr></table></figure>\n</blockquote>\n<h2 id=\"七、查看信息\"><a href=\"#七、查看信息\" class=\"headerlink\" title=\"七、查看信息\"></a>七、查看信息</h2><blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># 显示有变更的文件</span><br>$ git status<br><br><span class=\"hljs-comment\"># 显示当前分支的版本历史</span><br>$ git <span class=\"hljs-built_in\">log</span><br><br><span class=\"hljs-comment\"># 显示commit历史，以及每次commit发生变更的文件</span><br>$ git <span class=\"hljs-built_in\">log</span> --<span class=\"hljs-built_in\">stat</span><br><br><span class=\"hljs-comment\"># 搜索提交历史，根据关键词</span><br>$ git <span class=\"hljs-built_in\">log</span> -S [keyword]<br><br><span class=\"hljs-comment\"># 显示某个commit之后的所有变动，每个commit占据一行</span><br>$ git <span class=\"hljs-built_in\">log</span> [tag] HEAD --pretty=format:%s<br><br><span class=\"hljs-comment\"># 显示某个commit之后的所有变动，其&quot;提交说明&quot;必须符合搜索条件</span><br>$ git <span class=\"hljs-built_in\">log</span> [tag] HEAD --grep feature<br><br><span class=\"hljs-comment\"># 显示某个文件的版本历史，包括文件改名</span><br>$ git <span class=\"hljs-built_in\">log</span> --follow [file]<br>$ git whatchanged [file]<br><br><span class=\"hljs-comment\"># 显示指定文件相关的每一次diff</span><br>$ git <span class=\"hljs-built_in\">log</span> -p [file]<br><br><span class=\"hljs-comment\"># 显示过去5次提交</span><br>$ git <span class=\"hljs-built_in\">log</span> -5 --pretty --oneline<br><br><span class=\"hljs-comment\"># 显示所有提交过的用户，按提交次数排序</span><br>$ git shortlog -sn<br><br><span class=\"hljs-comment\"># 显示指定文件是什么人在什么时间修改过</span><br>$ git blame [file]<br><br><span class=\"hljs-comment\"># 显示暂存区和工作区的差异</span><br>$ git diff<br><br><span class=\"hljs-comment\"># 显示暂存区和上一个commit的差异</span><br>$ git diff --cached [file]<br><br><span class=\"hljs-comment\"># 显示工作区与当前分支最新commit之间的差异</span><br>$ git diff HEAD<br><br><span class=\"hljs-comment\"># 显示两次提交之间的差异</span><br>$ git diff [first-branch]...[second-branch]<br><br><span class=\"hljs-comment\"># 显示今天你写了多少行代码</span><br>$ git diff --shortstat <span class=\"hljs-string\">&quot;@&#123;0 day ago&#125;&quot;</span><br><br><span class=\"hljs-comment\"># 显示某次提交的元数据和内容变化</span><br>$ git show [commit]<br><br><span class=\"hljs-comment\"># 显示某次提交发生变化的文件</span><br>$ git show --name-only [commit]<br><br><span class=\"hljs-comment\"># 显示某次提交时，某个文件的内容</span><br>$ git show [commit]:[filename]<br><br><span class=\"hljs-comment\"># 显示当前分支的最近几次提交</span><br>$ git reflog<br></code></pre></td></tr></table></figure>\n</blockquote>\n<h2 id=\"八、远程同步\"><a href=\"#八、远程同步\" class=\"headerlink\" title=\"八、远程同步\"></a>八、远程同步</h2><blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># 下载远程仓库的所有变动</span><br>$ git fetch [remote]<br><br><span class=\"hljs-comment\"># 显示所有远程仓库</span><br>$ git remote -v<br><br><span class=\"hljs-comment\"># 显示某个远程仓库的信息</span><br>$ git remote show [remote]<br><br><span class=\"hljs-comment\"># 增加一个新的远程仓库，并命名</span><br>$ git remote add [shortname] [url]<br><br><span class=\"hljs-comment\"># 取回远程仓库的变化，并与本地分支合并</span><br>$ git pull [remote] [branch]<br><br><span class=\"hljs-comment\"># 上传本地指定分支到远程仓库</span><br>$ git push [remote] [branch]<br><br><span class=\"hljs-comment\"># 强行推送当前分支到远程仓库，即使有冲突</span><br>$ git push [remote] --force<br><br><span class=\"hljs-comment\"># 推送所有分支到远程仓库</span><br>$ git push [remote] --all<br></code></pre></td></tr></table></figure>\n</blockquote>\n<h2 id=\"九、撤销\"><a href=\"#九、撤销\" class=\"headerlink\" title=\"九、撤销\"></a>九、撤销</h2><blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># 恢复暂存区的指定文件到工作区                                 误删文件，用于恢复add时的状态</span><br>$ git checkout [file]<br><br><span class=\"hljs-comment\"># 恢复某个commit的指定文件到暂存区和工作区</span><br>$ git checkout [commit] [file]<br><br><span class=\"hljs-comment\"># 恢复暂存区的所有文件到工作区</span><br>$ git checkout .<br><br><span class=\"hljs-comment\"># 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变      已暂存的内容不想提交，用于取消暂存de</span><br>$ git reset [file]<br><br><span class=\"hljs-comment\"># 重置暂存区与工作区，与上一次commit保持一致</span><br>$ git reset --hard<br><br><span class=\"hljs-comment\"># 如果想回滚的话，比如说回滚到上一个版本，可以执行以下两种命令：</span><br><br>$ git reset --hard HEAD^         上上个版本就是 git reset --hard HEAD^^，以此类推。<br><br>$ git reset --hard HEAD~100      如果回滚到前 100 个版本，用这个命令比上一个命令更方便。<br><br><span class=\"hljs-comment\"># 假如回滚错了，想恢复，不记得版本号了，可以先执行此命令查看版本号：</span><br>$ git reflog<br><br><span class=\"hljs-comment\"># 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变</span><br>$ git reset [commit]<br><br><span class=\"hljs-comment\"># 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致</span><br>$ git reset --hard [commit]<br><br><span class=\"hljs-comment\"># 重置当前HEAD为指定commit，但保持暂存区和工作区不变</span><br>$ git reset --keep [commit]<br><br><span class=\"hljs-comment\"># 新建一个commit，用来撤销指定commit</span><br><span class=\"hljs-comment\"># 后者的所有变化都将被前者抵消，并且应用到当前分支</span><br>$ git revert [commit]<br><br><span class=\"hljs-comment\"># 暂时将未提交的变化移除，稍后再移入</span><br>$ git stash<br>$ git stash pop<br></code></pre></td></tr></table></figure>\n</blockquote>\n<h2 id=\"十、其他\"><a href=\"#十、其他\" class=\"headerlink\" title=\"十、其他\"></a>十、其他</h2><blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># 生成一个可供发布的压缩包</span><br>$ git archive<br></code></pre></td></tr></table></figure>\n\n</blockquote>\n<h2 id=\"说说一个比较常见的问题：如何合并冲突？\"><a href=\"#说说一个比较常见的问题：如何合并冲突？\" class=\"headerlink\" title=\"说说一个比较常见的问题：如何合并冲突？\"></a>说说一个比较常见的问题：如何合并冲突？</h2><blockquote>\n<p>当我们在远仓直接更新内容时，下次如果是在本地准备提交上传，如果忘记拉取最新更新，<br>那么在push时会拒绝我们推送，所以我们需要在提交前进行拉取远仓的最新变更，<br>然后手动处理冲突，最后再提交</p>\n</blockquote>\n<p>拉取远程仓库变更：在本地仓库中运行 git pull 命令，将远程仓库中的最新变更拉取到本地。</p>\n<p>处理冲突（如果存在）：如果在远程仓库和本地仓库同时修改了相同的文件，可能会发生冲突。Git 会将冲突标记在文件中，你需要手动解决这些冲突。打开有冲突的文件，查找并解决冲突的部分。完成后保存文件。</p>\n<p>添加和提交变更：在本地仓库中使用 git add 命令将修改后的文件标记为已暂存，然后使用 git commit 命令提交这些变更。确保你提供了有意义的提交消息，以便于他人理解你所做的更改。</p>\n<p>推送到远程仓库：使用 git push 命令将本地仓库的变更推送到远程仓库。</p>\n<h2 id=\"公司多分支仓库是怎么协作开发的？\"><a href=\"#公司多分支仓库是怎么协作开发的？\" class=\"headerlink\" title=\"公司多分支仓库是怎么协作开发的？\"></a>公司多分支仓库是怎么协作开发的？</h2><p>在Git中，每个人创建一个分支进行协作是一种常见的模式。在这种情况下，主分支通常被称为”main”，其他分支则用于个人或团队的工作。</p>\n<p>如果你想将主分支（main）的最新代码拉取到你的分支（github-wl）上，可以按照以下步骤进行操作：</p>\n<ol>\n<li>首先，确保你已经在你的本地仓库中创建了一个名为”github-wl”的分支。你可以使用以下命令创建并切换到该分支：</li>\n</ol>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">git checkout -b github-wl<br></code></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>接下来，你需要将主分支（main）的最新代码拉取到你的本地仓库。可以使用以下命令从远程仓库中拉取最新代码：</li>\n</ol>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">git fetch origin main<br></code></pre></td></tr></table></figure>\n\n<p>这将会获取主分支的最新更改，但不会自动合并到你的分支。</p>\n<ol start=\"3\">\n<li>如果你想将这些更改合并到你的分支上，可以使用以下命令进行合并：</li>\n</ol>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">git merge origin/main<br></code></pre></td></tr></table></figure>\n\n<p>这将把主分支的最新代码合并到你的当前分支（github-wl）上。</p>\n<ol start=\"4\">\n<li>如果在合并过程中出现冲突，你需要手动解决冲突。Git会在冲突的文件中标记出冲突的部分，你需要打开这些文件并手动编辑以解决冲突。</li>\n<li>一旦冲突解决完成，你可以使用以下命令将你的分支推送到远程仓库：</li>\n</ol>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">git push origin github-wl<br></code></pre></td></tr></table></figure>\n\n<p>这将把你的分支（github-wl）的更改推送到远程仓库。</p>\n<p>通过以上步骤，你可以将主分支（main）的最新代码拉取到你的分支（github-wl）上，并在解决冲突后将更改推送到远程仓库。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"常用-Git-命令清单\"><a href=\"#常用-Git-命令清单\" class=\"headerlink\" title=\"常用 Git 命令清单\"></a>常用 Git 命令清单</h1><blockquote>\n<p>整理：CS_GUIDER，作者：<a href=\"http://www.ruanyifeng.com/\">阮一峰</a>，戳<a href=\"https://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html\">原文链接</a>。</p>\n</blockquote>\n<p>我每天使用 Git ，但是很多命令记不住。</p>\n<p>一般来说，日常使用只要记住下图6个命令，就可以了。但是熟练使用，恐怕要记住60～100个命令。</p>\n<p><img src=\"http://www.ruanyifeng.com/blogimg/asset/2015/bg2015120901.png\" alt=\"img\"></p>\n<p>下面是我整理的常用 Git 命令清单。几个专用名词的译名如下。</p>\n<blockquote>\n<ul>\n<li>Workspace：工作区</li>\n<li>Index / Stage：暂存区</li>\n<li>Repository：仓库区（或本地仓库）</li>\n<li>Remote：远程仓库</li>\n</ul>\n</blockquote>\n<h2 id=\"一、新建代码库\"><a href=\"#一、新建代码库\" class=\"headerlink\" title=\"一、新建代码库\"></a>一、新建代码库</h2><blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># 在当前目录新建一个Git代码库</span><br>$ git init<br><br><span class=\"hljs-comment\"># 新建一个目录，将其初始化为Git代码库</span><br>$ git init [project-name]<br><br><span class=\"hljs-comment\"># 下载一个项目和它的整个代码历史</span><br>$ git <span class=\"hljs-built_in\">clone</span> [url]<br></code></pre></td></tr></table></figure>\n</blockquote>\n<h2 id=\"二、配置\"><a href=\"#二、配置\" class=\"headerlink\" title=\"二、配置\"></a>二、配置</h2><p>Git的设置文件为<code>.gitconfig</code>，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。</p>\n<blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># 显示当前的Git配置</span><br>$ git config --list<br><br><span class=\"hljs-comment\"># 编辑Git配置文件</span><br>$ git config -e [--global]<br><br><span class=\"hljs-comment\"># 设置提交代码时的用户信息</span><br>$ git config [--global] user.name <span class=\"hljs-string\">&quot;[name]&quot;</span><br>$ git config [--global] user.email <span class=\"hljs-string\">&quot;[email address]&quot;</span><br><br><span class=\"hljs-comment\"># usage: git config [&lt;options&gt;]</span><br>Config file location<br>    --global              use global config file<br>    --system              use system config file<br>    --<span class=\"hljs-built_in\">local</span>               use repository config file<br>    --worktree            use per-worktree config file<br>    -f, --file &lt;file&gt;     use given config file<br>    --blob &lt;blob-id&gt;      <span class=\"hljs-built_in\">read</span> config from given blob object<br><br>Action<br>    --get                 get value: name [value-pattern]<br>    --get-all             get all values: key [value-pattern]<br>    --get-regexp          get values <span class=\"hljs-keyword\">for</span> regexp: name-regex [value-pattern]<br>    --get-urlmatch        get value specific <span class=\"hljs-keyword\">for</span> the URL: section[.var] URL<br>    --replace-all         replace all matching variables: name value [value-pattern]<br>    --add                 add a new variable: name value<br>    --<span class=\"hljs-built_in\">unset</span>               remove a variable: name [value-pattern]<br>    --unset-all           remove all matches: name [value-pattern]<br>    --rename-section      rename section: old-name new-name<br>    --remove-section      remove a section: name<br>    -l, --list            list all<br>    --fixed-value         use string equality when comparing values to <span class=\"hljs-string\">&#x27;value-pattern&#x27;</span><br>    -e, --edit            open an editor<br>    --get-color           find the color configured: slot [default]<br>    --get-colorbool       find the color setting: slot [stdout-is-tty]<br><br>Type<br>    -t, --<span class=\"hljs-built_in\">type</span> &lt;&gt;         value is given this <span class=\"hljs-built_in\">type</span><br>    --bool                value is <span class=\"hljs-string\">&quot;true&quot;</span> or <span class=\"hljs-string\">&quot;false&quot;</span><br>    --int                 value is decimal number<br>    --bool-or-int         value is --bool or --int<br>    --bool-or-str         value is --bool or string<br>    --path                value is a path (file or directory name)<br>    --expiry-date         value is an expiry <span class=\"hljs-built_in\">date</span><br><br>Other<br>    -z, --null            terminate values with NUL byte<br>    --name-only           show variable names only<br>    --includes            respect include directives on lookup<br>    --show-origin         show origin of config (file, standard input, blob, <span class=\"hljs-built_in\">command</span> line)<br>    --show-scope          show scope of config (worktree, <span class=\"hljs-built_in\">local</span>, global, system, <span class=\"hljs-built_in\">command</span>)<br>    --default &lt;value&gt;     with --get, use default value when missing entry<br><br><br></code></pre></td></tr></table></figure>\n</blockquote>\n<h2 id=\"三、增加-删除文件\"><a href=\"#三、增加-删除文件\" class=\"headerlink\" title=\"三、增加/删除文件\"></a>三、增加/删除文件</h2><blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># 添加指定文件到暂存区</span><br>$ git add [file1] [file2] ...<br><br><span class=\"hljs-comment\"># 添加指定目录到暂存区，包括子目录</span><br>$ git add [<span class=\"hljs-built_in\">dir</span>]<br><br><span class=\"hljs-comment\"># 添加当前目录的所有文件到暂存区</span><br>$ git add .<br><br><span class=\"hljs-comment\"># 添加每个变化前，都会要求确认</span><br><span class=\"hljs-comment\"># 对于同一个文件的多处变化，可以实现分次提交</span><br>$ git add -p<br><br><span class=\"hljs-comment\"># 删除工作区文件，并且将这次删除放入暂存区</span><br>$ git <span class=\"hljs-built_in\">rm</span> [file1] [file2] ...<br><br><span class=\"hljs-comment\"># 停止追踪指定文件，但该文件会保留在工作区</span><br>$ git <span class=\"hljs-built_in\">rm</span> --cached [file]<br><br><span class=\"hljs-comment\"># 改名文件，并且将这个改名放入暂存区</span><br>$ git <span class=\"hljs-built_in\">mv</span> [file-original] [file-renamed]<br></code></pre></td></tr></table></figure>\n</blockquote>\n<h2 id=\"四、代码提交\"><a href=\"#四、代码提交\" class=\"headerlink\" title=\"四、代码提交\"></a>四、代码提交</h2><blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># 提交暂存区到仓库区</span><br>$ git commit -m [message]<br><br><span class=\"hljs-comment\"># 提交暂存区的指定文件到仓库区</span><br>$ git commit [file1] [file2] ... -m [message]<br><br><span class=\"hljs-comment\"># 提交工作区自上次commit之后的变化，直接到仓库区</span><br>$ git commit -a<br><br><span class=\"hljs-comment\"># 提交时显示所有diff信息</span><br>$ git commit -v<br><br><span class=\"hljs-comment\"># 使用一次新的commit，替代上一次提交</span><br><span class=\"hljs-comment\"># 如果代码没有任何新变化，则用来改写上一次commit的提交信息</span><br>$ git commit --amend -m [message]<br><br><span class=\"hljs-comment\"># 重做上一次commit，并包括指定文件的新变化</span><br>$ git commit --amend [file1] [file2] ...<br></code></pre></td></tr></table></figure>\n</blockquote>\n<h2 id=\"五、分支\"><a href=\"#五、分支\" class=\"headerlink\" title=\"五、分支\"></a>五、分支</h2><blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># 列出所有本地分支</span><br>$ git branch<br><br><span class=\"hljs-comment\"># 列出所有远程分支</span><br>$ git branch -r<br><br><span class=\"hljs-comment\"># 列出所有本地分支和远程分支</span><br>$ git branch -a<br><br><span class=\"hljs-comment\"># 新建一个分支，但依然停留在当前分支</span><br>$ git branch [branch-name]<br><br><span class=\"hljs-comment\"># 新建一个分支，并切换到该分支</span><br>$ git checkout -b [branch]<br><br><span class=\"hljs-comment\"># 新建一个分支，指向指定commit</span><br>$ git branch [branch] [commit]<br><br><span class=\"hljs-comment\"># 新建一个分支，与指定的远程分支建立追踪关系</span><br>$ git branch --track [branch] [remote-branch]<br><br><span class=\"hljs-comment\"># 切换到指定分支，并更新工作区</span><br>$ git checkout [branch-name]<br><br><span class=\"hljs-comment\"># 切换到上一个分支</span><br>$ git checkout -<br><br><span class=\"hljs-comment\"># 建立追踪关系，在现有分支与指定的远程分支之间</span><br>$ git branch --set-upstream [branch] [remote-branch]<br>$ 详细说明：<br>`--set-upstream`是`git push`命令的一个选项，它用于在将本地分支推送到远程仓库时，同时设置本地分支与远程分支的关联关系。<br><br>当您使用`git push`命令将本地分支推送到远程仓库时，Git会尝试将本地分支的更新推送到与之关联的远程分支。通常情况下，当您首次推送本地分支时，远程仓库可能还没有与之对应的远程分支。在这种情况下，如果您使用`--set-upstream`选项，Git会自动在远程仓库上创建一个与本地分支同名的分支，并将其与本地分支关联起来。<br><br>所以，当您执行以下命令时：<br>```<br>git push --set-upstream origin hexo<br>```<br>它的含义是将当前分支（假设是`hexo`）的更新推送到名为`origin`的远程仓库，并在远程仓库上创建一个名为`hexo`的分支，并将其与本地分支进行关联。<br><br>通过使用`--set-upstream`选项，您可以方便地建立本地分支与远程分支之间的连接，使得后续的`git push`命令可以自动将本地分支的更新推送到正确的远程分支。<br><br><span class=\"hljs-comment\"># 合并指定分支到当前分支</span><br>$ git merge [branch]<br><br><span class=\"hljs-comment\"># 选择一个commit，合并进当前分支</span><br>$ git cherry-pick [commit]<br><br><span class=\"hljs-comment\"># 删除分支</span><br>$ git branch -d [branch-name]<br><br><span class=\"hljs-comment\"># 删除远程分支</span><br>$ git push origin --delete [branch-name]<br>$ git branch -dr [remote/branch]<br></code></pre></td></tr></table></figure>\n</blockquote>\n<h2 id=\"六、标签\"><a href=\"#六、标签\" class=\"headerlink\" title=\"六、标签\"></a>六、标签</h2><blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># 列出所有tag</span><br>$ git tag<br><br><span class=\"hljs-comment\"># 新建一个tag在当前commit</span><br>$ git tag [tag]<br><br><span class=\"hljs-comment\"># 新建一个tag在指定commit</span><br>$ git tag [tag] [commit]<br><br><span class=\"hljs-comment\"># 删除本地tag</span><br>$ git tag -d [tag]<br><br><span class=\"hljs-comment\"># 删除远程tag</span><br>$ git push origin :refs/tags/[tagName]<br><br><span class=\"hljs-comment\"># 查看tag信息</span><br>$ git show [tag]<br><br><span class=\"hljs-comment\"># 提交指定tag</span><br>$ git push [remote] [tag]<br><br><span class=\"hljs-comment\"># 提交所有tag</span><br>$ git push [remote] --tags<br><br><span class=\"hljs-comment\"># 新建一个分支，指向某个tag</span><br>$ git checkout -b [branch] [tag]<br></code></pre></td></tr></table></figure>\n</blockquote>\n<h2 id=\"七、查看信息\"><a href=\"#七、查看信息\" class=\"headerlink\" title=\"七、查看信息\"></a>七、查看信息</h2><blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># 显示有变更的文件</span><br>$ git status<br><br><span class=\"hljs-comment\"># 显示当前分支的版本历史</span><br>$ git <span class=\"hljs-built_in\">log</span><br><br><span class=\"hljs-comment\"># 显示commit历史，以及每次commit发生变更的文件</span><br>$ git <span class=\"hljs-built_in\">log</span> --<span class=\"hljs-built_in\">stat</span><br><br><span class=\"hljs-comment\"># 搜索提交历史，根据关键词</span><br>$ git <span class=\"hljs-built_in\">log</span> -S [keyword]<br><br><span class=\"hljs-comment\"># 显示某个commit之后的所有变动，每个commit占据一行</span><br>$ git <span class=\"hljs-built_in\">log</span> [tag] HEAD --pretty=format:%s<br><br><span class=\"hljs-comment\"># 显示某个commit之后的所有变动，其&quot;提交说明&quot;必须符合搜索条件</span><br>$ git <span class=\"hljs-built_in\">log</span> [tag] HEAD --grep feature<br><br><span class=\"hljs-comment\"># 显示某个文件的版本历史，包括文件改名</span><br>$ git <span class=\"hljs-built_in\">log</span> --follow [file]<br>$ git whatchanged [file]<br><br><span class=\"hljs-comment\"># 显示指定文件相关的每一次diff</span><br>$ git <span class=\"hljs-built_in\">log</span> -p [file]<br><br><span class=\"hljs-comment\"># 显示过去5次提交</span><br>$ git <span class=\"hljs-built_in\">log</span> -5 --pretty --oneline<br><br><span class=\"hljs-comment\"># 显示所有提交过的用户，按提交次数排序</span><br>$ git shortlog -sn<br><br><span class=\"hljs-comment\"># 显示指定文件是什么人在什么时间修改过</span><br>$ git blame [file]<br><br><span class=\"hljs-comment\"># 显示暂存区和工作区的差异</span><br>$ git diff<br><br><span class=\"hljs-comment\"># 显示暂存区和上一个commit的差异</span><br>$ git diff --cached [file]<br><br><span class=\"hljs-comment\"># 显示工作区与当前分支最新commit之间的差异</span><br>$ git diff HEAD<br><br><span class=\"hljs-comment\"># 显示两次提交之间的差异</span><br>$ git diff [first-branch]...[second-branch]<br><br><span class=\"hljs-comment\"># 显示今天你写了多少行代码</span><br>$ git diff --shortstat <span class=\"hljs-string\">&quot;@&#123;0 day ago&#125;&quot;</span><br><br><span class=\"hljs-comment\"># 显示某次提交的元数据和内容变化</span><br>$ git show [commit]<br><br><span class=\"hljs-comment\"># 显示某次提交发生变化的文件</span><br>$ git show --name-only [commit]<br><br><span class=\"hljs-comment\"># 显示某次提交时，某个文件的内容</span><br>$ git show [commit]:[filename]<br><br><span class=\"hljs-comment\"># 显示当前分支的最近几次提交</span><br>$ git reflog<br></code></pre></td></tr></table></figure>\n</blockquote>\n<h2 id=\"八、远程同步\"><a href=\"#八、远程同步\" class=\"headerlink\" title=\"八、远程同步\"></a>八、远程同步</h2><blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># 下载远程仓库的所有变动</span><br>$ git fetch [remote]<br><br><span class=\"hljs-comment\"># 显示所有远程仓库</span><br>$ git remote -v<br><br><span class=\"hljs-comment\"># 显示某个远程仓库的信息</span><br>$ git remote show [remote]<br><br><span class=\"hljs-comment\"># 增加一个新的远程仓库，并命名</span><br>$ git remote add [shortname] [url]<br><br><span class=\"hljs-comment\"># 取回远程仓库的变化，并与本地分支合并</span><br>$ git pull [remote] [branch]<br><br><span class=\"hljs-comment\"># 上传本地指定分支到远程仓库</span><br>$ git push [remote] [branch]<br><br><span class=\"hljs-comment\"># 强行推送当前分支到远程仓库，即使有冲突</span><br>$ git push [remote] --force<br><br><span class=\"hljs-comment\"># 推送所有分支到远程仓库</span><br>$ git push [remote] --all<br></code></pre></td></tr></table></figure>\n</blockquote>\n<h2 id=\"九、撤销\"><a href=\"#九、撤销\" class=\"headerlink\" title=\"九、撤销\"></a>九、撤销</h2><blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># 恢复暂存区的指定文件到工作区                                 误删文件，用于恢复add时的状态</span><br>$ git checkout [file]<br><br><span class=\"hljs-comment\"># 恢复某个commit的指定文件到暂存区和工作区</span><br>$ git checkout [commit] [file]<br><br><span class=\"hljs-comment\"># 恢复暂存区的所有文件到工作区</span><br>$ git checkout .<br><br><span class=\"hljs-comment\"># 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变      已暂存的内容不想提交，用于取消暂存de</span><br>$ git reset [file]<br><br><span class=\"hljs-comment\"># 重置暂存区与工作区，与上一次commit保持一致</span><br>$ git reset --hard<br><br><span class=\"hljs-comment\"># 如果想回滚的话，比如说回滚到上一个版本，可以执行以下两种命令：</span><br><br>$ git reset --hard HEAD^         上上个版本就是 git reset --hard HEAD^^，以此类推。<br><br>$ git reset --hard HEAD~100      如果回滚到前 100 个版本，用这个命令比上一个命令更方便。<br><br><span class=\"hljs-comment\"># 假如回滚错了，想恢复，不记得版本号了，可以先执行此命令查看版本号：</span><br>$ git reflog<br><br><span class=\"hljs-comment\"># 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变</span><br>$ git reset [commit]<br><br><span class=\"hljs-comment\"># 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致</span><br>$ git reset --hard [commit]<br><br><span class=\"hljs-comment\"># 重置当前HEAD为指定commit，但保持暂存区和工作区不变</span><br>$ git reset --keep [commit]<br><br><span class=\"hljs-comment\"># 新建一个commit，用来撤销指定commit</span><br><span class=\"hljs-comment\"># 后者的所有变化都将被前者抵消，并且应用到当前分支</span><br>$ git revert [commit]<br><br><span class=\"hljs-comment\"># 暂时将未提交的变化移除，稍后再移入</span><br>$ git stash<br>$ git stash pop<br></code></pre></td></tr></table></figure>\n</blockquote>\n<h2 id=\"十、其他\"><a href=\"#十、其他\" class=\"headerlink\" title=\"十、其他\"></a>十、其他</h2><blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># 生成一个可供发布的压缩包</span><br>$ git archive<br></code></pre></td></tr></table></figure>\n\n</blockquote>\n<h2 id=\"说说一个比较常见的问题：如何合并冲突？\"><a href=\"#说说一个比较常见的问题：如何合并冲突？\" class=\"headerlink\" title=\"说说一个比较常见的问题：如何合并冲突？\"></a>说说一个比较常见的问题：如何合并冲突？</h2><blockquote>\n<p>当我们在远仓直接更新内容时，下次如果是在本地准备提交上传，如果忘记拉取最新更新，<br>那么在push时会拒绝我们推送，所以我们需要在提交前进行拉取远仓的最新变更，<br>然后手动处理冲突，最后再提交</p>\n</blockquote>\n<p>拉取远程仓库变更：在本地仓库中运行 git pull 命令，将远程仓库中的最新变更拉取到本地。</p>\n<p>处理冲突（如果存在）：如果在远程仓库和本地仓库同时修改了相同的文件，可能会发生冲突。Git 会将冲突标记在文件中，你需要手动解决这些冲突。打开有冲突的文件，查找并解决冲突的部分。完成后保存文件。</p>\n<p>添加和提交变更：在本地仓库中使用 git add 命令将修改后的文件标记为已暂存，然后使用 git commit 命令提交这些变更。确保你提供了有意义的提交消息，以便于他人理解你所做的更改。</p>\n<p>推送到远程仓库：使用 git push 命令将本地仓库的变更推送到远程仓库。</p>\n<h2 id=\"公司多分支仓库是怎么协作开发的？\"><a href=\"#公司多分支仓库是怎么协作开发的？\" class=\"headerlink\" title=\"公司多分支仓库是怎么协作开发的？\"></a>公司多分支仓库是怎么协作开发的？</h2><p>在Git中，每个人创建一个分支进行协作是一种常见的模式。在这种情况下，主分支通常被称为”main”，其他分支则用于个人或团队的工作。</p>\n<p>如果你想将主分支（main）的最新代码拉取到你的分支（github-wl）上，可以按照以下步骤进行操作：</p>\n<ol>\n<li>首先，确保你已经在你的本地仓库中创建了一个名为”github-wl”的分支。你可以使用以下命令创建并切换到该分支：</li>\n</ol>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">git checkout -b github-wl<br></code></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>接下来，你需要将主分支（main）的最新代码拉取到你的本地仓库。可以使用以下命令从远程仓库中拉取最新代码：</li>\n</ol>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">git fetch origin main<br></code></pre></td></tr></table></figure>\n\n<p>这将会获取主分支的最新更改，但不会自动合并到你的分支。</p>\n<ol start=\"3\">\n<li>如果你想将这些更改合并到你的分支上，可以使用以下命令进行合并：</li>\n</ol>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">git merge origin/main<br></code></pre></td></tr></table></figure>\n\n<p>这将把主分支的最新代码合并到你的当前分支（github-wl）上。</p>\n<ol start=\"4\">\n<li>如果在合并过程中出现冲突，你需要手动解决冲突。Git会在冲突的文件中标记出冲突的部分，你需要打开这些文件并手动编辑以解决冲突。</li>\n<li>一旦冲突解决完成，你可以使用以下命令将你的分支推送到远程仓库：</li>\n</ol>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">git push origin github-wl<br></code></pre></td></tr></table></figure>\n\n<p>这将把你的分支（github-wl）的更改推送到远程仓库。</p>\n<p>通过以上步骤，你可以将主分支（main）的最新代码拉取到你的分支（github-wl）上，并在解决冲突后将更改推送到远程仓库。</p>\n"},{"title":"Hexo 建站笔记","index_img":"https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202309120902040.png","description":"这是我的 Hexo 多端部署方案以及怎么把hexo博客部署到服务器，怎么优化博客访问速度？hexo博客优化","abbrlink":44559,"date":"2021-09-07T06:07:56.000Z","_content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nmerge commend\n\n```bash\n$ hexo cl && hexo g && hexo s\n$ hexo d\n```\n\n## 升级日志\n\n2023年11月15日\n\n1. 增加一个GitHub现在编辑button，可直接跳转GitHub远仓，进行修改提交。\n\n   > 为文章页增加了一个 GitHub 在线修改的 button，点击可在线提交到 GitHub`hexoBlog分支`(源文件)分支，同时触发流水线自动部署到`master分支`(pages)，所以会存在一种情况：每当我在线修改后，本地仓库文章与远仓不同步，本地写文章的话需要拉取最新更改。\n   >\n   > - 优化方案：是否可以有自动同步本地仓库的工作流\n   >\n   > - 解决方案：本地更新文章之前需要先拉取远仓最新更改，否则会提示：\n   >\n   >   ![image-20231126144130073](https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311261441104.png)\n   >\n   \n2. 修改了layout布局文件夹下面的post.ejs文件，设置文章index_img宽高比为5：3\n\n\t> \tattention: 更改文章页的index_img需要手动更改图片尺寸\n\n3. 设置 GitHub 工作流,当同步源文件到远仓时,会自动部署静态资源到 GitHub Pages.\n\n   > attention: 因为`imagemin-gifsicle`插件版本的问题,本地运行时没问题,通过远仓的工作流进行`npm install`时,有时会安装不上,有时安装好了运行会报错,因此就直接把本地的`node_modules`直接上传到了GitHub,同时,在GitHub工作流文件中去掉了依赖安装的步骤.\n   >\n   > - **GitHub工作流代码：**\n   >\n   > ```yml\n   > name: Build and Deploy  \n   > on: [push]  \n   > \n   > jobs:  \n   > build-and-deploy:  \n   > concurrency: ci-${{ github.ref }} # Recommended if you intend to make multiple deployments in quick succession.  \n   > runs-on: ubuntu-latest  \n   > steps:  \n   >       - name: Checkout 🔔  \n   >         uses: actions/checkout@v3  \n   > \n   >       - name: Install Hexo CLI    \n   >         run: npm install -g hexo-cli@4.3.0  \n   >         env:    \n   >           CI: false  \n   > \n   >       - name: Install Dependencies # 步骤3：安装依赖  \n   >         if: steps.cache.outputs.cache-hit != 'true'  \n   >         run: npm run build  \n   >         env:  \n   >           CI: false  \n   > \n   >       - name: Deploy 🚀 # 步骤4：部署  \n   >         # uses: JamesIves/github-pages-deploy-action@releases/v3  \n   >         uses: JamesIves/github-pages-deploy-action@v4  \n   >         with:  \n   >           GITHUB_TOKEN: ${{ secrets.GITEE_TOKEN }} # 使用 Gitee 令牌  \n   >           BRANCH: master # 部署到 master 分支  \n   >           FOLDER: public # 部署 public 文件夹\n   > ```\n   >\n   > - 有了工作流, 本地更新上传文章就可以通过脚本一键上传了！\n   >\n   > **本地仓库拉取远仓最新更改 windows shell 脚本:**\n   >\n   > ```shell\n   > @echo off\n   > \n   > E:\n   > \n   > cd E:\\CS_GUIDER\\hexo\n   > \n   > echo \"Pull the latest code from github...\"\n   > \n   > REM 因为Button在线修改是在GitHub远仓修改的，所以这里直接拉取GitHub远仓的更改\n   > \n   > echo \"pull source code...\"\n   > \n   > git pull origin hexoBlog\n   > \n   > echo \"pull source code over!\"\n   > \n   > echo \"deploy to gitee pages\"\n   > \n   > hexo cl && call hexo g && hexo d -m \"autoDeploy\"\n   > ```\n   >\n   > **本地一键上传远仓 windows shell 脚本:**\n   >\n   > ```shell\n   > @echo off\n   > \n   > E:\n   > \n   > cd E:\\CS_GUIDER\\hexo\n   > \n   > echo \"upload source code to remoteRepo...\"\n   > \n   > REM 目前版本中 gitee 远仓的工作流还待更新，所以这里我们任然使用 hexo-cli 脚手架的一键部署命令，这里需要在根目录的 config.yml 文件中进行配置远仓地址，这里因为GitHub工作流文件可以云端部署静态资源，所以我在文件中只配置了 Gitee 的远仓地址。（后续更新 Gitee 工作流之后就可以直接废弃hexo-cli的相关命令啦，但是如果修改了文件地址的话或者标题，可能会出现文章无法访问以及链接失效的问题，所以hexo clean还是需要了解一下的）\n   > \n   > echo \"trucking files over\"\n   > \n   > echo \"commit files\"\n   > \n   > git commit -m \"feat: auto synchronized.\"\n   > \n   > echo \"commit over\"\n   > \n   > echo \"push to github\"\n   > \n   > git push origin hexoBlog\n   > \n   > echo \"push gitee\"\n   > \n   > git push gitee hexoBlog\n   > \n   > ```\n\n\n\n## 我的 Hexo 多端部署方案\n\n> 由于部署在 GitHub Pages 上，国内访问速度很是拉跨。于是准备托管到 Gitee Pages 上，奈何 Gitee 个人版不支持自定义域名和ssl。\n>\n> 首先，我认为搭建博客有两个出发点。①是出于沉淀知识的目的，②则是出于沉淀知识的同时分享自己的知识，追求个人流量以及知名度。\n>\n> - **0投资沉淀私域知识（不想花钱，不关心访客量）：**\n>   - 首先推荐部署到`Gitee Pages`静态网页上，不仅提供了 https 链接，而且国内访问速度还是很 OK 的，缺点就是每次更新文章需要手动点击更新。喜欢摸索的可以学习下 CI/CD 持续部署，创建一个工作流文件，当监听到仓库更新时，自动部署到 Pages。\n>   - 其次推荐部署到`Github Pages`静态网页上，但是访问速度堪忧，有时需要魔法才可以正常访问。\n>   - **图片加载问题：**在`GitHub Pages`超级慢，前者还行。解决方案：购买一个云服务商的对象存储，例如华为云OBS、阿里云OSS...，创建一个图床，这样就可以解决图片加载问题了。\n> - **出于沉淀知识 + 分享知识，打造个人 IP：**\n>   - **前置条件：**域名、备案\n>     - **贫民方案-无服务器部署：**都知道服务器是不便宜的，我曾看到一篇博客，说可以部署到腾讯云的 Coding 平台，这样就可以使用自定义域名了，只需花一个域名的钱，也可以选择完成域名备案。[点击前往：文章更新于2020年，可能Coding平台已升级，未验证是否还支持静态网站部署](https://blog.csdn.net/qq_29654777/article/details/108222881)\n>   - **前置条件：**域名、备案 + 对象存储、CDN、服务器\n>     - **金主方案-个人服务器部署：**直接博客上云，推送到云端服务器的 GitHub 仓库-->远仓自定义主页domain-->域名控制台完成解析-->购买个人对象存储图床和 CDN 内容分发-->域名备案-->提交域名到各搜索引擎，例如[百度搜索资源平台](https://ziyuan.baidu.com/site/index#/)和[Google Search Console](https://search.google.com/search-console/welcome)，同时可以搭配百度统计和Google Analytics 来可视化分析自己博客的访问情况。\n> - **我的二者兼得方案：**\n>   - 待补充！\n>   - 百度资源搜索平台如何验证个人站点？谷歌搜索怎么验证个人站点？怎么提高百度收录量？\n\n## SEO优化\n\n> 1. 保持更新并紧扣关键字。经常更新博客，并确保文章内容紧紧围绕关键字展开，同时也要注意保持文章标题和内文的关键词自然出现，不要过度堆砌。\n>\n> 2. 优化内容页。SEO优化重点应以文章内容页为主，适当增加关键词(Keyword)、描述(Description)、抓取器(Robots)等标签，并确保每个页面都有唯一的URL。[参考链接](https://blog.csdn.net/u011316675/article/details/113750491)\n>\n>    ![image-20231125201620113](https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311252016193.png)\n>\n>    ![image-20231125201628969](https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311252016055.png)\n>\n>    注意description的获取优先级: `description>excerpt>content>config.description\n>\n> 3. 建立单一关键词策略。对于新博客，可以建立单一关键词策略，以增强网站对搜索引擎的权威性。\n>\n> 4. 合理分类栏目。使用目录形式分类栏目，并避免过度分类。对于比较重要的文章的URL，可以使用拼音、英文和分割线等结构。\n>\n> 5. 做好内部链接建设。在新文章中适当增加一些老文章的链接，并确保文章的内部链接自然出现。\n>\n> 6. 外部链接建设。建立其他博客或网站的外部链接，推荐使用工具如http://www.lusongsong.com/tool/seo/。\n>\n> 7. 垃圾留言处理。及时删除垃圾留言，否则可能严重影响排名。\n>\n> 8. Alt标签和图片信息。给每个博文插图添加和文章内容相关的alt信息，并在图片周围添加相关信息。\n>\n> 9. TAG标签使用。通过添加TAG标签可以增强主题的相关性和被搜索的概率。\n>\n> 10. 合理设置标题。文章的Title最好以“文章标题-博客名称”形式出现。\n> 11. 关键词自然出现。在文章标题、正文开头或结尾中自然出现关键词。\n> 12. 文章结尾优化。每篇文章的结尾处可加入“原创文章如转载，请注明出处”“本文首发于XXX网站”等信息，对SEO有一定帮助。\n\n## 生成sitemap.xml\n\n```shell\n#---------------------------\n# 站点地图（sitemap.xml）\n# 安装插件：\n#   -Google：npm install hexo-generator-sitemap --save\n#   -Baidu：npm install hexo-generator-baidu-sitemap --save\n#---------------------------\n\n# sitemap\nsitemap:\n  path: sitemap.xml\nbaidusitemap:\n  path: baidusitemap.xml\n```\n\n## 文件压缩--hexo-all-minifier\n\n> 如果安装的时候出现各种报错都没有在`GitHub`提到的`issues`中找到，仔细看报错内容提示，该重启的时候就重启，该上梯子就上梯子（不行就全局模式），卸载依赖：`npm uninstall hexo-all-minifier`；安装依赖：`npm install hexo-all-minifier --save`，这两个命令反复多来几次，就会忽然发现，安装成功了！！！！最后吐槽一句，被墙真不友好！！！\n\n```shell\n#---------------------------\n# 压缩插件\n# 安装插件：npm install hexo-all-minifier --save\n# 源码地址：https://github.com/chenzhutian/hexo-all-minifier\n#---------------------------\n\n#把以下配置文件添加到 _config.fluid.yml中\n\n#启用all_minifier\nall_minifier: true\n# html压缩\nhtml_minifier:\n  enable: true\n  ignore_error: false\n  exclude:\n\n# css压缩\ncss_minifier:\n  enable: true\n  exclude:\n    - '*.min.css'\n    \n# js压缩\njs_minifier:\n  enable: true\n  mangle: true\n  compress:\n  exclude:\n    - '*.min.js'\njs_concator:\n  enable: false\n  bundle_path: '/js/bundle.js'\n  front: false\n  silent: false\n\n# 图片优化\nimage_minifier:\n  enable: true\n  interlaced: false\n  multipass: false\n  optimizationLevel: 2\n  pngquant: false\n  progressive: false\n```\n\n**再记录、复盘一下这个插件在 GitHub 工作流中的问题！！！盲猜是因为 nodejs 的环境或者 npm 的环境问题**\n\n> 事情缘由：想给文章增加一个在线编辑的`Button`，被工作流文件和这个插件折腾了一天多。\n>\n> 问题所在：本地环境与 GitHub 环境有所不同，相同的依赖上传到GitHub，在hexo generate构建的时候，也就是npm run build的时候，工作流文件会报错。报错如下：\n>\n> ```bash\n> FATAL {\n>   err: Error: spawn /home/runner/work/WL2O2O.github.io/WL2O2O.github.io/node_modules/imagemin-gifsicle/node_modules/gifsicle/vendor/gifsicle ENOENT\n>       at ChildProcess._handle.onexit (node:internal/child_process:284:19)\n>       at onErrorNT (node:internal/child_process:477:16)\n>       at process.processTicksAndRejections (node:internal/process/task_queues:82:21) {\n>     errno: -2,\n>     code: 'ENOENT',\n>     syscall: 'spawn /home/runner/work/WL2O2O.github.io/WL2O2O.github.io/node_modules/imagemin-gifsicle/node_modules/gifsicle/vendor/gifsicle',\n>     path: '/home/runner/work/WL2O2O.github.io/WL2O2O.github.io/node_modules/imagemin-gifsicle/node_modules/gifsicle/vendor/gifsicle',\n>     spawnargs: [ '--no-warnings', '--no-app-extensions' ],\n>     stdout: <Buffer >,\n>     stderr: <Buffer >,\n>     failed: true,\n>     signal: null,\n>     cmd: '/home/runner/work/WL2O2O.github.io/WL2O2O.github.io/node_modules/imagemin-gifsicle/node_modules/gifsicle/vendor/gifsicle --no-warnings --no-app-extensions',\n>     timedOut: false,\n>     killed: false\n>   }\n> } Something's wrong. Maybe you can find the solution here: %s https://hexo.io/docs/troubleshooting.html\n> Error: Process completed with exit code 2.\n> ```\n>\n> 解决方案：\n>\n> 因为本地是完全没有问题的，而且我的依赖是本地直传 GitHub 远仓，于是，直接在`.gitignore`文件中忽略了这个插件涉及到的子插件问题。\n>\n> ```.gitignore\n> node_modules/imagemin-gifsicle/*\n> ```\n>\n> 暂时解决，后续有问题继续更改。\n>\n> 不足之处：\n>\n> 工作流文件中缺少在线构建的语句，因为想要与本地保持一致，暂时选择了直接上传，后续若有问题，再继续改进。工作流文件如下：\n>\n> ```yml\n> # name: Deploy # 工作流名称\n> # on:\n> #   push: # push 事件触发工作流\n> #     branches:\n> #       - hexoBlog # 只有在 hexoBlog 分支推送时触发工作流\n> # jobs:\n> #   build: # job1 id\n> #     runs-on: ubuntu-latest # 运行环境为最新版 Ubuntu\n> #     name: Deploy blog\n> #     steps:\n> #       - name: Checkout # 步骤1：获取源码\n> #         uses: actions/checkout@v2 # 使用 actions/checkout@v2\n> \n> #       - name: Cache node modules # 步骤2：缓存 node_modules\n> #         uses: actions/cache@v2\n> #         with:\n> #           path: node_modules\n> #           key: ${{ runner.os }}-node-${{ hashFiles('**/package-lock.json') }}\n> name: Build and Deploy\n> on: [push]\n> permissions: # 增加写入仓库分支的写权限，否则在最后一步部署时会出错，提示\n>   contents: write\n> jobs:\n>   build-and-deploy:\n>     concurrency: ci-${{ github.ref }} # Recommended if you intend to make multiple deployments in quick succession.\n>     runs-on: ubuntu-latest\n>     steps:\n>       - name: Checkout 🛎️\n>         uses: actions/checkout@v3\n>         \n>       - name: Install Hexo CLI  \n>         run: npm install -g hexo-cli@4.3.0\n>         env:  \n>           CI: false\n> \n>       - name: Install Dependencies # 步骤3：安装依赖\n>         if: steps.cache.outputs.cache-hit != 'true'\n>         run: npm run build\n>         env:\n>           CI: false\n>           \n>       - name: Deploy 🚀 # 步骤4：部署\n>         # uses: JamesIves/github-pages-deploy-action@releases/v3\n>         uses: JamesIves/github-pages-deploy-action@v4\n>         with:\n>           GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n>           BRANCH: master # 部署到 gh-pages 分支\n>           FOLDER: public # 部署 public 文件夹\n> ```\n>\n> [补充部署GitHub pages的一个repository](https://github.com/marketplace/actions/deploy-to-github-pages)\n>\n> 介绍:\n>\n> Automatically deploy your project to [GitHub Pages](https://pages.github.com/) with [GitHub Actions](https://github.com/features/actions). This action can be configured to push your production-ready code into any branch you'd like, including **gh-pages** and **docs**. It can also handle cross repository deployments and works with [GitHub Enterprise](https://github.com/enterprise) too.\n>\n> 官方提供的Action文件：\n>\n> ```yml\n> name: Build and Deploy\n> on: [push]\n> permissions:\n>   contents: write\n> jobs:\n>   build-and-deploy:\n>     concurrency: ci-${{ github.ref }} # Recommended if you intend to make multiple deployments in quick succession.\n>     runs-on: ubuntu-latest\n>     steps:\n>       - name: Checkout 🛎️\n>         uses: actions/checkout@v3\n> \n>       - name: Install and Build 🔧 # This example project is built using npm and outputs the result to the 'build' folder. Replace with the commands required to build your project, or remove this step entirely if your site is pre-built.\n>         run: |\n>           npm ci\n>           npm run build\n> \n>       - name: Deploy 🚀\n>         uses: JamesIves/github-pages-deploy-action@v4\n>         with:\n>           folder: build # The folder the action should deploy.\n> ```\n>\n\n## 文章置顶--hexo-generator-index\n\n```shell\n#---------------------------\n# 文章置顶\n# 安装时间：2023年10月24日\n# 安装插件：npm install hexo-generator-index --save\n# 源码地址：https://github.com/hexojs/hexo-generator-index.git\n#---------------------------\n# 使用方法\nsticky: 100（数值越大，优先级越高）\n```\n\n## 文章链接持久化\n\n```shell\n#---------------------------\n# 解决文章链接会随标题变动而变动，链接永久化插件\n# 安装地址：https://github.com/Rozbo/hexo-abbrlink\n# 安装插件：npm install hexo-abbrlink --save\n#---------------------------\npermalink: posts/:abbrlink.html\n# abbrlink config\nabbrlink:\n  alg: crc32      #support crc16(default) and crc32\n  rep: hex        #support dec(default) and hex\n  drafts: false   #(true)Process draft,(false)Do not process draft. false(default) \n  # Generate categories from directory-tree\n  # depth: the max_depth of directory-tree you want to generate, should > 0\n  auto_category:\n     enable: true  #true(default)\n     depth:        #3(default)\n     over_write: false \n  auto_title: false #enable auto title, it can auto fill the title by path\n  auto_date: false #enable auto date, it can auto fill the date by time today\n  force: false #enable force mode,in this mode, the plugin will ignore the cache, and calc the abbrlink for every post even it already had abbrlink. This only updates abbrlink rather than other front variables.\n```\n\n","source":"_posts/helloHexo.md","raw":"---\ntitle: Hexo 建站笔记\nindex_img: https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202309120902040.png\ncategories:\n  - Blog\ntags:\n  - 网站搭建\ndescription: 这是我的 Hexo 多端部署方案以及怎么把hexo博客部署到服务器，怎么优化博客访问速度？hexo博客优化\nabbrlink: 44559\ndate: 2021-09-07 14:07:56\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nmerge commend\n\n```bash\n$ hexo cl && hexo g && hexo s\n$ hexo d\n```\n\n## 升级日志\n\n2023年11月15日\n\n1. 增加一个GitHub现在编辑button，可直接跳转GitHub远仓，进行修改提交。\n\n   > 为文章页增加了一个 GitHub 在线修改的 button，点击可在线提交到 GitHub`hexoBlog分支`(源文件)分支，同时触发流水线自动部署到`master分支`(pages)，所以会存在一种情况：每当我在线修改后，本地仓库文章与远仓不同步，本地写文章的话需要拉取最新更改。\n   >\n   > - 优化方案：是否可以有自动同步本地仓库的工作流\n   >\n   > - 解决方案：本地更新文章之前需要先拉取远仓最新更改，否则会提示：\n   >\n   >   ![image-20231126144130073](https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311261441104.png)\n   >\n   \n2. 修改了layout布局文件夹下面的post.ejs文件，设置文章index_img宽高比为5：3\n\n\t> \tattention: 更改文章页的index_img需要手动更改图片尺寸\n\n3. 设置 GitHub 工作流,当同步源文件到远仓时,会自动部署静态资源到 GitHub Pages.\n\n   > attention: 因为`imagemin-gifsicle`插件版本的问题,本地运行时没问题,通过远仓的工作流进行`npm install`时,有时会安装不上,有时安装好了运行会报错,因此就直接把本地的`node_modules`直接上传到了GitHub,同时,在GitHub工作流文件中去掉了依赖安装的步骤.\n   >\n   > - **GitHub工作流代码：**\n   >\n   > ```yml\n   > name: Build and Deploy  \n   > on: [push]  \n   > \n   > jobs:  \n   > build-and-deploy:  \n   > concurrency: ci-${{ github.ref }} # Recommended if you intend to make multiple deployments in quick succession.  \n   > runs-on: ubuntu-latest  \n   > steps:  \n   >       - name: Checkout 🔔  \n   >         uses: actions/checkout@v3  \n   > \n   >       - name: Install Hexo CLI    \n   >         run: npm install -g hexo-cli@4.3.0  \n   >         env:    \n   >           CI: false  \n   > \n   >       - name: Install Dependencies # 步骤3：安装依赖  \n   >         if: steps.cache.outputs.cache-hit != 'true'  \n   >         run: npm run build  \n   >         env:  \n   >           CI: false  \n   > \n   >       - name: Deploy 🚀 # 步骤4：部署  \n   >         # uses: JamesIves/github-pages-deploy-action@releases/v3  \n   >         uses: JamesIves/github-pages-deploy-action@v4  \n   >         with:  \n   >           GITHUB_TOKEN: ${{ secrets.GITEE_TOKEN }} # 使用 Gitee 令牌  \n   >           BRANCH: master # 部署到 master 分支  \n   >           FOLDER: public # 部署 public 文件夹\n   > ```\n   >\n   > - 有了工作流, 本地更新上传文章就可以通过脚本一键上传了！\n   >\n   > **本地仓库拉取远仓最新更改 windows shell 脚本:**\n   >\n   > ```shell\n   > @echo off\n   > \n   > E:\n   > \n   > cd E:\\CS_GUIDER\\hexo\n   > \n   > echo \"Pull the latest code from github...\"\n   > \n   > REM 因为Button在线修改是在GitHub远仓修改的，所以这里直接拉取GitHub远仓的更改\n   > \n   > echo \"pull source code...\"\n   > \n   > git pull origin hexoBlog\n   > \n   > echo \"pull source code over!\"\n   > \n   > echo \"deploy to gitee pages\"\n   > \n   > hexo cl && call hexo g && hexo d -m \"autoDeploy\"\n   > ```\n   >\n   > **本地一键上传远仓 windows shell 脚本:**\n   >\n   > ```shell\n   > @echo off\n   > \n   > E:\n   > \n   > cd E:\\CS_GUIDER\\hexo\n   > \n   > echo \"upload source code to remoteRepo...\"\n   > \n   > REM 目前版本中 gitee 远仓的工作流还待更新，所以这里我们任然使用 hexo-cli 脚手架的一键部署命令，这里需要在根目录的 config.yml 文件中进行配置远仓地址，这里因为GitHub工作流文件可以云端部署静态资源，所以我在文件中只配置了 Gitee 的远仓地址。（后续更新 Gitee 工作流之后就可以直接废弃hexo-cli的相关命令啦，但是如果修改了文件地址的话或者标题，可能会出现文章无法访问以及链接失效的问题，所以hexo clean还是需要了解一下的）\n   > \n   > echo \"trucking files over\"\n   > \n   > echo \"commit files\"\n   > \n   > git commit -m \"feat: auto synchronized.\"\n   > \n   > echo \"commit over\"\n   > \n   > echo \"push to github\"\n   > \n   > git push origin hexoBlog\n   > \n   > echo \"push gitee\"\n   > \n   > git push gitee hexoBlog\n   > \n   > ```\n\n\n\n## 我的 Hexo 多端部署方案\n\n> 由于部署在 GitHub Pages 上，国内访问速度很是拉跨。于是准备托管到 Gitee Pages 上，奈何 Gitee 个人版不支持自定义域名和ssl。\n>\n> 首先，我认为搭建博客有两个出发点。①是出于沉淀知识的目的，②则是出于沉淀知识的同时分享自己的知识，追求个人流量以及知名度。\n>\n> - **0投资沉淀私域知识（不想花钱，不关心访客量）：**\n>   - 首先推荐部署到`Gitee Pages`静态网页上，不仅提供了 https 链接，而且国内访问速度还是很 OK 的，缺点就是每次更新文章需要手动点击更新。喜欢摸索的可以学习下 CI/CD 持续部署，创建一个工作流文件，当监听到仓库更新时，自动部署到 Pages。\n>   - 其次推荐部署到`Github Pages`静态网页上，但是访问速度堪忧，有时需要魔法才可以正常访问。\n>   - **图片加载问题：**在`GitHub Pages`超级慢，前者还行。解决方案：购买一个云服务商的对象存储，例如华为云OBS、阿里云OSS...，创建一个图床，这样就可以解决图片加载问题了。\n> - **出于沉淀知识 + 分享知识，打造个人 IP：**\n>   - **前置条件：**域名、备案\n>     - **贫民方案-无服务器部署：**都知道服务器是不便宜的，我曾看到一篇博客，说可以部署到腾讯云的 Coding 平台，这样就可以使用自定义域名了，只需花一个域名的钱，也可以选择完成域名备案。[点击前往：文章更新于2020年，可能Coding平台已升级，未验证是否还支持静态网站部署](https://blog.csdn.net/qq_29654777/article/details/108222881)\n>   - **前置条件：**域名、备案 + 对象存储、CDN、服务器\n>     - **金主方案-个人服务器部署：**直接博客上云，推送到云端服务器的 GitHub 仓库-->远仓自定义主页domain-->域名控制台完成解析-->购买个人对象存储图床和 CDN 内容分发-->域名备案-->提交域名到各搜索引擎，例如[百度搜索资源平台](https://ziyuan.baidu.com/site/index#/)和[Google Search Console](https://search.google.com/search-console/welcome)，同时可以搭配百度统计和Google Analytics 来可视化分析自己博客的访问情况。\n> - **我的二者兼得方案：**\n>   - 待补充！\n>   - 百度资源搜索平台如何验证个人站点？谷歌搜索怎么验证个人站点？怎么提高百度收录量？\n\n## SEO优化\n\n> 1. 保持更新并紧扣关键字。经常更新博客，并确保文章内容紧紧围绕关键字展开，同时也要注意保持文章标题和内文的关键词自然出现，不要过度堆砌。\n>\n> 2. 优化内容页。SEO优化重点应以文章内容页为主，适当增加关键词(Keyword)、描述(Description)、抓取器(Robots)等标签，并确保每个页面都有唯一的URL。[参考链接](https://blog.csdn.net/u011316675/article/details/113750491)\n>\n>    ![image-20231125201620113](https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311252016193.png)\n>\n>    ![image-20231125201628969](https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311252016055.png)\n>\n>    注意description的获取优先级: `description>excerpt>content>config.description\n>\n> 3. 建立单一关键词策略。对于新博客，可以建立单一关键词策略，以增强网站对搜索引擎的权威性。\n>\n> 4. 合理分类栏目。使用目录形式分类栏目，并避免过度分类。对于比较重要的文章的URL，可以使用拼音、英文和分割线等结构。\n>\n> 5. 做好内部链接建设。在新文章中适当增加一些老文章的链接，并确保文章的内部链接自然出现。\n>\n> 6. 外部链接建设。建立其他博客或网站的外部链接，推荐使用工具如http://www.lusongsong.com/tool/seo/。\n>\n> 7. 垃圾留言处理。及时删除垃圾留言，否则可能严重影响排名。\n>\n> 8. Alt标签和图片信息。给每个博文插图添加和文章内容相关的alt信息，并在图片周围添加相关信息。\n>\n> 9. TAG标签使用。通过添加TAG标签可以增强主题的相关性和被搜索的概率。\n>\n> 10. 合理设置标题。文章的Title最好以“文章标题-博客名称”形式出现。\n> 11. 关键词自然出现。在文章标题、正文开头或结尾中自然出现关键词。\n> 12. 文章结尾优化。每篇文章的结尾处可加入“原创文章如转载，请注明出处”“本文首发于XXX网站”等信息，对SEO有一定帮助。\n\n## 生成sitemap.xml\n\n```shell\n#---------------------------\n# 站点地图（sitemap.xml）\n# 安装插件：\n#   -Google：npm install hexo-generator-sitemap --save\n#   -Baidu：npm install hexo-generator-baidu-sitemap --save\n#---------------------------\n\n# sitemap\nsitemap:\n  path: sitemap.xml\nbaidusitemap:\n  path: baidusitemap.xml\n```\n\n## 文件压缩--hexo-all-minifier\n\n> 如果安装的时候出现各种报错都没有在`GitHub`提到的`issues`中找到，仔细看报错内容提示，该重启的时候就重启，该上梯子就上梯子（不行就全局模式），卸载依赖：`npm uninstall hexo-all-minifier`；安装依赖：`npm install hexo-all-minifier --save`，这两个命令反复多来几次，就会忽然发现，安装成功了！！！！最后吐槽一句，被墙真不友好！！！\n\n```shell\n#---------------------------\n# 压缩插件\n# 安装插件：npm install hexo-all-minifier --save\n# 源码地址：https://github.com/chenzhutian/hexo-all-minifier\n#---------------------------\n\n#把以下配置文件添加到 _config.fluid.yml中\n\n#启用all_minifier\nall_minifier: true\n# html压缩\nhtml_minifier:\n  enable: true\n  ignore_error: false\n  exclude:\n\n# css压缩\ncss_minifier:\n  enable: true\n  exclude:\n    - '*.min.css'\n    \n# js压缩\njs_minifier:\n  enable: true\n  mangle: true\n  compress:\n  exclude:\n    - '*.min.js'\njs_concator:\n  enable: false\n  bundle_path: '/js/bundle.js'\n  front: false\n  silent: false\n\n# 图片优化\nimage_minifier:\n  enable: true\n  interlaced: false\n  multipass: false\n  optimizationLevel: 2\n  pngquant: false\n  progressive: false\n```\n\n**再记录、复盘一下这个插件在 GitHub 工作流中的问题！！！盲猜是因为 nodejs 的环境或者 npm 的环境问题**\n\n> 事情缘由：想给文章增加一个在线编辑的`Button`，被工作流文件和这个插件折腾了一天多。\n>\n> 问题所在：本地环境与 GitHub 环境有所不同，相同的依赖上传到GitHub，在hexo generate构建的时候，也就是npm run build的时候，工作流文件会报错。报错如下：\n>\n> ```bash\n> FATAL {\n>   err: Error: spawn /home/runner/work/WL2O2O.github.io/WL2O2O.github.io/node_modules/imagemin-gifsicle/node_modules/gifsicle/vendor/gifsicle ENOENT\n>       at ChildProcess._handle.onexit (node:internal/child_process:284:19)\n>       at onErrorNT (node:internal/child_process:477:16)\n>       at process.processTicksAndRejections (node:internal/process/task_queues:82:21) {\n>     errno: -2,\n>     code: 'ENOENT',\n>     syscall: 'spawn /home/runner/work/WL2O2O.github.io/WL2O2O.github.io/node_modules/imagemin-gifsicle/node_modules/gifsicle/vendor/gifsicle',\n>     path: '/home/runner/work/WL2O2O.github.io/WL2O2O.github.io/node_modules/imagemin-gifsicle/node_modules/gifsicle/vendor/gifsicle',\n>     spawnargs: [ '--no-warnings', '--no-app-extensions' ],\n>     stdout: <Buffer >,\n>     stderr: <Buffer >,\n>     failed: true,\n>     signal: null,\n>     cmd: '/home/runner/work/WL2O2O.github.io/WL2O2O.github.io/node_modules/imagemin-gifsicle/node_modules/gifsicle/vendor/gifsicle --no-warnings --no-app-extensions',\n>     timedOut: false,\n>     killed: false\n>   }\n> } Something's wrong. Maybe you can find the solution here: %s https://hexo.io/docs/troubleshooting.html\n> Error: Process completed with exit code 2.\n> ```\n>\n> 解决方案：\n>\n> 因为本地是完全没有问题的，而且我的依赖是本地直传 GitHub 远仓，于是，直接在`.gitignore`文件中忽略了这个插件涉及到的子插件问题。\n>\n> ```.gitignore\n> node_modules/imagemin-gifsicle/*\n> ```\n>\n> 暂时解决，后续有问题继续更改。\n>\n> 不足之处：\n>\n> 工作流文件中缺少在线构建的语句，因为想要与本地保持一致，暂时选择了直接上传，后续若有问题，再继续改进。工作流文件如下：\n>\n> ```yml\n> # name: Deploy # 工作流名称\n> # on:\n> #   push: # push 事件触发工作流\n> #     branches:\n> #       - hexoBlog # 只有在 hexoBlog 分支推送时触发工作流\n> # jobs:\n> #   build: # job1 id\n> #     runs-on: ubuntu-latest # 运行环境为最新版 Ubuntu\n> #     name: Deploy blog\n> #     steps:\n> #       - name: Checkout # 步骤1：获取源码\n> #         uses: actions/checkout@v2 # 使用 actions/checkout@v2\n> \n> #       - name: Cache node modules # 步骤2：缓存 node_modules\n> #         uses: actions/cache@v2\n> #         with:\n> #           path: node_modules\n> #           key: ${{ runner.os }}-node-${{ hashFiles('**/package-lock.json') }}\n> name: Build and Deploy\n> on: [push]\n> permissions: # 增加写入仓库分支的写权限，否则在最后一步部署时会出错，提示\n>   contents: write\n> jobs:\n>   build-and-deploy:\n>     concurrency: ci-${{ github.ref }} # Recommended if you intend to make multiple deployments in quick succession.\n>     runs-on: ubuntu-latest\n>     steps:\n>       - name: Checkout 🛎️\n>         uses: actions/checkout@v3\n>         \n>       - name: Install Hexo CLI  \n>         run: npm install -g hexo-cli@4.3.0\n>         env:  \n>           CI: false\n> \n>       - name: Install Dependencies # 步骤3：安装依赖\n>         if: steps.cache.outputs.cache-hit != 'true'\n>         run: npm run build\n>         env:\n>           CI: false\n>           \n>       - name: Deploy 🚀 # 步骤4：部署\n>         # uses: JamesIves/github-pages-deploy-action@releases/v3\n>         uses: JamesIves/github-pages-deploy-action@v4\n>         with:\n>           GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n>           BRANCH: master # 部署到 gh-pages 分支\n>           FOLDER: public # 部署 public 文件夹\n> ```\n>\n> [补充部署GitHub pages的一个repository](https://github.com/marketplace/actions/deploy-to-github-pages)\n>\n> 介绍:\n>\n> Automatically deploy your project to [GitHub Pages](https://pages.github.com/) with [GitHub Actions](https://github.com/features/actions). This action can be configured to push your production-ready code into any branch you'd like, including **gh-pages** and **docs**. It can also handle cross repository deployments and works with [GitHub Enterprise](https://github.com/enterprise) too.\n>\n> 官方提供的Action文件：\n>\n> ```yml\n> name: Build and Deploy\n> on: [push]\n> permissions:\n>   contents: write\n> jobs:\n>   build-and-deploy:\n>     concurrency: ci-${{ github.ref }} # Recommended if you intend to make multiple deployments in quick succession.\n>     runs-on: ubuntu-latest\n>     steps:\n>       - name: Checkout 🛎️\n>         uses: actions/checkout@v3\n> \n>       - name: Install and Build 🔧 # This example project is built using npm and outputs the result to the 'build' folder. Replace with the commands required to build your project, or remove this step entirely if your site is pre-built.\n>         run: |\n>           npm ci\n>           npm run build\n> \n>       - name: Deploy 🚀\n>         uses: JamesIves/github-pages-deploy-action@v4\n>         with:\n>           folder: build # The folder the action should deploy.\n> ```\n>\n\n## 文章置顶--hexo-generator-index\n\n```shell\n#---------------------------\n# 文章置顶\n# 安装时间：2023年10月24日\n# 安装插件：npm install hexo-generator-index --save\n# 源码地址：https://github.com/hexojs/hexo-generator-index.git\n#---------------------------\n# 使用方法\nsticky: 100（数值越大，优先级越高）\n```\n\n## 文章链接持久化\n\n```shell\n#---------------------------\n# 解决文章链接会随标题变动而变动，链接永久化插件\n# 安装地址：https://github.com/Rozbo/hexo-abbrlink\n# 安装插件：npm install hexo-abbrlink --save\n#---------------------------\npermalink: posts/:abbrlink.html\n# abbrlink config\nabbrlink:\n  alg: crc32      #support crc16(default) and crc32\n  rep: hex        #support dec(default) and hex\n  drafts: false   #(true)Process draft,(false)Do not process draft. false(default) \n  # Generate categories from directory-tree\n  # depth: the max_depth of directory-tree you want to generate, should > 0\n  auto_category:\n     enable: true  #true(default)\n     depth:        #3(default)\n     over_write: false \n  auto_title: false #enable auto title, it can auto fill the title by path\n  auto_date: false #enable auto date, it can auto fill the date by time today\n  force: false #enable force mode,in this mode, the plugin will ignore the cache, and calc the abbrlink for every post even it already had abbrlink. This only updates abbrlink rather than other front variables.\n```\n\n","slug":"helloHexo","published":1,"updated":"2023-11-26T08:10:38.062Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clpkiczj50021fkfo79ap07jw","content":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">$ hexo new <span class=\"hljs-string\">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure>\n\n<p>merge commend</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">$ hexo cl &amp;&amp; hexo g &amp;&amp; hexo s<br>$ hexo d<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"升级日志\"><a href=\"#升级日志\" class=\"headerlink\" title=\"升级日志\"></a>升级日志</h2><p>2023年11月15日</p>\n<ol>\n<li><p>增加一个GitHub现在编辑button，可直接跳转GitHub远仓，进行修改提交。</p>\n<blockquote>\n<p>为文章页增加了一个 GitHub 在线修改的 button，点击可在线提交到 GitHub<code>hexoBlog分支</code>(源文件)分支，同时触发流水线自动部署到<code>master分支</code>(pages)，所以会存在一种情况：每当我在线修改后，本地仓库文章与远仓不同步，本地写文章的话需要拉取最新更改。</p>\n<ul>\n<li><p>优化方案：是否可以有自动同步本地仓库的工作流</p>\n</li>\n<li><p>解决方案：本地更新文章之前需要先拉取远仓最新更改，否则会提示：</p>\n<p><img src=\"https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311261441104.png\" alt=\"image-20231126144130073\"></p>\n</li>\n</ul>\n</blockquote>\n</li>\n<li><p>修改了layout布局文件夹下面的post.ejs文件，设置文章index_img宽高比为5：3</p>\n<blockquote>\n<pre><code class=\"hljs\">attention: 更改文章页的index_img需要手动更改图片尺寸\n</code></pre>\n</blockquote>\n</li>\n<li><p>设置 GitHub 工作流,当同步源文件到远仓时,会自动部署静态资源到 GitHub Pages.</p>\n<blockquote>\n<p>attention: 因为<code>imagemin-gifsicle</code>插件版本的问题,本地运行时没问题,通过远仓的工作流进行<code>npm install</code>时,有时会安装不上,有时安装好了运行会报错,因此就直接把本地的<code>node_modules</code>直接上传到了GitHub,同时,在GitHub工作流文件中去掉了依赖安装的步骤.</p>\n<ul>\n<li><strong>GitHub工作流代码：</strong></li>\n</ul>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs yml\"><span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">Build</span> <span class=\"hljs-string\">and</span> <span class=\"hljs-string\">Deploy</span>  <br><span class=\"hljs-attr\">on:</span> [<span class=\"hljs-string\">push</span>]  <br><br><span class=\"hljs-attr\">jobs:</span>  <br><span class=\"hljs-attr\">build-and-deploy:</span>  <br><span class=\"hljs-attr\">concurrency:</span> <span class=\"hljs-string\">ci-$&#123;&#123;</span> <span class=\"hljs-string\">github.ref</span> <span class=\"hljs-string\">&#125;&#125;</span> <span class=\"hljs-comment\"># Recommended if you intend to make multiple deployments in quick succession.  </span><br><span class=\"hljs-attr\">runs-on:</span> <span class=\"hljs-string\">ubuntu-latest</span>  <br><span class=\"hljs-attr\">steps:</span>  <br>      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">Checkout</span> <span class=\"hljs-string\">🔔</span>  <br>        <span class=\"hljs-attr\">uses:</span> <span class=\"hljs-string\">actions/checkout@v3</span>  <br><br>      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">Install</span> <span class=\"hljs-string\">Hexo</span> <span class=\"hljs-string\">CLI</span>    <br>        <span class=\"hljs-attr\">run:</span> <span class=\"hljs-string\">npm</span> <span class=\"hljs-string\">install</span> <span class=\"hljs-string\">-g</span> <span class=\"hljs-string\">hexo-cli@4.3.0</span>  <br>        <span class=\"hljs-attr\">env:</span>    <br>          <span class=\"hljs-attr\">CI:</span> <span class=\"hljs-literal\">false</span>  <br><br>      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">Install</span> <span class=\"hljs-string\">Dependencies</span> <span class=\"hljs-comment\"># 步骤3：安装依赖  </span><br>        <span class=\"hljs-attr\">if:</span> <span class=\"hljs-string\">steps.cache.outputs.cache-hit</span> <span class=\"hljs-type\">!=</span> <span class=\"hljs-string\">&#x27;true&#x27;</span>  <br>        <span class=\"hljs-attr\">run:</span> <span class=\"hljs-string\">npm</span> <span class=\"hljs-string\">run</span> <span class=\"hljs-string\">build</span>  <br>        <span class=\"hljs-attr\">env:</span>  <br>          <span class=\"hljs-attr\">CI:</span> <span class=\"hljs-literal\">false</span>  <br><br>      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">Deploy</span> <span class=\"hljs-string\">🚀</span> <span class=\"hljs-comment\"># 步骤4：部署  </span><br>        <span class=\"hljs-comment\"># uses: JamesIves/github-pages-deploy-action@releases/v3  </span><br>        <span class=\"hljs-attr\">uses:</span> <span class=\"hljs-string\">JamesIves/github-pages-deploy-action@v4</span>  <br>        <span class=\"hljs-attr\">with:</span>  <br>          <span class=\"hljs-attr\">GITHUB_TOKEN:</span> <span class=\"hljs-string\">$&#123;&#123;</span> <span class=\"hljs-string\">secrets.GITEE_TOKEN</span> <span class=\"hljs-string\">&#125;&#125;</span> <span class=\"hljs-comment\"># 使用 Gitee 令牌  </span><br>          <span class=\"hljs-attr\">BRANCH:</span> <span class=\"hljs-string\">master</span> <span class=\"hljs-comment\"># 部署到 master 分支  </span><br>          <span class=\"hljs-attr\">FOLDER:</span> <span class=\"hljs-string\">public</span> <span class=\"hljs-comment\"># 部署 public 文件夹</span><br></code></pre></td></tr></table></figure>\n\n<ul>\n<li>有了工作流, 本地更新上传文章就可以通过脚本一键上传了！</li>\n</ul>\n<p><strong>本地仓库拉取远仓最新更改 windows shell 脚本:</strong></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">@echo off<br><br>E:<br><br>cd E:\\CS_GUIDER\\hexo<br><br>echo &quot;Pull the latest code from github...&quot;<br><br>REM 因为Button在线修改是在GitHub远仓修改的，所以这里直接拉取GitHub远仓的更改<br><br>echo &quot;pull source code...&quot;<br><br>git pull origin hexoBlog<br><br>echo &quot;pull source code over!&quot;<br><br>echo &quot;deploy to gitee pages&quot;<br><br>hexo cl &amp;&amp; call hexo g &amp;&amp; hexo d -m &quot;autoDeploy&quot;<br></code></pre></td></tr></table></figure>\n\n<p><strong>本地一键上传远仓 windows shell 脚本:</strong></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">@echo off<br><br>E:<br><br>cd E:\\CS_GUIDER\\hexo<br><br>echo &quot;upload source code to remoteRepo...&quot;<br><br>REM 目前版本中 gitee 远仓的工作流还待更新，所以这里我们任然使用 hexo-cli 脚手架的一键部署命令，这里需要在根目录的 config.yml 文件中进行配置远仓地址，这里因为GitHub工作流文件可以云端部署静态资源，所以我在文件中只配置了 Gitee 的远仓地址。（后续更新 Gitee 工作流之后就可以直接废弃hexo-cli的相关命令啦，但是如果修改了文件地址的话或者标题，可能会出现文章无法访问以及链接失效的问题，所以hexo clean还是需要了解一下的）<br><br>echo &quot;trucking files over&quot;<br><br>echo &quot;commit files&quot;<br><br>git commit -m &quot;feat: auto synchronized.&quot;<br><br>echo &quot;commit over&quot;<br><br>echo &quot;push to github&quot;<br><br>git push origin hexoBlog<br><br>echo &quot;push gitee&quot;<br><br>git push gitee hexoBlog<br><br></code></pre></td></tr></table></figure></blockquote>\n</li>\n</ol>\n<h2 id=\"我的-Hexo-多端部署方案\"><a href=\"#我的-Hexo-多端部署方案\" class=\"headerlink\" title=\"我的 Hexo 多端部署方案\"></a>我的 Hexo 多端部署方案</h2><blockquote>\n<p>由于部署在 GitHub Pages 上，国内访问速度很是拉跨。于是准备托管到 Gitee Pages 上，奈何 Gitee 个人版不支持自定义域名和ssl。</p>\n<p>首先，我认为搭建博客有两个出发点。①是出于沉淀知识的目的，②则是出于沉淀知识的同时分享自己的知识，追求个人流量以及知名度。</p>\n<ul>\n<li><strong>0投资沉淀私域知识（不想花钱，不关心访客量）：</strong><ul>\n<li>首先推荐部署到<code>Gitee Pages</code>静态网页上，不仅提供了 https 链接，而且国内访问速度还是很 OK 的，缺点就是每次更新文章需要手动点击更新。喜欢摸索的可以学习下 CI/CD 持续部署，创建一个工作流文件，当监听到仓库更新时，自动部署到 Pages。</li>\n<li>其次推荐部署到<code>Github Pages</code>静态网页上，但是访问速度堪忧，有时需要魔法才可以正常访问。</li>\n<li><strong>图片加载问题：</strong>在<code>GitHub Pages</code>超级慢，前者还行。解决方案：购买一个云服务商的对象存储，例如华为云OBS、阿里云OSS…，创建一个图床，这样就可以解决图片加载问题了。</li>\n</ul>\n</li>\n<li><strong>出于沉淀知识 + 分享知识，打造个人 IP：</strong><ul>\n<li><strong>前置条件：</strong>域名、备案<ul>\n<li><strong>贫民方案-无服务器部署：</strong>都知道服务器是不便宜的，我曾看到一篇博客，说可以部署到腾讯云的 Coding 平台，这样就可以使用自定义域名了，只需花一个域名的钱，也可以选择完成域名备案。<a href=\"https://blog.csdn.net/qq_29654777/article/details/108222881\">点击前往：文章更新于2020年，可能Coding平台已升级，未验证是否还支持静态网站部署</a></li>\n</ul>\n</li>\n<li><strong>前置条件：</strong>域名、备案 + 对象存储、CDN、服务器<ul>\n<li><strong>金主方案-个人服务器部署：</strong>直接博客上云，推送到云端服务器的 GitHub 仓库–&gt;远仓自定义主页domain–&gt;域名控制台完成解析–&gt;购买个人对象存储图床和 CDN 内容分发–&gt;域名备案–&gt;提交域名到各搜索引擎，例如<a href=\"https://ziyuan.baidu.com/site/index#/\">百度搜索资源平台</a>和<a href=\"https://search.google.com/search-console/welcome\">Google Search Console</a>，同时可以搭配百度统计和Google Analytics 来可视化分析自己博客的访问情况。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong>我的二者兼得方案：</strong><ul>\n<li>待补充！</li>\n<li>百度资源搜索平台如何验证个人站点？谷歌搜索怎么验证个人站点？怎么提高百度收录量？</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<h2 id=\"SEO优化\"><a href=\"#SEO优化\" class=\"headerlink\" title=\"SEO优化\"></a>SEO优化</h2><blockquote>\n<ol>\n<li><p>保持更新并紧扣关键字。经常更新博客，并确保文章内容紧紧围绕关键字展开，同时也要注意保持文章标题和内文的关键词自然出现，不要过度堆砌。</p>\n</li>\n<li><p>优化内容页。SEO优化重点应以文章内容页为主，适当增加关键词(Keyword)、描述(Description)、抓取器(Robots)等标签，并确保每个页面都有唯一的URL。<a href=\"https://blog.csdn.net/u011316675/article/details/113750491\">参考链接</a></p>\n<p><img src=\"https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311252016193.png\" alt=\"image-20231125201620113\"></p>\n<p><img src=\"https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311252016055.png\" alt=\"image-20231125201628969\"></p>\n<p>注意description的获取优先级: `description&gt;excerpt&gt;content&gt;config.description</p>\n</li>\n<li><p>建立单一关键词策略。对于新博客，可以建立单一关键词策略，以增强网站对搜索引擎的权威性。</p>\n</li>\n<li><p>合理分类栏目。使用目录形式分类栏目，并避免过度分类。对于比较重要的文章的URL，可以使用拼音、英文和分割线等结构。</p>\n</li>\n<li><p>做好内部链接建设。在新文章中适当增加一些老文章的链接，并确保文章的内部链接自然出现。</p>\n</li>\n<li><p>外部链接建设。建立其他博客或网站的外部链接，推荐使用工具如<a href=\"http://www.lusongsong.com/tool/seo/%E3%80%82\">http://www.lusongsong.com/tool/seo/。</a></p>\n</li>\n<li><p>垃圾留言处理。及时删除垃圾留言，否则可能严重影响排名。</p>\n</li>\n<li><p>Alt标签和图片信息。给每个博文插图添加和文章内容相关的alt信息，并在图片周围添加相关信息。</p>\n</li>\n<li><p>TAG标签使用。通过添加TAG标签可以增强主题的相关性和被搜索的概率。</p>\n</li>\n<li><p>合理设置标题。文章的Title最好以“文章标题-博客名称”形式出现。</p>\n</li>\n<li><p>关键词自然出现。在文章标题、正文开头或结尾中自然出现关键词。</p>\n</li>\n<li><p>文章结尾优化。每篇文章的结尾处可加入“原创文章如转载，请注明出处”“本文首发于XXX网站”等信息，对SEO有一定帮助。</p>\n</li>\n</ol>\n</blockquote>\n<h2 id=\"生成sitemap-xml\"><a href=\"#生成sitemap-xml\" class=\"headerlink\" title=\"生成sitemap.xml\"></a>生成sitemap.xml</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\"><span class=\"hljs-meta prompt_\">#</span><span class=\"language-bash\">---------------------------</span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">站点地图（sitemap.xml）</span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">安装插件：</span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">  -Google：npm install hexo-generator-sitemap --save</span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">  -Baidu：npm install hexo-generator-baidu-sitemap --save</span><br><span class=\"hljs-meta prompt_\">#</span><span class=\"language-bash\">---------------------------</span><br><span class=\"hljs-meta prompt_\"></span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">sitemap</span><br>sitemap:<br>  path: sitemap.xml<br>baidusitemap:<br>  path: baidusitemap.xml<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"文件压缩–hexo-all-minifier\"><a href=\"#文件压缩–hexo-all-minifier\" class=\"headerlink\" title=\"文件压缩–hexo-all-minifier\"></a>文件压缩–hexo-all-minifier</h2><blockquote>\n<p>如果安装的时候出现各种报错都没有在<code>GitHub</code>提到的<code>issues</code>中找到，仔细看报错内容提示，该重启的时候就重启，该上梯子就上梯子（不行就全局模式），卸载依赖：<code>npm uninstall hexo-all-minifier</code>；安装依赖：<code>npm install hexo-all-minifier --save</code>，这两个命令反复多来几次，就会忽然发现，安装成功了！！！！最后吐槽一句，被墙真不友好！！！</p>\n</blockquote>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\"><span class=\"hljs-meta prompt_\">#</span><span class=\"language-bash\">---------------------------</span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">压缩插件</span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">安装插件：npm install hexo-all-minifier --save</span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">源码地址：https://github.com/chenzhutian/hexo-all-minifier</span><br><span class=\"hljs-meta prompt_\">#</span><span class=\"language-bash\">---------------------------</span><br><span class=\"hljs-meta prompt_\"></span><br><span class=\"hljs-meta prompt_\">#</span><span class=\"language-bash\">把以下配置文件添加到 _config.fluid.yml中</span><br><span class=\"hljs-meta prompt_\"></span><br><span class=\"hljs-meta prompt_\">#</span><span class=\"language-bash\">启用all_minifier</span><br>all_minifier: true<br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">html压缩</span><br>html_minifier:<br>  enable: true<br>  ignore_error: false<br>  exclude:<br><span class=\"hljs-meta prompt_\"></span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">css压缩</span><br>css_minifier:<br>  enable: true<br>  exclude:<br>    - &#x27;*.min.css&#x27;<br>    <br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">js压缩</span><br>js_minifier:<br>  enable: true<br>  mangle: true<br>  compress:<br>  exclude:<br>    - &#x27;*.min.js&#x27;<br>js_concator:<br>  enable: false<br>  bundle_path: &#x27;/js/bundle.js&#x27;<br>  front: false<br>  silent: false<br><span class=\"hljs-meta prompt_\"></span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">图片优化</span><br>image_minifier:<br>  enable: true<br>  interlaced: false<br>  multipass: false<br>  optimizationLevel: 2<br>  pngquant: false<br>  progressive: false<br></code></pre></td></tr></table></figure>\n\n<p><strong>再记录、复盘一下这个插件在 GitHub 工作流中的问题！！！盲猜是因为 nodejs 的环境或者 npm 的环境问题</strong></p>\n<blockquote>\n<p>事情缘由：想给文章增加一个在线编辑的<code>Button</code>，被工作流文件和这个插件折腾了一天多。</p>\n<p>问题所在：本地环境与 GitHub 环境有所不同，相同的依赖上传到GitHub，在hexo generate构建的时候，也就是npm run build的时候，工作流文件会报错。报错如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">FATAL &#123;<br>  err: Error: spawn /home/runner/work/WL2O2O.github.io/WL2O2O.github.io/node_modules/imagemin-gifsicle/node_modules/gifsicle/vendor/gifsicle ENOENT<br>      at ChildProcess._handle.onexit (node:internal/child_process:284:19)<br>      at onErrorNT (node:internal/child_process:477:16)<br>      at process.processTicksAndRejections (node:internal/process/task_queues:82:21) &#123;<br>    errno: -2,<br>    code: <span class=\"hljs-string\">&#x27;ENOENT&#x27;</span>,<br>    syscall: <span class=\"hljs-string\">&#x27;spawn /home/runner/work/WL2O2O.github.io/WL2O2O.github.io/node_modules/imagemin-gifsicle/node_modules/gifsicle/vendor/gifsicle&#x27;</span>,<br>    path: <span class=\"hljs-string\">&#x27;/home/runner/work/WL2O2O.github.io/WL2O2O.github.io/node_modules/imagemin-gifsicle/node_modules/gifsicle/vendor/gifsicle&#x27;</span>,<br>    spawnargs: [ <span class=\"hljs-string\">&#x27;--no-warnings&#x27;</span>, <span class=\"hljs-string\">&#x27;--no-app-extensions&#x27;</span> ],<br>    stdout: &lt;Buffer &gt;,<br>    stderr: &lt;Buffer &gt;,<br>    failed: <span class=\"hljs-literal\">true</span>,<br>    signal: null,<br>    cmd: <span class=\"hljs-string\">&#x27;/home/runner/work/WL2O2O.github.io/WL2O2O.github.io/node_modules/imagemin-gifsicle/node_modules/gifsicle/vendor/gifsicle --no-warnings --no-app-extensions&#x27;</span>,<br>    timedOut: <span class=\"hljs-literal\">false</span>,<br>    killed: <span class=\"hljs-literal\">false</span><br>  &#125;<br>&#125; Something<span class=\"hljs-string\">&#x27;s wrong. Maybe you can find the solution here: %s https://hexo.io/docs/troubleshooting.html</span><br><span class=\"hljs-string\">Error: Process completed with exit code 2.</span><br></code></pre></td></tr></table></figure>\n\n<p>解决方案：</p>\n<p>因为本地是完全没有问题的，而且我的依赖是本地直传 GitHub 远仓，于是，直接在<code>.gitignore</code>文件中忽略了这个插件涉及到的子插件问题。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs .gitignore\">node_modules/imagemin-gifsicle/*<br></code></pre></td></tr></table></figure>\n\n<p>暂时解决，后续有问题继续更改。</p>\n<p>不足之处：</p>\n<p>工作流文件中缺少在线构建的语句，因为想要与本地保持一致，暂时选择了直接上传，后续若有问题，再继续改进。工作流文件如下：</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs yml\"><span class=\"hljs-comment\"># name: Deploy # 工作流名称</span><br><span class=\"hljs-comment\"># on:</span><br><span class=\"hljs-comment\">#   push: # push 事件触发工作流</span><br><span class=\"hljs-comment\">#     branches:</span><br><span class=\"hljs-comment\">#       - hexoBlog # 只有在 hexoBlog 分支推送时触发工作流</span><br><span class=\"hljs-comment\"># jobs:</span><br><span class=\"hljs-comment\">#   build: # job1 id</span><br><span class=\"hljs-comment\">#     runs-on: ubuntu-latest # 运行环境为最新版 Ubuntu</span><br><span class=\"hljs-comment\">#     name: Deploy blog</span><br><span class=\"hljs-comment\">#     steps:</span><br><span class=\"hljs-comment\">#       - name: Checkout # 步骤1：获取源码</span><br><span class=\"hljs-comment\">#         uses: actions/checkout@v2 # 使用 actions/checkout@v2</span><br><br><span class=\"hljs-comment\">#       - name: Cache node modules # 步骤2：缓存 node_modules</span><br><span class=\"hljs-comment\">#         uses: actions/cache@v2</span><br><span class=\"hljs-comment\">#         with:</span><br><span class=\"hljs-comment\">#           path: node_modules</span><br><span class=\"hljs-comment\">#           key: $&#123;&#123; runner.os &#125;&#125;-node-$&#123;&#123; hashFiles(&#x27;**/package-lock.json&#x27;) &#125;&#125;</span><br><span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">Build</span> <span class=\"hljs-string\">and</span> <span class=\"hljs-string\">Deploy</span><br><span class=\"hljs-attr\">on:</span> [<span class=\"hljs-string\">push</span>]<br><span class=\"hljs-attr\">permissions:</span> <span class=\"hljs-comment\"># 增加写入仓库分支的写权限，否则在最后一步部署时会出错，提示</span><br>  <span class=\"hljs-attr\">contents:</span> <span class=\"hljs-string\">write</span><br><span class=\"hljs-attr\">jobs:</span><br>  <span class=\"hljs-attr\">build-and-deploy:</span><br>    <span class=\"hljs-attr\">concurrency:</span> <span class=\"hljs-string\">ci-$&#123;&#123;</span> <span class=\"hljs-string\">github.ref</span> <span class=\"hljs-string\">&#125;&#125;</span> <span class=\"hljs-comment\"># Recommended if you intend to make multiple deployments in quick succession.</span><br>    <span class=\"hljs-attr\">runs-on:</span> <span class=\"hljs-string\">ubuntu-latest</span><br>    <span class=\"hljs-attr\">steps:</span><br>      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">Checkout</span> <span class=\"hljs-string\">🛎️</span><br>        <span class=\"hljs-attr\">uses:</span> <span class=\"hljs-string\">actions/checkout@v3</span><br>        <br>      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">Install</span> <span class=\"hljs-string\">Hexo</span> <span class=\"hljs-string\">CLI</span>  <br>        <span class=\"hljs-attr\">run:</span> <span class=\"hljs-string\">npm</span> <span class=\"hljs-string\">install</span> <span class=\"hljs-string\">-g</span> <span class=\"hljs-string\">hexo-cli@4.3.0</span><br>        <span class=\"hljs-attr\">env:</span>  <br>          <span class=\"hljs-attr\">CI:</span> <span class=\"hljs-literal\">false</span><br><br>      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">Install</span> <span class=\"hljs-string\">Dependencies</span> <span class=\"hljs-comment\"># 步骤3：安装依赖</span><br>        <span class=\"hljs-attr\">if:</span> <span class=\"hljs-string\">steps.cache.outputs.cache-hit</span> <span class=\"hljs-type\">!=</span> <span class=\"hljs-string\">&#x27;true&#x27;</span><br>        <span class=\"hljs-attr\">run:</span> <span class=\"hljs-string\">npm</span> <span class=\"hljs-string\">run</span> <span class=\"hljs-string\">build</span><br>        <span class=\"hljs-attr\">env:</span><br>          <span class=\"hljs-attr\">CI:</span> <span class=\"hljs-literal\">false</span><br>          <br>      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">Deploy</span> <span class=\"hljs-string\">🚀</span> <span class=\"hljs-comment\"># 步骤4：部署</span><br>        <span class=\"hljs-comment\"># uses: JamesIves/github-pages-deploy-action@releases/v3</span><br>        <span class=\"hljs-attr\">uses:</span> <span class=\"hljs-string\">JamesIves/github-pages-deploy-action@v4</span><br>        <span class=\"hljs-attr\">with:</span><br>          <span class=\"hljs-attr\">GITHUB_TOKEN:</span> <span class=\"hljs-string\">$&#123;&#123;</span> <span class=\"hljs-string\">secrets.GITHUB_TOKEN</span> <span class=\"hljs-string\">&#125;&#125;</span><br>          <span class=\"hljs-attr\">BRANCH:</span> <span class=\"hljs-string\">master</span> <span class=\"hljs-comment\"># 部署到 gh-pages 分支</span><br>          <span class=\"hljs-attr\">FOLDER:</span> <span class=\"hljs-string\">public</span> <span class=\"hljs-comment\"># 部署 public 文件夹</span><br></code></pre></td></tr></table></figure>\n\n<p><a href=\"https://github.com/marketplace/actions/deploy-to-github-pages\">补充部署GitHub pages的一个repository</a></p>\n<p>介绍:</p>\n<p>Automatically deploy your project to <a href=\"https://pages.github.com/\">GitHub Pages</a> with <a href=\"https://github.com/features/actions\">GitHub Actions</a>. This action can be configured to push your production-ready code into any branch you’d like, including <strong>gh-pages</strong> and <strong>docs</strong>. It can also handle cross repository deployments and works with <a href=\"https://github.com/enterprise\">GitHub Enterprise</a> too.</p>\n<p>官方提供的Action文件：</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs yml\"><span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">Build</span> <span class=\"hljs-string\">and</span> <span class=\"hljs-string\">Deploy</span><br><span class=\"hljs-attr\">on:</span> [<span class=\"hljs-string\">push</span>]<br><span class=\"hljs-attr\">permissions:</span><br>  <span class=\"hljs-attr\">contents:</span> <span class=\"hljs-string\">write</span><br><span class=\"hljs-attr\">jobs:</span><br>  <span class=\"hljs-attr\">build-and-deploy:</span><br>    <span class=\"hljs-attr\">concurrency:</span> <span class=\"hljs-string\">ci-$&#123;&#123;</span> <span class=\"hljs-string\">github.ref</span> <span class=\"hljs-string\">&#125;&#125;</span> <span class=\"hljs-comment\"># Recommended if you intend to make multiple deployments in quick succession.</span><br>    <span class=\"hljs-attr\">runs-on:</span> <span class=\"hljs-string\">ubuntu-latest</span><br>    <span class=\"hljs-attr\">steps:</span><br>      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">Checkout</span> <span class=\"hljs-string\">🛎️</span><br>        <span class=\"hljs-attr\">uses:</span> <span class=\"hljs-string\">actions/checkout@v3</span><br><br>      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">Install</span> <span class=\"hljs-string\">and</span> <span class=\"hljs-string\">Build</span> <span class=\"hljs-string\">🔧</span> <span class=\"hljs-comment\"># This example project is built using npm and outputs the result to the &#x27;build&#x27; folder. Replace with the commands required to build your project, or remove this step entirely if your site is pre-built.</span><br>        <span class=\"hljs-attr\">run:</span> <span class=\"hljs-string\">|</span><br><span class=\"hljs-string\">          npm ci</span><br><span class=\"hljs-string\">          npm run build</span><br><span class=\"hljs-string\"></span><br>      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">Deploy</span> <span class=\"hljs-string\">🚀</span><br>        <span class=\"hljs-attr\">uses:</span> <span class=\"hljs-string\">JamesIves/github-pages-deploy-action@v4</span><br>        <span class=\"hljs-attr\">with:</span><br>          <span class=\"hljs-attr\">folder:</span> <span class=\"hljs-string\">build</span> <span class=\"hljs-comment\"># The folder the action should deploy.</span><br></code></pre></td></tr></table></figure>\n\n</blockquote>\n<h2 id=\"文章置顶–hexo-generator-index\"><a href=\"#文章置顶–hexo-generator-index\" class=\"headerlink\" title=\"文章置顶–hexo-generator-index\"></a>文章置顶–hexo-generator-index</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\"><span class=\"hljs-meta prompt_\">#</span><span class=\"language-bash\">---------------------------</span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">文章置顶</span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">安装时间：2023年10月24日</span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">安装插件：npm install hexo-generator-index --save</span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">源码地址：https://github.com/hexojs/hexo-generator-index.git</span><br><span class=\"hljs-meta prompt_\">#</span><span class=\"language-bash\">---------------------------</span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">使用方法</span><br>sticky: 100（数值越大，优先级越高）<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"文章链接持久化\"><a href=\"#文章链接持久化\" class=\"headerlink\" title=\"文章链接持久化\"></a>文章链接持久化</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\"><span class=\"hljs-meta prompt_\">#</span><span class=\"language-bash\">---------------------------</span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">解决文章链接会随标题变动而变动，链接永久化插件</span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">安装地址：https://github.com/Rozbo/hexo-abbrlink</span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">安装插件：npm install hexo-abbrlink --save</span><br><span class=\"hljs-meta prompt_\">#</span><span class=\"language-bash\">---------------------------</span><br>permalink: posts/:abbrlink.html<br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">abbrlink config</span><br>abbrlink:<br>  alg: crc32      #support crc16(default) and crc32<br>  rep: hex        #support dec(default) and hex<br>  drafts: false   #(true)Process draft,(false)Do not process draft. false(default) <br><span class=\"hljs-meta prompt_\">  # </span><span class=\"language-bash\">Generate categories from directory-tree</span><br><span class=\"hljs-meta prompt_\">  # </span><span class=\"language-bash\">depth: the max_depth of directory-tree you want to generate, should &gt; 0</span><br>  auto_category:<br>     enable: true  #true(default)<br>     depth:        #3(default)<br>     over_write: false <br>  auto_title: false #enable auto title, it can auto fill the title by path<br>  auto_date: false #enable auto date, it can auto fill the date by time today<br>  force: false #enable force mode,in this mode, the plugin will ignore the cache, and calc the abbrlink for every post even it already had abbrlink. This only updates abbrlink rather than other front variables.<br></code></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">$ hexo new <span class=\"hljs-string\">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure>\n\n<p>merge commend</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">$ hexo cl &amp;&amp; hexo g &amp;&amp; hexo s<br>$ hexo d<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"升级日志\"><a href=\"#升级日志\" class=\"headerlink\" title=\"升级日志\"></a>升级日志</h2><p>2023年11月15日</p>\n<ol>\n<li><p>增加一个GitHub现在编辑button，可直接跳转GitHub远仓，进行修改提交。</p>\n<blockquote>\n<p>为文章页增加了一个 GitHub 在线修改的 button，点击可在线提交到 GitHub<code>hexoBlog分支</code>(源文件)分支，同时触发流水线自动部署到<code>master分支</code>(pages)，所以会存在一种情况：每当我在线修改后，本地仓库文章与远仓不同步，本地写文章的话需要拉取最新更改。</p>\n<ul>\n<li><p>优化方案：是否可以有自动同步本地仓库的工作流</p>\n</li>\n<li><p>解决方案：本地更新文章之前需要先拉取远仓最新更改，否则会提示：</p>\n<p><img src=\"https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311261441104.png\" alt=\"image-20231126144130073\"></p>\n</li>\n</ul>\n</blockquote>\n</li>\n<li><p>修改了layout布局文件夹下面的post.ejs文件，设置文章index_img宽高比为5：3</p>\n<blockquote>\n<pre><code>attention: 更改文章页的index_img需要手动更改图片尺寸\n</code></pre>\n</blockquote>\n</li>\n<li><p>设置 GitHub 工作流,当同步源文件到远仓时,会自动部署静态资源到 GitHub Pages.</p>\n<blockquote>\n<p>attention: 因为<code>imagemin-gifsicle</code>插件版本的问题,本地运行时没问题,通过远仓的工作流进行<code>npm install</code>时,有时会安装不上,有时安装好了运行会报错,因此就直接把本地的<code>node_modules</code>直接上传到了GitHub,同时,在GitHub工作流文件中去掉了依赖安装的步骤.</p>\n<ul>\n<li><strong>GitHub工作流代码：</strong></li>\n</ul>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs yml\"><span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">Build</span> <span class=\"hljs-string\">and</span> <span class=\"hljs-string\">Deploy</span>  <br><span class=\"hljs-attr\">on:</span> [<span class=\"hljs-string\">push</span>]  <br><br><span class=\"hljs-attr\">jobs:</span>  <br><span class=\"hljs-attr\">build-and-deploy:</span>  <br><span class=\"hljs-attr\">concurrency:</span> <span class=\"hljs-string\">ci-$&#123;&#123;</span> <span class=\"hljs-string\">github.ref</span> <span class=\"hljs-string\">&#125;&#125;</span> <span class=\"hljs-comment\"># Recommended if you intend to make multiple deployments in quick succession.  </span><br><span class=\"hljs-attr\">runs-on:</span> <span class=\"hljs-string\">ubuntu-latest</span>  <br><span class=\"hljs-attr\">steps:</span>  <br>      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">Checkout</span> <span class=\"hljs-string\">🔔</span>  <br>        <span class=\"hljs-attr\">uses:</span> <span class=\"hljs-string\">actions/checkout@v3</span>  <br><br>      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">Install</span> <span class=\"hljs-string\">Hexo</span> <span class=\"hljs-string\">CLI</span>    <br>        <span class=\"hljs-attr\">run:</span> <span class=\"hljs-string\">npm</span> <span class=\"hljs-string\">install</span> <span class=\"hljs-string\">-g</span> <span class=\"hljs-string\">hexo-cli@4.3.0</span>  <br>        <span class=\"hljs-attr\">env:</span>    <br>          <span class=\"hljs-attr\">CI:</span> <span class=\"hljs-literal\">false</span>  <br><br>      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">Install</span> <span class=\"hljs-string\">Dependencies</span> <span class=\"hljs-comment\"># 步骤3：安装依赖  </span><br>        <span class=\"hljs-attr\">if:</span> <span class=\"hljs-string\">steps.cache.outputs.cache-hit</span> <span class=\"hljs-type\">!=</span> <span class=\"hljs-string\">&#x27;true&#x27;</span>  <br>        <span class=\"hljs-attr\">run:</span> <span class=\"hljs-string\">npm</span> <span class=\"hljs-string\">run</span> <span class=\"hljs-string\">build</span>  <br>        <span class=\"hljs-attr\">env:</span>  <br>          <span class=\"hljs-attr\">CI:</span> <span class=\"hljs-literal\">false</span>  <br><br>      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">Deploy</span> <span class=\"hljs-string\">🚀</span> <span class=\"hljs-comment\"># 步骤4：部署  </span><br>        <span class=\"hljs-comment\"># uses: JamesIves/github-pages-deploy-action@releases/v3  </span><br>        <span class=\"hljs-attr\">uses:</span> <span class=\"hljs-string\">JamesIves/github-pages-deploy-action@v4</span>  <br>        <span class=\"hljs-attr\">with:</span>  <br>          <span class=\"hljs-attr\">GITHUB_TOKEN:</span> <span class=\"hljs-string\">$&#123;&#123;</span> <span class=\"hljs-string\">secrets.GITEE_TOKEN</span> <span class=\"hljs-string\">&#125;&#125;</span> <span class=\"hljs-comment\"># 使用 Gitee 令牌  </span><br>          <span class=\"hljs-attr\">BRANCH:</span> <span class=\"hljs-string\">master</span> <span class=\"hljs-comment\"># 部署到 master 分支  </span><br>          <span class=\"hljs-attr\">FOLDER:</span> <span class=\"hljs-string\">public</span> <span class=\"hljs-comment\"># 部署 public 文件夹</span><br></code></pre></td></tr></table></figure>\n\n<ul>\n<li>有了工作流, 本地更新上传文章就可以通过脚本一键上传了！</li>\n</ul>\n<p><strong>本地仓库拉取远仓最新更改 windows shell 脚本:</strong></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">@echo off<br><br>E:<br><br>cd E:\\CS_GUIDER\\hexo<br><br>echo &quot;Pull the latest code from github...&quot;<br><br>REM 因为Button在线修改是在GitHub远仓修改的，所以这里直接拉取GitHub远仓的更改<br><br>echo &quot;pull source code...&quot;<br><br>git pull origin hexoBlog<br><br>echo &quot;pull source code over!&quot;<br><br>echo &quot;deploy to gitee pages&quot;<br><br>hexo cl &amp;&amp; call hexo g &amp;&amp; hexo d -m &quot;autoDeploy&quot;<br></code></pre></td></tr></table></figure>\n\n<p><strong>本地一键上传远仓 windows shell 脚本:</strong></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">@echo off<br><br>E:<br><br>cd E:\\CS_GUIDER\\hexo<br><br>echo &quot;upload source code to remoteRepo...&quot;<br><br>REM 目前版本中 gitee 远仓的工作流还待更新，所以这里我们任然使用 hexo-cli 脚手架的一键部署命令，这里需要在根目录的 config.yml 文件中进行配置远仓地址，这里因为GitHub工作流文件可以云端部署静态资源，所以我在文件中只配置了 Gitee 的远仓地址。（后续更新 Gitee 工作流之后就可以直接废弃hexo-cli的相关命令啦，但是如果修改了文件地址的话或者标题，可能会出现文章无法访问以及链接失效的问题，所以hexo clean还是需要了解一下的）<br><br>echo &quot;trucking files over&quot;<br><br>echo &quot;commit files&quot;<br><br>git commit -m &quot;feat: auto synchronized.&quot;<br><br>echo &quot;commit over&quot;<br><br>echo &quot;push to github&quot;<br><br>git push origin hexoBlog<br><br>echo &quot;push gitee&quot;<br><br>git push gitee hexoBlog<br><br></code></pre></td></tr></table></figure></blockquote>\n</li>\n</ol>\n<h2 id=\"我的-Hexo-多端部署方案\"><a href=\"#我的-Hexo-多端部署方案\" class=\"headerlink\" title=\"我的 Hexo 多端部署方案\"></a>我的 Hexo 多端部署方案</h2><blockquote>\n<p>由于部署在 GitHub Pages 上，国内访问速度很是拉跨。于是准备托管到 Gitee Pages 上，奈何 Gitee 个人版不支持自定义域名和ssl。</p>\n<p>首先，我认为搭建博客有两个出发点。①是出于沉淀知识的目的，②则是出于沉淀知识的同时分享自己的知识，追求个人流量以及知名度。</p>\n<ul>\n<li><strong>0投资沉淀私域知识（不想花钱，不关心访客量）：</strong><ul>\n<li>首先推荐部署到<code>Gitee Pages</code>静态网页上，不仅提供了 https 链接，而且国内访问速度还是很 OK 的，缺点就是每次更新文章需要手动点击更新。喜欢摸索的可以学习下 CI/CD 持续部署，创建一个工作流文件，当监听到仓库更新时，自动部署到 Pages。</li>\n<li>其次推荐部署到<code>Github Pages</code>静态网页上，但是访问速度堪忧，有时需要魔法才可以正常访问。</li>\n<li><strong>图片加载问题：</strong>在<code>GitHub Pages</code>超级慢，前者还行。解决方案：购买一个云服务商的对象存储，例如华为云OBS、阿里云OSS…，创建一个图床，这样就可以解决图片加载问题了。</li>\n</ul>\n</li>\n<li><strong>出于沉淀知识 + 分享知识，打造个人 IP：</strong><ul>\n<li><strong>前置条件：</strong>域名、备案<ul>\n<li><strong>贫民方案-无服务器部署：</strong>都知道服务器是不便宜的，我曾看到一篇博客，说可以部署到腾讯云的 Coding 平台，这样就可以使用自定义域名了，只需花一个域名的钱，也可以选择完成域名备案。<a href=\"https://blog.csdn.net/qq_29654777/article/details/108222881\">点击前往：文章更新于2020年，可能Coding平台已升级，未验证是否还支持静态网站部署</a></li>\n</ul>\n</li>\n<li><strong>前置条件：</strong>域名、备案 + 对象存储、CDN、服务器<ul>\n<li><strong>金主方案-个人服务器部署：</strong>直接博客上云，推送到云端服务器的 GitHub 仓库–&gt;远仓自定义主页domain–&gt;域名控制台完成解析–&gt;购买个人对象存储图床和 CDN 内容分发–&gt;域名备案–&gt;提交域名到各搜索引擎，例如<a href=\"https://ziyuan.baidu.com/site/index#/\">百度搜索资源平台</a>和<a href=\"https://search.google.com/search-console/welcome\">Google Search Console</a>，同时可以搭配百度统计和Google Analytics 来可视化分析自己博客的访问情况。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong>我的二者兼得方案：</strong><ul>\n<li>待补充！</li>\n<li>百度资源搜索平台如何验证个人站点？谷歌搜索怎么验证个人站点？怎么提高百度收录量？</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<h2 id=\"SEO优化\"><a href=\"#SEO优化\" class=\"headerlink\" title=\"SEO优化\"></a>SEO优化</h2><blockquote>\n<ol>\n<li><p>保持更新并紧扣关键字。经常更新博客，并确保文章内容紧紧围绕关键字展开，同时也要注意保持文章标题和内文的关键词自然出现，不要过度堆砌。</p>\n</li>\n<li><p>优化内容页。SEO优化重点应以文章内容页为主，适当增加关键词(Keyword)、描述(Description)、抓取器(Robots)等标签，并确保每个页面都有唯一的URL。<a href=\"https://blog.csdn.net/u011316675/article/details/113750491\">参考链接</a></p>\n<p><img src=\"https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311252016193.png\" alt=\"image-20231125201620113\"></p>\n<p><img src=\"https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311252016055.png\" alt=\"image-20231125201628969\"></p>\n<p>注意description的获取优先级: `description&gt;excerpt&gt;content&gt;config.description</p>\n</li>\n<li><p>建立单一关键词策略。对于新博客，可以建立单一关键词策略，以增强网站对搜索引擎的权威性。</p>\n</li>\n<li><p>合理分类栏目。使用目录形式分类栏目，并避免过度分类。对于比较重要的文章的URL，可以使用拼音、英文和分割线等结构。</p>\n</li>\n<li><p>做好内部链接建设。在新文章中适当增加一些老文章的链接，并确保文章的内部链接自然出现。</p>\n</li>\n<li><p>外部链接建设。建立其他博客或网站的外部链接，推荐使用工具如<a href=\"http://www.lusongsong.com/tool/seo/%E3%80%82\">http://www.lusongsong.com/tool/seo/。</a></p>\n</li>\n<li><p>垃圾留言处理。及时删除垃圾留言，否则可能严重影响排名。</p>\n</li>\n<li><p>Alt标签和图片信息。给每个博文插图添加和文章内容相关的alt信息，并在图片周围添加相关信息。</p>\n</li>\n<li><p>TAG标签使用。通过添加TAG标签可以增强主题的相关性和被搜索的概率。</p>\n</li>\n<li><p>合理设置标题。文章的Title最好以“文章标题-博客名称”形式出现。</p>\n</li>\n<li><p>关键词自然出现。在文章标题、正文开头或结尾中自然出现关键词。</p>\n</li>\n<li><p>文章结尾优化。每篇文章的结尾处可加入“原创文章如转载，请注明出处”“本文首发于XXX网站”等信息，对SEO有一定帮助。</p>\n</li>\n</ol>\n</blockquote>\n<h2 id=\"生成sitemap-xml\"><a href=\"#生成sitemap-xml\" class=\"headerlink\" title=\"生成sitemap.xml\"></a>生成sitemap.xml</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\"><span class=\"hljs-meta prompt_\">#</span><span class=\"language-bash\">---------------------------</span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">站点地图（sitemap.xml）</span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">安装插件：</span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">  -Google：npm install hexo-generator-sitemap --save</span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">  -Baidu：npm install hexo-generator-baidu-sitemap --save</span><br><span class=\"hljs-meta prompt_\">#</span><span class=\"language-bash\">---------------------------</span><br><span class=\"hljs-meta prompt_\"></span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">sitemap</span><br>sitemap:<br>  path: sitemap.xml<br>baidusitemap:<br>  path: baidusitemap.xml<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"文件压缩–hexo-all-minifier\"><a href=\"#文件压缩–hexo-all-minifier\" class=\"headerlink\" title=\"文件压缩–hexo-all-minifier\"></a>文件压缩–hexo-all-minifier</h2><blockquote>\n<p>如果安装的时候出现各种报错都没有在<code>GitHub</code>提到的<code>issues</code>中找到，仔细看报错内容提示，该重启的时候就重启，该上梯子就上梯子（不行就全局模式），卸载依赖：<code>npm uninstall hexo-all-minifier</code>；安装依赖：<code>npm install hexo-all-minifier --save</code>，这两个命令反复多来几次，就会忽然发现，安装成功了！！！！最后吐槽一句，被墙真不友好！！！</p>\n</blockquote>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\"><span class=\"hljs-meta prompt_\">#</span><span class=\"language-bash\">---------------------------</span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">压缩插件</span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">安装插件：npm install hexo-all-minifier --save</span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">源码地址：https://github.com/chenzhutian/hexo-all-minifier</span><br><span class=\"hljs-meta prompt_\">#</span><span class=\"language-bash\">---------------------------</span><br><span class=\"hljs-meta prompt_\"></span><br><span class=\"hljs-meta prompt_\">#</span><span class=\"language-bash\">把以下配置文件添加到 _config.fluid.yml中</span><br><span class=\"hljs-meta prompt_\"></span><br><span class=\"hljs-meta prompt_\">#</span><span class=\"language-bash\">启用all_minifier</span><br>all_minifier: true<br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">html压缩</span><br>html_minifier:<br>  enable: true<br>  ignore_error: false<br>  exclude:<br><span class=\"hljs-meta prompt_\"></span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">css压缩</span><br>css_minifier:<br>  enable: true<br>  exclude:<br>    - &#x27;*.min.css&#x27;<br>    <br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">js压缩</span><br>js_minifier:<br>  enable: true<br>  mangle: true<br>  compress:<br>  exclude:<br>    - &#x27;*.min.js&#x27;<br>js_concator:<br>  enable: false<br>  bundle_path: &#x27;/js/bundle.js&#x27;<br>  front: false<br>  silent: false<br><span class=\"hljs-meta prompt_\"></span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">图片优化</span><br>image_minifier:<br>  enable: true<br>  interlaced: false<br>  multipass: false<br>  optimizationLevel: 2<br>  pngquant: false<br>  progressive: false<br></code></pre></td></tr></table></figure>\n\n<p><strong>再记录、复盘一下这个插件在 GitHub 工作流中的问题！！！盲猜是因为 nodejs 的环境或者 npm 的环境问题</strong></p>\n<blockquote>\n<p>事情缘由：想给文章增加一个在线编辑的<code>Button</code>，被工作流文件和这个插件折腾了一天多。</p>\n<p>问题所在：本地环境与 GitHub 环境有所不同，相同的依赖上传到GitHub，在hexo generate构建的时候，也就是npm run build的时候，工作流文件会报错。报错如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">FATAL &#123;<br>  err: Error: spawn /home/runner/work/WL2O2O.github.io/WL2O2O.github.io/node_modules/imagemin-gifsicle/node_modules/gifsicle/vendor/gifsicle ENOENT<br>      at ChildProcess._handle.onexit (node:internal/child_process:284:19)<br>      at onErrorNT (node:internal/child_process:477:16)<br>      at process.processTicksAndRejections (node:internal/process/task_queues:82:21) &#123;<br>    errno: -2,<br>    code: <span class=\"hljs-string\">&#x27;ENOENT&#x27;</span>,<br>    syscall: <span class=\"hljs-string\">&#x27;spawn /home/runner/work/WL2O2O.github.io/WL2O2O.github.io/node_modules/imagemin-gifsicle/node_modules/gifsicle/vendor/gifsicle&#x27;</span>,<br>    path: <span class=\"hljs-string\">&#x27;/home/runner/work/WL2O2O.github.io/WL2O2O.github.io/node_modules/imagemin-gifsicle/node_modules/gifsicle/vendor/gifsicle&#x27;</span>,<br>    spawnargs: [ <span class=\"hljs-string\">&#x27;--no-warnings&#x27;</span>, <span class=\"hljs-string\">&#x27;--no-app-extensions&#x27;</span> ],<br>    stdout: &lt;Buffer &gt;,<br>    stderr: &lt;Buffer &gt;,<br>    failed: <span class=\"hljs-literal\">true</span>,<br>    signal: null,<br>    cmd: <span class=\"hljs-string\">&#x27;/home/runner/work/WL2O2O.github.io/WL2O2O.github.io/node_modules/imagemin-gifsicle/node_modules/gifsicle/vendor/gifsicle --no-warnings --no-app-extensions&#x27;</span>,<br>    timedOut: <span class=\"hljs-literal\">false</span>,<br>    killed: <span class=\"hljs-literal\">false</span><br>  &#125;<br>&#125; Something<span class=\"hljs-string\">&#x27;s wrong. Maybe you can find the solution here: %s https://hexo.io/docs/troubleshooting.html</span><br><span class=\"hljs-string\">Error: Process completed with exit code 2.</span><br></code></pre></td></tr></table></figure>\n\n<p>解决方案：</p>\n<p>因为本地是完全没有问题的，而且我的依赖是本地直传 GitHub 远仓，于是，直接在<code>.gitignore</code>文件中忽略了这个插件涉及到的子插件问题。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs .gitignore\">node_modules/imagemin-gifsicle/*<br></code></pre></td></tr></table></figure>\n\n<p>暂时解决，后续有问题继续更改。</p>\n<p>不足之处：</p>\n<p>工作流文件中缺少在线构建的语句，因为想要与本地保持一致，暂时选择了直接上传，后续若有问题，再继续改进。工作流文件如下：</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs yml\"><span class=\"hljs-comment\"># name: Deploy # 工作流名称</span><br><span class=\"hljs-comment\"># on:</span><br><span class=\"hljs-comment\">#   push: # push 事件触发工作流</span><br><span class=\"hljs-comment\">#     branches:</span><br><span class=\"hljs-comment\">#       - hexoBlog # 只有在 hexoBlog 分支推送时触发工作流</span><br><span class=\"hljs-comment\"># jobs:</span><br><span class=\"hljs-comment\">#   build: # job1 id</span><br><span class=\"hljs-comment\">#     runs-on: ubuntu-latest # 运行环境为最新版 Ubuntu</span><br><span class=\"hljs-comment\">#     name: Deploy blog</span><br><span class=\"hljs-comment\">#     steps:</span><br><span class=\"hljs-comment\">#       - name: Checkout # 步骤1：获取源码</span><br><span class=\"hljs-comment\">#         uses: actions/checkout@v2 # 使用 actions/checkout@v2</span><br><br><span class=\"hljs-comment\">#       - name: Cache node modules # 步骤2：缓存 node_modules</span><br><span class=\"hljs-comment\">#         uses: actions/cache@v2</span><br><span class=\"hljs-comment\">#         with:</span><br><span class=\"hljs-comment\">#           path: node_modules</span><br><span class=\"hljs-comment\">#           key: $&#123;&#123; runner.os &#125;&#125;-node-$&#123;&#123; hashFiles(&#x27;**/package-lock.json&#x27;) &#125;&#125;</span><br><span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">Build</span> <span class=\"hljs-string\">and</span> <span class=\"hljs-string\">Deploy</span><br><span class=\"hljs-attr\">on:</span> [<span class=\"hljs-string\">push</span>]<br><span class=\"hljs-attr\">permissions:</span> <span class=\"hljs-comment\"># 增加写入仓库分支的写权限，否则在最后一步部署时会出错，提示</span><br>  <span class=\"hljs-attr\">contents:</span> <span class=\"hljs-string\">write</span><br><span class=\"hljs-attr\">jobs:</span><br>  <span class=\"hljs-attr\">build-and-deploy:</span><br>    <span class=\"hljs-attr\">concurrency:</span> <span class=\"hljs-string\">ci-$&#123;&#123;</span> <span class=\"hljs-string\">github.ref</span> <span class=\"hljs-string\">&#125;&#125;</span> <span class=\"hljs-comment\"># Recommended if you intend to make multiple deployments in quick succession.</span><br>    <span class=\"hljs-attr\">runs-on:</span> <span class=\"hljs-string\">ubuntu-latest</span><br>    <span class=\"hljs-attr\">steps:</span><br>      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">Checkout</span> <span class=\"hljs-string\">🛎️</span><br>        <span class=\"hljs-attr\">uses:</span> <span class=\"hljs-string\">actions/checkout@v3</span><br>        <br>      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">Install</span> <span class=\"hljs-string\">Hexo</span> <span class=\"hljs-string\">CLI</span>  <br>        <span class=\"hljs-attr\">run:</span> <span class=\"hljs-string\">npm</span> <span class=\"hljs-string\">install</span> <span class=\"hljs-string\">-g</span> <span class=\"hljs-string\">hexo-cli@4.3.0</span><br>        <span class=\"hljs-attr\">env:</span>  <br>          <span class=\"hljs-attr\">CI:</span> <span class=\"hljs-literal\">false</span><br><br>      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">Install</span> <span class=\"hljs-string\">Dependencies</span> <span class=\"hljs-comment\"># 步骤3：安装依赖</span><br>        <span class=\"hljs-attr\">if:</span> <span class=\"hljs-string\">steps.cache.outputs.cache-hit</span> <span class=\"hljs-type\">!=</span> <span class=\"hljs-string\">&#x27;true&#x27;</span><br>        <span class=\"hljs-attr\">run:</span> <span class=\"hljs-string\">npm</span> <span class=\"hljs-string\">run</span> <span class=\"hljs-string\">build</span><br>        <span class=\"hljs-attr\">env:</span><br>          <span class=\"hljs-attr\">CI:</span> <span class=\"hljs-literal\">false</span><br>          <br>      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">Deploy</span> <span class=\"hljs-string\">🚀</span> <span class=\"hljs-comment\"># 步骤4：部署</span><br>        <span class=\"hljs-comment\"># uses: JamesIves/github-pages-deploy-action@releases/v3</span><br>        <span class=\"hljs-attr\">uses:</span> <span class=\"hljs-string\">JamesIves/github-pages-deploy-action@v4</span><br>        <span class=\"hljs-attr\">with:</span><br>          <span class=\"hljs-attr\">GITHUB_TOKEN:</span> <span class=\"hljs-string\">$&#123;&#123;</span> <span class=\"hljs-string\">secrets.GITHUB_TOKEN</span> <span class=\"hljs-string\">&#125;&#125;</span><br>          <span class=\"hljs-attr\">BRANCH:</span> <span class=\"hljs-string\">master</span> <span class=\"hljs-comment\"># 部署到 gh-pages 分支</span><br>          <span class=\"hljs-attr\">FOLDER:</span> <span class=\"hljs-string\">public</span> <span class=\"hljs-comment\"># 部署 public 文件夹</span><br></code></pre></td></tr></table></figure>\n\n<p><a href=\"https://github.com/marketplace/actions/deploy-to-github-pages\">补充部署GitHub pages的一个repository</a></p>\n<p>介绍:</p>\n<p>Automatically deploy your project to <a href=\"https://pages.github.com/\">GitHub Pages</a> with <a href=\"https://github.com/features/actions\">GitHub Actions</a>. This action can be configured to push your production-ready code into any branch you’d like, including <strong>gh-pages</strong> and <strong>docs</strong>. It can also handle cross repository deployments and works with <a href=\"https://github.com/enterprise\">GitHub Enterprise</a> too.</p>\n<p>官方提供的Action文件：</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs yml\"><span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">Build</span> <span class=\"hljs-string\">and</span> <span class=\"hljs-string\">Deploy</span><br><span class=\"hljs-attr\">on:</span> [<span class=\"hljs-string\">push</span>]<br><span class=\"hljs-attr\">permissions:</span><br>  <span class=\"hljs-attr\">contents:</span> <span class=\"hljs-string\">write</span><br><span class=\"hljs-attr\">jobs:</span><br>  <span class=\"hljs-attr\">build-and-deploy:</span><br>    <span class=\"hljs-attr\">concurrency:</span> <span class=\"hljs-string\">ci-$&#123;&#123;</span> <span class=\"hljs-string\">github.ref</span> <span class=\"hljs-string\">&#125;&#125;</span> <span class=\"hljs-comment\"># Recommended if you intend to make multiple deployments in quick succession.</span><br>    <span class=\"hljs-attr\">runs-on:</span> <span class=\"hljs-string\">ubuntu-latest</span><br>    <span class=\"hljs-attr\">steps:</span><br>      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">Checkout</span> <span class=\"hljs-string\">🛎️</span><br>        <span class=\"hljs-attr\">uses:</span> <span class=\"hljs-string\">actions/checkout@v3</span><br><br>      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">Install</span> <span class=\"hljs-string\">and</span> <span class=\"hljs-string\">Build</span> <span class=\"hljs-string\">🔧</span> <span class=\"hljs-comment\"># This example project is built using npm and outputs the result to the &#x27;build&#x27; folder. Replace with the commands required to build your project, or remove this step entirely if your site is pre-built.</span><br>        <span class=\"hljs-attr\">run:</span> <span class=\"hljs-string\">|</span><br><span class=\"hljs-string\">          npm ci</span><br><span class=\"hljs-string\">          npm run build</span><br><span class=\"hljs-string\"></span><br>      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">Deploy</span> <span class=\"hljs-string\">🚀</span><br>        <span class=\"hljs-attr\">uses:</span> <span class=\"hljs-string\">JamesIves/github-pages-deploy-action@v4</span><br>        <span class=\"hljs-attr\">with:</span><br>          <span class=\"hljs-attr\">folder:</span> <span class=\"hljs-string\">build</span> <span class=\"hljs-comment\"># The folder the action should deploy.</span><br></code></pre></td></tr></table></figure>\n\n</blockquote>\n<h2 id=\"文章置顶–hexo-generator-index\"><a href=\"#文章置顶–hexo-generator-index\" class=\"headerlink\" title=\"文章置顶–hexo-generator-index\"></a>文章置顶–hexo-generator-index</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\"><span class=\"hljs-meta prompt_\">#</span><span class=\"language-bash\">---------------------------</span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">文章置顶</span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">安装时间：2023年10月24日</span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">安装插件：npm install hexo-generator-index --save</span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">源码地址：https://github.com/hexojs/hexo-generator-index.git</span><br><span class=\"hljs-meta prompt_\">#</span><span class=\"language-bash\">---------------------------</span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">使用方法</span><br>sticky: 100（数值越大，优先级越高）<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"文章链接持久化\"><a href=\"#文章链接持久化\" class=\"headerlink\" title=\"文章链接持久化\"></a>文章链接持久化</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\"><span class=\"hljs-meta prompt_\">#</span><span class=\"language-bash\">---------------------------</span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">解决文章链接会随标题变动而变动，链接永久化插件</span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">安装地址：https://github.com/Rozbo/hexo-abbrlink</span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">安装插件：npm install hexo-abbrlink --save</span><br><span class=\"hljs-meta prompt_\">#</span><span class=\"language-bash\">---------------------------</span><br>permalink: posts/:abbrlink.html<br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">abbrlink config</span><br>abbrlink:<br>  alg: crc32      #support crc16(default) and crc32<br>  rep: hex        #support dec(default) and hex<br>  drafts: false   #(true)Process draft,(false)Do not process draft. false(default) <br><span class=\"hljs-meta prompt_\">  # </span><span class=\"language-bash\">Generate categories from directory-tree</span><br><span class=\"hljs-meta prompt_\">  # </span><span class=\"language-bash\">depth: the max_depth of directory-tree you want to generate, should &gt; 0</span><br>  auto_category:<br>     enable: true  #true(default)<br>     depth:        #3(default)<br>     over_write: false <br>  auto_title: false #enable auto title, it can auto fill the title by path<br>  auto_date: false #enable auto date, it can auto fill the date by time today<br>  force: false #enable force mode,in this mode, the plugin will ignore the cache, and calc the abbrlink for every post even it already had abbrlink. This only updates abbrlink rather than other front variables.<br></code></pre></td></tr></table></figure>\n\n"},{"title":"Vuepress 博客搭建","index_img":"https://v2.vuepress.vuejs.org/images/hero.png","abbrlink":7284,"date":"2022-11-07T00:58:32.000Z","_content":"\n# 通过vuepress更新个人博客\n\n## 博客搭建教程\n\n> 本教程使用 pnpm 作为项目管理器，因为 VuePress 和 VuePress Theme Hope 都是通过 pnpm 来管理依赖的。\n\n### 1、安装 Pnpm\n\n在终端中输入下列命令安装 pnpm:\n\n```bash\ncorepack enable\ncorepack prepare pnpm@latest --activate\n```\n\n### 2、初始化项目\n\n```cmd\npnpm create vuepress-theme-hope my-docs\n```\n\n### 3、常用命令\n\n- `vuepress dev [dir]` 会启动一个开发服务器，以便让你在本地开发你的 VuePress 站点。\n- `vuepress build [dir]` 会将你的 VuePress 站点构建成静态文件，以便你进行后续部署。\n\n> 使用模板\n>\n> 如果你在使用 VuePress Theme Hope 模板，你可以在 `package.json` 中发现下列三个命令:\n>\n> \n>\n> ```json\n> {\n>   \"scripts\": {\n>     \"docs:build\": \"vuepress build src\",\n>     \"docs:clean-dev\": \"vuepress dev src --clean-cache\",\n>     \"docs:dev\": \"vuepress dev src\"\n>   }\n> }\n> ```\n>\n> 这意味着你可以使用:\n>\n> - `pnpm docs:dev` 启动开发服务器\n> - `pnpm docs:build` 构建项目并输出\n> - `pnpm docs:clean-dev` 清除缓存并启动开发服务器\n\n### 4、 升级版本\n\n如果你需要升级主题和 VuePress 版本，请执行以下命令:\n\n```cmd\npnpm dlx vp-update\n```\n\n## 完善基本框架\n\n### 1、了解基本结构\n\n### 2、完善导航栏以及相关配置\n\n3、\n\n\n\n![](http://images.rl0206.love/202304181527666.png)\n\n![](http://images.rl0206.love/202304192047438.png)\n\n![](http://images.rl0206.love/202304221329083.ico)\n\n### [评论插件：Waline](https://plugin-comment2.vuejs.press/zh/guide/waline.html)\n\n#### 数据库\n\n* 首先登录[leancloud](https://console.leancloud.app/apps)，注册数据库，记录`APP ID`,`APP Key` 和 `Master Key`以便后续使用；\n\n#### 服务端\n\n* 登录[Vercel](https://vercel.com/new/clone?repository-url=https%3A%2F%2Fgithub.com%2Fwalinejs%2Fwaline%2Ftree%2Fmain%2Fexample) 进行服务端部署，设置环境变量之后，重新部署，即可获得serveUrl。\n  * 我获取到的服务端地址：https://cs-guider-6cmm99f2s-wl2o2o.vercel.app/\n\n> 此时可以配置自己的域名，以便进行管理，不配置域名就通过以上服务端地址进行管理即可。\n>\n> **配置域名之后的管理网址**：\n>\n> - 评论系统：example.your-domain.com\n> - 评论管理：example.your-domain.com/ui\n\n#### 客户端\n\n#### 使用插件\n\n在插件选项中设置 `provider: \"Waline\"`，同时设置服务端地址 `serverURL` 为上一步获取到的值。\n\n此时，将 `<CommentService>` 组件放置在你网站中合适的位置 (通常是页面的底部)，即可使用 Waline 评论功能。\n\n提示\n\n你也可以传入其他 Waline 支持的选项 (除了 `el`)。\n\n详情请见 [Waline 配置](https://plugin-comment2.vuejs.press/zh/config/waline.html)\n\n#### 评论管理 (管理端)\n\n1. 部署完成后，请访问 `<serverURL>/ui/register` 进行注册。首个注册的人会被设定成管理员。\n2. 管理员登陆后，即可看到评论管理界面。在这里可以修改、标记或删除评论。\n3. 用户也可通过评论框注册账号，登陆后会跳转到自己的档案页。\n\n### [评论插件：giscus](https://giscus.app/zh-CN)\n\n#### 选择仓库\n\n选择 giscus 连接到的仓库。请确保：\n\n1. **此仓库是[公开的](https://docs.github.com/en/github/administering-a-repository/managing-repository-settings/setting-repository-visibility#making-a-repository-public)**，否则访客将无法查看 discussion。\n2. **[giscus](https://github.com/apps/giscus) app 已安装**否则访客将无法评论和回应。\n3. **Discussions**功能已[在你的仓库中启用](https://docs.github.com/en/github/administering-a-repository/managing-repository-settings/enabling-or-disabling-github-discussions-for-a-repository)。\n\n仓库：（输入用户名/仓库名）\n\n*一个**公开的（public）** GitHub 仓库。Discussion 将被连接到此仓库。*\n\n#### 选择页面与嵌入的 discussion 之间的映射关系。\n\n建议选择：**Discussion 的标题包含页面的 `pathname`**\n\n#### Discussion 分类\n\n选择新 discussions 所在的分类。 推荐使用**公告（announcements）**类型的分类，以确保新 discussion 只能由仓库维护者和 giscus 创建。\n\n#### 启用 giscus\n\n```js\n<script src=\"https://giscus.app/client.js\"\n        data-repo=\"[在此输入仓库]\"\n        data-repo-id=\"[在此输入仓库 ID]\"\n        data-category=\"[在此输入分类名]\"\n        data-category-id=\"[在此输入分类 ID]\"\n        data-mapping=\"pathname\"\n        data-strict=\"0\"\n        data-reactions-enabled=\"1\"\n        data-emit-metadata=\"0\"\n        data-input-position=\"bottom\"\n        data-theme=\"preferred_color_scheme\"\n        data-lang=\"zh-CN\"\n        crossorigin=\"anonymous\"\n        async>\n</script>\n```\n\n完成以上几项之后，上面代码段中会出现对应的repo、repoId、category、categoryId，复制下来，稍后有用。\n\n在theme.ts中添加如下配置：\n\n```\nplugins：{\n\tcomment: {\n   \t\tprovider: \"Giscus\",\n   \t\trepo: \"WL2O2O/CS_GUIDER_Giscus\",\n  \t\trepoId: \"your id\",\n   \t\tcategory: \"Announcements\",\n   \t\tcategoryId: \"yours id\"\n \t },\n}\n```\n\n### 解决自动部署git pages：\n\n新创建一个autopush.bat文件，将以下代码复制到文件中：\n\n```bat\n@echo off\ngit add .\ngit commit -m \"update article\"\ngit pull origin master\ngit push origin master\n```\n\n此时推送到gitee是正常的，但是推送之后，git pages的页面不会自动更新，于是经过百度，了解到可以通过Git的Webhooks功能，来实现git pages的自动更新。\n\n了解一下webHook：\n\n> 每次您 push 代码后，都会给远程 HTTP URL 发送一个 POST 请求 [更多说明 »](https://gitee.com/help/categories/40)\n>\n> WebHook 增加对钉钉的支持 [更多说明 »](https://gitee.com/help/articles/4135)\n>\n> WebHook 增加对企业微信的支持 [更多说明 »](https://gitee.com/help/articles/4296)\n>\n> WebHook 增加对飞书的支持 [更多说明 »](https://gitee.com/help/articles/4297)\n\n以下是在Windows系统中使用Git的Webhooks功能自动更新Gitee Pages的步骤：\n\n1. 在Gitee仓库的设置页面中，找到Webhooks设置，并添加一个新的Webhook，将Payload URL设置为你的博客页面的URL。\n2. 在你的Vuepress博客项目中添加一个post-commit钩子脚本，用于向Gitee仓库发送Webhooks请求，触发Gitee Pages更新。在项目的.git/hooks目录中创建一个post-commit.bat文件，内容如下：\n\n```bat\n@echo off\ncurl -X POST https://gitee.com/api/v5/repos/{WLei224}/{WLei224}/hooks/{0c8adb9d-f0cf-450b-8d75-3cc56ac7bf3c}/trigger\\?access_token\\={583af4fe8a6611d418da106c6c8bae88}\n```\n\n将上述命令中的{用户名}、{仓库名}、{Webhook ID}和{访问令牌}替换为你自己的信息。其中，Webhook ID可以在Gitee仓库的Webhooks设置页面中找到，访问令牌可以在Gitee账号的个人设置页面中生成。\n\n1. 为post-commit.bat文件添加可执行权限。在终端中进入项目的.git/hooks目录，执行以下命令：\n\n```bash\nchmod +x post-commit.bat\n```\n\n1. 推送代码到Gitee仓库，当你执行git commit命令后，post-commit.bat脚本会自动发送Webhooks请求，触发Gitee Pages更新。\n\n通过上述步骤，你可以在Windows系统中实现自动更新Gitee Pages，提高博客发布的效率和便捷性。\n\n### 博客引入思维导图\n\n### Markmap\n\nMarkmap 是一个将 Markdown 转换为思维导图的工具。它相对于主题内置的 flowchart 支持更多的格式与内容。\n\n1. 使用 [Markmapopen in new window](https://markmap.js.org/) 生成思维导图 HTML 文件（安装markmap插件，可以以思维导图的图形预览markdown文件，然后可选是否导出为html文件）\n2. 将 HTML 文件放在 `.vuepress/public/` 下\n3. 通过 `<iframe>` 插入到 Markdown\n\n输入:\n\n```html\n<iframe\n  :src=\"$withBase('/markmap/demo-zh.html')\"\n  width=\"100%\"\n  height=\"400\"\n  frameborder=\"0\"\n  scrolling=\"No\"\n  leftmargin=\"0\"\n  topmargin=\"0\"\n/>\n```\n\n输出:\n\n<iframe src=\"/markmap/demo-zh.html\" width=\"100%\" height=\"400\" frameborder=\"0\" scrolling=\"No\" leftmargin=\"0\" topmargin=\"0\"></iframe>\n\n------\n\n\n\n### 尝试缩短博客构建时间的方法（以下是GPT生成的步骤，待测试！）\n\nVuePress 使用的是 Webpack 构建工具，而使用 pnpm 作为包管理器则可以大幅缩短安装依赖包的时间。然而，如果在使用 pnpm 构建 VuePress 网站时仍然遇到了速度很慢的问题，可以尝试以下几个方法：\n\n1. 更新 pnpm 版本：首先，您可以尝试升级 pnpm 的版本。较新的版本通常会修复一些问题并提高性能。您可以使用以下命令来更新 pnpm：\n\n\n   ````\n   npm i -g pnpm@latest\n   ````\n\n2. 切换镜像源：如果您使用的是国外的包管理器镜像源，可能会导致下载速度很慢。您可以尝试切换到国内的镜像源，例如淘宝镜像、cnpmjs 等。您可以使用以下命令来设置淘宝镜像源：\n\n   ````\n   pnpm config set registry https://registry.npm.taobao.org\n   ````\n   \n3. 使用缓存：在第一次构建 VuePress 网站时，pnpm 会下载所有依赖包，并且可能会需要很长时间。一种解决方法是使用缓存，在下一次构建时从缓存中加载依赖包而不是重新下载。您可以使用以下命令来启用缓存：\n\n   ````\n   pnpm install --shamefully-hoist --store-dir=./.pnpm-store\n   \n   在第一次构建时，pnpm 会将依赖包缓存到指定的目录中。在下一次构建时，pnpm 将从缓存中加载依赖包，而不是重新下载。\n   ````\n   \n4. 升级 Node.js 版本：VuePress 需要使用较新的版本的 Node.js，如果您的 Node.js 版本太旧，可能会导致构建速度变慢。您可以尝试将 Node.js 版本升级到最新版，并重新构建 VuePress 网站。\n\n5. 按需加载：如果您的 VuePress 网站包含大量的页面和组件，可以尝试使用按需加载来提高构建速度。您可以使用 VuePress 的 `async` 组件来实现按需加载，例如：\n\n   ````\n   <AsyncContent path=\"./path/to/file.vue\" />\n   ```\n   \n   这将使 VuePress 仅在需要时才加载组件，而不是在构建时将所有组件都打包进最终的 JavaScript 文件中。\n   ````\n\n以上是一些可以尝试的方法来提高使用 pnpm 构建 VuePress 网站的速度。如果以上方法仍然无法解决您的问题，您可以尝试在 VuePress 官方的 GitHub 仓库中搜索类似的问题，或者在 VuePress 社区中询问其他人是否遇到了类似的问题并得到了解决方法。\n\n\n### 要在 VuePress 中集成百度统计，您需要遵循以下步骤：\n\n在百度统计中创建站点并获取统计代码：首先，您需要在百度统计中创建一个站点，并获取相应的统计代码。在百度统计管理面板中，选择您要添加统计代码的站点，然后单击“代码管理”按钮。在“统计代码”页面中，您将看到一段 JavaScript 代码。复制该代码以备后用。\n\n在 VuePress 中创建配置文件：接下来，您需要在 VuePress 项目中创建一个配置文件。在您的 VuePress 项目根目录下，创建一个名为 .vuepress 的文件夹，然后在该文件夹中创建一个名为 config.js 的配置文件。在 config.js 文件中添加以下代码：\n\n```\nmodule.exports = {\n  head: [\n    ['script', {}, `\n      var _hmt = _hmt || [];\n      (function() {\n        var hm = document.createElement(\"script\");\n        hm.src = \"https://hm.baidu.com/hm.js?YOUR_BAIDU_SITE_ID\";\n        var s = document.getElementsByTagName(\"script\")[0]; \n        s.parentNode.insertBefore(hm, s);\n      })();\n   `]\n  ]\n}\n```\n\n在代码中，将 `YOUR_BAIDU_SITE_ID` 替换为您在百度统计中创建站点时获得的站点 ID。\n\n将配置文件添加到 Git 仓库并部署网站：完成上述步骤后，将创建的 .vuepress 文件夹和其中的 config.js 文件添加到您的 Git 仓库中，并将网站部署到您的服务器或托管平台上。如果您使用的是 GitHub Pages，您可以将 .vuepress 文件夹和其中的 config.js 文件添加到您的 GitHub 仓库中，并在仓库的设置页面中将 GitHub Pages 的源设置为“master branch /docs folder”。\n\n验证是否成功添加了百度统计：最后，您可以访问您的网站并登录到百度统计管理面板中，查看是否有网站访问数据。如果一切正常，您应该能够在百度统计中看到您网站的访问数据和用户行为数据。\n\n以上是在 VuePress 中集成百度统计的步骤和代码示例。请注意，由于百度统计的代码可能会随时更新，所以建议您在将代码添加到您的 VuePress 项目中之前，先阅读并遵循百度统计的官方文档。另外，您还可以使用 VuePress 插件来方便地集成百度统计，例如 vuepress-plugin-baidu-analytics 插件。此插件可以自动在您的 VuePress 网站中添加百度统计代码，而无需手动编辑配置文件。您可以在 VuePress 插件市场中搜索该插件，并按照其文档说明进行安装和配置。\n\n\n\n### 站长工具：百度资源搜索平台\n\n> ***网站言则会那个不通过的问题：***\n\n在平台添加网站时，需要进行文件或者HTML标签进行验证，之前一直验证都不通过，昨天（23年/5月26日）根据报错信息，终于验证通过了，我选择的验证方式是文件验证，因为在vuepress博客中构建的每一个html文件添加相应的标签，我还没有找到合适的方法，于是就通过文件验证的方法进行了相关的验证，\n\n刚开始按照网站的提示，将验证文件放在网站的根目录下，然后按要求照做了，结果是一直未验证通过。点击确认验证文件可以正常访问，也访问不到相应的验证文件，然后就想着还是路径不对，然后求助了`ChatGpt`,把验证文件换了一个路径进行上传，然后问题就解决了！！！\n\n> ***API 提交和 Sitemap 提交应该选择哪一个？***\n\nAPI 提交和 Sitemap 提交都可以帮助搜索引擎更好地收录和展示您的网站数据，但是它们的作用和适用场景略有不同。\n\nAPI 提交是指通过将网站数据以 API 接口的形式提供给搜索引擎，让搜索引擎可以更及时、准确地获取网站数据。API 提交通常适用于动态内容和实时数据的网站，比如新闻、社交媒体、股票行情等。API 提交可以让搜索引擎更快地获取网站数据，从而更及时地更新搜索结果，提高网站曝光度和流量。\n\nSitemap 提交是指将网站的 Sitemap 文件提交给搜索引擎，以便搜索引擎更好地了解网站的结构和内容。Sitemap 提交通常适用于静态内容和定期更新的网站，比如博客、电商网站、企业网站等。Sitemap 提交可以让搜索引擎更快地了解网站的结构和内容，从而更好地收录和展示网站的信息，提高网站的可见性和搜索排名。\n\n综合来说，API 提交和 Sitemap 提交都可以提高网站的曝光度和流量，但是它们的适用场景略有不同。对于动态内容和实时数据的网站，API 提交更为适用；对于静态内容和定期更新的网站，Sitemap 提交更为适用。在实际应用中，可以根据网站的特点和需求，选择合适的提交方式来促进网站的发展和成长。\n\n\n\n### 域名备案需要服务器IP的问题\n\n> 必须要有服务器吗？\n\n根据中国互联网信息办公室的规定，如果您的个人博客使用的域名在中国大陆境内进行访问，需要进行备案才能正常访问。备案需要提供服务器的信息，包括服务器所在地、服务器的 IP 地址、备案主体信息等。\n\n如果您的个人博客部署在 GitHub Pages 或其他类似的静态网站托管服务上，而没有自己的服务器，那么备案可能会有一定的困难。因为备案需要提供服务器的信息，如果没有自己的服务器，就无法提供这些信息。此时，您可以考虑购买虚拟主机或云服务器等产品，然后将个人博客迁移到这些服务器上，再进行备案。\n\n在购买虚拟主机或云服务器时，您可以选择腾讯云或其他云服务提供商，根据自己的需求选择合适的产品类型和配置，然后将个人博客部署到服务器上。备案完成后，将域名解析到服务器的 IP地址，就可以正常访问个人博客了。\n\n需要注意的是，备案需要提供真实的备案主体信息，包括个人或单位的营业执照、身份证等证件，如果您是个人用户，需要提供有效的身份证件。因此，在进行备案之前，建议先了解备案的相关规定和流程，准备好备案所需的材料和信息，以免出现不必要的麻烦。\n\n另外，备案是一个比较复杂的过程，需要注意各个环节的细节。如果您对备案流程和规定不熟悉，建议咨询相关专业人士或官方机构的客服人员，以避免出现不必要的错误和问题。\n\n","source":"_posts/helloVuepress.md","raw":"---\ntitle: Vuepress 博客搭建\nindex_img: 'https://v2.vuepress.vuejs.org/images/hero.png'\ncategories:\n  - Blog\ntags:\n  - 网站搭建\nabbrlink: 7284\ndate: 2022-11-07 08:58:32\n---\n\n# 通过vuepress更新个人博客\n\n## 博客搭建教程\n\n> 本教程使用 pnpm 作为项目管理器，因为 VuePress 和 VuePress Theme Hope 都是通过 pnpm 来管理依赖的。\n\n### 1、安装 Pnpm\n\n在终端中输入下列命令安装 pnpm:\n\n```bash\ncorepack enable\ncorepack prepare pnpm@latest --activate\n```\n\n### 2、初始化项目\n\n```cmd\npnpm create vuepress-theme-hope my-docs\n```\n\n### 3、常用命令\n\n- `vuepress dev [dir]` 会启动一个开发服务器，以便让你在本地开发你的 VuePress 站点。\n- `vuepress build [dir]` 会将你的 VuePress 站点构建成静态文件，以便你进行后续部署。\n\n> 使用模板\n>\n> 如果你在使用 VuePress Theme Hope 模板，你可以在 `package.json` 中发现下列三个命令:\n>\n> \n>\n> ```json\n> {\n>   \"scripts\": {\n>     \"docs:build\": \"vuepress build src\",\n>     \"docs:clean-dev\": \"vuepress dev src --clean-cache\",\n>     \"docs:dev\": \"vuepress dev src\"\n>   }\n> }\n> ```\n>\n> 这意味着你可以使用:\n>\n> - `pnpm docs:dev` 启动开发服务器\n> - `pnpm docs:build` 构建项目并输出\n> - `pnpm docs:clean-dev` 清除缓存并启动开发服务器\n\n### 4、 升级版本\n\n如果你需要升级主题和 VuePress 版本，请执行以下命令:\n\n```cmd\npnpm dlx vp-update\n```\n\n## 完善基本框架\n\n### 1、了解基本结构\n\n### 2、完善导航栏以及相关配置\n\n3、\n\n\n\n![](http://images.rl0206.love/202304181527666.png)\n\n![](http://images.rl0206.love/202304192047438.png)\n\n![](http://images.rl0206.love/202304221329083.ico)\n\n### [评论插件：Waline](https://plugin-comment2.vuejs.press/zh/guide/waline.html)\n\n#### 数据库\n\n* 首先登录[leancloud](https://console.leancloud.app/apps)，注册数据库，记录`APP ID`,`APP Key` 和 `Master Key`以便后续使用；\n\n#### 服务端\n\n* 登录[Vercel](https://vercel.com/new/clone?repository-url=https%3A%2F%2Fgithub.com%2Fwalinejs%2Fwaline%2Ftree%2Fmain%2Fexample) 进行服务端部署，设置环境变量之后，重新部署，即可获得serveUrl。\n  * 我获取到的服务端地址：https://cs-guider-6cmm99f2s-wl2o2o.vercel.app/\n\n> 此时可以配置自己的域名，以便进行管理，不配置域名就通过以上服务端地址进行管理即可。\n>\n> **配置域名之后的管理网址**：\n>\n> - 评论系统：example.your-domain.com\n> - 评论管理：example.your-domain.com/ui\n\n#### 客户端\n\n#### 使用插件\n\n在插件选项中设置 `provider: \"Waline\"`，同时设置服务端地址 `serverURL` 为上一步获取到的值。\n\n此时，将 `<CommentService>` 组件放置在你网站中合适的位置 (通常是页面的底部)，即可使用 Waline 评论功能。\n\n提示\n\n你也可以传入其他 Waline 支持的选项 (除了 `el`)。\n\n详情请见 [Waline 配置](https://plugin-comment2.vuejs.press/zh/config/waline.html)\n\n#### 评论管理 (管理端)\n\n1. 部署完成后，请访问 `<serverURL>/ui/register` 进行注册。首个注册的人会被设定成管理员。\n2. 管理员登陆后，即可看到评论管理界面。在这里可以修改、标记或删除评论。\n3. 用户也可通过评论框注册账号，登陆后会跳转到自己的档案页。\n\n### [评论插件：giscus](https://giscus.app/zh-CN)\n\n#### 选择仓库\n\n选择 giscus 连接到的仓库。请确保：\n\n1. **此仓库是[公开的](https://docs.github.com/en/github/administering-a-repository/managing-repository-settings/setting-repository-visibility#making-a-repository-public)**，否则访客将无法查看 discussion。\n2. **[giscus](https://github.com/apps/giscus) app 已安装**否则访客将无法评论和回应。\n3. **Discussions**功能已[在你的仓库中启用](https://docs.github.com/en/github/administering-a-repository/managing-repository-settings/enabling-or-disabling-github-discussions-for-a-repository)。\n\n仓库：（输入用户名/仓库名）\n\n*一个**公开的（public）** GitHub 仓库。Discussion 将被连接到此仓库。*\n\n#### 选择页面与嵌入的 discussion 之间的映射关系。\n\n建议选择：**Discussion 的标题包含页面的 `pathname`**\n\n#### Discussion 分类\n\n选择新 discussions 所在的分类。 推荐使用**公告（announcements）**类型的分类，以确保新 discussion 只能由仓库维护者和 giscus 创建。\n\n#### 启用 giscus\n\n```js\n<script src=\"https://giscus.app/client.js\"\n        data-repo=\"[在此输入仓库]\"\n        data-repo-id=\"[在此输入仓库 ID]\"\n        data-category=\"[在此输入分类名]\"\n        data-category-id=\"[在此输入分类 ID]\"\n        data-mapping=\"pathname\"\n        data-strict=\"0\"\n        data-reactions-enabled=\"1\"\n        data-emit-metadata=\"0\"\n        data-input-position=\"bottom\"\n        data-theme=\"preferred_color_scheme\"\n        data-lang=\"zh-CN\"\n        crossorigin=\"anonymous\"\n        async>\n</script>\n```\n\n完成以上几项之后，上面代码段中会出现对应的repo、repoId、category、categoryId，复制下来，稍后有用。\n\n在theme.ts中添加如下配置：\n\n```\nplugins：{\n\tcomment: {\n   \t\tprovider: \"Giscus\",\n   \t\trepo: \"WL2O2O/CS_GUIDER_Giscus\",\n  \t\trepoId: \"your id\",\n   \t\tcategory: \"Announcements\",\n   \t\tcategoryId: \"yours id\"\n \t },\n}\n```\n\n### 解决自动部署git pages：\n\n新创建一个autopush.bat文件，将以下代码复制到文件中：\n\n```bat\n@echo off\ngit add .\ngit commit -m \"update article\"\ngit pull origin master\ngit push origin master\n```\n\n此时推送到gitee是正常的，但是推送之后，git pages的页面不会自动更新，于是经过百度，了解到可以通过Git的Webhooks功能，来实现git pages的自动更新。\n\n了解一下webHook：\n\n> 每次您 push 代码后，都会给远程 HTTP URL 发送一个 POST 请求 [更多说明 »](https://gitee.com/help/categories/40)\n>\n> WebHook 增加对钉钉的支持 [更多说明 »](https://gitee.com/help/articles/4135)\n>\n> WebHook 增加对企业微信的支持 [更多说明 »](https://gitee.com/help/articles/4296)\n>\n> WebHook 增加对飞书的支持 [更多说明 »](https://gitee.com/help/articles/4297)\n\n以下是在Windows系统中使用Git的Webhooks功能自动更新Gitee Pages的步骤：\n\n1. 在Gitee仓库的设置页面中，找到Webhooks设置，并添加一个新的Webhook，将Payload URL设置为你的博客页面的URL。\n2. 在你的Vuepress博客项目中添加一个post-commit钩子脚本，用于向Gitee仓库发送Webhooks请求，触发Gitee Pages更新。在项目的.git/hooks目录中创建一个post-commit.bat文件，内容如下：\n\n```bat\n@echo off\ncurl -X POST https://gitee.com/api/v5/repos/{WLei224}/{WLei224}/hooks/{0c8adb9d-f0cf-450b-8d75-3cc56ac7bf3c}/trigger\\?access_token\\={583af4fe8a6611d418da106c6c8bae88}\n```\n\n将上述命令中的{用户名}、{仓库名}、{Webhook ID}和{访问令牌}替换为你自己的信息。其中，Webhook ID可以在Gitee仓库的Webhooks设置页面中找到，访问令牌可以在Gitee账号的个人设置页面中生成。\n\n1. 为post-commit.bat文件添加可执行权限。在终端中进入项目的.git/hooks目录，执行以下命令：\n\n```bash\nchmod +x post-commit.bat\n```\n\n1. 推送代码到Gitee仓库，当你执行git commit命令后，post-commit.bat脚本会自动发送Webhooks请求，触发Gitee Pages更新。\n\n通过上述步骤，你可以在Windows系统中实现自动更新Gitee Pages，提高博客发布的效率和便捷性。\n\n### 博客引入思维导图\n\n### Markmap\n\nMarkmap 是一个将 Markdown 转换为思维导图的工具。它相对于主题内置的 flowchart 支持更多的格式与内容。\n\n1. 使用 [Markmapopen in new window](https://markmap.js.org/) 生成思维导图 HTML 文件（安装markmap插件，可以以思维导图的图形预览markdown文件，然后可选是否导出为html文件）\n2. 将 HTML 文件放在 `.vuepress/public/` 下\n3. 通过 `<iframe>` 插入到 Markdown\n\n输入:\n\n```html\n<iframe\n  :src=\"$withBase('/markmap/demo-zh.html')\"\n  width=\"100%\"\n  height=\"400\"\n  frameborder=\"0\"\n  scrolling=\"No\"\n  leftmargin=\"0\"\n  topmargin=\"0\"\n/>\n```\n\n输出:\n\n<iframe src=\"/markmap/demo-zh.html\" width=\"100%\" height=\"400\" frameborder=\"0\" scrolling=\"No\" leftmargin=\"0\" topmargin=\"0\"></iframe>\n\n------\n\n\n\n### 尝试缩短博客构建时间的方法（以下是GPT生成的步骤，待测试！）\n\nVuePress 使用的是 Webpack 构建工具，而使用 pnpm 作为包管理器则可以大幅缩短安装依赖包的时间。然而，如果在使用 pnpm 构建 VuePress 网站时仍然遇到了速度很慢的问题，可以尝试以下几个方法：\n\n1. 更新 pnpm 版本：首先，您可以尝试升级 pnpm 的版本。较新的版本通常会修复一些问题并提高性能。您可以使用以下命令来更新 pnpm：\n\n\n   ````\n   npm i -g pnpm@latest\n   ````\n\n2. 切换镜像源：如果您使用的是国外的包管理器镜像源，可能会导致下载速度很慢。您可以尝试切换到国内的镜像源，例如淘宝镜像、cnpmjs 等。您可以使用以下命令来设置淘宝镜像源：\n\n   ````\n   pnpm config set registry https://registry.npm.taobao.org\n   ````\n   \n3. 使用缓存：在第一次构建 VuePress 网站时，pnpm 会下载所有依赖包，并且可能会需要很长时间。一种解决方法是使用缓存，在下一次构建时从缓存中加载依赖包而不是重新下载。您可以使用以下命令来启用缓存：\n\n   ````\n   pnpm install --shamefully-hoist --store-dir=./.pnpm-store\n   \n   在第一次构建时，pnpm 会将依赖包缓存到指定的目录中。在下一次构建时，pnpm 将从缓存中加载依赖包，而不是重新下载。\n   ````\n   \n4. 升级 Node.js 版本：VuePress 需要使用较新的版本的 Node.js，如果您的 Node.js 版本太旧，可能会导致构建速度变慢。您可以尝试将 Node.js 版本升级到最新版，并重新构建 VuePress 网站。\n\n5. 按需加载：如果您的 VuePress 网站包含大量的页面和组件，可以尝试使用按需加载来提高构建速度。您可以使用 VuePress 的 `async` 组件来实现按需加载，例如：\n\n   ````\n   <AsyncContent path=\"./path/to/file.vue\" />\n   ```\n   \n   这将使 VuePress 仅在需要时才加载组件，而不是在构建时将所有组件都打包进最终的 JavaScript 文件中。\n   ````\n\n以上是一些可以尝试的方法来提高使用 pnpm 构建 VuePress 网站的速度。如果以上方法仍然无法解决您的问题，您可以尝试在 VuePress 官方的 GitHub 仓库中搜索类似的问题，或者在 VuePress 社区中询问其他人是否遇到了类似的问题并得到了解决方法。\n\n\n### 要在 VuePress 中集成百度统计，您需要遵循以下步骤：\n\n在百度统计中创建站点并获取统计代码：首先，您需要在百度统计中创建一个站点，并获取相应的统计代码。在百度统计管理面板中，选择您要添加统计代码的站点，然后单击“代码管理”按钮。在“统计代码”页面中，您将看到一段 JavaScript 代码。复制该代码以备后用。\n\n在 VuePress 中创建配置文件：接下来，您需要在 VuePress 项目中创建一个配置文件。在您的 VuePress 项目根目录下，创建一个名为 .vuepress 的文件夹，然后在该文件夹中创建一个名为 config.js 的配置文件。在 config.js 文件中添加以下代码：\n\n```\nmodule.exports = {\n  head: [\n    ['script', {}, `\n      var _hmt = _hmt || [];\n      (function() {\n        var hm = document.createElement(\"script\");\n        hm.src = \"https://hm.baidu.com/hm.js?YOUR_BAIDU_SITE_ID\";\n        var s = document.getElementsByTagName(\"script\")[0]; \n        s.parentNode.insertBefore(hm, s);\n      })();\n   `]\n  ]\n}\n```\n\n在代码中，将 `YOUR_BAIDU_SITE_ID` 替换为您在百度统计中创建站点时获得的站点 ID。\n\n将配置文件添加到 Git 仓库并部署网站：完成上述步骤后，将创建的 .vuepress 文件夹和其中的 config.js 文件添加到您的 Git 仓库中，并将网站部署到您的服务器或托管平台上。如果您使用的是 GitHub Pages，您可以将 .vuepress 文件夹和其中的 config.js 文件添加到您的 GitHub 仓库中，并在仓库的设置页面中将 GitHub Pages 的源设置为“master branch /docs folder”。\n\n验证是否成功添加了百度统计：最后，您可以访问您的网站并登录到百度统计管理面板中，查看是否有网站访问数据。如果一切正常，您应该能够在百度统计中看到您网站的访问数据和用户行为数据。\n\n以上是在 VuePress 中集成百度统计的步骤和代码示例。请注意，由于百度统计的代码可能会随时更新，所以建议您在将代码添加到您的 VuePress 项目中之前，先阅读并遵循百度统计的官方文档。另外，您还可以使用 VuePress 插件来方便地集成百度统计，例如 vuepress-plugin-baidu-analytics 插件。此插件可以自动在您的 VuePress 网站中添加百度统计代码，而无需手动编辑配置文件。您可以在 VuePress 插件市场中搜索该插件，并按照其文档说明进行安装和配置。\n\n\n\n### 站长工具：百度资源搜索平台\n\n> ***网站言则会那个不通过的问题：***\n\n在平台添加网站时，需要进行文件或者HTML标签进行验证，之前一直验证都不通过，昨天（23年/5月26日）根据报错信息，终于验证通过了，我选择的验证方式是文件验证，因为在vuepress博客中构建的每一个html文件添加相应的标签，我还没有找到合适的方法，于是就通过文件验证的方法进行了相关的验证，\n\n刚开始按照网站的提示，将验证文件放在网站的根目录下，然后按要求照做了，结果是一直未验证通过。点击确认验证文件可以正常访问，也访问不到相应的验证文件，然后就想着还是路径不对，然后求助了`ChatGpt`,把验证文件换了一个路径进行上传，然后问题就解决了！！！\n\n> ***API 提交和 Sitemap 提交应该选择哪一个？***\n\nAPI 提交和 Sitemap 提交都可以帮助搜索引擎更好地收录和展示您的网站数据，但是它们的作用和适用场景略有不同。\n\nAPI 提交是指通过将网站数据以 API 接口的形式提供给搜索引擎，让搜索引擎可以更及时、准确地获取网站数据。API 提交通常适用于动态内容和实时数据的网站，比如新闻、社交媒体、股票行情等。API 提交可以让搜索引擎更快地获取网站数据，从而更及时地更新搜索结果，提高网站曝光度和流量。\n\nSitemap 提交是指将网站的 Sitemap 文件提交给搜索引擎，以便搜索引擎更好地了解网站的结构和内容。Sitemap 提交通常适用于静态内容和定期更新的网站，比如博客、电商网站、企业网站等。Sitemap 提交可以让搜索引擎更快地了解网站的结构和内容，从而更好地收录和展示网站的信息，提高网站的可见性和搜索排名。\n\n综合来说，API 提交和 Sitemap 提交都可以提高网站的曝光度和流量，但是它们的适用场景略有不同。对于动态内容和实时数据的网站，API 提交更为适用；对于静态内容和定期更新的网站，Sitemap 提交更为适用。在实际应用中，可以根据网站的特点和需求，选择合适的提交方式来促进网站的发展和成长。\n\n\n\n### 域名备案需要服务器IP的问题\n\n> 必须要有服务器吗？\n\n根据中国互联网信息办公室的规定，如果您的个人博客使用的域名在中国大陆境内进行访问，需要进行备案才能正常访问。备案需要提供服务器的信息，包括服务器所在地、服务器的 IP 地址、备案主体信息等。\n\n如果您的个人博客部署在 GitHub Pages 或其他类似的静态网站托管服务上，而没有自己的服务器，那么备案可能会有一定的困难。因为备案需要提供服务器的信息，如果没有自己的服务器，就无法提供这些信息。此时，您可以考虑购买虚拟主机或云服务器等产品，然后将个人博客迁移到这些服务器上，再进行备案。\n\n在购买虚拟主机或云服务器时，您可以选择腾讯云或其他云服务提供商，根据自己的需求选择合适的产品类型和配置，然后将个人博客部署到服务器上。备案完成后，将域名解析到服务器的 IP地址，就可以正常访问个人博客了。\n\n需要注意的是，备案需要提供真实的备案主体信息，包括个人或单位的营业执照、身份证等证件，如果您是个人用户，需要提供有效的身份证件。因此，在进行备案之前，建议先了解备案的相关规定和流程，准备好备案所需的材料和信息，以免出现不必要的麻烦。\n\n另外，备案是一个比较复杂的过程，需要注意各个环节的细节。如果您对备案流程和规定不熟悉，建议咨询相关专业人士或官方机构的客服人员，以避免出现不必要的错误和问题。\n\n","slug":"helloVuepress","published":1,"updated":"2023-10-16T06:58:59.286Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clpkiczj60025fkfogzctee32","content":"<h1 id=\"通过vuepress更新个人博客\"><a href=\"#通过vuepress更新个人博客\" class=\"headerlink\" title=\"通过vuepress更新个人博客\"></a>通过vuepress更新个人博客</h1><h2 id=\"博客搭建教程\"><a href=\"#博客搭建教程\" class=\"headerlink\" title=\"博客搭建教程\"></a>博客搭建教程</h2><blockquote>\n<p>本教程使用 pnpm 作为项目管理器，因为 VuePress 和 VuePress Theme Hope 都是通过 pnpm 来管理依赖的。</p>\n</blockquote>\n<h3 id=\"1、安装-Pnpm\"><a href=\"#1、安装-Pnpm\" class=\"headerlink\" title=\"1、安装 Pnpm\"></a>1、安装 Pnpm</h3><p>在终端中输入下列命令安装 pnpm:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">corepack <span class=\"hljs-built_in\">enable</span><br>corepack prepare pnpm@latest --activate<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"2、初始化项目\"><a href=\"#2、初始化项目\" class=\"headerlink\" title=\"2、初始化项目\"></a>2、初始化项目</h3><figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmd\">pnpm create vuepress-theme-hope my-docs<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"3、常用命令\"><a href=\"#3、常用命令\" class=\"headerlink\" title=\"3、常用命令\"></a>3、常用命令</h3><ul>\n<li><code>vuepress dev [dir]</code> 会启动一个开发服务器，以便让你在本地开发你的 VuePress 站点。</li>\n<li><code>vuepress build [dir]</code> 会将你的 VuePress 站点构建成静态文件，以便你进行后续部署。</li>\n</ul>\n<blockquote>\n<p>使用模板</p>\n<p>如果你在使用 VuePress Theme Hope 模板，你可以在 <code>package.json</code> 中发现下列三个命令:</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs json\"><span class=\"hljs-punctuation\">&#123;</span><br>  <span class=\"hljs-attr\">&quot;scripts&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-punctuation\">&#123;</span><br>    <span class=\"hljs-attr\">&quot;docs:build&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">&quot;vuepress build src&quot;</span><span class=\"hljs-punctuation\">,</span><br>    <span class=\"hljs-attr\">&quot;docs:clean-dev&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">&quot;vuepress dev src --clean-cache&quot;</span><span class=\"hljs-punctuation\">,</span><br>    <span class=\"hljs-attr\">&quot;docs:dev&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">&quot;vuepress dev src&quot;</span><br>  <span class=\"hljs-punctuation\">&#125;</span><br><span class=\"hljs-punctuation\">&#125;</span><br></code></pre></td></tr></table></figure>\n\n<p>这意味着你可以使用:</p>\n<ul>\n<li><code>pnpm docs:dev</code> 启动开发服务器</li>\n<li><code>pnpm docs:build</code> 构建项目并输出</li>\n<li><code>pnpm docs:clean-dev</code> 清除缓存并启动开发服务器</li>\n</ul>\n</blockquote>\n<h3 id=\"4、-升级版本\"><a href=\"#4、-升级版本\" class=\"headerlink\" title=\"4、 升级版本\"></a>4、 升级版本</h3><p>如果你需要升级主题和 VuePress 版本，请执行以下命令:</p>\n<figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmd\">pnpm dlx vp-update<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"完善基本框架\"><a href=\"#完善基本框架\" class=\"headerlink\" title=\"完善基本框架\"></a>完善基本框架</h2><h3 id=\"1、了解基本结构\"><a href=\"#1、了解基本结构\" class=\"headerlink\" title=\"1、了解基本结构\"></a>1、了解基本结构</h3><h3 id=\"2、完善导航栏以及相关配置\"><a href=\"#2、完善导航栏以及相关配置\" class=\"headerlink\" title=\"2、完善导航栏以及相关配置\"></a>2、完善导航栏以及相关配置</h3><p>3、</p>\n<p><img src=\"http://images.rl0206.love/202304181527666.png\"></p>\n<p><img src=\"http://images.rl0206.love/202304192047438.png\"></p>\n<p><img src=\"http://images.rl0206.love/202304221329083.ico\"></p>\n<h3 id=\"评论插件：Waline\"><a href=\"#评论插件：Waline\" class=\"headerlink\" title=\"评论插件：Waline\"></a><a href=\"https://plugin-comment2.vuejs.press/zh/guide/waline.html\">评论插件：Waline</a></h3><h4 id=\"数据库\"><a href=\"#数据库\" class=\"headerlink\" title=\"数据库\"></a>数据库</h4><ul>\n<li>首先登录<a href=\"https://console.leancloud.app/apps\">leancloud</a>，注册数据库，记录<code>APP ID</code>,<code>APP Key</code> 和 <code>Master Key</code>以便后续使用；</li>\n</ul>\n<h4 id=\"服务端\"><a href=\"#服务端\" class=\"headerlink\" title=\"服务端\"></a>服务端</h4><ul>\n<li>登录<a href=\"https://vercel.com/new/clone?repository-url=https://github.com/walinejs/waline/tree/main/example\">Vercel</a> 进行服务端部署，设置环境变量之后，重新部署，即可获得serveUrl。<ul>\n<li>我获取到的服务端地址：<a href=\"https://cs-guider-6cmm99f2s-wl2o2o.vercel.app/\">https://cs-guider-6cmm99f2s-wl2o2o.vercel.app/</a></li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>此时可以配置自己的域名，以便进行管理，不配置域名就通过以上服务端地址进行管理即可。</p>\n<p><strong>配置域名之后的管理网址</strong>：</p>\n<ul>\n<li>评论系统：example.your-domain.com</li>\n<li>评论管理：example.your-domain.com/ui</li>\n</ul>\n</blockquote>\n<h4 id=\"客户端\"><a href=\"#客户端\" class=\"headerlink\" title=\"客户端\"></a>客户端</h4><h4 id=\"使用插件\"><a href=\"#使用插件\" class=\"headerlink\" title=\"使用插件\"></a>使用插件</h4><p>在插件选项中设置 <code>provider: &quot;Waline&quot;</code>，同时设置服务端地址 <code>serverURL</code> 为上一步获取到的值。</p>\n<p>此时，将 <code>&lt;CommentService&gt;</code> 组件放置在你网站中合适的位置 (通常是页面的底部)，即可使用 Waline 评论功能。</p>\n<p>提示</p>\n<p>你也可以传入其他 Waline 支持的选项 (除了 <code>el</code>)。</p>\n<p>详情请见 <a href=\"https://plugin-comment2.vuejs.press/zh/config/waline.html\">Waline 配置</a></p>\n<h4 id=\"评论管理-管理端\"><a href=\"#评论管理-管理端\" class=\"headerlink\" title=\"评论管理 (管理端)\"></a>评论管理 (管理端)</h4><ol>\n<li>部署完成后，请访问 <code>&lt;serverURL&gt;/ui/register</code> 进行注册。首个注册的人会被设定成管理员。</li>\n<li>管理员登陆后，即可看到评论管理界面。在这里可以修改、标记或删除评论。</li>\n<li>用户也可通过评论框注册账号，登陆后会跳转到自己的档案页。</li>\n</ol>\n<h3 id=\"评论插件：giscus\"><a href=\"#评论插件：giscus\" class=\"headerlink\" title=\"评论插件：giscus\"></a><a href=\"https://giscus.app/zh-CN\">评论插件：giscus</a></h3><h4 id=\"选择仓库\"><a href=\"#选择仓库\" class=\"headerlink\" title=\"选择仓库\"></a>选择仓库</h4><p>选择 giscus 连接到的仓库。请确保：</p>\n<ol>\n<li>**此仓库是<a href=\"https://docs.github.com/en/github/administering-a-repository/managing-repository-settings/setting-repository-visibility#making-a-repository-public\">公开的</a>**，否则访客将无法查看 discussion。</li>\n<li><strong><a href=\"https://github.com/apps/giscus\">giscus</a> app 已安装</strong>否则访客将无法评论和回应。</li>\n<li><strong>Discussions</strong>功能已<a href=\"https://docs.github.com/en/github/administering-a-repository/managing-repository-settings/enabling-or-disabling-github-discussions-for-a-repository\">在你的仓库中启用</a>。</li>\n</ol>\n<p>仓库：（输入用户名/仓库名）</p>\n<p><em>一个*<em>公开的（public）</em></em> GitHub 仓库。Discussion 将被连接到此仓库。*</p>\n<h4 id=\"选择页面与嵌入的-discussion-之间的映射关系。\"><a href=\"#选择页面与嵌入的-discussion-之间的映射关系。\" class=\"headerlink\" title=\"选择页面与嵌入的 discussion 之间的映射关系。\"></a>选择页面与嵌入的 discussion 之间的映射关系。</h4><p>建议选择：<strong>Discussion 的标题包含页面的 <code>pathname</code></strong></p>\n<h4 id=\"Discussion-分类\"><a href=\"#Discussion-分类\" class=\"headerlink\" title=\"Discussion 分类\"></a>Discussion 分类</h4><p>选择新 discussions 所在的分类。 推荐使用<strong>公告（announcements）</strong>类型的分类，以确保新 discussion 只能由仓库维护者和 giscus 创建。</p>\n<h4 id=\"启用-giscus\"><a href=\"#启用-giscus\" class=\"headerlink\" title=\"启用 giscus\"></a>启用 giscus</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">&lt;script src=<span class=\"hljs-string\">&quot;https://giscus.app/client.js&quot;</span><br>        data-repo=<span class=\"hljs-string\">&quot;[在此输入仓库]&quot;</span><br>        data-repo-id=<span class=\"hljs-string\">&quot;[在此输入仓库 ID]&quot;</span><br>        data-category=<span class=\"hljs-string\">&quot;[在此输入分类名]&quot;</span><br>        data-category-id=<span class=\"hljs-string\">&quot;[在此输入分类 ID]&quot;</span><br>        data-mapping=<span class=\"hljs-string\">&quot;pathname&quot;</span><br>        data-strict=<span class=\"hljs-string\">&quot;0&quot;</span><br>        data-reactions-enabled=<span class=\"hljs-string\">&quot;1&quot;</span><br>        data-emit-metadata=<span class=\"hljs-string\">&quot;0&quot;</span><br>        data-input-position=<span class=\"hljs-string\">&quot;bottom&quot;</span><br>        data-theme=<span class=\"hljs-string\">&quot;preferred_color_scheme&quot;</span><br>        data-lang=<span class=\"hljs-string\">&quot;zh-CN&quot;</span><br>        crossorigin=<span class=\"hljs-string\">&quot;anonymous&quot;</span><br>        <span class=\"hljs-keyword\">async</span>&gt;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure>\n\n<p>完成以上几项之后，上面代码段中会出现对应的repo、repoId、category、categoryId，复制下来，稍后有用。</p>\n<p>在theme.ts中添加如下配置：</p>\n<figure class=\"highlight dts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs dts\">plugins：<span class=\"hljs-punctuation\">&#123;</span><br><span class=\"hljs-symbol\">\tcomment:</span> <span class=\"hljs-punctuation\">&#123;</span><br><span class=\"hljs-symbol\">   \t\tprovider:</span> <span class=\"hljs-string\">&quot;Giscus&quot;</span>,<br><span class=\"hljs-symbol\">   \t\trepo:</span> <span class=\"hljs-string\">&quot;WL2O2O/CS_GUIDER_Giscus&quot;</span>,<br><span class=\"hljs-symbol\">  \t\trepoId:</span> <span class=\"hljs-string\">&quot;your id&quot;</span>,<br><span class=\"hljs-symbol\">   \t\tcategory:</span> <span class=\"hljs-string\">&quot;Announcements&quot;</span>,<br><span class=\"hljs-symbol\">   \t\tcategoryId:</span> <span class=\"hljs-string\">&quot;yours id&quot;</span><br> \t <span class=\"hljs-punctuation\">&#125;</span>,<br><span class=\"hljs-punctuation\">&#125;</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"解决自动部署git-pages：\"><a href=\"#解决自动部署git-pages：\" class=\"headerlink\" title=\"解决自动部署git pages：\"></a>解决自动部署git pages：</h3><p>新创建一个autopush.bat文件，将以下代码复制到文件中：</p>\n<figure class=\"highlight bat\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bat\">@<span class=\"hljs-built_in\">echo</span> off<br>git add .<br>git commit -m &quot;update article&quot;<br>git pull origin master<br>git push origin master<br></code></pre></td></tr></table></figure>\n\n<p>此时推送到gitee是正常的，但是推送之后，git pages的页面不会自动更新，于是经过百度，了解到可以通过Git的Webhooks功能，来实现git pages的自动更新。</p>\n<p>了解一下webHook：</p>\n<blockquote>\n<p>每次您 push 代码后，都会给远程 HTTP URL 发送一个 POST 请求 <a href=\"https://gitee.com/help/categories/40\">更多说明 »</a></p>\n<p>WebHook 增加对钉钉的支持 <a href=\"https://gitee.com/help/articles/4135\">更多说明 »</a></p>\n<p>WebHook 增加对企业微信的支持 <a href=\"https://gitee.com/help/articles/4296\">更多说明 »</a></p>\n<p>WebHook 增加对飞书的支持 <a href=\"https://gitee.com/help/articles/4297\">更多说明 »</a></p>\n</blockquote>\n<p>以下是在Windows系统中使用Git的Webhooks功能自动更新Gitee Pages的步骤：</p>\n<ol>\n<li>在Gitee仓库的设置页面中，找到Webhooks设置，并添加一个新的Webhook，将Payload URL设置为你的博客页面的URL。</li>\n<li>在你的Vuepress博客项目中添加一个post-commit钩子脚本，用于向Gitee仓库发送Webhooks请求，触发Gitee Pages更新。在项目的.git/hooks目录中创建一个post-commit.bat文件，内容如下：</li>\n</ol>\n<figure class=\"highlight bat\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bat\">@<span class=\"hljs-built_in\">echo</span> off<br>curl -X POST https://gitee.com/api/v5/repos/&#123;WLei224&#125;/&#123;WLei224&#125;/hooks/&#123;<span class=\"hljs-number\">0</span>c8adb9d-f0cf-<span class=\"hljs-number\">450</span>b-<span class=\"hljs-number\">8</span>d75-<span class=\"hljs-number\">3</span>cc56ac7bf3c&#125;/trigger\\?access_token\\=&#123;<span class=\"hljs-number\">583</span>af4fe8a6611d418da106c6c8bae88&#125;<br></code></pre></td></tr></table></figure>\n\n<p>将上述命令中的{用户名}、{仓库名}、{Webhook ID}和{访问令牌}替换为你自己的信息。其中，Webhook ID可以在Gitee仓库的Webhooks设置页面中找到，访问令牌可以在Gitee账号的个人设置页面中生成。</p>\n<ol>\n<li>为post-commit.bat文件添加可执行权限。在终端中进入项目的.git/hooks目录，执行以下命令：</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-built_in\">chmod</span> +x post-commit.bat<br></code></pre></td></tr></table></figure>\n\n<ol>\n<li>推送代码到Gitee仓库，当你执行git commit命令后，post-commit.bat脚本会自动发送Webhooks请求，触发Gitee Pages更新。</li>\n</ol>\n<p>通过上述步骤，你可以在Windows系统中实现自动更新Gitee Pages，提高博客发布的效率和便捷性。</p>\n<h3 id=\"博客引入思维导图\"><a href=\"#博客引入思维导图\" class=\"headerlink\" title=\"博客引入思维导图\"></a>博客引入思维导图</h3><h3 id=\"Markmap\"><a href=\"#Markmap\" class=\"headerlink\" title=\"Markmap\"></a>Markmap</h3><p>Markmap 是一个将 Markdown 转换为思维导图的工具。它相对于主题内置的 flowchart 支持更多的格式与内容。</p>\n<ol>\n<li>使用 <a href=\"https://markmap.js.org/\">Markmapopen in new window</a> 生成思维导图 HTML 文件（安装markmap插件，可以以思维导图的图形预览markdown文件，然后可选是否导出为html文件）</li>\n<li>将 HTML 文件放在 <code>.vuepress/public/</code> 下</li>\n<li>通过 <code>&lt;iframe&gt;</code> 插入到 Markdown</li>\n</ol>\n<p>输入:</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">iframe</span></span><br><span class=\"hljs-tag\">  <span class=\"hljs-attr\">:src</span>=<span class=\"hljs-string\">&quot;$withBase(&#x27;/markmap/demo-zh.html&#x27;)&quot;</span></span><br><span class=\"hljs-tag\">  <span class=\"hljs-attr\">width</span>=<span class=\"hljs-string\">&quot;100%&quot;</span></span><br><span class=\"hljs-tag\">  <span class=\"hljs-attr\">height</span>=<span class=\"hljs-string\">&quot;400&quot;</span></span><br><span class=\"hljs-tag\">  <span class=\"hljs-attr\">frameborder</span>=<span class=\"hljs-string\">&quot;0&quot;</span></span><br><span class=\"hljs-tag\">  <span class=\"hljs-attr\">scrolling</span>=<span class=\"hljs-string\">&quot;No&quot;</span></span><br><span class=\"hljs-tag\">  <span class=\"hljs-attr\">leftmargin</span>=<span class=\"hljs-string\">&quot;0&quot;</span></span><br><span class=\"hljs-tag\">  <span class=\"hljs-attr\">topmargin</span>=<span class=\"hljs-string\">&quot;0&quot;</span></span><br><span class=\"hljs-tag\">/&gt;</span><br></code></pre></td></tr></table></figure>\n\n<p>输出:</p>\n<iframe src=\"/markmap/demo-zh.html\" width=\"100%\" height=\"400\" frameborder=\"0\" scrolling=\"No\" leftmargin=\"0\" topmargin=\"0\"></iframe>\n\n<hr>\n<h3 id=\"尝试缩短博客构建时间的方法（以下是GPT生成的步骤，待测试！）\"><a href=\"#尝试缩短博客构建时间的方法（以下是GPT生成的步骤，待测试！）\" class=\"headerlink\" title=\"尝试缩短博客构建时间的方法（以下是GPT生成的步骤，待测试！）\"></a>尝试缩短博客构建时间的方法（以下是GPT生成的步骤，待测试！）</h3><p>VuePress 使用的是 Webpack 构建工具，而使用 pnpm 作为包管理器则可以大幅缩短安装依赖包的时间。然而，如果在使用 pnpm 构建 VuePress 网站时仍然遇到了速度很慢的问题，可以尝试以下几个方法：</p>\n<ol>\n<li>更新 pnpm 版本：首先，您可以尝试升级 pnpm 的版本。较新的版本通常会修复一些问题并提高性能。您可以使用以下命令来更新 pnpm：</li>\n</ol>\n   <figure class=\"highlight coffeescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs coffeescript\"><span class=\"hljs-built_in\">npm</span> i -g pnpm@latest<br></code></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li><p>切换镜像源：如果您使用的是国外的包管理器镜像源，可能会导致下载速度很慢。您可以尝试切换到国内的镜像源，例如淘宝镜像、cnpmjs 等。您可以使用以下命令来设置淘宝镜像源：</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs arduino\">pnpm config set registry https:<span class=\"hljs-comment\">//registry.npm.taobao.org</span><br></code></pre></td></tr></table></figure></li>\n<li><p>使用缓存：在第一次构建 VuePress 网站时，pnpm 会下载所有依赖包，并且可能会需要很长时间。一种解决方法是使用缓存，在下一次构建时从缓存中加载依赖包而不是重新下载。您可以使用以下命令来启用缓存：</p>\n<figure class=\"highlight jboss-cli\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs jboss-cli\">pnpm install <span class=\"hljs-params\">--shamefully-hoist</span> <span class=\"hljs-params\">--store-dir=</span><span class=\"hljs-string\">./.pnpm-store</span><br><br>在第一次构建时，pnpm 会将依赖包缓存到指定的目录中。在下一次构建时，pnpm 将从缓存中加载依赖包，而不是重新下载。<br></code></pre></td></tr></table></figure></li>\n<li><p>升级 Node.js 版本：VuePress 需要使用较新的版本的 Node.js，如果您的 Node.js 版本太旧，可能会导致构建速度变慢。您可以尝试将 Node.js 版本升级到最新版，并重新构建 VuePress 网站。</p>\n</li>\n<li><p>按需加载：如果您的 VuePress 网站包含大量的页面和组件，可以尝试使用按需加载来提高构建速度。您可以使用 VuePress 的 <code>async</code> 组件来实现按需加载，例如：</p>\n<figure class=\"highlight autohotkey\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs autohotkey\">&lt;AsyncContent path=<span class=\"hljs-string\">&quot;./path/to/file.vue&quot;</span> /&gt;<br>```<br><br>这将使 VuePress 仅在需要时才加载组件，而不是在构建时将所有组件都打包进最终的 JavaScript 文件中。<br></code></pre></td></tr></table></figure></li>\n</ol>\n<p>以上是一些可以尝试的方法来提高使用 pnpm 构建 VuePress 网站的速度。如果以上方法仍然无法解决您的问题，您可以尝试在 VuePress 官方的 GitHub 仓库中搜索类似的问题，或者在 VuePress 社区中询问其他人是否遇到了类似的问题并得到了解决方法。</p>\n<h3 id=\"要在-VuePress-中集成百度统计，您需要遵循以下步骤：\"><a href=\"#要在-VuePress-中集成百度统计，您需要遵循以下步骤：\" class=\"headerlink\" title=\"要在 VuePress 中集成百度统计，您需要遵循以下步骤：\"></a>要在 VuePress 中集成百度统计，您需要遵循以下步骤：</h3><p>在百度统计中创建站点并获取统计代码：首先，您需要在百度统计中创建一个站点，并获取相应的统计代码。在百度统计管理面板中，选择您要添加统计代码的站点，然后单击“代码管理”按钮。在“统计代码”页面中，您将看到一段 JavaScript 代码。复制该代码以备后用。</p>\n<p>在 VuePress 中创建配置文件：接下来，您需要在 VuePress 项目中创建一个配置文件。在您的 VuePress 项目根目录下，创建一个名为 .vuepress 的文件夹，然后在该文件夹中创建一个名为 config.js 的配置文件。在 config.js 文件中添加以下代码：</p>\n<figure class=\"highlight coffeescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs coffeescript\">module.<span class=\"hljs-built_in\">exports</span> = &#123;<br>  head: [<br>    [<span class=\"hljs-string\">&#x27;script&#x27;</span>, &#123;&#125;, `<span class=\"language-javascript\"></span><br><span class=\"language-javascript\">      <span class=\"hljs-keyword\">var</span> _hmt = _hmt || [];</span><br><span class=\"language-javascript\">      (<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) &#123;</span><br><span class=\"language-javascript\">        <span class=\"hljs-keyword\">var</span> hm = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">createElement</span>(<span class=\"hljs-string\">&quot;script&quot;</span>);</span><br><span class=\"language-javascript\">        hm.<span class=\"hljs-property\">src</span> = <span class=\"hljs-string\">&quot;https://hm.baidu.com/hm.js?YOUR_BAIDU_SITE_ID&quot;</span>;</span><br><span class=\"language-javascript\">        <span class=\"hljs-keyword\">var</span> s = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">getElementsByTagName</span>(<span class=\"hljs-string\">&quot;script&quot;</span>)[<span class=\"hljs-number\">0</span>]; </span><br><span class=\"language-javascript\">        s.<span class=\"hljs-property\">parentNode</span>.<span class=\"hljs-title function_\">insertBefore</span>(hm, s);</span><br><span class=\"language-javascript\">      &#125;)();</span><br><span class=\"language-javascript\">   </span>`]<br>  ]<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>在代码中，将 <code>YOUR_BAIDU_SITE_ID</code> 替换为您在百度统计中创建站点时获得的站点 ID。</p>\n<p>将配置文件添加到 Git 仓库并部署网站：完成上述步骤后，将创建的 .vuepress 文件夹和其中的 config.js 文件添加到您的 Git 仓库中，并将网站部署到您的服务器或托管平台上。如果您使用的是 GitHub Pages，您可以将 .vuepress 文件夹和其中的 config.js 文件添加到您的 GitHub 仓库中，并在仓库的设置页面中将 GitHub Pages 的源设置为“master branch /docs folder”。</p>\n<p>验证是否成功添加了百度统计：最后，您可以访问您的网站并登录到百度统计管理面板中，查看是否有网站访问数据。如果一切正常，您应该能够在百度统计中看到您网站的访问数据和用户行为数据。</p>\n<p>以上是在 VuePress 中集成百度统计的步骤和代码示例。请注意，由于百度统计的代码可能会随时更新，所以建议您在将代码添加到您的 VuePress 项目中之前，先阅读并遵循百度统计的官方文档。另外，您还可以使用 VuePress 插件来方便地集成百度统计，例如 vuepress-plugin-baidu-analytics 插件。此插件可以自动在您的 VuePress 网站中添加百度统计代码，而无需手动编辑配置文件。您可以在 VuePress 插件市场中搜索该插件，并按照其文档说明进行安装和配置。</p>\n<h3 id=\"站长工具：百度资源搜索平台\"><a href=\"#站长工具：百度资源搜索平台\" class=\"headerlink\" title=\"站长工具：百度资源搜索平台\"></a>站长工具：百度资源搜索平台</h3><blockquote>\n<p><em><strong>网站言则会那个不通过的问题：</strong></em></p>\n</blockquote>\n<p>在平台添加网站时，需要进行文件或者HTML标签进行验证，之前一直验证都不通过，昨天（23年/5月26日）根据报错信息，终于验证通过了，我选择的验证方式是文件验证，因为在vuepress博客中构建的每一个html文件添加相应的标签，我还没有找到合适的方法，于是就通过文件验证的方法进行了相关的验证，</p>\n<p>刚开始按照网站的提示，将验证文件放在网站的根目录下，然后按要求照做了，结果是一直未验证通过。点击确认验证文件可以正常访问，也访问不到相应的验证文件，然后就想着还是路径不对，然后求助了<code>ChatGpt</code>,把验证文件换了一个路径进行上传，然后问题就解决了！！！</p>\n<blockquote>\n<p><em><strong>API 提交和 Sitemap 提交应该选择哪一个？</strong></em></p>\n</blockquote>\n<p>API 提交和 Sitemap 提交都可以帮助搜索引擎更好地收录和展示您的网站数据，但是它们的作用和适用场景略有不同。</p>\n<p>API 提交是指通过将网站数据以 API 接口的形式提供给搜索引擎，让搜索引擎可以更及时、准确地获取网站数据。API 提交通常适用于动态内容和实时数据的网站，比如新闻、社交媒体、股票行情等。API 提交可以让搜索引擎更快地获取网站数据，从而更及时地更新搜索结果，提高网站曝光度和流量。</p>\n<p>Sitemap 提交是指将网站的 Sitemap 文件提交给搜索引擎，以便搜索引擎更好地了解网站的结构和内容。Sitemap 提交通常适用于静态内容和定期更新的网站，比如博客、电商网站、企业网站等。Sitemap 提交可以让搜索引擎更快地了解网站的结构和内容，从而更好地收录和展示网站的信息，提高网站的可见性和搜索排名。</p>\n<p>综合来说，API 提交和 Sitemap 提交都可以提高网站的曝光度和流量，但是它们的适用场景略有不同。对于动态内容和实时数据的网站，API 提交更为适用；对于静态内容和定期更新的网站，Sitemap 提交更为适用。在实际应用中，可以根据网站的特点和需求，选择合适的提交方式来促进网站的发展和成长。</p>\n<h3 id=\"域名备案需要服务器IP的问题\"><a href=\"#域名备案需要服务器IP的问题\" class=\"headerlink\" title=\"域名备案需要服务器IP的问题\"></a>域名备案需要服务器IP的问题</h3><blockquote>\n<p>必须要有服务器吗？</p>\n</blockquote>\n<p>根据中国互联网信息办公室的规定，如果您的个人博客使用的域名在中国大陆境内进行访问，需要进行备案才能正常访问。备案需要提供服务器的信息，包括服务器所在地、服务器的 IP 地址、备案主体信息等。</p>\n<p>如果您的个人博客部署在 GitHub Pages 或其他类似的静态网站托管服务上，而没有自己的服务器，那么备案可能会有一定的困难。因为备案需要提供服务器的信息，如果没有自己的服务器，就无法提供这些信息。此时，您可以考虑购买虚拟主机或云服务器等产品，然后将个人博客迁移到这些服务器上，再进行备案。</p>\n<p>在购买虚拟主机或云服务器时，您可以选择腾讯云或其他云服务提供商，根据自己的需求选择合适的产品类型和配置，然后将个人博客部署到服务器上。备案完成后，将域名解析到服务器的 IP地址，就可以正常访问个人博客了。</p>\n<p>需要注意的是，备案需要提供真实的备案主体信息，包括个人或单位的营业执照、身份证等证件，如果您是个人用户，需要提供有效的身份证件。因此，在进行备案之前，建议先了解备案的相关规定和流程，准备好备案所需的材料和信息，以免出现不必要的麻烦。</p>\n<p>另外，备案是一个比较复杂的过程，需要注意各个环节的细节。如果您对备案流程和规定不熟悉，建议咨询相关专业人士或官方机构的客服人员，以避免出现不必要的错误和问题。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"通过vuepress更新个人博客\"><a href=\"#通过vuepress更新个人博客\" class=\"headerlink\" title=\"通过vuepress更新个人博客\"></a>通过vuepress更新个人博客</h1><h2 id=\"博客搭建教程\"><a href=\"#博客搭建教程\" class=\"headerlink\" title=\"博客搭建教程\"></a>博客搭建教程</h2><blockquote>\n<p>本教程使用 pnpm 作为项目管理器，因为 VuePress 和 VuePress Theme Hope 都是通过 pnpm 来管理依赖的。</p>\n</blockquote>\n<h3 id=\"1、安装-Pnpm\"><a href=\"#1、安装-Pnpm\" class=\"headerlink\" title=\"1、安装 Pnpm\"></a>1、安装 Pnpm</h3><p>在终端中输入下列命令安装 pnpm:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">corepack <span class=\"hljs-built_in\">enable</span><br>corepack prepare pnpm@latest --activate<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"2、初始化项目\"><a href=\"#2、初始化项目\" class=\"headerlink\" title=\"2、初始化项目\"></a>2、初始化项目</h3><figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmd\">pnpm create vuepress-theme-hope my-docs<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"3、常用命令\"><a href=\"#3、常用命令\" class=\"headerlink\" title=\"3、常用命令\"></a>3、常用命令</h3><ul>\n<li><code>vuepress dev [dir]</code> 会启动一个开发服务器，以便让你在本地开发你的 VuePress 站点。</li>\n<li><code>vuepress build [dir]</code> 会将你的 VuePress 站点构建成静态文件，以便你进行后续部署。</li>\n</ul>\n<blockquote>\n<p>使用模板</p>\n<p>如果你在使用 VuePress Theme Hope 模板，你可以在 <code>package.json</code> 中发现下列三个命令:</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs json\"><span class=\"hljs-punctuation\">&#123;</span><br>  <span class=\"hljs-attr\">&quot;scripts&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-punctuation\">&#123;</span><br>    <span class=\"hljs-attr\">&quot;docs:build&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">&quot;vuepress build src&quot;</span><span class=\"hljs-punctuation\">,</span><br>    <span class=\"hljs-attr\">&quot;docs:clean-dev&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">&quot;vuepress dev src --clean-cache&quot;</span><span class=\"hljs-punctuation\">,</span><br>    <span class=\"hljs-attr\">&quot;docs:dev&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">&quot;vuepress dev src&quot;</span><br>  <span class=\"hljs-punctuation\">&#125;</span><br><span class=\"hljs-punctuation\">&#125;</span><br></code></pre></td></tr></table></figure>\n\n<p>这意味着你可以使用:</p>\n<ul>\n<li><code>pnpm docs:dev</code> 启动开发服务器</li>\n<li><code>pnpm docs:build</code> 构建项目并输出</li>\n<li><code>pnpm docs:clean-dev</code> 清除缓存并启动开发服务器</li>\n</ul>\n</blockquote>\n<h3 id=\"4、-升级版本\"><a href=\"#4、-升级版本\" class=\"headerlink\" title=\"4、 升级版本\"></a>4、 升级版本</h3><p>如果你需要升级主题和 VuePress 版本，请执行以下命令:</p>\n<figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmd\">pnpm dlx vp-update<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"完善基本框架\"><a href=\"#完善基本框架\" class=\"headerlink\" title=\"完善基本框架\"></a>完善基本框架</h2><h3 id=\"1、了解基本结构\"><a href=\"#1、了解基本结构\" class=\"headerlink\" title=\"1、了解基本结构\"></a>1、了解基本结构</h3><h3 id=\"2、完善导航栏以及相关配置\"><a href=\"#2、完善导航栏以及相关配置\" class=\"headerlink\" title=\"2、完善导航栏以及相关配置\"></a>2、完善导航栏以及相关配置</h3><p>3、</p>\n<p><img src=\"http://images.rl0206.love/202304181527666.png\"></p>\n<p><img src=\"http://images.rl0206.love/202304192047438.png\"></p>\n<p><img src=\"http://images.rl0206.love/202304221329083.ico\"></p>\n<h3 id=\"评论插件：Waline\"><a href=\"#评论插件：Waline\" class=\"headerlink\" title=\"评论插件：Waline\"></a><a href=\"https://plugin-comment2.vuejs.press/zh/guide/waline.html\">评论插件：Waline</a></h3><h4 id=\"数据库\"><a href=\"#数据库\" class=\"headerlink\" title=\"数据库\"></a>数据库</h4><ul>\n<li>首先登录<a href=\"https://console.leancloud.app/apps\">leancloud</a>，注册数据库，记录<code>APP ID</code>,<code>APP Key</code> 和 <code>Master Key</code>以便后续使用；</li>\n</ul>\n<h4 id=\"服务端\"><a href=\"#服务端\" class=\"headerlink\" title=\"服务端\"></a>服务端</h4><ul>\n<li>登录<a href=\"https://vercel.com/new/clone?repository-url=https://github.com/walinejs/waline/tree/main/example\">Vercel</a> 进行服务端部署，设置环境变量之后，重新部署，即可获得serveUrl。<ul>\n<li>我获取到的服务端地址：<a href=\"https://cs-guider-6cmm99f2s-wl2o2o.vercel.app/\">https://cs-guider-6cmm99f2s-wl2o2o.vercel.app/</a></li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>此时可以配置自己的域名，以便进行管理，不配置域名就通过以上服务端地址进行管理即可。</p>\n<p><strong>配置域名之后的管理网址</strong>：</p>\n<ul>\n<li>评论系统：example.your-domain.com</li>\n<li>评论管理：example.your-domain.com/ui</li>\n</ul>\n</blockquote>\n<h4 id=\"客户端\"><a href=\"#客户端\" class=\"headerlink\" title=\"客户端\"></a>客户端</h4><h4 id=\"使用插件\"><a href=\"#使用插件\" class=\"headerlink\" title=\"使用插件\"></a>使用插件</h4><p>在插件选项中设置 <code>provider: &quot;Waline&quot;</code>，同时设置服务端地址 <code>serverURL</code> 为上一步获取到的值。</p>\n<p>此时，将 <code>&lt;CommentService&gt;</code> 组件放置在你网站中合适的位置 (通常是页面的底部)，即可使用 Waline 评论功能。</p>\n<p>提示</p>\n<p>你也可以传入其他 Waline 支持的选项 (除了 <code>el</code>)。</p>\n<p>详情请见 <a href=\"https://plugin-comment2.vuejs.press/zh/config/waline.html\">Waline 配置</a></p>\n<h4 id=\"评论管理-管理端\"><a href=\"#评论管理-管理端\" class=\"headerlink\" title=\"评论管理 (管理端)\"></a>评论管理 (管理端)</h4><ol>\n<li>部署完成后，请访问 <code>&lt;serverURL&gt;/ui/register</code> 进行注册。首个注册的人会被设定成管理员。</li>\n<li>管理员登陆后，即可看到评论管理界面。在这里可以修改、标记或删除评论。</li>\n<li>用户也可通过评论框注册账号，登陆后会跳转到自己的档案页。</li>\n</ol>\n<h3 id=\"评论插件：giscus\"><a href=\"#评论插件：giscus\" class=\"headerlink\" title=\"评论插件：giscus\"></a><a href=\"https://giscus.app/zh-CN\">评论插件：giscus</a></h3><h4 id=\"选择仓库\"><a href=\"#选择仓库\" class=\"headerlink\" title=\"选择仓库\"></a>选择仓库</h4><p>选择 giscus 连接到的仓库。请确保：</p>\n<ol>\n<li>**此仓库是<a href=\"https://docs.github.com/en/github/administering-a-repository/managing-repository-settings/setting-repository-visibility#making-a-repository-public\">公开的</a>**，否则访客将无法查看 discussion。</li>\n<li><strong><a href=\"https://github.com/apps/giscus\">giscus</a> app 已安装</strong>否则访客将无法评论和回应。</li>\n<li><strong>Discussions</strong>功能已<a href=\"https://docs.github.com/en/github/administering-a-repository/managing-repository-settings/enabling-or-disabling-github-discussions-for-a-repository\">在你的仓库中启用</a>。</li>\n</ol>\n<p>仓库：（输入用户名/仓库名）</p>\n<p><em>一个*<em>公开的（public）</em></em> GitHub 仓库。Discussion 将被连接到此仓库。*</p>\n<h4 id=\"选择页面与嵌入的-discussion-之间的映射关系。\"><a href=\"#选择页面与嵌入的-discussion-之间的映射关系。\" class=\"headerlink\" title=\"选择页面与嵌入的 discussion 之间的映射关系。\"></a>选择页面与嵌入的 discussion 之间的映射关系。</h4><p>建议选择：<strong>Discussion 的标题包含页面的 <code>pathname</code></strong></p>\n<h4 id=\"Discussion-分类\"><a href=\"#Discussion-分类\" class=\"headerlink\" title=\"Discussion 分类\"></a>Discussion 分类</h4><p>选择新 discussions 所在的分类。 推荐使用<strong>公告（announcements）</strong>类型的分类，以确保新 discussion 只能由仓库维护者和 giscus 创建。</p>\n<h4 id=\"启用-giscus\"><a href=\"#启用-giscus\" class=\"headerlink\" title=\"启用 giscus\"></a>启用 giscus</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">&lt;script src=<span class=\"hljs-string\">&quot;https://giscus.app/client.js&quot;</span><br>        data-repo=<span class=\"hljs-string\">&quot;[在此输入仓库]&quot;</span><br>        data-repo-id=<span class=\"hljs-string\">&quot;[在此输入仓库 ID]&quot;</span><br>        data-category=<span class=\"hljs-string\">&quot;[在此输入分类名]&quot;</span><br>        data-category-id=<span class=\"hljs-string\">&quot;[在此输入分类 ID]&quot;</span><br>        data-mapping=<span class=\"hljs-string\">&quot;pathname&quot;</span><br>        data-strict=<span class=\"hljs-string\">&quot;0&quot;</span><br>        data-reactions-enabled=<span class=\"hljs-string\">&quot;1&quot;</span><br>        data-emit-metadata=<span class=\"hljs-string\">&quot;0&quot;</span><br>        data-input-position=<span class=\"hljs-string\">&quot;bottom&quot;</span><br>        data-theme=<span class=\"hljs-string\">&quot;preferred_color_scheme&quot;</span><br>        data-lang=<span class=\"hljs-string\">&quot;zh-CN&quot;</span><br>        crossorigin=<span class=\"hljs-string\">&quot;anonymous&quot;</span><br>        <span class=\"hljs-keyword\">async</span>&gt;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure>\n\n<p>完成以上几项之后，上面代码段中会出现对应的repo、repoId、category、categoryId，复制下来，稍后有用。</p>\n<p>在theme.ts中添加如下配置：</p>\n<figure class=\"highlight dts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs dts\">plugins：<span class=\"hljs-punctuation\">&#123;</span><br><span class=\"hljs-symbol\">\tcomment:</span> <span class=\"hljs-punctuation\">&#123;</span><br><span class=\"hljs-symbol\">   \t\tprovider:</span> <span class=\"hljs-string\">&quot;Giscus&quot;</span>,<br><span class=\"hljs-symbol\">   \t\trepo:</span> <span class=\"hljs-string\">&quot;WL2O2O/CS_GUIDER_Giscus&quot;</span>,<br><span class=\"hljs-symbol\">  \t\trepoId:</span> <span class=\"hljs-string\">&quot;your id&quot;</span>,<br><span class=\"hljs-symbol\">   \t\tcategory:</span> <span class=\"hljs-string\">&quot;Announcements&quot;</span>,<br><span class=\"hljs-symbol\">   \t\tcategoryId:</span> <span class=\"hljs-string\">&quot;yours id&quot;</span><br> \t <span class=\"hljs-punctuation\">&#125;</span>,<br><span class=\"hljs-punctuation\">&#125;</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"解决自动部署git-pages：\"><a href=\"#解决自动部署git-pages：\" class=\"headerlink\" title=\"解决自动部署git pages：\"></a>解决自动部署git pages：</h3><p>新创建一个autopush.bat文件，将以下代码复制到文件中：</p>\n<figure class=\"highlight bat\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bat\">@<span class=\"hljs-built_in\">echo</span> off<br>git add .<br>git commit -m &quot;update article&quot;<br>git pull origin master<br>git push origin master<br></code></pre></td></tr></table></figure>\n\n<p>此时推送到gitee是正常的，但是推送之后，git pages的页面不会自动更新，于是经过百度，了解到可以通过Git的Webhooks功能，来实现git pages的自动更新。</p>\n<p>了解一下webHook：</p>\n<blockquote>\n<p>每次您 push 代码后，都会给远程 HTTP URL 发送一个 POST 请求 <a href=\"https://gitee.com/help/categories/40\">更多说明 »</a></p>\n<p>WebHook 增加对钉钉的支持 <a href=\"https://gitee.com/help/articles/4135\">更多说明 »</a></p>\n<p>WebHook 增加对企业微信的支持 <a href=\"https://gitee.com/help/articles/4296\">更多说明 »</a></p>\n<p>WebHook 增加对飞书的支持 <a href=\"https://gitee.com/help/articles/4297\">更多说明 »</a></p>\n</blockquote>\n<p>以下是在Windows系统中使用Git的Webhooks功能自动更新Gitee Pages的步骤：</p>\n<ol>\n<li>在Gitee仓库的设置页面中，找到Webhooks设置，并添加一个新的Webhook，将Payload URL设置为你的博客页面的URL。</li>\n<li>在你的Vuepress博客项目中添加一个post-commit钩子脚本，用于向Gitee仓库发送Webhooks请求，触发Gitee Pages更新。在项目的.git/hooks目录中创建一个post-commit.bat文件，内容如下：</li>\n</ol>\n<figure class=\"highlight bat\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bat\">@<span class=\"hljs-built_in\">echo</span> off<br>curl -X POST https://gitee.com/api/v5/repos/&#123;WLei224&#125;/&#123;WLei224&#125;/hooks/&#123;<span class=\"hljs-number\">0</span>c8adb9d-f0cf-<span class=\"hljs-number\">450</span>b-<span class=\"hljs-number\">8</span>d75-<span class=\"hljs-number\">3</span>cc56ac7bf3c&#125;/trigger\\?access_token\\=&#123;<span class=\"hljs-number\">583</span>af4fe8a6611d418da106c6c8bae88&#125;<br></code></pre></td></tr></table></figure>\n\n<p>将上述命令中的{用户名}、{仓库名}、{Webhook ID}和{访问令牌}替换为你自己的信息。其中，Webhook ID可以在Gitee仓库的Webhooks设置页面中找到，访问令牌可以在Gitee账号的个人设置页面中生成。</p>\n<ol>\n<li>为post-commit.bat文件添加可执行权限。在终端中进入项目的.git/hooks目录，执行以下命令：</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-built_in\">chmod</span> +x post-commit.bat<br></code></pre></td></tr></table></figure>\n\n<ol>\n<li>推送代码到Gitee仓库，当你执行git commit命令后，post-commit.bat脚本会自动发送Webhooks请求，触发Gitee Pages更新。</li>\n</ol>\n<p>通过上述步骤，你可以在Windows系统中实现自动更新Gitee Pages，提高博客发布的效率和便捷性。</p>\n<h3 id=\"博客引入思维导图\"><a href=\"#博客引入思维导图\" class=\"headerlink\" title=\"博客引入思维导图\"></a>博客引入思维导图</h3><h3 id=\"Markmap\"><a href=\"#Markmap\" class=\"headerlink\" title=\"Markmap\"></a>Markmap</h3><p>Markmap 是一个将 Markdown 转换为思维导图的工具。它相对于主题内置的 flowchart 支持更多的格式与内容。</p>\n<ol>\n<li>使用 <a href=\"https://markmap.js.org/\">Markmapopen in new window</a> 生成思维导图 HTML 文件（安装markmap插件，可以以思维导图的图形预览markdown文件，然后可选是否导出为html文件）</li>\n<li>将 HTML 文件放在 <code>.vuepress/public/</code> 下</li>\n<li>通过 <code>&lt;iframe&gt;</code> 插入到 Markdown</li>\n</ol>\n<p>输入:</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">iframe</span></span><br><span class=\"hljs-tag\">  <span class=\"hljs-attr\">:src</span>=<span class=\"hljs-string\">&quot;$withBase(&#x27;/markmap/demo-zh.html&#x27;)&quot;</span></span><br><span class=\"hljs-tag\">  <span class=\"hljs-attr\">width</span>=<span class=\"hljs-string\">&quot;100%&quot;</span></span><br><span class=\"hljs-tag\">  <span class=\"hljs-attr\">height</span>=<span class=\"hljs-string\">&quot;400&quot;</span></span><br><span class=\"hljs-tag\">  <span class=\"hljs-attr\">frameborder</span>=<span class=\"hljs-string\">&quot;0&quot;</span></span><br><span class=\"hljs-tag\">  <span class=\"hljs-attr\">scrolling</span>=<span class=\"hljs-string\">&quot;No&quot;</span></span><br><span class=\"hljs-tag\">  <span class=\"hljs-attr\">leftmargin</span>=<span class=\"hljs-string\">&quot;0&quot;</span></span><br><span class=\"hljs-tag\">  <span class=\"hljs-attr\">topmargin</span>=<span class=\"hljs-string\">&quot;0&quot;</span></span><br><span class=\"hljs-tag\">/&gt;</span><br></code></pre></td></tr></table></figure>\n\n<p>输出:</p>\n<iframe src=\"/markmap/demo-zh.html\" width=\"100%\" height=\"400\" frameborder=\"0\" scrolling=\"No\" leftmargin=\"0\" topmargin=\"0\"></iframe>\n\n<hr>\n<h3 id=\"尝试缩短博客构建时间的方法（以下是GPT生成的步骤，待测试！）\"><a href=\"#尝试缩短博客构建时间的方法（以下是GPT生成的步骤，待测试！）\" class=\"headerlink\" title=\"尝试缩短博客构建时间的方法（以下是GPT生成的步骤，待测试！）\"></a>尝试缩短博客构建时间的方法（以下是GPT生成的步骤，待测试！）</h3><p>VuePress 使用的是 Webpack 构建工具，而使用 pnpm 作为包管理器则可以大幅缩短安装依赖包的时间。然而，如果在使用 pnpm 构建 VuePress 网站时仍然遇到了速度很慢的问题，可以尝试以下几个方法：</p>\n<ol>\n<li>更新 pnpm 版本：首先，您可以尝试升级 pnpm 的版本。较新的版本通常会修复一些问题并提高性能。您可以使用以下命令来更新 pnpm：</li>\n</ol>\n   <figure class=\"highlight coffeescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs coffeescript\"><span class=\"hljs-built_in\">npm</span> i -g pnpm@latest<br></code></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li><p>切换镜像源：如果您使用的是国外的包管理器镜像源，可能会导致下载速度很慢。您可以尝试切换到国内的镜像源，例如淘宝镜像、cnpmjs 等。您可以使用以下命令来设置淘宝镜像源：</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs arduino\">pnpm config set registry https:<span class=\"hljs-comment\">//registry.npm.taobao.org</span><br></code></pre></td></tr></table></figure></li>\n<li><p>使用缓存：在第一次构建 VuePress 网站时，pnpm 会下载所有依赖包，并且可能会需要很长时间。一种解决方法是使用缓存，在下一次构建时从缓存中加载依赖包而不是重新下载。您可以使用以下命令来启用缓存：</p>\n<figure class=\"highlight jboss-cli\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs jboss-cli\">pnpm install <span class=\"hljs-params\">--shamefully-hoist</span> <span class=\"hljs-params\">--store-dir=</span><span class=\"hljs-string\">./.pnpm-store</span><br><br>在第一次构建时，pnpm 会将依赖包缓存到指定的目录中。在下一次构建时，pnpm 将从缓存中加载依赖包，而不是重新下载。<br></code></pre></td></tr></table></figure></li>\n<li><p>升级 Node.js 版本：VuePress 需要使用较新的版本的 Node.js，如果您的 Node.js 版本太旧，可能会导致构建速度变慢。您可以尝试将 Node.js 版本升级到最新版，并重新构建 VuePress 网站。</p>\n</li>\n<li><p>按需加载：如果您的 VuePress 网站包含大量的页面和组件，可以尝试使用按需加载来提高构建速度。您可以使用 VuePress 的 <code>async</code> 组件来实现按需加载，例如：</p>\n<figure class=\"highlight autohotkey\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs autohotkey\">&lt;AsyncContent path=<span class=\"hljs-string\">&quot;./path/to/file.vue&quot;</span> /&gt;<br>```<br><br>这将使 VuePress 仅在需要时才加载组件，而不是在构建时将所有组件都打包进最终的 JavaScript 文件中。<br></code></pre></td></tr></table></figure></li>\n</ol>\n<p>以上是一些可以尝试的方法来提高使用 pnpm 构建 VuePress 网站的速度。如果以上方法仍然无法解决您的问题，您可以尝试在 VuePress 官方的 GitHub 仓库中搜索类似的问题，或者在 VuePress 社区中询问其他人是否遇到了类似的问题并得到了解决方法。</p>\n<h3 id=\"要在-VuePress-中集成百度统计，您需要遵循以下步骤：\"><a href=\"#要在-VuePress-中集成百度统计，您需要遵循以下步骤：\" class=\"headerlink\" title=\"要在 VuePress 中集成百度统计，您需要遵循以下步骤：\"></a>要在 VuePress 中集成百度统计，您需要遵循以下步骤：</h3><p>在百度统计中创建站点并获取统计代码：首先，您需要在百度统计中创建一个站点，并获取相应的统计代码。在百度统计管理面板中，选择您要添加统计代码的站点，然后单击“代码管理”按钮。在“统计代码”页面中，您将看到一段 JavaScript 代码。复制该代码以备后用。</p>\n<p>在 VuePress 中创建配置文件：接下来，您需要在 VuePress 项目中创建一个配置文件。在您的 VuePress 项目根目录下，创建一个名为 .vuepress 的文件夹，然后在该文件夹中创建一个名为 config.js 的配置文件。在 config.js 文件中添加以下代码：</p>\n<figure class=\"highlight coffeescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs coffeescript\">module.<span class=\"hljs-built_in\">exports</span> = &#123;<br>  head: [<br>    [<span class=\"hljs-string\">&#x27;script&#x27;</span>, &#123;&#125;, `<span class=\"language-javascript\"></span><br><span class=\"language-javascript\">      <span class=\"hljs-keyword\">var</span> _hmt = _hmt || [];</span><br><span class=\"language-javascript\">      (<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) &#123;</span><br><span class=\"language-javascript\">        <span class=\"hljs-keyword\">var</span> hm = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">createElement</span>(<span class=\"hljs-string\">&quot;script&quot;</span>);</span><br><span class=\"language-javascript\">        hm.<span class=\"hljs-property\">src</span> = <span class=\"hljs-string\">&quot;https://hm.baidu.com/hm.js?YOUR_BAIDU_SITE_ID&quot;</span>;</span><br><span class=\"language-javascript\">        <span class=\"hljs-keyword\">var</span> s = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">getElementsByTagName</span>(<span class=\"hljs-string\">&quot;script&quot;</span>)[<span class=\"hljs-number\">0</span>]; </span><br><span class=\"language-javascript\">        s.<span class=\"hljs-property\">parentNode</span>.<span class=\"hljs-title function_\">insertBefore</span>(hm, s);</span><br><span class=\"language-javascript\">      &#125;)();</span><br><span class=\"language-javascript\">   </span>`]<br>  ]<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>在代码中，将 <code>YOUR_BAIDU_SITE_ID</code> 替换为您在百度统计中创建站点时获得的站点 ID。</p>\n<p>将配置文件添加到 Git 仓库并部署网站：完成上述步骤后，将创建的 .vuepress 文件夹和其中的 config.js 文件添加到您的 Git 仓库中，并将网站部署到您的服务器或托管平台上。如果您使用的是 GitHub Pages，您可以将 .vuepress 文件夹和其中的 config.js 文件添加到您的 GitHub 仓库中，并在仓库的设置页面中将 GitHub Pages 的源设置为“master branch /docs folder”。</p>\n<p>验证是否成功添加了百度统计：最后，您可以访问您的网站并登录到百度统计管理面板中，查看是否有网站访问数据。如果一切正常，您应该能够在百度统计中看到您网站的访问数据和用户行为数据。</p>\n<p>以上是在 VuePress 中集成百度统计的步骤和代码示例。请注意，由于百度统计的代码可能会随时更新，所以建议您在将代码添加到您的 VuePress 项目中之前，先阅读并遵循百度统计的官方文档。另外，您还可以使用 VuePress 插件来方便地集成百度统计，例如 vuepress-plugin-baidu-analytics 插件。此插件可以自动在您的 VuePress 网站中添加百度统计代码，而无需手动编辑配置文件。您可以在 VuePress 插件市场中搜索该插件，并按照其文档说明进行安装和配置。</p>\n<h3 id=\"站长工具：百度资源搜索平台\"><a href=\"#站长工具：百度资源搜索平台\" class=\"headerlink\" title=\"站长工具：百度资源搜索平台\"></a>站长工具：百度资源搜索平台</h3><blockquote>\n<p><em><strong>网站言则会那个不通过的问题：</strong></em></p>\n</blockquote>\n<p>在平台添加网站时，需要进行文件或者HTML标签进行验证，之前一直验证都不通过，昨天（23年/5月26日）根据报错信息，终于验证通过了，我选择的验证方式是文件验证，因为在vuepress博客中构建的每一个html文件添加相应的标签，我还没有找到合适的方法，于是就通过文件验证的方法进行了相关的验证，</p>\n<p>刚开始按照网站的提示，将验证文件放在网站的根目录下，然后按要求照做了，结果是一直未验证通过。点击确认验证文件可以正常访问，也访问不到相应的验证文件，然后就想着还是路径不对，然后求助了<code>ChatGpt</code>,把验证文件换了一个路径进行上传，然后问题就解决了！！！</p>\n<blockquote>\n<p><em><strong>API 提交和 Sitemap 提交应该选择哪一个？</strong></em></p>\n</blockquote>\n<p>API 提交和 Sitemap 提交都可以帮助搜索引擎更好地收录和展示您的网站数据，但是它们的作用和适用场景略有不同。</p>\n<p>API 提交是指通过将网站数据以 API 接口的形式提供给搜索引擎，让搜索引擎可以更及时、准确地获取网站数据。API 提交通常适用于动态内容和实时数据的网站，比如新闻、社交媒体、股票行情等。API 提交可以让搜索引擎更快地获取网站数据，从而更及时地更新搜索结果，提高网站曝光度和流量。</p>\n<p>Sitemap 提交是指将网站的 Sitemap 文件提交给搜索引擎，以便搜索引擎更好地了解网站的结构和内容。Sitemap 提交通常适用于静态内容和定期更新的网站，比如博客、电商网站、企业网站等。Sitemap 提交可以让搜索引擎更快地了解网站的结构和内容，从而更好地收录和展示网站的信息，提高网站的可见性和搜索排名。</p>\n<p>综合来说，API 提交和 Sitemap 提交都可以提高网站的曝光度和流量，但是它们的适用场景略有不同。对于动态内容和实时数据的网站，API 提交更为适用；对于静态内容和定期更新的网站，Sitemap 提交更为适用。在实际应用中，可以根据网站的特点和需求，选择合适的提交方式来促进网站的发展和成长。</p>\n<h3 id=\"域名备案需要服务器IP的问题\"><a href=\"#域名备案需要服务器IP的问题\" class=\"headerlink\" title=\"域名备案需要服务器IP的问题\"></a>域名备案需要服务器IP的问题</h3><blockquote>\n<p>必须要有服务器吗？</p>\n</blockquote>\n<p>根据中国互联网信息办公室的规定，如果您的个人博客使用的域名在中国大陆境内进行访问，需要进行备案才能正常访问。备案需要提供服务器的信息，包括服务器所在地、服务器的 IP 地址、备案主体信息等。</p>\n<p>如果您的个人博客部署在 GitHub Pages 或其他类似的静态网站托管服务上，而没有自己的服务器，那么备案可能会有一定的困难。因为备案需要提供服务器的信息，如果没有自己的服务器，就无法提供这些信息。此时，您可以考虑购买虚拟主机或云服务器等产品，然后将个人博客迁移到这些服务器上，再进行备案。</p>\n<p>在购买虚拟主机或云服务器时，您可以选择腾讯云或其他云服务提供商，根据自己的需求选择合适的产品类型和配置，然后将个人博客部署到服务器上。备案完成后，将域名解析到服务器的 IP地址，就可以正常访问个人博客了。</p>\n<p>需要注意的是，备案需要提供真实的备案主体信息，包括个人或单位的营业执照、身份证等证件，如果您是个人用户，需要提供有效的身份证件。因此，在进行备案之前，建议先了解备案的相关规定和流程，准备好备案所需的材料和信息，以免出现不必要的麻烦。</p>\n<p>另外，备案是一个比较复杂的过程，需要注意各个环节的细节。如果您对备案流程和规定不熟悉，建议咨询相关专业人士或官方机构的客服人员，以避免出现不必要的错误和问题。</p>\n"},{"title":"hiOffer","hide":true,"abbrlink":54240,"date":"2023-09-23T13:06:01.000Z","_content":"\nBOSS您好，我对您发布的 XX 岗位很感兴趣。\n本人句由 XXX 的工作经验，上一段工作经历是在 XXX 公司担任 XXX\n\n（应届生写实习经验）\n主要负责 XXX ，XXX ，以及 XXX\n\n（主要写自己的工作内容，最好是浓缩为三点!\n  ✨✨✨这是最精髓的地方，设法吸引面试官继续看下去。）\n擅长 XXX，从〇到一 XXX ，落地 XXX，沉淀相关文档 XXX篇。\n\n（写自己的优势（人无我有，人有我精），\n   这个地方要根据 岗位的 JD 动态调整。最好是可以量化展示）\n\n熟练掌握 XXX, XXX, XXX\n\n（只写掌握，了解默认是不会\n   注意排序要按照岗位 JD 的顺序进行排列，然后加上通用技能）\n详细情况您可以看下我的简历，期待您的回复！\n\n\n\n![大佬给的招呼模板](https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202310081632483.png)\n","source":"_posts/hiOffer.md","raw":"---\ntitle: hiOffer\nhide: true\nabbrlink: 54240\ndate: 2023-09-23 21:06:01\ntags:\n---\n\nBOSS您好，我对您发布的 XX 岗位很感兴趣。\n本人句由 XXX 的工作经验，上一段工作经历是在 XXX 公司担任 XXX\n\n（应届生写实习经验）\n主要负责 XXX ，XXX ，以及 XXX\n\n（主要写自己的工作内容，最好是浓缩为三点!\n  ✨✨✨这是最精髓的地方，设法吸引面试官继续看下去。）\n擅长 XXX，从〇到一 XXX ，落地 XXX，沉淀相关文档 XXX篇。\n\n（写自己的优势（人无我有，人有我精），\n   这个地方要根据 岗位的 JD 动态调整。最好是可以量化展示）\n\n熟练掌握 XXX, XXX, XXX\n\n（只写掌握，了解默认是不会\n   注意排序要按照岗位 JD 的顺序进行排列，然后加上通用技能）\n详细情况您可以看下我的简历，期待您的回复！\n\n\n\n![大佬给的招呼模板](https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202310081632483.png)\n","slug":"hiOffer","published":1,"updated":"2023-10-16T06:58:59.288Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clpkiczj70028fkfodjjseigb","content":"<p>BOSS您好，我对您发布的 XX 岗位很感兴趣。<br>本人句由 XXX 的工作经验，上一段工作经历是在 XXX 公司担任 XXX</p>\n<p>（应届生写实习经验）<br>主要负责 XXX ，XXX ，以及 XXX</p>\n<p>（主要写自己的工作内容，最好是浓缩为三点!<br>  ✨✨✨这是最精髓的地方，设法吸引面试官继续看下去。）<br>擅长 XXX，从〇到一 XXX ，落地 XXX，沉淀相关文档 XXX篇。</p>\n<p>（写自己的优势（人无我有，人有我精），<br>   这个地方要根据 岗位的 JD 动态调整。最好是可以量化展示）</p>\n<p>熟练掌握 XXX, XXX, XXX</p>\n<p>（只写掌握，了解默认是不会<br>   注意排序要按照岗位 JD 的顺序进行排列，然后加上通用技能）<br>详细情况您可以看下我的简历，期待您的回复！</p>\n<p><img src=\"https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202310081632483.png\" alt=\"大佬给的招呼模板\"></p>\n","site":{"data":{}},"excerpt":"","more":"<p>BOSS您好，我对您发布的 XX 岗位很感兴趣。<br>本人句由 XXX 的工作经验，上一段工作经历是在 XXX 公司担任 XXX</p>\n<p>（应届生写实习经验）<br>主要负责 XXX ，XXX ，以及 XXX</p>\n<p>（主要写自己的工作内容，最好是浓缩为三点!<br>  ✨✨✨这是最精髓的地方，设法吸引面试官继续看下去。）<br>擅长 XXX，从〇到一 XXX ，落地 XXX，沉淀相关文档 XXX篇。</p>\n<p>（写自己的优势（人无我有，人有我精），<br>   这个地方要根据 岗位的 JD 动态调整。最好是可以量化展示）</p>\n<p>熟练掌握 XXX, XXX, XXX</p>\n<p>（只写掌握，了解默认是不会<br>   注意排序要按照岗位 JD 的顺序进行排列，然后加上通用技能）<br>详细情况您可以看下我的简历，期待您的回复！</p>\n<p><img src=\"https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202310081632483.png\" alt=\"大佬给的招呼模板\"></p>\n"},{"title":"项目如何从〇到一","excerpt":"项目如何从零到一，如何做好项目负责人，讲解项目立项、需求分析、组建团队的思路和方法","sticky":100,"abbrlink":62964,"date":"2023-07-02T03:23:41.000Z","_content":"***实操前须知：***\n\n> 1、准备充分：先阅读相关参考资料\n>\n> 2、付出实践：模块化学习、不断实践加强记忆\n>\n> 3、举一反三：单个模块可以熟练写出之后要举一反三、巩固学习效果\n>\n> 4、温故知新：复习笔记、时常回顾\n>\n> 3、总结反思：总结出一个问题合集，复盘用\n\n\n# 项目如何从零到一\n\n## 如何做好项目负责人\n\n**讲解项目立项、需求分析、组建团队的思路和方法**\n\n* ### 立项（立项表）\n\n  > * 需要做什么项目\n  > * 怎么招人\n  > * 怎么权衡成本\n\n  * **为什么想做**这个项目？\n  * 这个项目可以**解决什么**问题？\n    * 现有系统的痛点\n  * 这个项目的**核心亮点**是什么？\n    * \n  * 项目的取名？\n\n  \n\n* ### 调研\n\n  * xxx网\n    * 这个项目与我的有什么相似点\n    * 别人项目有什么优点？别人大而全，小而美\n    * 我的有什么缺点？\n\n* ### 需求分析（甘特图）\n\n  * 思考功能点，越详细越好\n    * 需要什么亮点的功能\n  * 优先级\n    * P0 必须有，核心，不完成不能上线\n    * P1 最好有，附加功能，有了更方便\n    * P2 建议有，\n    * P3 可有可无\n    * P4\n\n  > 了解一下需求管理工具：TAPO、jirua、表格（）\n\n  \n\n* ### 组队\n\n  * 描述自己的优势，能给别人带来什么\n  * 负责人：\n    * 1. 沟通协作的方式（微信群聊）\n      2. 文档沉淀的方法（在线文档，typora）\n      3. 确认代码协作的方式（Gitee、GitHub、gitlab）\n      4. 确认分工与对接方式（比如说前后端接口文档对接方式）\n\n## 如何做好架构师\n\n**跳出“码农”思维，从全局视角来设计一个新项目**\n\n* ### 技术选型\n\n  > 什么是技术选型？\n  >\n  > 你的团队会什么，大家熟悉什么\n  >\n  > 不用冷门技术，尽量使用热门的技术\n\n  > 根据需求：\n  >\n  > 1. 项目的量级？（百万并发，消息队列，分库分表，如果是小项目，尽量简单）\n  > 2. 项目的功能？（比如检索：可以用ES）\n\n  * 前端用什么？（小项目建议vue，大项目建议用React，方便整合JS，也看自己的熟悉程度）\n    * 那么如何决定用vue和React呢？此时就需要看你这个项目和哪一个组件库更加搭配一些，比如和Vant3搭配，那就用vue，和antDesign更搭配的话，就用React）\n    * 也即是说，根据项目实现效果来倒推，想要哪一种效果就用什么技术。 \n  * 后端用什么 \n  * 用什么上线\n  * 完成选型后的小demo\n\n  > 此时一定要确保每一个功能能够正常的跑通，防止后期版本不兼容等问题\n\n* ### 资源准备\n\n  > 需要什么资源，自然是花最少的钱，干最多的事情\n\n  * 服务器：各大厂商的服务器，一次一年\n    * 带宽（查看本地dist打开一次页面传输多少项资源（单位资源），计算方法：人数*单位资源大小）、CPU、内存、硬盘\n  * 数据库：\n  * 短信：\n  * 开发软件\n\n* ### 系统设计\n\n  > 什么是系统设计？\n  >\n  > 只用语言来进行描述，不写代码\n\n  * ### 整体设计\n\n    * 功能模块图（思维导图）\n      * 从整体到局部（先划分子系统）\n    * 技术架构图\n    * 库表设计\n    * 每个功能的实现逻辑\n      * 也就是详细设计\n\n  * ### 详细设计\n\n    > 每一个功能的大致实现流程，使用了什么的算法，也可以给每一个需求单独的开设一个实现方案文档\n\n    **eg：**\n\n    * xxx功能\n      1. 接口设计（参数、请求类型、请求体、返回值）\n      2. 流程（越详细越好，开发写代码就是按照这个逻辑**语言直接进行翻译**的）\n\n* ### 库表设计（根据需求与实际业务场景）\n\n  * 划分哪些库？（每个项目一个库）\n\n  * 划分哪些表？\n\n  * 每个表有哪些字段？\n\n  * 标语表之间的关联关系？（比如说外键？现在企业的开发中一般不用外键作为表之间的约束关系，一是因为不便于进行扩展，二是因为会影响效率。一般使用字段约定式关联！还有课上所学到的第一二三范式，第三范式一般不用）\n\n  > 设计很重要，一般来说库表一旦确定，就不会再进行更改，否则会造成库表死锁，卡住等问题，尽可能做到提前设计好，需求；\n  >\n  > id、create_time、upfate_time、is_delete（逻辑删除）正常来说每个表都需要设计id，因为你不知道这张表之后是否需要与其他表进行关联、扩展\n\n* ### 开发规范（✨✨✨）\n\n  * 编码规范\n    * 1. 人为约定（Google Java Style、Alibaba Java开发手册）\n      2. 插件（Alibaba Coding Guide、Check Style、）\n    * 前端：\n      1. Umi脚手架：`eslint`校验`js`和`ts`的语法 + `prettier`对代码进行美化 + `Stylient`检查检验`css`代码\n\n\n  > 团队开发一个项目是如何进行初始化项目呢？大的项目一般由架构师进行架构设计，个人项目或者小项目一般会进行讨论决定由哪个脚手架或者决定开发规范来进行设计。\n\n  * 提交规范（隐私保护）\n    * gitLog（约定每个需求提交的时候，进行备注统一的提交记录，例如关联需求文档）\n    * 该不该提交？（涉及真实的线上的数据库的地址，账号、密码等文件，这就需要添加到gitIgnore文件当中或者各种的Ignore文件当中）\n\n\n  > 涉及到个人经验的问题，一般项目初始化的时候便会忽略文件的提交\n\n* ### 需求排期\n\n  > 开发需求的时候尽量为每一个需求进行需求排期，私下先进行方案评估，做计划、设计、补充预估完成的时间（适当延后，两天可以完成的东西写三天，不盲目自信）\n\n## 做好开发第一步\n\n> 写在前面：\n>\n> 说说前后端如何进行协作？\n>\n> 1. 大家一起参加需求评审，明确需要做什么事情\n> 2. 前后端分别考虑需要怎么实现需求，前端找后端要接口，侯丹提供给前端哪些接口？\n> 3. 前后端对齐（确认字段与接口信息）\n> 4. 并行：前端用mock或者写死假数据，后端自己进行开发\n","source":"_posts/howtomakeproject.md","raw":"---\ntitle: 项目如何从〇到一\nexcerpt: 项目如何从零到一，如何做好项目负责人，讲解项目立项、需求分析、组建团队的思路和方法\nsticky: 100\ncategories:\n  - Project\ntags:\n  - 架构师\nabbrlink: 62964\ndate: 2023-07-02 11:23:41\n---\n***实操前须知：***\n\n> 1、准备充分：先阅读相关参考资料\n>\n> 2、付出实践：模块化学习、不断实践加强记忆\n>\n> 3、举一反三：单个模块可以熟练写出之后要举一反三、巩固学习效果\n>\n> 4、温故知新：复习笔记、时常回顾\n>\n> 3、总结反思：总结出一个问题合集，复盘用\n\n\n# 项目如何从零到一\n\n## 如何做好项目负责人\n\n**讲解项目立项、需求分析、组建团队的思路和方法**\n\n* ### 立项（立项表）\n\n  > * 需要做什么项目\n  > * 怎么招人\n  > * 怎么权衡成本\n\n  * **为什么想做**这个项目？\n  * 这个项目可以**解决什么**问题？\n    * 现有系统的痛点\n  * 这个项目的**核心亮点**是什么？\n    * \n  * 项目的取名？\n\n  \n\n* ### 调研\n\n  * xxx网\n    * 这个项目与我的有什么相似点\n    * 别人项目有什么优点？别人大而全，小而美\n    * 我的有什么缺点？\n\n* ### 需求分析（甘特图）\n\n  * 思考功能点，越详细越好\n    * 需要什么亮点的功能\n  * 优先级\n    * P0 必须有，核心，不完成不能上线\n    * P1 最好有，附加功能，有了更方便\n    * P2 建议有，\n    * P3 可有可无\n    * P4\n\n  > 了解一下需求管理工具：TAPO、jirua、表格（）\n\n  \n\n* ### 组队\n\n  * 描述自己的优势，能给别人带来什么\n  * 负责人：\n    * 1. 沟通协作的方式（微信群聊）\n      2. 文档沉淀的方法（在线文档，typora）\n      3. 确认代码协作的方式（Gitee、GitHub、gitlab）\n      4. 确认分工与对接方式（比如说前后端接口文档对接方式）\n\n## 如何做好架构师\n\n**跳出“码农”思维，从全局视角来设计一个新项目**\n\n* ### 技术选型\n\n  > 什么是技术选型？\n  >\n  > 你的团队会什么，大家熟悉什么\n  >\n  > 不用冷门技术，尽量使用热门的技术\n\n  > 根据需求：\n  >\n  > 1. 项目的量级？（百万并发，消息队列，分库分表，如果是小项目，尽量简单）\n  > 2. 项目的功能？（比如检索：可以用ES）\n\n  * 前端用什么？（小项目建议vue，大项目建议用React，方便整合JS，也看自己的熟悉程度）\n    * 那么如何决定用vue和React呢？此时就需要看你这个项目和哪一个组件库更加搭配一些，比如和Vant3搭配，那就用vue，和antDesign更搭配的话，就用React）\n    * 也即是说，根据项目实现效果来倒推，想要哪一种效果就用什么技术。 \n  * 后端用什么 \n  * 用什么上线\n  * 完成选型后的小demo\n\n  > 此时一定要确保每一个功能能够正常的跑通，防止后期版本不兼容等问题\n\n* ### 资源准备\n\n  > 需要什么资源，自然是花最少的钱，干最多的事情\n\n  * 服务器：各大厂商的服务器，一次一年\n    * 带宽（查看本地dist打开一次页面传输多少项资源（单位资源），计算方法：人数*单位资源大小）、CPU、内存、硬盘\n  * 数据库：\n  * 短信：\n  * 开发软件\n\n* ### 系统设计\n\n  > 什么是系统设计？\n  >\n  > 只用语言来进行描述，不写代码\n\n  * ### 整体设计\n\n    * 功能模块图（思维导图）\n      * 从整体到局部（先划分子系统）\n    * 技术架构图\n    * 库表设计\n    * 每个功能的实现逻辑\n      * 也就是详细设计\n\n  * ### 详细设计\n\n    > 每一个功能的大致实现流程，使用了什么的算法，也可以给每一个需求单独的开设一个实现方案文档\n\n    **eg：**\n\n    * xxx功能\n      1. 接口设计（参数、请求类型、请求体、返回值）\n      2. 流程（越详细越好，开发写代码就是按照这个逻辑**语言直接进行翻译**的）\n\n* ### 库表设计（根据需求与实际业务场景）\n\n  * 划分哪些库？（每个项目一个库）\n\n  * 划分哪些表？\n\n  * 每个表有哪些字段？\n\n  * 标语表之间的关联关系？（比如说外键？现在企业的开发中一般不用外键作为表之间的约束关系，一是因为不便于进行扩展，二是因为会影响效率。一般使用字段约定式关联！还有课上所学到的第一二三范式，第三范式一般不用）\n\n  > 设计很重要，一般来说库表一旦确定，就不会再进行更改，否则会造成库表死锁，卡住等问题，尽可能做到提前设计好，需求；\n  >\n  > id、create_time、upfate_time、is_delete（逻辑删除）正常来说每个表都需要设计id，因为你不知道这张表之后是否需要与其他表进行关联、扩展\n\n* ### 开发规范（✨✨✨）\n\n  * 编码规范\n    * 1. 人为约定（Google Java Style、Alibaba Java开发手册）\n      2. 插件（Alibaba Coding Guide、Check Style、）\n    * 前端：\n      1. Umi脚手架：`eslint`校验`js`和`ts`的语法 + `prettier`对代码进行美化 + `Stylient`检查检验`css`代码\n\n\n  > 团队开发一个项目是如何进行初始化项目呢？大的项目一般由架构师进行架构设计，个人项目或者小项目一般会进行讨论决定由哪个脚手架或者决定开发规范来进行设计。\n\n  * 提交规范（隐私保护）\n    * gitLog（约定每个需求提交的时候，进行备注统一的提交记录，例如关联需求文档）\n    * 该不该提交？（涉及真实的线上的数据库的地址，账号、密码等文件，这就需要添加到gitIgnore文件当中或者各种的Ignore文件当中）\n\n\n  > 涉及到个人经验的问题，一般项目初始化的时候便会忽略文件的提交\n\n* ### 需求排期\n\n  > 开发需求的时候尽量为每一个需求进行需求排期，私下先进行方案评估，做计划、设计、补充预估完成的时间（适当延后，两天可以完成的东西写三天，不盲目自信）\n\n## 做好开发第一步\n\n> 写在前面：\n>\n> 说说前后端如何进行协作？\n>\n> 1. 大家一起参加需求评审，明确需要做什么事情\n> 2. 前后端分别考虑需要怎么实现需求，前端找后端要接口，侯丹提供给前端哪些接口？\n> 3. 前后端对齐（确认字段与接口信息）\n> 4. 并行：前端用mock或者写死假数据，后端自己进行开发\n","slug":"howtomakeproject","published":1,"updated":"2023-10-24T03:29:08.694Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clpkiczj8002dfkfof28r4sn7","content":"<p><em><strong>实操前须知：</strong></em></p>\n<blockquote>\n<p>1、准备充分：先阅读相关参考资料</p>\n<p>2、付出实践：模块化学习、不断实践加强记忆</p>\n<p>3、举一反三：单个模块可以熟练写出之后要举一反三、巩固学习效果</p>\n<p>4、温故知新：复习笔记、时常回顾</p>\n<p>3、总结反思：总结出一个问题合集，复盘用</p>\n</blockquote>\n<h1 id=\"项目如何从零到一\"><a href=\"#项目如何从零到一\" class=\"headerlink\" title=\"项目如何从零到一\"></a>项目如何从零到一</h1><h2 id=\"如何做好项目负责人\"><a href=\"#如何做好项目负责人\" class=\"headerlink\" title=\"如何做好项目负责人\"></a>如何做好项目负责人</h2><p><strong>讲解项目立项、需求分析、组建团队的思路和方法</strong></p>\n<ul>\n<li><h3 id=\"立项（立项表）\"><a href=\"#立项（立项表）\" class=\"headerlink\" title=\"立项（立项表）\"></a>立项（立项表）</h3><blockquote>\n<ul>\n<li>需要做什么项目</li>\n<li>怎么招人</li>\n<li>怎么权衡成本</li>\n</ul>\n</blockquote>\n<ul>\n<li><strong>为什么想做</strong>这个项目？</li>\n<li>这个项目可以<strong>解决什么</strong>问题？<ul>\n<li>现有系统的痛点</li>\n</ul>\n</li>\n<li>这个项目的<strong>核心亮点</strong>是什么？<br>* </li>\n<li>项目的取名？</li>\n</ul>\n</li>\n<li><h3 id=\"调研\"><a href=\"#调研\" class=\"headerlink\" title=\"调研\"></a>调研</h3><ul>\n<li>xxx网<ul>\n<li>这个项目与我的有什么相似点</li>\n<li>别人项目有什么优点？别人大而全，小而美</li>\n<li>我的有什么缺点？</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><h3 id=\"需求分析（甘特图）\"><a href=\"#需求分析（甘特图）\" class=\"headerlink\" title=\"需求分析（甘特图）\"></a>需求分析（甘特图）</h3><ul>\n<li>思考功能点，越详细越好<ul>\n<li>需要什么亮点的功能</li>\n</ul>\n</li>\n<li>优先级<ul>\n<li>P0 必须有，核心，不完成不能上线</li>\n<li>P1 最好有，附加功能，有了更方便</li>\n<li>P2 建议有，</li>\n<li>P3 可有可无</li>\n<li>P4</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>了解一下需求管理工具：TAPO、jirua、表格（）</p>\n</blockquote>\n</li>\n<li><h3 id=\"组队\"><a href=\"#组队\" class=\"headerlink\" title=\"组队\"></a>组队</h3><ul>\n<li>描述自己的优势，能给别人带来什么</li>\n<li>负责人：<ul>\n<li><ol>\n<li>沟通协作的方式（微信群聊）</li>\n<li>文档沉淀的方法（在线文档，typora）</li>\n<li>确认代码协作的方式（Gitee、GitHub、gitlab）</li>\n<li>确认分工与对接方式（比如说前后端接口文档对接方式）</li>\n</ol>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"如何做好架构师\"><a href=\"#如何做好架构师\" class=\"headerlink\" title=\"如何做好架构师\"></a>如何做好架构师</h2><p><strong>跳出“码农”思维，从全局视角来设计一个新项目</strong></p>\n<ul>\n<li><h3 id=\"技术选型\"><a href=\"#技术选型\" class=\"headerlink\" title=\"技术选型\"></a>技术选型</h3><blockquote>\n<p>什么是技术选型？</p>\n<p>你的团队会什么，大家熟悉什么</p>\n<p>不用冷门技术，尽量使用热门的技术</p>\n</blockquote>\n<blockquote>\n<p>根据需求：</p>\n<ol>\n<li>项目的量级？（百万并发，消息队列，分库分表，如果是小项目，尽量简单）</li>\n<li>项目的功能？（比如检索：可以用ES）</li>\n</ol>\n</blockquote>\n<ul>\n<li>前端用什么？（小项目建议vue，大项目建议用React，方便整合JS，也看自己的熟悉程度）<ul>\n<li>那么如何决定用vue和React呢？此时就需要看你这个项目和哪一个组件库更加搭配一些，比如和Vant3搭配，那就用vue，和antDesign更搭配的话，就用React）</li>\n<li>也即是说，根据项目实现效果来倒推，想要哪一种效果就用什么技术。 </li>\n</ul>\n</li>\n<li>后端用什么 </li>\n<li>用什么上线</li>\n<li>完成选型后的小demo</li>\n</ul>\n<blockquote>\n<p>此时一定要确保每一个功能能够正常的跑通，防止后期版本不兼容等问题</p>\n</blockquote>\n</li>\n<li><h3 id=\"资源准备\"><a href=\"#资源准备\" class=\"headerlink\" title=\"资源准备\"></a>资源准备</h3><blockquote>\n<p>需要什么资源，自然是花最少的钱，干最多的事情</p>\n</blockquote>\n<ul>\n<li>服务器：各大厂商的服务器，一次一年<ul>\n<li>带宽（查看本地dist打开一次页面传输多少项资源（单位资源），计算方法：人数*单位资源大小）、CPU、内存、硬盘</li>\n</ul>\n</li>\n<li>数据库：</li>\n<li>短信：</li>\n<li>开发软件</li>\n</ul>\n</li>\n<li><h3 id=\"系统设计\"><a href=\"#系统设计\" class=\"headerlink\" title=\"系统设计\"></a>系统设计</h3><blockquote>\n<p>什么是系统设计？</p>\n<p>只用语言来进行描述，不写代码</p>\n</blockquote>\n<ul>\n<li><h3 id=\"整体设计\"><a href=\"#整体设计\" class=\"headerlink\" title=\"整体设计\"></a>整体设计</h3><ul>\n<li>功能模块图（思维导图）<ul>\n<li>从整体到局部（先划分子系统）</li>\n</ul>\n</li>\n<li>技术架构图</li>\n<li>库表设计</li>\n<li>每个功能的实现逻辑<ul>\n<li>也就是详细设计</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><h3 id=\"详细设计\"><a href=\"#详细设计\" class=\"headerlink\" title=\"详细设计\"></a>详细设计</h3><blockquote>\n<p>每一个功能的大致实现流程，使用了什么的算法，也可以给每一个需求单独的开设一个实现方案文档</p>\n</blockquote>\n<p><strong>eg：</strong></p>\n<ul>\n<li>xxx功能<ol>\n<li>接口设计（参数、请求类型、请求体、返回值）</li>\n<li>流程（越详细越好，开发写代码就是按照这个逻辑<strong>语言直接进行翻译</strong>的）</li>\n</ol>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><h3 id=\"库表设计（根据需求与实际业务场景）\"><a href=\"#库表设计（根据需求与实际业务场景）\" class=\"headerlink\" title=\"库表设计（根据需求与实际业务场景）\"></a>库表设计（根据需求与实际业务场景）</h3><ul>\n<li><p>划分哪些库？（每个项目一个库）</p>\n</li>\n<li><p>划分哪些表？</p>\n</li>\n<li><p>每个表有哪些字段？</p>\n</li>\n<li><p>标语表之间的关联关系？（比如说外键？现在企业的开发中一般不用外键作为表之间的约束关系，一是因为不便于进行扩展，二是因为会影响效率。一般使用字段约定式关联！还有课上所学到的第一二三范式，第三范式一般不用）</p>\n</li>\n</ul>\n<blockquote>\n<p>设计很重要，一般来说库表一旦确定，就不会再进行更改，否则会造成库表死锁，卡住等问题，尽可能做到提前设计好，需求；</p>\n<p>id、create_time、upfate_time、is_delete（逻辑删除）正常来说每个表都需要设计id，因为你不知道这张表之后是否需要与其他表进行关联、扩展</p>\n</blockquote>\n</li>\n<li><h3 id=\"开发规范（✨✨✨）\"><a href=\"#开发规范（✨✨✨）\" class=\"headerlink\" title=\"开发规范（✨✨✨）\"></a>开发规范（✨✨✨）</h3><ul>\n<li>编码规范<ul>\n<li><ol>\n<li>人为约定（Google Java Style、Alibaba Java开发手册）</li>\n<li>插件（Alibaba Coding Guide、Check Style、）</li>\n</ol>\n</li>\n<li>前端：<ol>\n<li>Umi脚手架：<code>eslint</code>校验<code>js</code>和<code>ts</code>的语法 + <code>prettier</code>对代码进行美化 + <code>Stylient</code>检查检验<code>css</code>代码</li>\n</ol>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>团队开发一个项目是如何进行初始化项目呢？大的项目一般由架构师进行架构设计，个人项目或者小项目一般会进行讨论决定由哪个脚手架或者决定开发规范来进行设计。</p>\n</blockquote>\n<ul>\n<li>提交规范（隐私保护）<ul>\n<li>gitLog（约定每个需求提交的时候，进行备注统一的提交记录，例如关联需求文档）</li>\n<li>该不该提交？（涉及真实的线上的数据库的地址，账号、密码等文件，这就需要添加到gitIgnore文件当中或者各种的Ignore文件当中）</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>涉及到个人经验的问题，一般项目初始化的时候便会忽略文件的提交</p>\n</blockquote>\n<ul>\n<li><h3 id=\"需求排期\"><a href=\"#需求排期\" class=\"headerlink\" title=\"需求排期\"></a>需求排期</h3><blockquote>\n<p>开发需求的时候尽量为每一个需求进行需求排期，私下先进行方案评估，做计划、设计、补充预估完成的时间（适当延后，两天可以完成的东西写三天，不盲目自信）</p>\n</blockquote>\n</li>\n</ul>\n<h2 id=\"做好开发第一步\"><a href=\"#做好开发第一步\" class=\"headerlink\" title=\"做好开发第一步\"></a>做好开发第一步</h2><blockquote>\n<p>写在前面：</p>\n<p>说说前后端如何进行协作？</p>\n<ol>\n<li>大家一起参加需求评审，明确需要做什么事情</li>\n<li>前后端分别考虑需要怎么实现需求，前端找后端要接口，侯丹提供给前端哪些接口？</li>\n<li>前后端对齐（确认字段与接口信息）</li>\n<li>并行：前端用mock或者写死假数据，后端自己进行开发</li>\n</ol>\n</blockquote>\n","site":{"data":{}},"more":"<p><em><strong>实操前须知：</strong></em></p>\n<blockquote>\n<p>1、准备充分：先阅读相关参考资料</p>\n<p>2、付出实践：模块化学习、不断实践加强记忆</p>\n<p>3、举一反三：单个模块可以熟练写出之后要举一反三、巩固学习效果</p>\n<p>4、温故知新：复习笔记、时常回顾</p>\n<p>3、总结反思：总结出一个问题合集，复盘用</p>\n</blockquote>\n<h1 id=\"项目如何从零到一\"><a href=\"#项目如何从零到一\" class=\"headerlink\" title=\"项目如何从零到一\"></a>项目如何从零到一</h1><h2 id=\"如何做好项目负责人\"><a href=\"#如何做好项目负责人\" class=\"headerlink\" title=\"如何做好项目负责人\"></a>如何做好项目负责人</h2><p><strong>讲解项目立项、需求分析、组建团队的思路和方法</strong></p>\n<ul>\n<li><h3 id=\"立项（立项表）\"><a href=\"#立项（立项表）\" class=\"headerlink\" title=\"立项（立项表）\"></a>立项（立项表）</h3><blockquote>\n<ul>\n<li>需要做什么项目</li>\n<li>怎么招人</li>\n<li>怎么权衡成本</li>\n</ul>\n</blockquote>\n<ul>\n<li><strong>为什么想做</strong>这个项目？</li>\n<li>这个项目可以<strong>解决什么</strong>问题？<ul>\n<li>现有系统的痛点</li>\n</ul>\n</li>\n<li>这个项目的<strong>核心亮点</strong>是什么？<br>* </li>\n<li>项目的取名？</li>\n</ul>\n</li>\n<li><h3 id=\"调研\"><a href=\"#调研\" class=\"headerlink\" title=\"调研\"></a>调研</h3><ul>\n<li>xxx网<ul>\n<li>这个项目与我的有什么相似点</li>\n<li>别人项目有什么优点？别人大而全，小而美</li>\n<li>我的有什么缺点？</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><h3 id=\"需求分析（甘特图）\"><a href=\"#需求分析（甘特图）\" class=\"headerlink\" title=\"需求分析（甘特图）\"></a>需求分析（甘特图）</h3><ul>\n<li>思考功能点，越详细越好<ul>\n<li>需要什么亮点的功能</li>\n</ul>\n</li>\n<li>优先级<ul>\n<li>P0 必须有，核心，不完成不能上线</li>\n<li>P1 最好有，附加功能，有了更方便</li>\n<li>P2 建议有，</li>\n<li>P3 可有可无</li>\n<li>P4</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>了解一下需求管理工具：TAPO、jirua、表格（）</p>\n</blockquote>\n</li>\n<li><h3 id=\"组队\"><a href=\"#组队\" class=\"headerlink\" title=\"组队\"></a>组队</h3><ul>\n<li>描述自己的优势，能给别人带来什么</li>\n<li>负责人：<ul>\n<li><ol>\n<li>沟通协作的方式（微信群聊）</li>\n<li>文档沉淀的方法（在线文档，typora）</li>\n<li>确认代码协作的方式（Gitee、GitHub、gitlab）</li>\n<li>确认分工与对接方式（比如说前后端接口文档对接方式）</li>\n</ol>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"如何做好架构师\"><a href=\"#如何做好架构师\" class=\"headerlink\" title=\"如何做好架构师\"></a>如何做好架构师</h2><p><strong>跳出“码农”思维，从全局视角来设计一个新项目</strong></p>\n<ul>\n<li><h3 id=\"技术选型\"><a href=\"#技术选型\" class=\"headerlink\" title=\"技术选型\"></a>技术选型</h3><blockquote>\n<p>什么是技术选型？</p>\n<p>你的团队会什么，大家熟悉什么</p>\n<p>不用冷门技术，尽量使用热门的技术</p>\n</blockquote>\n<blockquote>\n<p>根据需求：</p>\n<ol>\n<li>项目的量级？（百万并发，消息队列，分库分表，如果是小项目，尽量简单）</li>\n<li>项目的功能？（比如检索：可以用ES）</li>\n</ol>\n</blockquote>\n<ul>\n<li>前端用什么？（小项目建议vue，大项目建议用React，方便整合JS，也看自己的熟悉程度）<ul>\n<li>那么如何决定用vue和React呢？此时就需要看你这个项目和哪一个组件库更加搭配一些，比如和Vant3搭配，那就用vue，和antDesign更搭配的话，就用React）</li>\n<li>也即是说，根据项目实现效果来倒推，想要哪一种效果就用什么技术。 </li>\n</ul>\n</li>\n<li>后端用什么 </li>\n<li>用什么上线</li>\n<li>完成选型后的小demo</li>\n</ul>\n<blockquote>\n<p>此时一定要确保每一个功能能够正常的跑通，防止后期版本不兼容等问题</p>\n</blockquote>\n</li>\n<li><h3 id=\"资源准备\"><a href=\"#资源准备\" class=\"headerlink\" title=\"资源准备\"></a>资源准备</h3><blockquote>\n<p>需要什么资源，自然是花最少的钱，干最多的事情</p>\n</blockquote>\n<ul>\n<li>服务器：各大厂商的服务器，一次一年<ul>\n<li>带宽（查看本地dist打开一次页面传输多少项资源（单位资源），计算方法：人数*单位资源大小）、CPU、内存、硬盘</li>\n</ul>\n</li>\n<li>数据库：</li>\n<li>短信：</li>\n<li>开发软件</li>\n</ul>\n</li>\n<li><h3 id=\"系统设计\"><a href=\"#系统设计\" class=\"headerlink\" title=\"系统设计\"></a>系统设计</h3><blockquote>\n<p>什么是系统设计？</p>\n<p>只用语言来进行描述，不写代码</p>\n</blockquote>\n<ul>\n<li><h3 id=\"整体设计\"><a href=\"#整体设计\" class=\"headerlink\" title=\"整体设计\"></a>整体设计</h3><ul>\n<li>功能模块图（思维导图）<ul>\n<li>从整体到局部（先划分子系统）</li>\n</ul>\n</li>\n<li>技术架构图</li>\n<li>库表设计</li>\n<li>每个功能的实现逻辑<ul>\n<li>也就是详细设计</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><h3 id=\"详细设计\"><a href=\"#详细设计\" class=\"headerlink\" title=\"详细设计\"></a>详细设计</h3><blockquote>\n<p>每一个功能的大致实现流程，使用了什么的算法，也可以给每一个需求单独的开设一个实现方案文档</p>\n</blockquote>\n<p><strong>eg：</strong></p>\n<ul>\n<li>xxx功能<ol>\n<li>接口设计（参数、请求类型、请求体、返回值）</li>\n<li>流程（越详细越好，开发写代码就是按照这个逻辑<strong>语言直接进行翻译</strong>的）</li>\n</ol>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><h3 id=\"库表设计（根据需求与实际业务场景）\"><a href=\"#库表设计（根据需求与实际业务场景）\" class=\"headerlink\" title=\"库表设计（根据需求与实际业务场景）\"></a>库表设计（根据需求与实际业务场景）</h3><ul>\n<li><p>划分哪些库？（每个项目一个库）</p>\n</li>\n<li><p>划分哪些表？</p>\n</li>\n<li><p>每个表有哪些字段？</p>\n</li>\n<li><p>标语表之间的关联关系？（比如说外键？现在企业的开发中一般不用外键作为表之间的约束关系，一是因为不便于进行扩展，二是因为会影响效率。一般使用字段约定式关联！还有课上所学到的第一二三范式，第三范式一般不用）</p>\n</li>\n</ul>\n<blockquote>\n<p>设计很重要，一般来说库表一旦确定，就不会再进行更改，否则会造成库表死锁，卡住等问题，尽可能做到提前设计好，需求；</p>\n<p>id、create_time、upfate_time、is_delete（逻辑删除）正常来说每个表都需要设计id，因为你不知道这张表之后是否需要与其他表进行关联、扩展</p>\n</blockquote>\n</li>\n<li><h3 id=\"开发规范（✨✨✨）\"><a href=\"#开发规范（✨✨✨）\" class=\"headerlink\" title=\"开发规范（✨✨✨）\"></a>开发规范（✨✨✨）</h3><ul>\n<li>编码规范<ul>\n<li><ol>\n<li>人为约定（Google Java Style、Alibaba Java开发手册）</li>\n<li>插件（Alibaba Coding Guide、Check Style、）</li>\n</ol>\n</li>\n<li>前端：<ol>\n<li>Umi脚手架：<code>eslint</code>校验<code>js</code>和<code>ts</code>的语法 + <code>prettier</code>对代码进行美化 + <code>Stylient</code>检查检验<code>css</code>代码</li>\n</ol>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>团队开发一个项目是如何进行初始化项目呢？大的项目一般由架构师进行架构设计，个人项目或者小项目一般会进行讨论决定由哪个脚手架或者决定开发规范来进行设计。</p>\n</blockquote>\n<ul>\n<li>提交规范（隐私保护）<ul>\n<li>gitLog（约定每个需求提交的时候，进行备注统一的提交记录，例如关联需求文档）</li>\n<li>该不该提交？（涉及真实的线上的数据库的地址，账号、密码等文件，这就需要添加到gitIgnore文件当中或者各种的Ignore文件当中）</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>涉及到个人经验的问题，一般项目初始化的时候便会忽略文件的提交</p>\n</blockquote>\n<ul>\n<li><h3 id=\"需求排期\"><a href=\"#需求排期\" class=\"headerlink\" title=\"需求排期\"></a>需求排期</h3><blockquote>\n<p>开发需求的时候尽量为每一个需求进行需求排期，私下先进行方案评估，做计划、设计、补充预估完成的时间（适当延后，两天可以完成的东西写三天，不盲目自信）</p>\n</blockquote>\n</li>\n</ul>\n<h2 id=\"做好开发第一步\"><a href=\"#做好开发第一步\" class=\"headerlink\" title=\"做好开发第一步\"></a>做好开发第一步</h2><blockquote>\n<p>写在前面：</p>\n<p>说说前后端如何进行协作？</p>\n<ol>\n<li>大家一起参加需求评审，明确需要做什么事情</li>\n<li>前后端分别考虑需要怎么实现需求，前端找后端要接口，侯丹提供给前端哪些接口？</li>\n<li>前后端对齐（确认字段与接口信息）</li>\n<li>并行：前端用mock或者写死假数据，后端自己进行开发</li>\n</ol>\n</blockquote>\n"},{"title":"云上个人书库","excerpt":"项目介绍：基于华为云鲲鹏ECS搭建的无广告、简洁、便捷的个人书库。","abbrlink":65275,"date":"2023-08-01T05:58:32.000Z","_content":"\n# 云上个人书库\n\n## 项目介绍\n\n基于华为云鲲鹏ECS搭建的无广告、简洁、便捷的个人书库。\n\n## 搭建方案\n\n![搭建方案图](https://cdn.jsdelivr.net/gh/wl2o2o/blogCdn/img/202308141150924.png)\n\n\n\n\n\n步骤 1  长时间未操作弹性云服务器远程登录界面而登出，忘记宝塔登录的业务平面地址，可输入以下指令重新查看面板入口。\n\n```shell\n/etc/init.d/bt default\n```\n\n","source":"_posts/library.md","raw":"---\ntitle: 云上个人书库\nexcerpt: 项目介绍：基于华为云鲲鹏ECS搭建的无广告、简洁、便捷的个人书库。\ncategories:\n  - Project\ntags:\n  - 云上书库\nabbrlink: 65275\ndate: 2023-08-01 13:58:32\n---\n\n# 云上个人书库\n\n## 项目介绍\n\n基于华为云鲲鹏ECS搭建的无广告、简洁、便捷的个人书库。\n\n## 搭建方案\n\n![搭建方案图](https://cdn.jsdelivr.net/gh/wl2o2o/blogCdn/img/202308141150924.png)\n\n\n\n\n\n步骤 1  长时间未操作弹性云服务器远程登录界面而登出，忘记宝塔登录的业务平面地址，可输入以下指令重新查看面板入口。\n\n```shell\n/etc/init.d/bt default\n```\n\n","slug":"library","published":1,"updated":"2023-10-16T06:58:59.293Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clpkiczj9002gfkfo9c7tc510","content":"<h1 id=\"云上个人书库\"><a href=\"#云上个人书库\" class=\"headerlink\" title=\"云上个人书库\"></a>云上个人书库</h1><h2 id=\"项目介绍\"><a href=\"#项目介绍\" class=\"headerlink\" title=\"项目介绍\"></a>项目介绍</h2><p>基于华为云鲲鹏ECS搭建的无广告、简洁、便捷的个人书库。</p>\n<h2 id=\"搭建方案\"><a href=\"#搭建方案\" class=\"headerlink\" title=\"搭建方案\"></a>搭建方案</h2><p><img src=\"https://cdn.jsdelivr.net/gh/wl2o2o/blogCdn/img/202308141150924.png\" alt=\"搭建方案图\"></p>\n<p>步骤 1  长时间未操作弹性云服务器远程登录界面而登出，忘记宝塔登录的业务平面地址，可输入以下指令重新查看面板入口。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">/etc/init.d/bt default<br></code></pre></td></tr></table></figure>\n\n","site":{"data":{}},"more":"<h1 id=\"云上个人书库\"><a href=\"#云上个人书库\" class=\"headerlink\" title=\"云上个人书库\"></a>云上个人书库</h1><h2 id=\"项目介绍\"><a href=\"#项目介绍\" class=\"headerlink\" title=\"项目介绍\"></a>项目介绍</h2><p>基于华为云鲲鹏ECS搭建的无广告、简洁、便捷的个人书库。</p>\n<h2 id=\"搭建方案\"><a href=\"#搭建方案\" class=\"headerlink\" title=\"搭建方案\"></a>搭建方案</h2><p><img src=\"https://cdn.jsdelivr.net/gh/wl2o2o/blogCdn/img/202308141150924.png\" alt=\"搭建方案图\"></p>\n<p>步骤 1  长时间未操作弹性云服务器远程登录界面而登出，忘记宝塔登录的业务平面地址，可输入以下指令重新查看面板入口。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">/etc/init.d/bt default<br></code></pre></td></tr></table></figure>\n\n"},{"title":"一篇文章搞懂 log4j 的使用方法","abbrlink":11624,"date":"2023-09-21T16:33:33.000Z","_content":"\n# 一篇文章搞懂 MyBatis 配置 log4j 的使用方法\n\n> [Log4j](https://logging.apache.org/log4j/2.x/index.html)是 Apache 的一个开源项目，通过使用Log4j，我们可以控制日志信息输送的目的地是控制台、文件、GUI组件，甚至是套接口服务器、NT的事件记录器、UNIX Syslog 守护进程等；我们也可以控制每一条日志的输出格式；通过定义每一条日志信息的级别，我们能够更加细致地控制日志的生成过程。最令人感兴趣的就是，这些可以通过一个配置文件来灵活地进行配置，而不需要修改应用的代码。\n>\n> ​\t\t\t\t\t\t\t\t\t——————摘自百度百科\n\n## 一、引入依赖\n\n```xml\n<dependency>\n            <groupId>log4j</groupId>\n            <artifactId>log4j</artifactId>\n            <version>1.2.12</version>\n</dependency>\n```\n\n## 二、在`mybatis-config.xml`文件加入 setting 标签\n\n```xml\n<!--设置使用的日志类型-->\n<settings>\n    <setting name=\"logImpl\" value=\"LOG4J\"/>\n</settings>\n```\n\n### `mybatis-config.xml`文件模板:\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-config.dtd\">\n\n<!--MyBatis配置-->\n<configuration>\n\n    <!--添加properties配置文件路径(外部配置、动态替换)-->\n    <properties resource=\"database.properties\" />\n\n    <!--设置使用的日志类型-->\n    <settings>\n        <setting name=\"logImpl\" value=\"LOG4J\"/>\n    </settings>\n\n    <!--JDBC环境配置、选中默认环境-->\n    <environments default=\"MySqlDB\">\n        <!--MySql数据库环境配置-->\n        <environment id=\"MySqlDB\">\n            <!--事务管理-->\n            <transactionManager type=\"JDBC\"/>\n            <!--连接池-->\n            <dataSource type=\"POOLED\">\n                <property name=\"driver\" value=\"${driver}\"/>\n                <property name=\"url\" value=\"${url}\"/>\n                <property name=\"username\" value=\"${username}\"/>\n                <property name=\"password\" value=\"${password}\"/>\n            </dataSource>\n        </environment>\n    </environments>\n\n\n\n    <!--Mapper注册-->\n    <mappers>\n        <!--注册Mapper文件的所在位置-->\n        <mapper resource=\"mapper/UserMapper.xml\"/>\n    </mappers>\n</configuration>\n```\n\n### `database.properties`配置文件模板：\n\n```properties\n#key=value\ndriver=com.mysql.cj.jdbc.Driver\nurl=jdbc:mysql://localhost:3306/test?characterEncoding=utf8&useSSL=false&serverTimezone=Asia/Shanghai\nusername=root\npassword=root\n```\n\n\n\n## 三、在 resources 目录下创建log4j.properties并写入：\n\n```properties\n#将等级为DEBUG的日志信息输出到console和file这两个目的地，console和file的定义在下面的代码\nlog4j.rootLogger=DEBUG,console,file\n \n#控制台输出的相关设置\nlog4j.appender.console = org.apache.log4j.ConsoleAppender\nlog4j.appender.console.Target = System.out\nlog4j.appender.console.Threshold=DEBUG\n#布局\nlog4j.appender.console.layout = org.apache.log4j.PatternLayout\n#日志格式\nlog4j.appender.console.layout.ConversionPattern=[%c]-%m%n\n \n#文件输出的相关设置\nlog4j.appender.file = org.apache.log4j.RollingFileAppender\n#生成文件的名字\nlog4j.appender.file.File=./log/shao.log\n#文件最大大小\nlog4j.appender.file.MaxFileSize=10mb\nlog4j.appender.file.Threshold=DEBUG\nlog4j.appender.file.layout=org.apache.log4j.PatternLayout\nlog4j.appender.file.layout.ConversionPattern=[%p][%d{yy-MM-dd}][%c]%m%n\n \n#日志输出级别\nlog4j.logger.org.mybatis=DEBUG\nlog4j.logger.java.sql=DEBUG\nlog4j.logger.java.sql.Statement=DEBUG\nlog4j.logger.java.sql.ResultSet=DEBUG\nlog4j.logger.java.sql.PreparedStatement=DEBUG\n```\n\n## 四、运行测试\n\n![测试成功](https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202309220052332.png)\n\nover！\n","source":"_posts/log4j.md","raw":"---\ntitle: 一篇文章搞懂 log4j 的使用方法\ncategories:\n  - 框架\ntags:\n  - MyBatis\n  - Logging Services\nabbrlink: 11624\ndate: 2023-09-22 00:33:33\n---\n\n# 一篇文章搞懂 MyBatis 配置 log4j 的使用方法\n\n> [Log4j](https://logging.apache.org/log4j/2.x/index.html)是 Apache 的一个开源项目，通过使用Log4j，我们可以控制日志信息输送的目的地是控制台、文件、GUI组件，甚至是套接口服务器、NT的事件记录器、UNIX Syslog 守护进程等；我们也可以控制每一条日志的输出格式；通过定义每一条日志信息的级别，我们能够更加细致地控制日志的生成过程。最令人感兴趣的就是，这些可以通过一个配置文件来灵活地进行配置，而不需要修改应用的代码。\n>\n> ​\t\t\t\t\t\t\t\t\t——————摘自百度百科\n\n## 一、引入依赖\n\n```xml\n<dependency>\n            <groupId>log4j</groupId>\n            <artifactId>log4j</artifactId>\n            <version>1.2.12</version>\n</dependency>\n```\n\n## 二、在`mybatis-config.xml`文件加入 setting 标签\n\n```xml\n<!--设置使用的日志类型-->\n<settings>\n    <setting name=\"logImpl\" value=\"LOG4J\"/>\n</settings>\n```\n\n### `mybatis-config.xml`文件模板:\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-config.dtd\">\n\n<!--MyBatis配置-->\n<configuration>\n\n    <!--添加properties配置文件路径(外部配置、动态替换)-->\n    <properties resource=\"database.properties\" />\n\n    <!--设置使用的日志类型-->\n    <settings>\n        <setting name=\"logImpl\" value=\"LOG4J\"/>\n    </settings>\n\n    <!--JDBC环境配置、选中默认环境-->\n    <environments default=\"MySqlDB\">\n        <!--MySql数据库环境配置-->\n        <environment id=\"MySqlDB\">\n            <!--事务管理-->\n            <transactionManager type=\"JDBC\"/>\n            <!--连接池-->\n            <dataSource type=\"POOLED\">\n                <property name=\"driver\" value=\"${driver}\"/>\n                <property name=\"url\" value=\"${url}\"/>\n                <property name=\"username\" value=\"${username}\"/>\n                <property name=\"password\" value=\"${password}\"/>\n            </dataSource>\n        </environment>\n    </environments>\n\n\n\n    <!--Mapper注册-->\n    <mappers>\n        <!--注册Mapper文件的所在位置-->\n        <mapper resource=\"mapper/UserMapper.xml\"/>\n    </mappers>\n</configuration>\n```\n\n### `database.properties`配置文件模板：\n\n```properties\n#key=value\ndriver=com.mysql.cj.jdbc.Driver\nurl=jdbc:mysql://localhost:3306/test?characterEncoding=utf8&useSSL=false&serverTimezone=Asia/Shanghai\nusername=root\npassword=root\n```\n\n\n\n## 三、在 resources 目录下创建log4j.properties并写入：\n\n```properties\n#将等级为DEBUG的日志信息输出到console和file这两个目的地，console和file的定义在下面的代码\nlog4j.rootLogger=DEBUG,console,file\n \n#控制台输出的相关设置\nlog4j.appender.console = org.apache.log4j.ConsoleAppender\nlog4j.appender.console.Target = System.out\nlog4j.appender.console.Threshold=DEBUG\n#布局\nlog4j.appender.console.layout = org.apache.log4j.PatternLayout\n#日志格式\nlog4j.appender.console.layout.ConversionPattern=[%c]-%m%n\n \n#文件输出的相关设置\nlog4j.appender.file = org.apache.log4j.RollingFileAppender\n#生成文件的名字\nlog4j.appender.file.File=./log/shao.log\n#文件最大大小\nlog4j.appender.file.MaxFileSize=10mb\nlog4j.appender.file.Threshold=DEBUG\nlog4j.appender.file.layout=org.apache.log4j.PatternLayout\nlog4j.appender.file.layout.ConversionPattern=[%p][%d{yy-MM-dd}][%c]%m%n\n \n#日志输出级别\nlog4j.logger.org.mybatis=DEBUG\nlog4j.logger.java.sql=DEBUG\nlog4j.logger.java.sql.Statement=DEBUG\nlog4j.logger.java.sql.ResultSet=DEBUG\nlog4j.logger.java.sql.PreparedStatement=DEBUG\n```\n\n## 四、运行测试\n\n![测试成功](https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202309220052332.png)\n\nover！\n","slug":"log4j","published":1,"updated":"2023-10-16T06:58:59.291Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clpkiczja002kfkfo7j9y7hii","content":"<h1 id=\"一篇文章搞懂-MyBatis-配置-log4j-的使用方法\"><a href=\"#一篇文章搞懂-MyBatis-配置-log4j-的使用方法\" class=\"headerlink\" title=\"一篇文章搞懂 MyBatis 配置 log4j 的使用方法\"></a>一篇文章搞懂 MyBatis 配置 log4j 的使用方法</h1><blockquote>\n<p><a href=\"https://logging.apache.org/log4j/2.x/index.html\">Log4j</a>是 Apache 的一个开源项目，通过使用Log4j，我们可以控制日志信息输送的目的地是控制台、文件、GUI组件，甚至是套接口服务器、NT的事件记录器、UNIX Syslog 守护进程等；我们也可以控制每一条日志的输出格式；通过定义每一条日志信息的级别，我们能够更加细致地控制日志的生成过程。最令人感兴趣的就是，这些可以通过一个配置文件来灵活地进行配置，而不需要修改应用的代码。</p>\n<p>​                                    ——————摘自百度百科</p>\n</blockquote>\n<h2 id=\"一、引入依赖\"><a href=\"#一、引入依赖\" class=\"headerlink\" title=\"一、引入依赖\"></a>一、引入依赖</h2><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span><br>            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>log4j<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span><br>            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>log4j<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span><br>            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>1.2.12<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"二、在mybatis-config-xml文件加入-setting-标签\"><a href=\"#二、在mybatis-config-xml文件加入-setting-标签\" class=\"headerlink\" title=\"二、在mybatis-config.xml文件加入 setting 标签\"></a>二、在<code>mybatis-config.xml</code>文件加入 setting 标签</h2><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs xml\"><span class=\"hljs-comment\">&lt;!--设置使用的日志类型--&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">settings</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">setting</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;logImpl&quot;</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">&quot;LOG4J&quot;</span>/&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">settings</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"mybatis-config-xml文件模板\"><a href=\"#mybatis-config-xml文件模板\" class=\"headerlink\" title=\"mybatis-config.xml文件模板:\"></a><code>mybatis-config.xml</code>文件模板:</h3><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs xml\"><span class=\"hljs-meta\">&lt;?xml version=<span class=\"hljs-string\">&quot;1.0&quot;</span> encoding=<span class=\"hljs-string\">&quot;UTF-8&quot;</span> ?&gt;</span><br><span class=\"hljs-meta\">&lt;!DOCTYPE <span class=\"hljs-keyword\">configuration</span> <span class=\"hljs-keyword\">PUBLIC</span> <span class=\"hljs-string\">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span><br><span class=\"hljs-meta\">        <span class=\"hljs-string\">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span><br><br><span class=\"hljs-comment\">&lt;!--MyBatis配置--&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">configuration</span>&gt;</span><br><br>    <span class=\"hljs-comment\">&lt;!--添加properties配置文件路径(外部配置、动态替换)--&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">properties</span> <span class=\"hljs-attr\">resource</span>=<span class=\"hljs-string\">&quot;database.properties&quot;</span> /&gt;</span><br><br>    <span class=\"hljs-comment\">&lt;!--设置使用的日志类型--&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">settings</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">setting</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;logImpl&quot;</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">&quot;LOG4J&quot;</span>/&gt;</span><br>    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">settings</span>&gt;</span><br><br>    <span class=\"hljs-comment\">&lt;!--JDBC环境配置、选中默认环境--&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">environments</span> <span class=\"hljs-attr\">default</span>=<span class=\"hljs-string\">&quot;MySqlDB&quot;</span>&gt;</span><br>        <span class=\"hljs-comment\">&lt;!--MySql数据库环境配置--&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">environment</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;MySqlDB&quot;</span>&gt;</span><br>            <span class=\"hljs-comment\">&lt;!--事务管理--&gt;</span><br>            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">transactionManager</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;JDBC&quot;</span>/&gt;</span><br>            <span class=\"hljs-comment\">&lt;!--连接池--&gt;</span><br>            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dataSource</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;POOLED&quot;</span>&gt;</span><br>                <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">property</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;driver&quot;</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">&quot;$&#123;driver&#125;&quot;</span>/&gt;</span><br>                <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">property</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;url&quot;</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">&quot;$&#123;url&#125;&quot;</span>/&gt;</span><br>                <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">property</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;username&quot;</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">&quot;$&#123;username&#125;&quot;</span>/&gt;</span><br>                <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">property</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;password&quot;</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">&quot;$&#123;password&#125;&quot;</span>/&gt;</span><br>            <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dataSource</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">environment</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">environments</span>&gt;</span><br><br><br><br>    <span class=\"hljs-comment\">&lt;!--Mapper注册--&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">mappers</span>&gt;</span><br>        <span class=\"hljs-comment\">&lt;!--注册Mapper文件的所在位置--&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">mapper</span> <span class=\"hljs-attr\">resource</span>=<span class=\"hljs-string\">&quot;mapper/UserMapper.xml&quot;</span>/&gt;</span><br>    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">mappers</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">configuration</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"database-properties配置文件模板：\"><a href=\"#database-properties配置文件模板：\" class=\"headerlink\" title=\"database.properties配置文件模板：\"></a><code>database.properties</code>配置文件模板：</h3><figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs properties\"><span class=\"hljs-comment\">#key=value</span><br><span class=\"hljs-attr\">driver</span>=<span class=\"hljs-string\">com.mysql.cj.jdbc.Driver</span><br><span class=\"hljs-attr\">url</span>=<span class=\"hljs-string\">jdbc:mysql://localhost:3306/test?characterEncoding=utf8&amp;useSSL=false&amp;serverTimezone=Asia/Shanghai</span><br><span class=\"hljs-attr\">username</span>=<span class=\"hljs-string\">root</span><br><span class=\"hljs-attr\">password</span>=<span class=\"hljs-string\">root</span><br></code></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"三、在-resources-目录下创建log4j-properties并写入：\"><a href=\"#三、在-resources-目录下创建log4j-properties并写入：\" class=\"headerlink\" title=\"三、在 resources 目录下创建log4j.properties并写入：\"></a>三、在 resources 目录下创建log4j.properties并写入：</h2><figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs properties\"><span class=\"hljs-comment\">#将等级为DEBUG的日志信息输出到console和file这两个目的地，console和file的定义在下面的代码</span><br><span class=\"hljs-attr\">log4j.rootLogger</span>=<span class=\"hljs-string\">DEBUG,console,file</span><br><span class=\"hljs-comment\"> </span><br><span class=\"hljs-comment\">#控制台输出的相关设置</span><br><span class=\"hljs-attr\">log4j.appender.console</span> = <span class=\"hljs-string\">org.apache.log4j.ConsoleAppender</span><br><span class=\"hljs-attr\">log4j.appender.console.Target</span> = <span class=\"hljs-string\">System.out</span><br><span class=\"hljs-attr\">log4j.appender.console.Threshold</span>=<span class=\"hljs-string\">DEBUG</span><br><span class=\"hljs-comment\">#布局</span><br><span class=\"hljs-attr\">log4j.appender.console.layout</span> = <span class=\"hljs-string\">org.apache.log4j.PatternLayout</span><br><span class=\"hljs-comment\">#日志格式</span><br><span class=\"hljs-attr\">log4j.appender.console.layout.ConversionPattern</span>=<span class=\"hljs-string\">[%c]-%m%n</span><br><span class=\"hljs-comment\"> </span><br><span class=\"hljs-comment\">#文件输出的相关设置</span><br><span class=\"hljs-attr\">log4j.appender.file</span> = <span class=\"hljs-string\">org.apache.log4j.RollingFileAppender</span><br><span class=\"hljs-comment\">#生成文件的名字</span><br><span class=\"hljs-attr\">log4j.appender.file.File</span>=<span class=\"hljs-string\">./log/shao.log</span><br><span class=\"hljs-comment\">#文件最大大小</span><br><span class=\"hljs-attr\">log4j.appender.file.MaxFileSize</span>=<span class=\"hljs-string\">10mb</span><br><span class=\"hljs-attr\">log4j.appender.file.Threshold</span>=<span class=\"hljs-string\">DEBUG</span><br><span class=\"hljs-attr\">log4j.appender.file.layout</span>=<span class=\"hljs-string\">org.apache.log4j.PatternLayout</span><br><span class=\"hljs-attr\">log4j.appender.file.layout.ConversionPattern</span>=<span class=\"hljs-string\">[%p][%d&#123;yy-MM-dd&#125;][%c]%m%n</span><br><span class=\"hljs-comment\"> </span><br><span class=\"hljs-comment\">#日志输出级别</span><br><span class=\"hljs-attr\">log4j.logger.org.mybatis</span>=<span class=\"hljs-string\">DEBUG</span><br><span class=\"hljs-attr\">log4j.logger.java.sql</span>=<span class=\"hljs-string\">DEBUG</span><br><span class=\"hljs-attr\">log4j.logger.java.sql.Statement</span>=<span class=\"hljs-string\">DEBUG</span><br><span class=\"hljs-attr\">log4j.logger.java.sql.ResultSet</span>=<span class=\"hljs-string\">DEBUG</span><br><span class=\"hljs-attr\">log4j.logger.java.sql.PreparedStatement</span>=<span class=\"hljs-string\">DEBUG</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"四、运行测试\"><a href=\"#四、运行测试\" class=\"headerlink\" title=\"四、运行测试\"></a>四、运行测试</h2><p><img src=\"https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202309220052332.png\" alt=\"测试成功\"></p>\n<p>over！</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"一篇文章搞懂-MyBatis-配置-log4j-的使用方法\"><a href=\"#一篇文章搞懂-MyBatis-配置-log4j-的使用方法\" class=\"headerlink\" title=\"一篇文章搞懂 MyBatis 配置 log4j 的使用方法\"></a>一篇文章搞懂 MyBatis 配置 log4j 的使用方法</h1><blockquote>\n<p><a href=\"https://logging.apache.org/log4j/2.x/index.html\">Log4j</a>是 Apache 的一个开源项目，通过使用Log4j，我们可以控制日志信息输送的目的地是控制台、文件、GUI组件，甚至是套接口服务器、NT的事件记录器、UNIX Syslog 守护进程等；我们也可以控制每一条日志的输出格式；通过定义每一条日志信息的级别，我们能够更加细致地控制日志的生成过程。最令人感兴趣的就是，这些可以通过一个配置文件来灵活地进行配置，而不需要修改应用的代码。</p>\n<p>​                                    ——————摘自百度百科</p>\n</blockquote>\n<h2 id=\"一、引入依赖\"><a href=\"#一、引入依赖\" class=\"headerlink\" title=\"一、引入依赖\"></a>一、引入依赖</h2><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span><br>            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>log4j<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span><br>            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>log4j<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span><br>            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>1.2.12<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"二、在mybatis-config-xml文件加入-setting-标签\"><a href=\"#二、在mybatis-config-xml文件加入-setting-标签\" class=\"headerlink\" title=\"二、在mybatis-config.xml文件加入 setting 标签\"></a>二、在<code>mybatis-config.xml</code>文件加入 setting 标签</h2><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs xml\"><span class=\"hljs-comment\">&lt;!--设置使用的日志类型--&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">settings</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">setting</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;logImpl&quot;</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">&quot;LOG4J&quot;</span>/&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">settings</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"mybatis-config-xml文件模板\"><a href=\"#mybatis-config-xml文件模板\" class=\"headerlink\" title=\"mybatis-config.xml文件模板:\"></a><code>mybatis-config.xml</code>文件模板:</h3><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs xml\"><span class=\"hljs-meta\">&lt;?xml version=<span class=\"hljs-string\">&quot;1.0&quot;</span> encoding=<span class=\"hljs-string\">&quot;UTF-8&quot;</span> ?&gt;</span><br><span class=\"hljs-meta\">&lt;!DOCTYPE <span class=\"hljs-keyword\">configuration</span> <span class=\"hljs-keyword\">PUBLIC</span> <span class=\"hljs-string\">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span><br><span class=\"hljs-meta\">        <span class=\"hljs-string\">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span><br><br><span class=\"hljs-comment\">&lt;!--MyBatis配置--&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">configuration</span>&gt;</span><br><br>    <span class=\"hljs-comment\">&lt;!--添加properties配置文件路径(外部配置、动态替换)--&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">properties</span> <span class=\"hljs-attr\">resource</span>=<span class=\"hljs-string\">&quot;database.properties&quot;</span> /&gt;</span><br><br>    <span class=\"hljs-comment\">&lt;!--设置使用的日志类型--&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">settings</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">setting</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;logImpl&quot;</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">&quot;LOG4J&quot;</span>/&gt;</span><br>    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">settings</span>&gt;</span><br><br>    <span class=\"hljs-comment\">&lt;!--JDBC环境配置、选中默认环境--&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">environments</span> <span class=\"hljs-attr\">default</span>=<span class=\"hljs-string\">&quot;MySqlDB&quot;</span>&gt;</span><br>        <span class=\"hljs-comment\">&lt;!--MySql数据库环境配置--&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">environment</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;MySqlDB&quot;</span>&gt;</span><br>            <span class=\"hljs-comment\">&lt;!--事务管理--&gt;</span><br>            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">transactionManager</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;JDBC&quot;</span>/&gt;</span><br>            <span class=\"hljs-comment\">&lt;!--连接池--&gt;</span><br>            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dataSource</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;POOLED&quot;</span>&gt;</span><br>                <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">property</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;driver&quot;</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">&quot;$&#123;driver&#125;&quot;</span>/&gt;</span><br>                <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">property</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;url&quot;</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">&quot;$&#123;url&#125;&quot;</span>/&gt;</span><br>                <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">property</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;username&quot;</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">&quot;$&#123;username&#125;&quot;</span>/&gt;</span><br>                <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">property</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;password&quot;</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">&quot;$&#123;password&#125;&quot;</span>/&gt;</span><br>            <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dataSource</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">environment</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">environments</span>&gt;</span><br><br><br><br>    <span class=\"hljs-comment\">&lt;!--Mapper注册--&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">mappers</span>&gt;</span><br>        <span class=\"hljs-comment\">&lt;!--注册Mapper文件的所在位置--&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">mapper</span> <span class=\"hljs-attr\">resource</span>=<span class=\"hljs-string\">&quot;mapper/UserMapper.xml&quot;</span>/&gt;</span><br>    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">mappers</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">configuration</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"database-properties配置文件模板：\"><a href=\"#database-properties配置文件模板：\" class=\"headerlink\" title=\"database.properties配置文件模板：\"></a><code>database.properties</code>配置文件模板：</h3><figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs properties\"><span class=\"hljs-comment\">#key=value</span><br><span class=\"hljs-attr\">driver</span>=<span class=\"hljs-string\">com.mysql.cj.jdbc.Driver</span><br><span class=\"hljs-attr\">url</span>=<span class=\"hljs-string\">jdbc:mysql://localhost:3306/test?characterEncoding=utf8&amp;useSSL=false&amp;serverTimezone=Asia/Shanghai</span><br><span class=\"hljs-attr\">username</span>=<span class=\"hljs-string\">root</span><br><span class=\"hljs-attr\">password</span>=<span class=\"hljs-string\">root</span><br></code></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"三、在-resources-目录下创建log4j-properties并写入：\"><a href=\"#三、在-resources-目录下创建log4j-properties并写入：\" class=\"headerlink\" title=\"三、在 resources 目录下创建log4j.properties并写入：\"></a>三、在 resources 目录下创建log4j.properties并写入：</h2><figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs properties\"><span class=\"hljs-comment\">#将等级为DEBUG的日志信息输出到console和file这两个目的地，console和file的定义在下面的代码</span><br><span class=\"hljs-attr\">log4j.rootLogger</span>=<span class=\"hljs-string\">DEBUG,console,file</span><br><span class=\"hljs-comment\"> </span><br><span class=\"hljs-comment\">#控制台输出的相关设置</span><br><span class=\"hljs-attr\">log4j.appender.console</span> = <span class=\"hljs-string\">org.apache.log4j.ConsoleAppender</span><br><span class=\"hljs-attr\">log4j.appender.console.Target</span> = <span class=\"hljs-string\">System.out</span><br><span class=\"hljs-attr\">log4j.appender.console.Threshold</span>=<span class=\"hljs-string\">DEBUG</span><br><span class=\"hljs-comment\">#布局</span><br><span class=\"hljs-attr\">log4j.appender.console.layout</span> = <span class=\"hljs-string\">org.apache.log4j.PatternLayout</span><br><span class=\"hljs-comment\">#日志格式</span><br><span class=\"hljs-attr\">log4j.appender.console.layout.ConversionPattern</span>=<span class=\"hljs-string\">[%c]-%m%n</span><br><span class=\"hljs-comment\"> </span><br><span class=\"hljs-comment\">#文件输出的相关设置</span><br><span class=\"hljs-attr\">log4j.appender.file</span> = <span class=\"hljs-string\">org.apache.log4j.RollingFileAppender</span><br><span class=\"hljs-comment\">#生成文件的名字</span><br><span class=\"hljs-attr\">log4j.appender.file.File</span>=<span class=\"hljs-string\">./log/shao.log</span><br><span class=\"hljs-comment\">#文件最大大小</span><br><span class=\"hljs-attr\">log4j.appender.file.MaxFileSize</span>=<span class=\"hljs-string\">10mb</span><br><span class=\"hljs-attr\">log4j.appender.file.Threshold</span>=<span class=\"hljs-string\">DEBUG</span><br><span class=\"hljs-attr\">log4j.appender.file.layout</span>=<span class=\"hljs-string\">org.apache.log4j.PatternLayout</span><br><span class=\"hljs-attr\">log4j.appender.file.layout.ConversionPattern</span>=<span class=\"hljs-string\">[%p][%d&#123;yy-MM-dd&#125;][%c]%m%n</span><br><span class=\"hljs-comment\"> </span><br><span class=\"hljs-comment\">#日志输出级别</span><br><span class=\"hljs-attr\">log4j.logger.org.mybatis</span>=<span class=\"hljs-string\">DEBUG</span><br><span class=\"hljs-attr\">log4j.logger.java.sql</span>=<span class=\"hljs-string\">DEBUG</span><br><span class=\"hljs-attr\">log4j.logger.java.sql.Statement</span>=<span class=\"hljs-string\">DEBUG</span><br><span class=\"hljs-attr\">log4j.logger.java.sql.ResultSet</span>=<span class=\"hljs-string\">DEBUG</span><br><span class=\"hljs-attr\">log4j.logger.java.sql.PreparedStatement</span>=<span class=\"hljs-string\">DEBUG</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"四、运行测试\"><a href=\"#四、运行测试\" class=\"headerlink\" title=\"四、运行测试\"></a>四、运行测试</h2><p><img src=\"https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202309220052332.png\" alt=\"测试成功\"></p>\n<p>over！</p>\n"},{"title":"MySQL笔记","index_img":"https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311151627638.png","abbrlink":45387,"date":"2023-01-06T10:23:52.000Z","_content":"# MySQL 的逻辑架构图![](https://cdn.jsdelivr.net/gh/wl2o2o/blogCdn/img/202306061044225.png)\n\n\n\nmysql可以分为server层和存储引擎层两部分，其中，Server层包括连接器、分析器、查询缓存、优化器、执行器；存储引擎层负责数据的存储和提取。其架构模式是插件式的，支持 InnoDB、MyISAM、Memory 等多个存储引擎。现在最常用的存储引擎是 InnoDB，它从 MySQL 5.5.5 版本开始成为了默认存储引擎。也就是说，你执行 create table 建表的时候，如果不指定引擎类型，默认使用的就是 InnoDB。不过，你也可以通过指定存储引擎的类型来选择别的引擎，比如在 create table 语句中使用 engine=memory, 来指定使用内存引擎创建表。不同存储引擎的表数据存取方式不同，支持的功能也不同，在后面的文章中，我们会讨论到引擎的选择。从图中不难看出，不同的存储引擎共用一个 Server 层，也就是从连接器到执行器的部分。你可以先对每个组件的名字有个印象，接下来我会结合开头提到的那条 SQL 语句，带你走一遍整个执行流程，依次看下每个组件的作用。\n\n## 从简单的查询语句分析sql语句执行流程：\n\n> 连接——>查询缓存——>分析器——>优化器——>执行器\n\n### 连接阶段：\n\n```cmd\nmysql -h$ip -P$port -u$user -p\n```\n\n虽然密码也可以直接跟在 -p 后面写在命令行中，但这样可能会导致你的密码泄露。如果你连的是生产服务器，强烈建议你不要这么做。\n\n* 连接命令中的 mysql 是客户端工具，用来跟服务端建立连接。在完成经典的 TCP 握手后，连接器就要开始认证你的身份，这个时候用的就是你输入的用户名和密码。\n\n* 如果用户名或密码不对，你就会收到一个\"Access denied for user\"的错误，然后客户端程序结束执行。如果用户名密码认证通过，连接器会到权限表里面查出你拥有的权限。之后，这个连接里面的权限判断逻辑，都将依赖于此时读到的权限。\n\n连接完成后，如果你没有后续的动作，这个连接就处于空闲状态，你可以在 `show processlist `命令中看到它。文本中这个图是 `show processlist` 的结果，其中的 Command 列显示为“Sleep”的这一行，就表示现在系统里面有一个空闲连接。\n\n![](https://static001.geekbang.org/resource/image/f2/ed/f2da4aa3a672d48ec05df97b9f992fed.png?wh=875*163)\n\n客户端如果太长时间没动静，连接器就会自动将它断开。这个时间是由参数 wait_timeout 控制的，默认值是 8 小时。\n\n数据库里面，长连接是指连接成功后，如果客户端持续有请求，则一直使用同一个连接。短连接则是指每次执行完很少的几次查询就断开连接，下次查询再重新建立一个。建立连接的过程通常是比较复杂的，所以我建议你在使用中要尽量减少建立连接的动作，也就是尽量使用长连接。但是全部使用长连接后，你可能会发现，有些时候 MySQL 占用内存涨得特别快，这是因为 MySQL 在执行过程中临时使用的内存是管理在连接对象里面的。这些资源会在连接断开的时候才释放。所以如果长连接累积下来，可能导致内存占用太大，被系统强行杀掉（OOM），从现象看就是 MySQL 异常重启了。\n\n为了防止这种情况的出现，\n\n* 定期断开长连接。使用一段时间，或者程序里面判断执行过一个占用内存的大查询后，断开连接，之后要查询再重连。\n* 如果你用的是 MySQL 5.7 或更新版本，可以在每次执行一个比较大的操作后，通过执行 `mysql_reset_connection `来重新初始化连接资源。这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚刚创建完时的状态。\n\n### 查询缓存：\n\n拿到一个查询请求后，会先到查询缓存看看，之前是不是执行过这条语句。之前执行过的语句及其结果可能会以 key-value 对的形式，被直接缓存在内存中。查询到后直接返回结果，反而则执行下一步的执行阶段。\n\n但是，建议不要使用查询缓存，因为查询缓存往往弊大于利。查询缓存的失效非常频繁，只要有对一个表的更新，这个表上所有的查询缓存都会被清空。对于更新压力大的数据库来说，查询缓存的命中率会非常低。除非你的业务就是有一张静态表，很长时间才会更新一次。比如，一个系统配置表，那这张表上的查询才适合使用查询缓存。\n\n待补充... ...","source":"_posts/mysql.md","raw":"---\ntitle: MySQL笔记\nindex_img: >-\n  https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311151627638.png\ncategories:\n  - Database\ntags:\n  - MySQL\nabbrlink: 45387\ndate: 2023-01-06 18:23:52\n---\n# MySQL 的逻辑架构图![](https://cdn.jsdelivr.net/gh/wl2o2o/blogCdn/img/202306061044225.png)\n\n\n\nmysql可以分为server层和存储引擎层两部分，其中，Server层包括连接器、分析器、查询缓存、优化器、执行器；存储引擎层负责数据的存储和提取。其架构模式是插件式的，支持 InnoDB、MyISAM、Memory 等多个存储引擎。现在最常用的存储引擎是 InnoDB，它从 MySQL 5.5.5 版本开始成为了默认存储引擎。也就是说，你执行 create table 建表的时候，如果不指定引擎类型，默认使用的就是 InnoDB。不过，你也可以通过指定存储引擎的类型来选择别的引擎，比如在 create table 语句中使用 engine=memory, 来指定使用内存引擎创建表。不同存储引擎的表数据存取方式不同，支持的功能也不同，在后面的文章中，我们会讨论到引擎的选择。从图中不难看出，不同的存储引擎共用一个 Server 层，也就是从连接器到执行器的部分。你可以先对每个组件的名字有个印象，接下来我会结合开头提到的那条 SQL 语句，带你走一遍整个执行流程，依次看下每个组件的作用。\n\n## 从简单的查询语句分析sql语句执行流程：\n\n> 连接——>查询缓存——>分析器——>优化器——>执行器\n\n### 连接阶段：\n\n```cmd\nmysql -h$ip -P$port -u$user -p\n```\n\n虽然密码也可以直接跟在 -p 后面写在命令行中，但这样可能会导致你的密码泄露。如果你连的是生产服务器，强烈建议你不要这么做。\n\n* 连接命令中的 mysql 是客户端工具，用来跟服务端建立连接。在完成经典的 TCP 握手后，连接器就要开始认证你的身份，这个时候用的就是你输入的用户名和密码。\n\n* 如果用户名或密码不对，你就会收到一个\"Access denied for user\"的错误，然后客户端程序结束执行。如果用户名密码认证通过，连接器会到权限表里面查出你拥有的权限。之后，这个连接里面的权限判断逻辑，都将依赖于此时读到的权限。\n\n连接完成后，如果你没有后续的动作，这个连接就处于空闲状态，你可以在 `show processlist `命令中看到它。文本中这个图是 `show processlist` 的结果，其中的 Command 列显示为“Sleep”的这一行，就表示现在系统里面有一个空闲连接。\n\n![](https://static001.geekbang.org/resource/image/f2/ed/f2da4aa3a672d48ec05df97b9f992fed.png?wh=875*163)\n\n客户端如果太长时间没动静，连接器就会自动将它断开。这个时间是由参数 wait_timeout 控制的，默认值是 8 小时。\n\n数据库里面，长连接是指连接成功后，如果客户端持续有请求，则一直使用同一个连接。短连接则是指每次执行完很少的几次查询就断开连接，下次查询再重新建立一个。建立连接的过程通常是比较复杂的，所以我建议你在使用中要尽量减少建立连接的动作，也就是尽量使用长连接。但是全部使用长连接后，你可能会发现，有些时候 MySQL 占用内存涨得特别快，这是因为 MySQL 在执行过程中临时使用的内存是管理在连接对象里面的。这些资源会在连接断开的时候才释放。所以如果长连接累积下来，可能导致内存占用太大，被系统强行杀掉（OOM），从现象看就是 MySQL 异常重启了。\n\n为了防止这种情况的出现，\n\n* 定期断开长连接。使用一段时间，或者程序里面判断执行过一个占用内存的大查询后，断开连接，之后要查询再重连。\n* 如果你用的是 MySQL 5.7 或更新版本，可以在每次执行一个比较大的操作后，通过执行 `mysql_reset_connection `来重新初始化连接资源。这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚刚创建完时的状态。\n\n### 查询缓存：\n\n拿到一个查询请求后，会先到查询缓存看看，之前是不是执行过这条语句。之前执行过的语句及其结果可能会以 key-value 对的形式，被直接缓存在内存中。查询到后直接返回结果，反而则执行下一步的执行阶段。\n\n但是，建议不要使用查询缓存，因为查询缓存往往弊大于利。查询缓存的失效非常频繁，只要有对一个表的更新，这个表上所有的查询缓存都会被清空。对于更新压力大的数据库来说，查询缓存的命中率会非常低。除非你的业务就是有一张静态表，很长时间才会更新一次。比如，一个系统配置表，那这张表上的查询才适合使用查询缓存。\n\n待补充... ...","slug":"mysql","published":1,"updated":"2023-11-15T08:38:26.206Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clpkiczjc002nfkfo5599dkyd","content":"<h1 id=\"MySQL-的逻辑架构图\"><a href=\"#MySQL-的逻辑架构图\" class=\"headerlink\" title=\"MySQL 的逻辑架构图\"></a>MySQL 的逻辑架构图<img src=\"https://cdn.jsdelivr.net/gh/wl2o2o/blogCdn/img/202306061044225.png\"></h1><p>mysql可以分为server层和存储引擎层两部分，其中，Server层包括连接器、分析器、查询缓存、优化器、执行器；存储引擎层负责数据的存储和提取。其架构模式是插件式的，支持 InnoDB、MyISAM、Memory 等多个存储引擎。现在最常用的存储引擎是 InnoDB，它从 MySQL 5.5.5 版本开始成为了默认存储引擎。也就是说，你执行 create table 建表的时候，如果不指定引擎类型，默认使用的就是 InnoDB。不过，你也可以通过指定存储引擎的类型来选择别的引擎，比如在 create table 语句中使用 engine=memory, 来指定使用内存引擎创建表。不同存储引擎的表数据存取方式不同，支持的功能也不同，在后面的文章中，我们会讨论到引擎的选择。从图中不难看出，不同的存储引擎共用一个 Server 层，也就是从连接器到执行器的部分。你可以先对每个组件的名字有个印象，接下来我会结合开头提到的那条 SQL 语句，带你走一遍整个执行流程，依次看下每个组件的作用。</p>\n<h2 id=\"从简单的查询语句分析sql语句执行流程：\"><a href=\"#从简单的查询语句分析sql语句执行流程：\" class=\"headerlink\" title=\"从简单的查询语句分析sql语句执行流程：\"></a>从简单的查询语句分析sql语句执行流程：</h2><blockquote>\n<p>连接——&gt;查询缓存——&gt;分析器——&gt;优化器——&gt;执行器</p>\n</blockquote>\n<h3 id=\"连接阶段：\"><a href=\"#连接阶段：\" class=\"headerlink\" title=\"连接阶段：\"></a>连接阶段：</h3><figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmd\">mysql -h$ip -P$port -u$user -p<br></code></pre></td></tr></table></figure>\n\n<p>虽然密码也可以直接跟在 -p 后面写在命令行中，但这样可能会导致你的密码泄露。如果你连的是生产服务器，强烈建议你不要这么做。</p>\n<ul>\n<li><p>连接命令中的 mysql 是客户端工具，用来跟服务端建立连接。在完成经典的 TCP 握手后，连接器就要开始认证你的身份，这个时候用的就是你输入的用户名和密码。</p>\n</li>\n<li><p>如果用户名或密码不对，你就会收到一个”Access denied for user”的错误，然后客户端程序结束执行。如果用户名密码认证通过，连接器会到权限表里面查出你拥有的权限。之后，这个连接里面的权限判断逻辑，都将依赖于此时读到的权限。</p>\n</li>\n</ul>\n<p>连接完成后，如果你没有后续的动作，这个连接就处于空闲状态，你可以在 <code>show processlist </code>命令中看到它。文本中这个图是 <code>show processlist</code> 的结果，其中的 Command 列显示为“Sleep”的这一行，就表示现在系统里面有一个空闲连接。</p>\n<p><img src=\"https://static001.geekbang.org/resource/image/f2/ed/f2da4aa3a672d48ec05df97b9f992fed.png?wh=875*163\"></p>\n<p>客户端如果太长时间没动静，连接器就会自动将它断开。这个时间是由参数 wait_timeout 控制的，默认值是 8 小时。</p>\n<p>数据库里面，长连接是指连接成功后，如果客户端持续有请求，则一直使用同一个连接。短连接则是指每次执行完很少的几次查询就断开连接，下次查询再重新建立一个。建立连接的过程通常是比较复杂的，所以我建议你在使用中要尽量减少建立连接的动作，也就是尽量使用长连接。但是全部使用长连接后，你可能会发现，有些时候 MySQL 占用内存涨得特别快，这是因为 MySQL 在执行过程中临时使用的内存是管理在连接对象里面的。这些资源会在连接断开的时候才释放。所以如果长连接累积下来，可能导致内存占用太大，被系统强行杀掉（OOM），从现象看就是 MySQL 异常重启了。</p>\n<p>为了防止这种情况的出现，</p>\n<ul>\n<li>定期断开长连接。使用一段时间，或者程序里面判断执行过一个占用内存的大查询后，断开连接，之后要查询再重连。</li>\n<li>如果你用的是 MySQL 5.7 或更新版本，可以在每次执行一个比较大的操作后，通过执行 <code>mysql_reset_connection </code>来重新初始化连接资源。这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚刚创建完时的状态。</li>\n</ul>\n<h3 id=\"查询缓存：\"><a href=\"#查询缓存：\" class=\"headerlink\" title=\"查询缓存：\"></a>查询缓存：</h3><p>拿到一个查询请求后，会先到查询缓存看看，之前是不是执行过这条语句。之前执行过的语句及其结果可能会以 key-value 对的形式，被直接缓存在内存中。查询到后直接返回结果，反而则执行下一步的执行阶段。</p>\n<p>但是，建议不要使用查询缓存，因为查询缓存往往弊大于利。查询缓存的失效非常频繁，只要有对一个表的更新，这个表上所有的查询缓存都会被清空。对于更新压力大的数据库来说，查询缓存的命中率会非常低。除非你的业务就是有一张静态表，很长时间才会更新一次。比如，一个系统配置表，那这张表上的查询才适合使用查询缓存。</p>\n<p>待补充… …</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"MySQL-的逻辑架构图\"><a href=\"#MySQL-的逻辑架构图\" class=\"headerlink\" title=\"MySQL 的逻辑架构图\"></a>MySQL 的逻辑架构图<img src=\"https://cdn.jsdelivr.net/gh/wl2o2o/blogCdn/img/202306061044225.png\"></h1><p>mysql可以分为server层和存储引擎层两部分，其中，Server层包括连接器、分析器、查询缓存、优化器、执行器；存储引擎层负责数据的存储和提取。其架构模式是插件式的，支持 InnoDB、MyISAM、Memory 等多个存储引擎。现在最常用的存储引擎是 InnoDB，它从 MySQL 5.5.5 版本开始成为了默认存储引擎。也就是说，你执行 create table 建表的时候，如果不指定引擎类型，默认使用的就是 InnoDB。不过，你也可以通过指定存储引擎的类型来选择别的引擎，比如在 create table 语句中使用 engine=memory, 来指定使用内存引擎创建表。不同存储引擎的表数据存取方式不同，支持的功能也不同，在后面的文章中，我们会讨论到引擎的选择。从图中不难看出，不同的存储引擎共用一个 Server 层，也就是从连接器到执行器的部分。你可以先对每个组件的名字有个印象，接下来我会结合开头提到的那条 SQL 语句，带你走一遍整个执行流程，依次看下每个组件的作用。</p>\n<h2 id=\"从简单的查询语句分析sql语句执行流程：\"><a href=\"#从简单的查询语句分析sql语句执行流程：\" class=\"headerlink\" title=\"从简单的查询语句分析sql语句执行流程：\"></a>从简单的查询语句分析sql语句执行流程：</h2><blockquote>\n<p>连接——&gt;查询缓存——&gt;分析器——&gt;优化器——&gt;执行器</p>\n</blockquote>\n<h3 id=\"连接阶段：\"><a href=\"#连接阶段：\" class=\"headerlink\" title=\"连接阶段：\"></a>连接阶段：</h3><figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmd\">mysql -h$ip -P$port -u$user -p<br></code></pre></td></tr></table></figure>\n\n<p>虽然密码也可以直接跟在 -p 后面写在命令行中，但这样可能会导致你的密码泄露。如果你连的是生产服务器，强烈建议你不要这么做。</p>\n<ul>\n<li><p>连接命令中的 mysql 是客户端工具，用来跟服务端建立连接。在完成经典的 TCP 握手后，连接器就要开始认证你的身份，这个时候用的就是你输入的用户名和密码。</p>\n</li>\n<li><p>如果用户名或密码不对，你就会收到一个”Access denied for user”的错误，然后客户端程序结束执行。如果用户名密码认证通过，连接器会到权限表里面查出你拥有的权限。之后，这个连接里面的权限判断逻辑，都将依赖于此时读到的权限。</p>\n</li>\n</ul>\n<p>连接完成后，如果你没有后续的动作，这个连接就处于空闲状态，你可以在 <code>show processlist </code>命令中看到它。文本中这个图是 <code>show processlist</code> 的结果，其中的 Command 列显示为“Sleep”的这一行，就表示现在系统里面有一个空闲连接。</p>\n<p><img src=\"https://static001.geekbang.org/resource/image/f2/ed/f2da4aa3a672d48ec05df97b9f992fed.png?wh=875*163\"></p>\n<p>客户端如果太长时间没动静，连接器就会自动将它断开。这个时间是由参数 wait_timeout 控制的，默认值是 8 小时。</p>\n<p>数据库里面，长连接是指连接成功后，如果客户端持续有请求，则一直使用同一个连接。短连接则是指每次执行完很少的几次查询就断开连接，下次查询再重新建立一个。建立连接的过程通常是比较复杂的，所以我建议你在使用中要尽量减少建立连接的动作，也就是尽量使用长连接。但是全部使用长连接后，你可能会发现，有些时候 MySQL 占用内存涨得特别快，这是因为 MySQL 在执行过程中临时使用的内存是管理在连接对象里面的。这些资源会在连接断开的时候才释放。所以如果长连接累积下来，可能导致内存占用太大，被系统强行杀掉（OOM），从现象看就是 MySQL 异常重启了。</p>\n<p>为了防止这种情况的出现，</p>\n<ul>\n<li>定期断开长连接。使用一段时间，或者程序里面判断执行过一个占用内存的大查询后，断开连接，之后要查询再重连。</li>\n<li>如果你用的是 MySQL 5.7 或更新版本，可以在每次执行一个比较大的操作后，通过执行 <code>mysql_reset_connection </code>来重新初始化连接资源。这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚刚创建完时的状态。</li>\n</ul>\n<h3 id=\"查询缓存：\"><a href=\"#查询缓存：\" class=\"headerlink\" title=\"查询缓存：\"></a>查询缓存：</h3><p>拿到一个查询请求后，会先到查询缓存看看，之前是不是执行过这条语句。之前执行过的语句及其结果可能会以 key-value 对的形式，被直接缓存在内存中。查询到后直接返回结果，反而则执行下一步的执行阶段。</p>\n<p>但是，建议不要使用查询缓存，因为查询缓存往往弊大于利。查询缓存的失效非常频繁，只要有对一个表的更新，这个表上所有的查询缓存都会被清空。对于更新压力大的数据库来说，查询缓存的命中率会非常低。除非你的业务就是有一张静态表，很长时间才会更新一次。比如，一个系统配置表，那这张表上的查询才适合使用查询缓存。</p>\n<p>待补充… …</p>\n"},{"title":"love","banner_img":"https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202308220005240.jpg","hide":true,"abbrlink":1739,"date":"2023-05-21T05:14:21.000Z","_content":"\n\n\n<div style=\"background-image: url('https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202308220004780.jpg'); background-position: center center; background-repeat: no-repeat; background-size: cover; padding: 20px; opacity: 0.7; color: purple; line-height: 2; margin-top: 20px; margin-bottom: 20px;font-size: 15px;\">\n    <div>Dear 爱宝</div>\n    <div>\n        &#160;&#160;&#160;&#160;铃铃铃🎐✨✨~，五十二点零元已到账！欢迎来到属于我们的私人网页，七夕快乐呀💐！！！✈1438743713083<br>\n        &#160;&#160;&#160;&#160;没想到吧，像小磊子这样的恋爱脑（可以理解为好男人🤩🤩🤩），怎么敢如此放肆跟爱宝要红包呢？？！加载这个网页的速度是不是有点慢或者相当慢，俺一直尽力在修复。我爱你我爱你我超级爱你❤️。反正俺已经非常迫不及待地想要开学了，每每放假最开心的事除了见面，就是开学，爱宝竟然一点不想开学，俺不信俺不信，肯定是因为开学就要学习了，一定不是不期待见面，一定是这样子的。嘿嘿🥰，七夕快乐呀俺滴宝贝公主。<br>\n        &#160;&#160;&#160;&#160;在这个暑假里，俺说过最多的一句话除了好嘞、好滴，可能就是：“俺继续学习啦”，其实，宝嘎感觉自己的压力其实还蛮大的，也是俺自己的不断施压，因为我一定要让我们过上幸福地、美好的生活，我必须做到，必须做到，必须做到！然后在这个暑假里，或许有什么时候，俺对爱宝的情绪有照顾不周的地方，还请爱宝见谅，因为，我感觉我忙碌了一整个暑假，吃、喝、学、看抖音，虽然爱宝不说，总感觉有什么时候情绪不对（也可能是俺比较敏感）。因为有时候很长时间不给爱宝发消息，总有点很不习惯，但是，我需要学习，积累技术经验，魏磊的目标是让爱宝躺平！！！，记住，俺不是画饼，真的不是。<br>\n        &#160;&#160;&#160;&#160;时间真的不可说，一转眼，三年过去了，也是我们一起走过的第3个七夕啦，俺说过的一定会做到！诶嘿，考一下，前两个七夕小磊子都干了什么？还想得起来嘛？实不相瞒，俺也是翻了翻相册才浮现出一篇篇美好的画面。翻过三年的相册，不得不说，我们的故事放在甜剧界肯定也是相当“炸裂”的。不过我相信，预测一下，以后我们的生活一定更加美好！<br>\n        &#160;&#160;&#160;&#160;第一个七月七，也就是2021年8月14日（0814熟悉的数字，是吧，当时应该买彩票），第一件针织品艾草小荷包；第二个七月七，小磊子熬了几个大夜，将新娘手捧花赶制了出来；第三个七月七，小磊子会怎么计划呢？还是手工？还是什么... ...<br>\n        &#160;&#160;&#160;&#160;铛铛铛铛~,这个网页就是第三个七月七的surprise🎉🎉🎉啦，我自己都感觉，这个网页多少些许敷衍。但是，这是用自己学到的知识，准备的惊喜au😎😎😎（手动狗头表情包）<br><br>\n    </div>\n    <div style=\"text-align: right; color: purple; line-height: 1.5; font-size: 15px;\">\n        小磊子<br>\n        2023年七夕<br>\n        癸卯年七月初五书\n    </div>\n</div>\n","source":"_posts/love.md","raw":"---\ntitle: love\nbanner_img: >-\n  https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202308220005240.jpg\nhide: true\nabbrlink: 1739\ndate: 2023-05-21 13:14:21\n---\n\n\n\n<div style=\"background-image: url('https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202308220004780.jpg'); background-position: center center; background-repeat: no-repeat; background-size: cover; padding: 20px; opacity: 0.7; color: purple; line-height: 2; margin-top: 20px; margin-bottom: 20px;font-size: 15px;\">\n    <div>Dear 爱宝</div>\n    <div>\n        &#160;&#160;&#160;&#160;铃铃铃🎐✨✨~，五十二点零元已到账！欢迎来到属于我们的私人网页，七夕快乐呀💐！！！✈1438743713083<br>\n        &#160;&#160;&#160;&#160;没想到吧，像小磊子这样的恋爱脑（可以理解为好男人🤩🤩🤩），怎么敢如此放肆跟爱宝要红包呢？？！加载这个网页的速度是不是有点慢或者相当慢，俺一直尽力在修复。我爱你我爱你我超级爱你❤️。反正俺已经非常迫不及待地想要开学了，每每放假最开心的事除了见面，就是开学，爱宝竟然一点不想开学，俺不信俺不信，肯定是因为开学就要学习了，一定不是不期待见面，一定是这样子的。嘿嘿🥰，七夕快乐呀俺滴宝贝公主。<br>\n        &#160;&#160;&#160;&#160;在这个暑假里，俺说过最多的一句话除了好嘞、好滴，可能就是：“俺继续学习啦”，其实，宝嘎感觉自己的压力其实还蛮大的，也是俺自己的不断施压，因为我一定要让我们过上幸福地、美好的生活，我必须做到，必须做到，必须做到！然后在这个暑假里，或许有什么时候，俺对爱宝的情绪有照顾不周的地方，还请爱宝见谅，因为，我感觉我忙碌了一整个暑假，吃、喝、学、看抖音，虽然爱宝不说，总感觉有什么时候情绪不对（也可能是俺比较敏感）。因为有时候很长时间不给爱宝发消息，总有点很不习惯，但是，我需要学习，积累技术经验，魏磊的目标是让爱宝躺平！！！，记住，俺不是画饼，真的不是。<br>\n        &#160;&#160;&#160;&#160;时间真的不可说，一转眼，三年过去了，也是我们一起走过的第3个七夕啦，俺说过的一定会做到！诶嘿，考一下，前两个七夕小磊子都干了什么？还想得起来嘛？实不相瞒，俺也是翻了翻相册才浮现出一篇篇美好的画面。翻过三年的相册，不得不说，我们的故事放在甜剧界肯定也是相当“炸裂”的。不过我相信，预测一下，以后我们的生活一定更加美好！<br>\n        &#160;&#160;&#160;&#160;第一个七月七，也就是2021年8月14日（0814熟悉的数字，是吧，当时应该买彩票），第一件针织品艾草小荷包；第二个七月七，小磊子熬了几个大夜，将新娘手捧花赶制了出来；第三个七月七，小磊子会怎么计划呢？还是手工？还是什么... ...<br>\n        &#160;&#160;&#160;&#160;铛铛铛铛~,这个网页就是第三个七月七的surprise🎉🎉🎉啦，我自己都感觉，这个网页多少些许敷衍。但是，这是用自己学到的知识，准备的惊喜au😎😎😎（手动狗头表情包）<br><br>\n    </div>\n    <div style=\"text-align: right; color: purple; line-height: 1.5; font-size: 15px;\">\n        小磊子<br>\n        2023年七夕<br>\n        癸卯年七月初五书\n    </div>\n</div>\n","slug":"love","published":1,"updated":"2023-10-16T06:58:59.294Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clpkiczjd002sfkfo901o7v2d","content":"<div style=\"background-image: url('https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202308220004780.jpg'); background-position: center center; background-repeat: no-repeat; background-size: cover; padding: 20px; opacity: 0.7; color: purple; line-height: 2; margin-top: 20px; margin-bottom: 20px;font-size: 15px;\">\n    <div>Dear 爱宝</div>\n    <div>\n        &#160;&#160;&#160;&#160;铃铃铃🎐✨✨~，五十二点零元已到账！欢迎来到属于我们的私人网页，七夕快乐呀💐！！！✈1438743713083<br>\n        &#160;&#160;&#160;&#160;没想到吧，像小磊子这样的恋爱脑（可以理解为好男人🤩🤩🤩），怎么敢如此放肆跟爱宝要红包呢？？！加载这个网页的速度是不是有点慢或者相当慢，俺一直尽力在修复。我爱你我爱你我超级爱你❤️。反正俺已经非常迫不及待地想要开学了，每每放假最开心的事除了见面，就是开学，爱宝竟然一点不想开学，俺不信俺不信，肯定是因为开学就要学习了，一定不是不期待见面，一定是这样子的。嘿嘿🥰，七夕快乐呀俺滴宝贝公主。<br>\n        &#160;&#160;&#160;&#160;在这个暑假里，俺说过最多的一句话除了好嘞、好滴，可能就是：“俺继续学习啦”，其实，宝嘎感觉自己的压力其实还蛮大的，也是俺自己的不断施压，因为我一定要让我们过上幸福地、美好的生活，我必须做到，必须做到，必须做到！然后在这个暑假里，或许有什么时候，俺对爱宝的情绪有照顾不周的地方，还请爱宝见谅，因为，我感觉我忙碌了一整个暑假，吃、喝、学、看抖音，虽然爱宝不说，总感觉有什么时候情绪不对（也可能是俺比较敏感）。因为有时候很长时间不给爱宝发消息，总有点很不习惯，但是，我需要学习，积累技术经验，魏磊的目标是让爱宝躺平！！！，记住，俺不是画饼，真的不是。<br>\n        &#160;&#160;&#160;&#160;时间真的不可说，一转眼，三年过去了，也是我们一起走过的第3个七夕啦，俺说过的一定会做到！诶嘿，考一下，前两个七夕小磊子都干了什么？还想得起来嘛？实不相瞒，俺也是翻了翻相册才浮现出一篇篇美好的画面。翻过三年的相册，不得不说，我们的故事放在甜剧界肯定也是相当“炸裂”的。不过我相信，预测一下，以后我们的生活一定更加美好！<br>\n        &#160;&#160;&#160;&#160;第一个七月七，也就是2021年8月14日（0814熟悉的数字，是吧，当时应该买彩票），第一件针织品艾草小荷包；第二个七月七，小磊子熬了几个大夜，将新娘手捧花赶制了出来；第三个七月七，小磊子会怎么计划呢？还是手工？还是什么... ...<br>\n        &#160;&#160;&#160;&#160;铛铛铛铛~,这个网页就是第三个七月七的surprise🎉🎉🎉啦，我自己都感觉，这个网页多少些许敷衍。但是，这是用自己学到的知识，准备的惊喜au😎😎😎（手动狗头表情包）<br><br>\n    </div>\n    <div style=\"text-align: right; color: purple; line-height: 1.5; font-size: 15px;\">\n        小磊子<br>\n        2023年七夕<br>\n        癸卯年七月初五书\n    </div>\n</div>\n","site":{"data":{}},"excerpt":"","more":"<div style=\"background-image: url('https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202308220004780.jpg'); background-position: center center; background-repeat: no-repeat; background-size: cover; padding: 20px; opacity: 0.7; color: purple; line-height: 2; margin-top: 20px; margin-bottom: 20px;font-size: 15px;\">\n    <div>Dear 爱宝</div>\n    <div>\n        &#160;&#160;&#160;&#160;铃铃铃🎐✨✨~，五十二点零元已到账！欢迎来到属于我们的私人网页，七夕快乐呀💐！！！✈1438743713083<br>\n        &#160;&#160;&#160;&#160;没想到吧，像小磊子这样的恋爱脑（可以理解为好男人🤩🤩🤩），怎么敢如此放肆跟爱宝要红包呢？？！加载这个网页的速度是不是有点慢或者相当慢，俺一直尽力在修复。我爱你我爱你我超级爱你❤️。反正俺已经非常迫不及待地想要开学了，每每放假最开心的事除了见面，就是开学，爱宝竟然一点不想开学，俺不信俺不信，肯定是因为开学就要学习了，一定不是不期待见面，一定是这样子的。嘿嘿🥰，七夕快乐呀俺滴宝贝公主。<br>\n        &#160;&#160;&#160;&#160;在这个暑假里，俺说过最多的一句话除了好嘞、好滴，可能就是：“俺继续学习啦”，其实，宝嘎感觉自己的压力其实还蛮大的，也是俺自己的不断施压，因为我一定要让我们过上幸福地、美好的生活，我必须做到，必须做到，必须做到！然后在这个暑假里，或许有什么时候，俺对爱宝的情绪有照顾不周的地方，还请爱宝见谅，因为，我感觉我忙碌了一整个暑假，吃、喝、学、看抖音，虽然爱宝不说，总感觉有什么时候情绪不对（也可能是俺比较敏感）。因为有时候很长时间不给爱宝发消息，总有点很不习惯，但是，我需要学习，积累技术经验，魏磊的目标是让爱宝躺平！！！，记住，俺不是画饼，真的不是。<br>\n        &#160;&#160;&#160;&#160;时间真的不可说，一转眼，三年过去了，也是我们一起走过的第3个七夕啦，俺说过的一定会做到！诶嘿，考一下，前两个七夕小磊子都干了什么？还想得起来嘛？实不相瞒，俺也是翻了翻相册才浮现出一篇篇美好的画面。翻过三年的相册，不得不说，我们的故事放在甜剧界肯定也是相当“炸裂”的。不过我相信，预测一下，以后我们的生活一定更加美好！<br>\n        &#160;&#160;&#160;&#160;第一个七月七，也就是2021年8月14日（0814熟悉的数字，是吧，当时应该买彩票），第一件针织品艾草小荷包；第二个七月七，小磊子熬了几个大夜，将新娘手捧花赶制了出来；第三个七月七，小磊子会怎么计划呢？还是手工？还是什么... ...<br>\n        &#160;&#160;&#160;&#160;铛铛铛铛~,这个网页就是第三个七月七的surprise🎉🎉🎉啦，我自己都感觉，这个网页多少些许敷衍。但是，这是用自己学到的知识，准备的惊喜au😎😎😎（手动狗头表情包）<br><br>\n    </div>\n    <div style=\"text-align: right; color: purple; line-height: 1.5; font-size: 15px;\">\n        小磊子<br>\n        2023年七夕<br>\n        癸卯年七月初五书\n    </div>\n</div>\n"},{"title":"netblog","index_img":"https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202309120902040.png","abbrlink":34693,"date":"2023-08-21T17:23:17.000Z","_content":"\n# 博客上云\n\n> 博客的访问速度实在是太慢了，准备尝试把博客部署到华为云ECS。\n>\n> 环境：\n>\n> 华为云CentOS\n\n新鲜事第一步：打开官方文档\n\n​\t[Hexo博客的官方文档](https://hexo.io/zh-cn/docs/)\n\n## 安装前提\n\n安装 Hexo 相当简单，只需要先安装下列应用程序即可：\n\n- [Node.js](http://nodejs.org/) (Node.js 版本需不低于 10.13，建议使用 Node.js 12.0 及以上版本)\n- [Git](http://git-scm.com/)\n\n如果您的电脑中已经安装上述必备程序，那么恭喜您！你可以直接前往 [安装 Hexo](https://hexo.io/zh-cn/docs/#安装-Hexo) 步骤。\n\n### Node的安装\n\n为了后续排错方便，我们使用 NVM 来进行 Node 的安装。\n\n```\n# 安装NVM\n$ curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.38.0/\n\n# 激活配置\n$ source ~/.bashrc\n```\n\n![image-20230822013352104](https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202308220133637.png)\n\n#### Node.js 版本限制\n\n如果你坚持使用旧的 Node.js，你可以考虑安装 Hexo 的过去版本。\n\n请注意，我们不提供对过去版本 Hexo 的错误修复。\n\n我们强烈建议永远安装 [最新版本](https://www.npmjs.com/package/hexo?activeTab=versions) 的 Hexo，以及 [推荐的 Node.js 版本](https://hexo.io/zh-cn/docs/#安装前提)。\n\n| Hexo 版本   | 最低版本 (Node.js 版本) | 最高版本 (Node.js 版本) |\n| :---------- | :---------------------- | :---------------------- |\n| 6.2+        | 12.13.0                 | latest                  |\n| 6.0+        | 12.13.0                 | 18.5.0                  |\n| 5.0+        | 10.13.0                 | 12.0.0                  |\n| 4.1 - 4.2   | 8.10                    | 10.0.0                  |\n| 4.0         | 8.6                     | 8.10.0                  |\n| 3.3 - 3.9   | 6.9                     | 8.0.0                   |\n| 3.2 - 3.3   | 0.12                    | 未知                    |\n| 3.0 - 3.1   | 0.10 或 iojs            | 未知                    |\n| 0.0.1 - 2.8 | 0.10                    | 未知                    |\n\n### Git的安装\n\n```\nyum install git-core\n```\n\n![image-20230822013716334](https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202308220137246.png)\n\n安装完毕！！！\n\n**开始搭建Git服务器：**\n\n1. 添加一个git用户\n\n```\n# 添加git用户\n$ adduser git \n\n# 改变sudoers文件的权限为文件所有者可写\n$ chmod 740 /etc/sudoers\n$ vim /etc/sudoers\n\n# 添加一行内容,按esc,再按:wq退出编辑\n将 git ALL=(ALL) ALL 添加到root ALL=(ALL) ALL下方\n\n# 将sudoers文件的权限改回文件所有者可读\n$ chmod 400 /etc/sudoers \n\n# 设置服务器的git密码，用于git连接。输入时看不到任何显示，输入完成回车即可\n$ sudo passwd git \n```\n\n2. 给服务器和主机的Git配置SSH密钥\n\n* 如果你的本地电脑中已有ssh密钥则跳过这一步，直接到`C:\\Users\\你的用户名\\.ssh`中找到`id_rsa.pub`通过宝塔面板或者FTP将`id_rsa.pub`上传到`/home/git/.ssh`。\n\n> 注意，如果**你是云服务器的话**这里一定要将密钥上传到 `/home/git/.ssh` 这个路径，不然是不生效的，为什么不生效，这里就相当于什么呢？！就是相当于你把你服务器中的密钥添加到了 git 中，其中 git 的路径为/home/git ,所以肯定要添加到这个地方。\n>\n> 如果**你是在虚拟机中**，那么.ssh是有一个默认路径的，一般为：`/root/.ssh`,直接把生成的公钥放到这个位置或者通过 ssh 上传即可。\n>\n> 究其原因，你在你的Windows电脑上，需要将一个项目或者文件上传到GitHub（或者Gitee），然后通过仓库的https链接很多时候会报网络超时的错误，相信很多时候大家都会遇到，于是，我们发现GitHub官方还给出了仓库的ssh链接：`git@github.com:username/repositoryname`，就是这个样子，然后要是用这个的话，你就需要在本地生成一个密钥对，生成方法和下面的方法一样，然后就可以在电脑的`C:\\Users\\你的用户名\\.ssh`这个路径下看到已经生成的id_rsa（私钥）、id_ras.pub（公钥）。然后你需要将生成的公钥添加到GitHub的设置中，如图：\n>\n> ![image-20230824204900135](https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202308242054482.png)\n>\n> 同理以上操作就相当于 Linux 系统的操作，只是系统不同罢了，知识点 + 1.\n\n* 如果你本地电脑`C:\\Users\\你的用户名\\.ssh`中没有生成过ssh密钥，可以按照如下步骤生成密钥：\n\n  ```\n  用户\n  git config --global user.name \"你要设置的git软件的用户名\"\n  git config --global user.email \"你要设置的邮箱\"\n  \n  ssh-keygen -t rsa -C \"你刚刚设置的邮箱\"\n  ```\n\n **为什么要进行通过配置ssh密钥？**\n\n这样主机和服务器的git连接时无需密码即可，更加方便。\n\n3. 在服务器中新建仓库\n\n   ```\n   cd /home/git\n   git init --bare hexoblog.git #在/home/git下初始化一个名为hexoblog的仓库\n   ```\n\n4. 配置钩子实现自动部署\n\n    找到`/home/git/hexoblog.git/hooks`下的`post-receive`文件，如果没有则新建一个该文件，将其内容改为\n\n   ```sh\n   #!/bin/sh\n   git --work-tree=/home/www/xxx --git-dir=/home/git/hexoblog.git checkout -f\n   ```\n\n   以上内容是一条命令，前者`/home/www/xxx`为网页资源目录，后者`/home/git/hexoblog.git`为云git仓库。意为当主机将静态文件推给服务器的git仓库后，自动触发hooks文件下的脚本，服务器能够自动将文件部署到网页资源目录，也就是什么呢，相当于Windows系统中 GitHub 网站的 Action，或者也就是`Git pages`部署，只不过在 Linux 系统中，操作麻烦一点。\n\n5. **然后设置网页资源目录的IO权限，否则git没有权限修改网页资源目录的内容，无法实现自动部署！！！**\n\n```shell\nsudo chmod +x /home/git/hexoblog.git/hooks/pre-receive #赋予其可执行权限\nsudo chown -R git:git /home/git/ #仓库目录的所有者改为git\nsudo chown -R git:git /home/www/ #站点文件夹所有者改为git\n```\n\n## Hexo脚手架安装\n\n### 直接全局安装：\n\n```\n$ npm install -g hexo-cli\n```\n\n安装很慢的话，可以先设置npm的淘宝镜像：\n\n```\n$ npm config set registry https://registry.npm.taobao.org\n```\n\n官网也给出了进阶局部安装方法，如下：\n\n### 进阶安装和使用\n\n> 对于熟悉 npm 的进阶用户，可以仅局部安装 `hexo` 包。\n>\n> ```\n> $ npm install hexo\n> ```\n>\n> 安装以后，可以使用以下两种方式执行 Hexo：\n>\n> 1. `npx hexo <command>`\n>\n> 2. Linux 用户可以将 Hexo 所在的目录下的 `node_modules` 添加到环境变量之中即可直接使用 `hexo <command>`：\n>\n>    ```\n>    echo 'PATH=\"$PATH:./node_modules/.bin\"' >> ~/.profile\n>    ```\n\n## 本地跑一个hexo博客Demo\n\n直接参考[官方文档](https://hexo.io/zh-cn/),初始化一个博客，已经有hexo博客的话就直接跳过。\n\n在你的博客目录下面的.config.yml中添加远程git仓库的地址，也就是上面我们在服务器中新建的仓库地址，如图：\n\n![image-20230824210942989](https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202308242109919.png)\n\n然后就可以愉快的`hexo deploy`了。\n\n推荐一起使用：`hexo cl && hexo g && hexo d`\n\n## 怎么访问部署到云服务器的博客呢？\n\n`云服务器IP:`+ 端口号进行访问\n\n### 在宝塔面板添加站点\n\n 由于云服务器在域名没有备案的情况下不开放80端口，所以手动设置一个空闲的32端口用于访问网页。\n\n![img](https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202308242124448.png)\n\n 将网站目录设置为如下（自定义即可）\n\n![img](https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202308242124720.png)\n\n这里使用的是宝塔面板，也可以使用`nginx`进行配置,参考文章：https://blog.csdn.net/weixin_56301399/article/details/129270887\n\n## 全网最全SEO强化篇之怎么让百度、谷歌、必应各大搜索引擎收录自己的文章\n\n- 百度\n  - 是需要域名备案的，前提是拥有一台云服务器，所以我先搁置，后续补充\n\n- [谷歌：Google Search Console](https://search.google.com/search-console/welcome)\n\n  - 如何进行验证？\n\n  ![image-20230825013409616](https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202308250135183.png)\n","source":"_posts/netblog.md","raw":"---\ntitle: netblog\nindex_img: >-\n  https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202309120902040.png\ncategories:\n  - Blog\ntags:\n  - 网站搭建\nabbrlink: 34693\ndate: 2023-08-22 01:23:17\n---\n\n# 博客上云\n\n> 博客的访问速度实在是太慢了，准备尝试把博客部署到华为云ECS。\n>\n> 环境：\n>\n> 华为云CentOS\n\n新鲜事第一步：打开官方文档\n\n​\t[Hexo博客的官方文档](https://hexo.io/zh-cn/docs/)\n\n## 安装前提\n\n安装 Hexo 相当简单，只需要先安装下列应用程序即可：\n\n- [Node.js](http://nodejs.org/) (Node.js 版本需不低于 10.13，建议使用 Node.js 12.0 及以上版本)\n- [Git](http://git-scm.com/)\n\n如果您的电脑中已经安装上述必备程序，那么恭喜您！你可以直接前往 [安装 Hexo](https://hexo.io/zh-cn/docs/#安装-Hexo) 步骤。\n\n### Node的安装\n\n为了后续排错方便，我们使用 NVM 来进行 Node 的安装。\n\n```\n# 安装NVM\n$ curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.38.0/\n\n# 激活配置\n$ source ~/.bashrc\n```\n\n![image-20230822013352104](https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202308220133637.png)\n\n#### Node.js 版本限制\n\n如果你坚持使用旧的 Node.js，你可以考虑安装 Hexo 的过去版本。\n\n请注意，我们不提供对过去版本 Hexo 的错误修复。\n\n我们强烈建议永远安装 [最新版本](https://www.npmjs.com/package/hexo?activeTab=versions) 的 Hexo，以及 [推荐的 Node.js 版本](https://hexo.io/zh-cn/docs/#安装前提)。\n\n| Hexo 版本   | 最低版本 (Node.js 版本) | 最高版本 (Node.js 版本) |\n| :---------- | :---------------------- | :---------------------- |\n| 6.2+        | 12.13.0                 | latest                  |\n| 6.0+        | 12.13.0                 | 18.5.0                  |\n| 5.0+        | 10.13.0                 | 12.0.0                  |\n| 4.1 - 4.2   | 8.10                    | 10.0.0                  |\n| 4.0         | 8.6                     | 8.10.0                  |\n| 3.3 - 3.9   | 6.9                     | 8.0.0                   |\n| 3.2 - 3.3   | 0.12                    | 未知                    |\n| 3.0 - 3.1   | 0.10 或 iojs            | 未知                    |\n| 0.0.1 - 2.8 | 0.10                    | 未知                    |\n\n### Git的安装\n\n```\nyum install git-core\n```\n\n![image-20230822013716334](https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202308220137246.png)\n\n安装完毕！！！\n\n**开始搭建Git服务器：**\n\n1. 添加一个git用户\n\n```\n# 添加git用户\n$ adduser git \n\n# 改变sudoers文件的权限为文件所有者可写\n$ chmod 740 /etc/sudoers\n$ vim /etc/sudoers\n\n# 添加一行内容,按esc,再按:wq退出编辑\n将 git ALL=(ALL) ALL 添加到root ALL=(ALL) ALL下方\n\n# 将sudoers文件的权限改回文件所有者可读\n$ chmod 400 /etc/sudoers \n\n# 设置服务器的git密码，用于git连接。输入时看不到任何显示，输入完成回车即可\n$ sudo passwd git \n```\n\n2. 给服务器和主机的Git配置SSH密钥\n\n* 如果你的本地电脑中已有ssh密钥则跳过这一步，直接到`C:\\Users\\你的用户名\\.ssh`中找到`id_rsa.pub`通过宝塔面板或者FTP将`id_rsa.pub`上传到`/home/git/.ssh`。\n\n> 注意，如果**你是云服务器的话**这里一定要将密钥上传到 `/home/git/.ssh` 这个路径，不然是不生效的，为什么不生效，这里就相当于什么呢？！就是相当于你把你服务器中的密钥添加到了 git 中，其中 git 的路径为/home/git ,所以肯定要添加到这个地方。\n>\n> 如果**你是在虚拟机中**，那么.ssh是有一个默认路径的，一般为：`/root/.ssh`,直接把生成的公钥放到这个位置或者通过 ssh 上传即可。\n>\n> 究其原因，你在你的Windows电脑上，需要将一个项目或者文件上传到GitHub（或者Gitee），然后通过仓库的https链接很多时候会报网络超时的错误，相信很多时候大家都会遇到，于是，我们发现GitHub官方还给出了仓库的ssh链接：`git@github.com:username/repositoryname`，就是这个样子，然后要是用这个的话，你就需要在本地生成一个密钥对，生成方法和下面的方法一样，然后就可以在电脑的`C:\\Users\\你的用户名\\.ssh`这个路径下看到已经生成的id_rsa（私钥）、id_ras.pub（公钥）。然后你需要将生成的公钥添加到GitHub的设置中，如图：\n>\n> ![image-20230824204900135](https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202308242054482.png)\n>\n> 同理以上操作就相当于 Linux 系统的操作，只是系统不同罢了，知识点 + 1.\n\n* 如果你本地电脑`C:\\Users\\你的用户名\\.ssh`中没有生成过ssh密钥，可以按照如下步骤生成密钥：\n\n  ```\n  用户\n  git config --global user.name \"你要设置的git软件的用户名\"\n  git config --global user.email \"你要设置的邮箱\"\n  \n  ssh-keygen -t rsa -C \"你刚刚设置的邮箱\"\n  ```\n\n **为什么要进行通过配置ssh密钥？**\n\n这样主机和服务器的git连接时无需密码即可，更加方便。\n\n3. 在服务器中新建仓库\n\n   ```\n   cd /home/git\n   git init --bare hexoblog.git #在/home/git下初始化一个名为hexoblog的仓库\n   ```\n\n4. 配置钩子实现自动部署\n\n    找到`/home/git/hexoblog.git/hooks`下的`post-receive`文件，如果没有则新建一个该文件，将其内容改为\n\n   ```sh\n   #!/bin/sh\n   git --work-tree=/home/www/xxx --git-dir=/home/git/hexoblog.git checkout -f\n   ```\n\n   以上内容是一条命令，前者`/home/www/xxx`为网页资源目录，后者`/home/git/hexoblog.git`为云git仓库。意为当主机将静态文件推给服务器的git仓库后，自动触发hooks文件下的脚本，服务器能够自动将文件部署到网页资源目录，也就是什么呢，相当于Windows系统中 GitHub 网站的 Action，或者也就是`Git pages`部署，只不过在 Linux 系统中，操作麻烦一点。\n\n5. **然后设置网页资源目录的IO权限，否则git没有权限修改网页资源目录的内容，无法实现自动部署！！！**\n\n```shell\nsudo chmod +x /home/git/hexoblog.git/hooks/pre-receive #赋予其可执行权限\nsudo chown -R git:git /home/git/ #仓库目录的所有者改为git\nsudo chown -R git:git /home/www/ #站点文件夹所有者改为git\n```\n\n## Hexo脚手架安装\n\n### 直接全局安装：\n\n```\n$ npm install -g hexo-cli\n```\n\n安装很慢的话，可以先设置npm的淘宝镜像：\n\n```\n$ npm config set registry https://registry.npm.taobao.org\n```\n\n官网也给出了进阶局部安装方法，如下：\n\n### 进阶安装和使用\n\n> 对于熟悉 npm 的进阶用户，可以仅局部安装 `hexo` 包。\n>\n> ```\n> $ npm install hexo\n> ```\n>\n> 安装以后，可以使用以下两种方式执行 Hexo：\n>\n> 1. `npx hexo <command>`\n>\n> 2. Linux 用户可以将 Hexo 所在的目录下的 `node_modules` 添加到环境变量之中即可直接使用 `hexo <command>`：\n>\n>    ```\n>    echo 'PATH=\"$PATH:./node_modules/.bin\"' >> ~/.profile\n>    ```\n\n## 本地跑一个hexo博客Demo\n\n直接参考[官方文档](https://hexo.io/zh-cn/),初始化一个博客，已经有hexo博客的话就直接跳过。\n\n在你的博客目录下面的.config.yml中添加远程git仓库的地址，也就是上面我们在服务器中新建的仓库地址，如图：\n\n![image-20230824210942989](https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202308242109919.png)\n\n然后就可以愉快的`hexo deploy`了。\n\n推荐一起使用：`hexo cl && hexo g && hexo d`\n\n## 怎么访问部署到云服务器的博客呢？\n\n`云服务器IP:`+ 端口号进行访问\n\n### 在宝塔面板添加站点\n\n 由于云服务器在域名没有备案的情况下不开放80端口，所以手动设置一个空闲的32端口用于访问网页。\n\n![img](https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202308242124448.png)\n\n 将网站目录设置为如下（自定义即可）\n\n![img](https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202308242124720.png)\n\n这里使用的是宝塔面板，也可以使用`nginx`进行配置,参考文章：https://blog.csdn.net/weixin_56301399/article/details/129270887\n\n## 全网最全SEO强化篇之怎么让百度、谷歌、必应各大搜索引擎收录自己的文章\n\n- 百度\n  - 是需要域名备案的，前提是拥有一台云服务器，所以我先搁置，后续补充\n\n- [谷歌：Google Search Console](https://search.google.com/search-console/welcome)\n\n  - 如何进行验证？\n\n  ![image-20230825013409616](https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202308250135183.png)\n","slug":"netblog","published":1,"updated":"2023-11-30T01:18:02.058Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clpkiczje002vfkfohe014v6q","content":"<h1 id=\"博客上云\"><a href=\"#博客上云\" class=\"headerlink\" title=\"博客上云\"></a>博客上云</h1><blockquote>\n<p>博客的访问速度实在是太慢了，准备尝试把博客部署到华为云ECS。</p>\n<p>环境：</p>\n<p>华为云CentOS</p>\n</blockquote>\n<p>新鲜事第一步：打开官方文档</p>\n<p>​    <a href=\"https://hexo.io/zh-cn/docs/\">Hexo博客的官方文档</a></p>\n<h2 id=\"安装前提\"><a href=\"#安装前提\" class=\"headerlink\" title=\"安装前提\"></a>安装前提</h2><p>安装 Hexo 相当简单，只需要先安装下列应用程序即可：</p>\n<ul>\n<li><a href=\"http://nodejs.org/\">Node.js</a> (Node.js 版本需不低于 10.13，建议使用 Node.js 12.0 及以上版本)</li>\n<li><a href=\"http://git-scm.com/\">Git</a></li>\n</ul>\n<p>如果您的电脑中已经安装上述必备程序，那么恭喜您！你可以直接前往 <a href=\"https://hexo.io/zh-cn/docs/#%E5%AE%89%E8%A3%85-Hexo\">安装 Hexo</a> 步骤。</p>\n<h3 id=\"Node的安装\"><a href=\"#Node的安装\" class=\"headerlink\" title=\"Node的安装\"></a>Node的安装</h3><p>为了后续排错方便，我们使用 NVM 来进行 Node 的安装。</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs awk\"><span class=\"hljs-comment\"># 安装NVM</span><br>$ curl -o- https:<span class=\"hljs-regexp\">//</span>raw.githubusercontent.com<span class=\"hljs-regexp\">/nvm-sh/</span>nvm<span class=\"hljs-regexp\">/v0.38.0/</span><br><br><span class=\"hljs-comment\"># 激活配置</span><br>$ source ~/.bashrc<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202308220133637.png\" alt=\"image-20230822013352104\"></p>\n<h4 id=\"Node-js-版本限制\"><a href=\"#Node-js-版本限制\" class=\"headerlink\" title=\"Node.js 版本限制\"></a>Node.js 版本限制</h4><p>如果你坚持使用旧的 Node.js，你可以考虑安装 Hexo 的过去版本。</p>\n<p>请注意，我们不提供对过去版本 Hexo 的错误修复。</p>\n<p>我们强烈建议永远安装 <a href=\"https://www.npmjs.com/package/hexo?activeTab=versions\">最新版本</a> 的 Hexo，以及 <a href=\"https://hexo.io/zh-cn/docs/#%E5%AE%89%E8%A3%85%E5%89%8D%E6%8F%90\">推荐的 Node.js 版本</a>。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Hexo 版本</th>\n<th align=\"left\">最低版本 (Node.js 版本)</th>\n<th align=\"left\">最高版本 (Node.js 版本)</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">6.2+</td>\n<td align=\"left\">12.13.0</td>\n<td align=\"left\">latest</td>\n</tr>\n<tr>\n<td align=\"left\">6.0+</td>\n<td align=\"left\">12.13.0</td>\n<td align=\"left\">18.5.0</td>\n</tr>\n<tr>\n<td align=\"left\">5.0+</td>\n<td align=\"left\">10.13.0</td>\n<td align=\"left\">12.0.0</td>\n</tr>\n<tr>\n<td align=\"left\">4.1 - 4.2</td>\n<td align=\"left\">8.10</td>\n<td align=\"left\">10.0.0</td>\n</tr>\n<tr>\n<td align=\"left\">4.0</td>\n<td align=\"left\">8.6</td>\n<td align=\"left\">8.10.0</td>\n</tr>\n<tr>\n<td align=\"left\">3.3 - 3.9</td>\n<td align=\"left\">6.9</td>\n<td align=\"left\">8.0.0</td>\n</tr>\n<tr>\n<td align=\"left\">3.2 - 3.3</td>\n<td align=\"left\">0.12</td>\n<td align=\"left\">未知</td>\n</tr>\n<tr>\n<td align=\"left\">3.0 - 3.1</td>\n<td align=\"left\">0.10 或 iojs</td>\n<td align=\"left\">未知</td>\n</tr>\n<tr>\n<td align=\"left\">0.0.1 - 2.8</td>\n<td align=\"left\">0.10</td>\n<td align=\"left\">未知</td>\n</tr>\n</tbody></table>\n<h3 id=\"Git的安装\"><a href=\"#Git的安装\" class=\"headerlink\" title=\"Git的安装\"></a>Git的安装</h3><figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\">yum <span class=\"hljs-keyword\">install</span> git-core<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202308220137246.png\" alt=\"image-20230822013716334\"></p>\n<p>安装完毕！！！</p>\n<p><strong>开始搭建Git服务器：</strong></p>\n<ol>\n<li>添加一个git用户</li>\n</ol>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\"><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">添加git用户</span><br><span class=\"hljs-meta prompt_\">$ </span><span class=\"language-bash\">adduser git</span> <br><span class=\"hljs-meta prompt_\"></span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">改变sudoers文件的权限为文件所有者可写</span><br><span class=\"hljs-meta prompt_\">$ </span><span class=\"language-bash\"><span class=\"hljs-built_in\">chmod</span> 740 /etc/sudoers</span><br><span class=\"hljs-meta prompt_\">$ </span><span class=\"language-bash\">vim /etc/sudoers</span><br><span class=\"hljs-meta prompt_\"></span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">添加一行内容,按esc,再按:wq退出编辑</span><br>将 git ALL=(ALL) ALL 添加到root ALL=(ALL) ALL下方<br><span class=\"hljs-meta prompt_\"></span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">将sudoers文件的权限改回文件所有者可读</span><br><span class=\"hljs-meta prompt_\">$ </span><span class=\"language-bash\"><span class=\"hljs-built_in\">chmod</span> 400 /etc/sudoers</span> <br><span class=\"hljs-meta prompt_\"></span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">设置服务器的git密码，用于git连接。输入时看不到任何显示，输入完成回车即可</span><br><span class=\"hljs-meta prompt_\">$ </span><span class=\"language-bash\">sudo passwd git</span> <br></code></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>给服务器和主机的Git配置SSH密钥</li>\n</ol>\n<ul>\n<li>如果你的本地电脑中已有ssh密钥则跳过这一步，直接到<code>C:\\Users\\你的用户名\\.ssh</code>中找到<code>id_rsa.pub</code>通过宝塔面板或者FTP将<code>id_rsa.pub</code>上传到<code>/home/git/.ssh</code>。</li>\n</ul>\n<blockquote>\n<p>注意，如果<strong>你是云服务器的话</strong>这里一定要将密钥上传到 <code>/home/git/.ssh</code> 这个路径，不然是不生效的，为什么不生效，这里就相当于什么呢？！就是相当于你把你服务器中的密钥添加到了 git 中，其中 git 的路径为/home/git ,所以肯定要添加到这个地方。</p>\n<p>如果<strong>你是在虚拟机中</strong>，那么.ssh是有一个默认路径的，一般为：<code>/root/.ssh</code>,直接把生成的公钥放到这个位置或者通过 ssh 上传即可。</p>\n<p>究其原因，你在你的Windows电脑上，需要将一个项目或者文件上传到GitHub（或者Gitee），然后通过仓库的https链接很多时候会报网络超时的错误，相信很多时候大家都会遇到，于是，我们发现GitHub官方还给出了仓库的ssh链接：<code>git@github.com:username/repositoryname</code>，就是这个样子，然后要是用这个的话，你就需要在本地生成一个密钥对，生成方法和下面的方法一样，然后就可以在电脑的<code>C:\\Users\\你的用户名\\.ssh</code>这个路径下看到已经生成的id_rsa（私钥）、id_ras.pub（公钥）。然后你需要将生成的公钥添加到GitHub的设置中，如图：</p>\n<p><img src=\"https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202308242054482.png\" alt=\"image-20230824204900135\"></p>\n<p>同理以上操作就相当于 Linux 系统的操作，只是系统不同罢了，知识点 + 1.</p>\n</blockquote>\n<ul>\n<li><p>如果你本地电脑<code>C:\\Users\\你的用户名\\.ssh</code>中没有生成过ssh密钥，可以按照如下步骤生成密钥：</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stylus\">用户<br>git config <span class=\"hljs-attr\">--global</span> user<span class=\"hljs-selector-class\">.name</span> <span class=\"hljs-string\">&quot;你要设置的git软件的用户名&quot;</span><br>git config <span class=\"hljs-attr\">--global</span> user<span class=\"hljs-selector-class\">.email</span> <span class=\"hljs-string\">&quot;你要设置的邮箱&quot;</span><br><br>ssh-keygen -t rsa -C <span class=\"hljs-string\">&quot;你刚刚设置的邮箱&quot;</span><br></code></pre></td></tr></table></figure></li>\n<li><p><em>为什么要进行通过配置ssh密钥？</em>*</p>\n</li>\n</ul>\n<p>这样主机和服务器的git连接时无需密码即可，更加方便。</p>\n<ol start=\"3\">\n<li><p>在服务器中新建仓库</p>\n<figure class=\"highlight gradle\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs gradle\">cd <span class=\"hljs-regexp\">/home/gi</span>t<br>git init --bare hexoblog.git #在<span class=\"hljs-regexp\">/home/gi</span>t下初始化一个名为hexoblog的仓库<br></code></pre></td></tr></table></figure></li>\n<li><p>配置钩子实现自动部署</p>\n<p> 找到<code>/home/git/hexoblog.git/hooks</code>下的<code>post-receive</code>文件，如果没有则新建一个该文件，将其内容改为</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sh\"><span class=\"hljs-meta\">#!/bin/sh</span><br>git --work-tree=/home/www/xxx --git-dir=/home/git/hexoblog.git checkout -f<br></code></pre></td></tr></table></figure>\n\n<p>以上内容是一条命令，前者<code>/home/www/xxx</code>为网页资源目录，后者<code>/home/git/hexoblog.git</code>为云git仓库。意为当主机将静态文件推给服务器的git仓库后，自动触发hooks文件下的脚本，服务器能够自动将文件部署到网页资源目录，也就是什么呢，相当于Windows系统中 GitHub 网站的 Action，或者也就是<code>Git pages</code>部署，只不过在 Linux 系统中，操作麻烦一点。</p>\n</li>\n<li><p><strong>然后设置网页资源目录的IO权限，否则git没有权限修改网页资源目录的内容，无法实现自动部署！！！</strong></p>\n</li>\n</ol>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">sudo chmod +x /home/git/hexoblog.git/hooks/pre-receive #赋予其可执行权限<br>sudo chown -R git:git /home/git/ #仓库目录的所有者改为git<br>sudo chown -R git:git /home/www/ #站点文件夹所有者改为git<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"Hexo脚手架安装\"><a href=\"#Hexo脚手架安装\" class=\"headerlink\" title=\"Hexo脚手架安装\"></a>Hexo脚手架安装</h2><h3 id=\"直接全局安装：\"><a href=\"#直接全局安装：\" class=\"headerlink\" title=\"直接全局安装：\"></a>直接全局安装：</h3><figure class=\"highlight avrasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs avrasm\">$ npm install -g hexo-<span class=\"hljs-keyword\">cli</span><br></code></pre></td></tr></table></figure>\n\n<p>安装很慢的话，可以先设置npm的淘宝镜像：</p>\n<figure class=\"highlight gams\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs gams\"><span class=\"hljs-symbol\">$</span> npm config <span class=\"hljs-keyword\">set</span> registry <span class=\"hljs-comment\">https:</span>//<span class=\"hljs-comment\">registry.npm.taobao.org</span><br></code></pre></td></tr></table></figure>\n\n<p>官网也给出了进阶局部安装方法，如下：</p>\n<h3 id=\"进阶安装和使用\"><a href=\"#进阶安装和使用\" class=\"headerlink\" title=\"进阶安装和使用\"></a>进阶安装和使用</h3><blockquote>\n<p>对于熟悉 npm 的进阶用户，可以仅局部安装 <code>hexo</code> 包。</p>\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\">$ npm <span class=\"hljs-keyword\">install</span> hexo<br></code></pre></td></tr></table></figure>\n\n<p>安装以后，可以使用以下两种方式执行 Hexo：</p>\n<ol>\n<li><p><code>npx hexo &lt;command&gt;</code></p>\n</li>\n<li><p>Linux 用户可以将 Hexo 所在的目录下的 <code>node_modules</code> 添加到环境变量之中即可直接使用 <code>hexo &lt;command&gt;</code>：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-string\">&#x27;PATH=&quot;$PATH:./node_modules/.bin&quot;&#x27;</span> &gt;&gt; ~/.profile<br></code></pre></td></tr></table></figure></li>\n</ol>\n</blockquote>\n<h2 id=\"本地跑一个hexo博客Demo\"><a href=\"#本地跑一个hexo博客Demo\" class=\"headerlink\" title=\"本地跑一个hexo博客Demo\"></a>本地跑一个hexo博客Demo</h2><p>直接参考<a href=\"https://hexo.io/zh-cn/\">官方文档</a>,初始化一个博客，已经有hexo博客的话就直接跳过。</p>\n<p>在你的博客目录下面的.config.yml中添加远程git仓库的地址，也就是上面我们在服务器中新建的仓库地址，如图：</p>\n<p><img src=\"https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202308242109919.png\" alt=\"image-20230824210942989\"></p>\n<p>然后就可以愉快的<code>hexo deploy</code>了。</p>\n<p>推荐一起使用：<code>hexo cl &amp;&amp; hexo g &amp;&amp; hexo d</code></p>\n<h2 id=\"怎么访问部署到云服务器的博客呢？\"><a href=\"#怎么访问部署到云服务器的博客呢？\" class=\"headerlink\" title=\"怎么访问部署到云服务器的博客呢？\"></a>怎么访问部署到云服务器的博客呢？</h2><p><code>云服务器IP:</code>+ 端口号进行访问</p>\n<h3 id=\"在宝塔面板添加站点\"><a href=\"#在宝塔面板添加站点\" class=\"headerlink\" title=\"在宝塔面板添加站点\"></a>在宝塔面板添加站点</h3><p> 由于云服务器在域名没有备案的情况下不开放80端口，所以手动设置一个空闲的32端口用于访问网页。</p>\n<p><img src=\"https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202308242124448.png\" alt=\"img\"></p>\n<p> 将网站目录设置为如下（自定义即可）</p>\n<p><img src=\"https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202308242124720.png\" alt=\"img\"></p>\n<p>这里使用的是宝塔面板，也可以使用<code>nginx</code>进行配置,参考文章：<a href=\"https://blog.csdn.net/weixin_56301399/article/details/129270887\">https://blog.csdn.net/weixin_56301399/article/details/129270887</a></p>\n<h2 id=\"全网最全SEO强化篇之怎么让百度、谷歌、必应各大搜索引擎收录自己的文章\"><a href=\"#全网最全SEO强化篇之怎么让百度、谷歌、必应各大搜索引擎收录自己的文章\" class=\"headerlink\" title=\"全网最全SEO强化篇之怎么让百度、谷歌、必应各大搜索引擎收录自己的文章\"></a>全网最全SEO强化篇之怎么让百度、谷歌、必应各大搜索引擎收录自己的文章</h2><ul>\n<li><p>百度</p>\n<ul>\n<li>是需要域名备案的，前提是拥有一台云服务器，所以我先搁置，后续补充</li>\n</ul>\n</li>\n<li><p><a href=\"https://search.google.com/search-console/welcome\">谷歌：Google Search Console</a></p>\n<ul>\n<li>如何进行验证？</li>\n</ul>\n<p><img src=\"https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202308250135183.png\" alt=\"image-20230825013409616\"></p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"博客上云\"><a href=\"#博客上云\" class=\"headerlink\" title=\"博客上云\"></a>博客上云</h1><blockquote>\n<p>博客的访问速度实在是太慢了，准备尝试把博客部署到华为云ECS。</p>\n<p>环境：</p>\n<p>华为云CentOS</p>\n</blockquote>\n<p>新鲜事第一步：打开官方文档</p>\n<p>​    <a href=\"https://hexo.io/zh-cn/docs/\">Hexo博客的官方文档</a></p>\n<h2 id=\"安装前提\"><a href=\"#安装前提\" class=\"headerlink\" title=\"安装前提\"></a>安装前提</h2><p>安装 Hexo 相当简单，只需要先安装下列应用程序即可：</p>\n<ul>\n<li><a href=\"http://nodejs.org/\">Node.js</a> (Node.js 版本需不低于 10.13，建议使用 Node.js 12.0 及以上版本)</li>\n<li><a href=\"http://git-scm.com/\">Git</a></li>\n</ul>\n<p>如果您的电脑中已经安装上述必备程序，那么恭喜您！你可以直接前往 <a href=\"https://hexo.io/zh-cn/docs/#%E5%AE%89%E8%A3%85-Hexo\">安装 Hexo</a> 步骤。</p>\n<h3 id=\"Node的安装\"><a href=\"#Node的安装\" class=\"headerlink\" title=\"Node的安装\"></a>Node的安装</h3><p>为了后续排错方便，我们使用 NVM 来进行 Node 的安装。</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs awk\"><span class=\"hljs-comment\"># 安装NVM</span><br>$ curl -o- https:<span class=\"hljs-regexp\">//</span>raw.githubusercontent.com<span class=\"hljs-regexp\">/nvm-sh/</span>nvm<span class=\"hljs-regexp\">/v0.38.0/</span><br><br><span class=\"hljs-comment\"># 激活配置</span><br>$ source ~/.bashrc<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202308220133637.png\" alt=\"image-20230822013352104\"></p>\n<h4 id=\"Node-js-版本限制\"><a href=\"#Node-js-版本限制\" class=\"headerlink\" title=\"Node.js 版本限制\"></a>Node.js 版本限制</h4><p>如果你坚持使用旧的 Node.js，你可以考虑安装 Hexo 的过去版本。</p>\n<p>请注意，我们不提供对过去版本 Hexo 的错误修复。</p>\n<p>我们强烈建议永远安装 <a href=\"https://www.npmjs.com/package/hexo?activeTab=versions\">最新版本</a> 的 Hexo，以及 <a href=\"https://hexo.io/zh-cn/docs/#%E5%AE%89%E8%A3%85%E5%89%8D%E6%8F%90\">推荐的 Node.js 版本</a>。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Hexo 版本</th>\n<th align=\"left\">最低版本 (Node.js 版本)</th>\n<th align=\"left\">最高版本 (Node.js 版本)</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">6.2+</td>\n<td align=\"left\">12.13.0</td>\n<td align=\"left\">latest</td>\n</tr>\n<tr>\n<td align=\"left\">6.0+</td>\n<td align=\"left\">12.13.0</td>\n<td align=\"left\">18.5.0</td>\n</tr>\n<tr>\n<td align=\"left\">5.0+</td>\n<td align=\"left\">10.13.0</td>\n<td align=\"left\">12.0.0</td>\n</tr>\n<tr>\n<td align=\"left\">4.1 - 4.2</td>\n<td align=\"left\">8.10</td>\n<td align=\"left\">10.0.0</td>\n</tr>\n<tr>\n<td align=\"left\">4.0</td>\n<td align=\"left\">8.6</td>\n<td align=\"left\">8.10.0</td>\n</tr>\n<tr>\n<td align=\"left\">3.3 - 3.9</td>\n<td align=\"left\">6.9</td>\n<td align=\"left\">8.0.0</td>\n</tr>\n<tr>\n<td align=\"left\">3.2 - 3.3</td>\n<td align=\"left\">0.12</td>\n<td align=\"left\">未知</td>\n</tr>\n<tr>\n<td align=\"left\">3.0 - 3.1</td>\n<td align=\"left\">0.10 或 iojs</td>\n<td align=\"left\">未知</td>\n</tr>\n<tr>\n<td align=\"left\">0.0.1 - 2.8</td>\n<td align=\"left\">0.10</td>\n<td align=\"left\">未知</td>\n</tr>\n</tbody></table>\n<h3 id=\"Git的安装\"><a href=\"#Git的安装\" class=\"headerlink\" title=\"Git的安装\"></a>Git的安装</h3><figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\">yum <span class=\"hljs-keyword\">install</span> git-core<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202308220137246.png\" alt=\"image-20230822013716334\"></p>\n<p>安装完毕！！！</p>\n<p><strong>开始搭建Git服务器：</strong></p>\n<ol>\n<li>添加一个git用户</li>\n</ol>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\"><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">添加git用户</span><br><span class=\"hljs-meta prompt_\">$ </span><span class=\"language-bash\">adduser git</span> <br><span class=\"hljs-meta prompt_\"></span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">改变sudoers文件的权限为文件所有者可写</span><br><span class=\"hljs-meta prompt_\">$ </span><span class=\"language-bash\"><span class=\"hljs-built_in\">chmod</span> 740 /etc/sudoers</span><br><span class=\"hljs-meta prompt_\">$ </span><span class=\"language-bash\">vim /etc/sudoers</span><br><span class=\"hljs-meta prompt_\"></span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">添加一行内容,按esc,再按:wq退出编辑</span><br>将 git ALL=(ALL) ALL 添加到root ALL=(ALL) ALL下方<br><span class=\"hljs-meta prompt_\"></span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">将sudoers文件的权限改回文件所有者可读</span><br><span class=\"hljs-meta prompt_\">$ </span><span class=\"language-bash\"><span class=\"hljs-built_in\">chmod</span> 400 /etc/sudoers</span> <br><span class=\"hljs-meta prompt_\"></span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">设置服务器的git密码，用于git连接。输入时看不到任何显示，输入完成回车即可</span><br><span class=\"hljs-meta prompt_\">$ </span><span class=\"language-bash\">sudo passwd git</span> <br></code></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>给服务器和主机的Git配置SSH密钥</li>\n</ol>\n<ul>\n<li>如果你的本地电脑中已有ssh密钥则跳过这一步，直接到<code>C:\\Users\\你的用户名\\.ssh</code>中找到<code>id_rsa.pub</code>通过宝塔面板或者FTP将<code>id_rsa.pub</code>上传到<code>/home/git/.ssh</code>。</li>\n</ul>\n<blockquote>\n<p>注意，如果<strong>你是云服务器的话</strong>这里一定要将密钥上传到 <code>/home/git/.ssh</code> 这个路径，不然是不生效的，为什么不生效，这里就相当于什么呢？！就是相当于你把你服务器中的密钥添加到了 git 中，其中 git 的路径为/home/git ,所以肯定要添加到这个地方。</p>\n<p>如果<strong>你是在虚拟机中</strong>，那么.ssh是有一个默认路径的，一般为：<code>/root/.ssh</code>,直接把生成的公钥放到这个位置或者通过 ssh 上传即可。</p>\n<p>究其原因，你在你的Windows电脑上，需要将一个项目或者文件上传到GitHub（或者Gitee），然后通过仓库的https链接很多时候会报网络超时的错误，相信很多时候大家都会遇到，于是，我们发现GitHub官方还给出了仓库的ssh链接：<code>git@github.com:username/repositoryname</code>，就是这个样子，然后要是用这个的话，你就需要在本地生成一个密钥对，生成方法和下面的方法一样，然后就可以在电脑的<code>C:\\Users\\你的用户名\\.ssh</code>这个路径下看到已经生成的id_rsa（私钥）、id_ras.pub（公钥）。然后你需要将生成的公钥添加到GitHub的设置中，如图：</p>\n<p><img src=\"https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202308242054482.png\" alt=\"image-20230824204900135\"></p>\n<p>同理以上操作就相当于 Linux 系统的操作，只是系统不同罢了，知识点 + 1.</p>\n</blockquote>\n<ul>\n<li><p>如果你本地电脑<code>C:\\Users\\你的用户名\\.ssh</code>中没有生成过ssh密钥，可以按照如下步骤生成密钥：</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stylus\">用户<br>git config <span class=\"hljs-attr\">--global</span> user<span class=\"hljs-selector-class\">.name</span> <span class=\"hljs-string\">&quot;你要设置的git软件的用户名&quot;</span><br>git config <span class=\"hljs-attr\">--global</span> user<span class=\"hljs-selector-class\">.email</span> <span class=\"hljs-string\">&quot;你要设置的邮箱&quot;</span><br><br>ssh-keygen -t rsa -C <span class=\"hljs-string\">&quot;你刚刚设置的邮箱&quot;</span><br></code></pre></td></tr></table></figure></li>\n<li><p><em>为什么要进行通过配置ssh密钥？</em>*</p>\n</li>\n</ul>\n<p>这样主机和服务器的git连接时无需密码即可，更加方便。</p>\n<ol start=\"3\">\n<li><p>在服务器中新建仓库</p>\n<figure class=\"highlight gradle\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs gradle\">cd <span class=\"hljs-regexp\">/home/gi</span>t<br>git init --bare hexoblog.git #在<span class=\"hljs-regexp\">/home/gi</span>t下初始化一个名为hexoblog的仓库<br></code></pre></td></tr></table></figure></li>\n<li><p>配置钩子实现自动部署</p>\n<p> 找到<code>/home/git/hexoblog.git/hooks</code>下的<code>post-receive</code>文件，如果没有则新建一个该文件，将其内容改为</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sh\"><span class=\"hljs-meta\">#!/bin/sh</span><br>git --work-tree=/home/www/xxx --git-dir=/home/git/hexoblog.git checkout -f<br></code></pre></td></tr></table></figure>\n\n<p>以上内容是一条命令，前者<code>/home/www/xxx</code>为网页资源目录，后者<code>/home/git/hexoblog.git</code>为云git仓库。意为当主机将静态文件推给服务器的git仓库后，自动触发hooks文件下的脚本，服务器能够自动将文件部署到网页资源目录，也就是什么呢，相当于Windows系统中 GitHub 网站的 Action，或者也就是<code>Git pages</code>部署，只不过在 Linux 系统中，操作麻烦一点。</p>\n</li>\n<li><p><strong>然后设置网页资源目录的IO权限，否则git没有权限修改网页资源目录的内容，无法实现自动部署！！！</strong></p>\n</li>\n</ol>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">sudo chmod +x /home/git/hexoblog.git/hooks/pre-receive #赋予其可执行权限<br>sudo chown -R git:git /home/git/ #仓库目录的所有者改为git<br>sudo chown -R git:git /home/www/ #站点文件夹所有者改为git<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"Hexo脚手架安装\"><a href=\"#Hexo脚手架安装\" class=\"headerlink\" title=\"Hexo脚手架安装\"></a>Hexo脚手架安装</h2><h3 id=\"直接全局安装：\"><a href=\"#直接全局安装：\" class=\"headerlink\" title=\"直接全局安装：\"></a>直接全局安装：</h3><figure class=\"highlight avrasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs avrasm\">$ npm install -g hexo-<span class=\"hljs-keyword\">cli</span><br></code></pre></td></tr></table></figure>\n\n<p>安装很慢的话，可以先设置npm的淘宝镜像：</p>\n<figure class=\"highlight gams\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs gams\"><span class=\"hljs-symbol\">$</span> npm config <span class=\"hljs-keyword\">set</span> registry <span class=\"hljs-comment\">https:</span>//<span class=\"hljs-comment\">registry.npm.taobao.org</span><br></code></pre></td></tr></table></figure>\n\n<p>官网也给出了进阶局部安装方法，如下：</p>\n<h3 id=\"进阶安装和使用\"><a href=\"#进阶安装和使用\" class=\"headerlink\" title=\"进阶安装和使用\"></a>进阶安装和使用</h3><blockquote>\n<p>对于熟悉 npm 的进阶用户，可以仅局部安装 <code>hexo</code> 包。</p>\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\">$ npm <span class=\"hljs-keyword\">install</span> hexo<br></code></pre></td></tr></table></figure>\n\n<p>安装以后，可以使用以下两种方式执行 Hexo：</p>\n<ol>\n<li><p><code>npx hexo &lt;command&gt;</code></p>\n</li>\n<li><p>Linux 用户可以将 Hexo 所在的目录下的 <code>node_modules</code> 添加到环境变量之中即可直接使用 <code>hexo &lt;command&gt;</code>：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-string\">&#x27;PATH=&quot;$PATH:./node_modules/.bin&quot;&#x27;</span> &gt;&gt; ~/.profile<br></code></pre></td></tr></table></figure></li>\n</ol>\n</blockquote>\n<h2 id=\"本地跑一个hexo博客Demo\"><a href=\"#本地跑一个hexo博客Demo\" class=\"headerlink\" title=\"本地跑一个hexo博客Demo\"></a>本地跑一个hexo博客Demo</h2><p>直接参考<a href=\"https://hexo.io/zh-cn/\">官方文档</a>,初始化一个博客，已经有hexo博客的话就直接跳过。</p>\n<p>在你的博客目录下面的.config.yml中添加远程git仓库的地址，也就是上面我们在服务器中新建的仓库地址，如图：</p>\n<p><img src=\"https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202308242109919.png\" alt=\"image-20230824210942989\"></p>\n<p>然后就可以愉快的<code>hexo deploy</code>了。</p>\n<p>推荐一起使用：<code>hexo cl &amp;&amp; hexo g &amp;&amp; hexo d</code></p>\n<h2 id=\"怎么访问部署到云服务器的博客呢？\"><a href=\"#怎么访问部署到云服务器的博客呢？\" class=\"headerlink\" title=\"怎么访问部署到云服务器的博客呢？\"></a>怎么访问部署到云服务器的博客呢？</h2><p><code>云服务器IP:</code>+ 端口号进行访问</p>\n<h3 id=\"在宝塔面板添加站点\"><a href=\"#在宝塔面板添加站点\" class=\"headerlink\" title=\"在宝塔面板添加站点\"></a>在宝塔面板添加站点</h3><p> 由于云服务器在域名没有备案的情况下不开放80端口，所以手动设置一个空闲的32端口用于访问网页。</p>\n<p><img src=\"https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202308242124448.png\" alt=\"img\"></p>\n<p> 将网站目录设置为如下（自定义即可）</p>\n<p><img src=\"https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202308242124720.png\" alt=\"img\"></p>\n<p>这里使用的是宝塔面板，也可以使用<code>nginx</code>进行配置,参考文章：<a href=\"https://blog.csdn.net/weixin_56301399/article/details/129270887\">https://blog.csdn.net/weixin_56301399/article/details/129270887</a></p>\n<h2 id=\"全网最全SEO强化篇之怎么让百度、谷歌、必应各大搜索引擎收录自己的文章\"><a href=\"#全网最全SEO强化篇之怎么让百度、谷歌、必应各大搜索引擎收录自己的文章\" class=\"headerlink\" title=\"全网最全SEO强化篇之怎么让百度、谷歌、必应各大搜索引擎收录自己的文章\"></a>全网最全SEO强化篇之怎么让百度、谷歌、必应各大搜索引擎收录自己的文章</h2><ul>\n<li><p>百度</p>\n<ul>\n<li>是需要域名备案的，前提是拥有一台云服务器，所以我先搁置，后续补充</li>\n</ul>\n</li>\n<li><p><a href=\"https://search.google.com/search-console/welcome\">谷歌：Google Search Console</a></p>\n<ul>\n<li>如何进行验证？</li>\n</ul>\n<p><img src=\"https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202308250135183.png\" alt=\"image-20230825013409616\"></p>\n</li>\n</ul>\n"},{"title":"一篇文章搞懂什么是Netty","index_img":"https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311151627639.png","abbrlink":5282,"date":"2022-10-31T22:58:32.000Z","_content":"# 什么是Netty\n\n## 是什么？\n\nNetty 是一个开源的、高性能的、异步的、事件驱动的网络应用程序框架，它基于 Java NIO（Non-blocking I/O）技术，提供了简单易用的 API，可用于开发各种网络应用程序，包括客户端和服务器端应用程序，如网络协议服务器、Web 服务、高性能代理服务器、游戏服务器等。\n\n## 优缺点？\n\n### 优点：\n\n1. 高性能和可伸缩性：Netty 基于 Java NIO 技术，使用非阻塞 I/O 模型，具有更好的性能和可伸缩性，可以处理大量的并发连接。\n2. 异步和事件驱动：Netty 使用事件驱动的设计模式，通过异步的方式处理网络 I/O 事件，提高了应用程序的并发处理能力。\n3. 简单易用的 API：Netty 提供了简单易用、灵活可扩展的 API，使得开发网络应用程序更加容易和快速。\n4. 支持多种协议：Netty 支持多种主流的网络协议，如 HTTP、WebSocket、TCP、UDP、SMTP、FTP 等，且支持自定义的协议。\n5. 可扩展性：Netty 的设计允许用户自定义和扩展各种组件，包括编解码器、处理器、事件监听器等。\n\n### 缺点：\n\n1. 学习成本相对较高：Netty 是一个底层的网络应用程序框架，需要具备一定的网络编程和 Java 编程的基础知识，学习起来相对较为困难。\n2. 细节较多：Netty 的设计和使用需要注意一些细节问题，如线程安全、连接管理、性能优化等方面的问题，需要开发人员具备一定的经验和技能。\n3. 部署和维护相对较为复杂：Netty 的底层网络编程需要具备一定的系统调优和网络架构设计的知识，部署和维护相对较为复杂。\n\n## 应用程场景？\n\n应用场景：\n\nNetty 可以应用于各种网络应用程序的开发，包括客户端和服务器端应用程序，如网络协议服务器、Web 服务、高性能代理服务器、游戏服务器等。具体来说，Netty 可以用于以下场景：\n\n1. 高性能的网络协议服务器：Netty 的异步、事件驱动的设计模式和非阻塞 I/O 模型，使得它非常适合用于开发高性能的网络协议服务器，如 HTTP 服务器、WebSocket 服务器等。\n2. 高并发的网络代理服务器：Netty 的异步和事件驱动的设计模式，以及其可扩展的编解码器和处理器，使得它非常适合用于开发高并发的网络代理服务器，如反向代理服务器、负载均衡服务器等。\n3. 高效的游戏服务器：Netty 的高性能和异步的设计模式，使得它非常适合用于开发高效的游戏服务器，如实时多人在线游戏服务器、游戏聊天服务器等。\n4. 高可用的分布式系统：Netty 的可扩展性和灵活性，使得它非常适合用于开发高可用的分布式系统，如分布式存储系统、分布式缓存系统等。","source":"_posts/netty.md","raw":"---\ntitle: 一篇文章搞懂什么是Netty\nindex_img: https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311151627639.png\ncategories:\n  - 框架\ntags:\n  - Netty\nabbrlink: 5282\ndate: 2022-11-01 06:58:32\n---\n# 什么是Netty\n\n## 是什么？\n\nNetty 是一个开源的、高性能的、异步的、事件驱动的网络应用程序框架，它基于 Java NIO（Non-blocking I/O）技术，提供了简单易用的 API，可用于开发各种网络应用程序，包括客户端和服务器端应用程序，如网络协议服务器、Web 服务、高性能代理服务器、游戏服务器等。\n\n## 优缺点？\n\n### 优点：\n\n1. 高性能和可伸缩性：Netty 基于 Java NIO 技术，使用非阻塞 I/O 模型，具有更好的性能和可伸缩性，可以处理大量的并发连接。\n2. 异步和事件驱动：Netty 使用事件驱动的设计模式，通过异步的方式处理网络 I/O 事件，提高了应用程序的并发处理能力。\n3. 简单易用的 API：Netty 提供了简单易用、灵活可扩展的 API，使得开发网络应用程序更加容易和快速。\n4. 支持多种协议：Netty 支持多种主流的网络协议，如 HTTP、WebSocket、TCP、UDP、SMTP、FTP 等，且支持自定义的协议。\n5. 可扩展性：Netty 的设计允许用户自定义和扩展各种组件，包括编解码器、处理器、事件监听器等。\n\n### 缺点：\n\n1. 学习成本相对较高：Netty 是一个底层的网络应用程序框架，需要具备一定的网络编程和 Java 编程的基础知识，学习起来相对较为困难。\n2. 细节较多：Netty 的设计和使用需要注意一些细节问题，如线程安全、连接管理、性能优化等方面的问题，需要开发人员具备一定的经验和技能。\n3. 部署和维护相对较为复杂：Netty 的底层网络编程需要具备一定的系统调优和网络架构设计的知识，部署和维护相对较为复杂。\n\n## 应用程场景？\n\n应用场景：\n\nNetty 可以应用于各种网络应用程序的开发，包括客户端和服务器端应用程序，如网络协议服务器、Web 服务、高性能代理服务器、游戏服务器等。具体来说，Netty 可以用于以下场景：\n\n1. 高性能的网络协议服务器：Netty 的异步、事件驱动的设计模式和非阻塞 I/O 模型，使得它非常适合用于开发高性能的网络协议服务器，如 HTTP 服务器、WebSocket 服务器等。\n2. 高并发的网络代理服务器：Netty 的异步和事件驱动的设计模式，以及其可扩展的编解码器和处理器，使得它非常适合用于开发高并发的网络代理服务器，如反向代理服务器、负载均衡服务器等。\n3. 高效的游戏服务器：Netty 的高性能和异步的设计模式，使得它非常适合用于开发高效的游戏服务器，如实时多人在线游戏服务器、游戏聊天服务器等。\n4. 高可用的分布式系统：Netty 的可扩展性和灵活性，使得它非常适合用于开发高可用的分布式系统，如分布式存储系统、分布式缓存系统等。","slug":"netty","published":1,"updated":"2023-11-15T08:38:44.047Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clpkiczjf002yfkfo3gcge6jj","content":"<h1 id=\"什么是Netty\"><a href=\"#什么是Netty\" class=\"headerlink\" title=\"什么是Netty\"></a>什么是Netty</h1><h2 id=\"是什么？\"><a href=\"#是什么？\" class=\"headerlink\" title=\"是什么？\"></a>是什么？</h2><p>Netty 是一个开源的、高性能的、异步的、事件驱动的网络应用程序框架，它基于 Java NIO（Non-blocking I/O）技术，提供了简单易用的 API，可用于开发各种网络应用程序，包括客户端和服务器端应用程序，如网络协议服务器、Web 服务、高性能代理服务器、游戏服务器等。</p>\n<h2 id=\"优缺点？\"><a href=\"#优缺点？\" class=\"headerlink\" title=\"优缺点？\"></a>优缺点？</h2><h3 id=\"优点：\"><a href=\"#优点：\" class=\"headerlink\" title=\"优点：\"></a>优点：</h3><ol>\n<li>高性能和可伸缩性：Netty 基于 Java NIO 技术，使用非阻塞 I/O 模型，具有更好的性能和可伸缩性，可以处理大量的并发连接。</li>\n<li>异步和事件驱动：Netty 使用事件驱动的设计模式，通过异步的方式处理网络 I/O 事件，提高了应用程序的并发处理能力。</li>\n<li>简单易用的 API：Netty 提供了简单易用、灵活可扩展的 API，使得开发网络应用程序更加容易和快速。</li>\n<li>支持多种协议：Netty 支持多种主流的网络协议，如 HTTP、WebSocket、TCP、UDP、SMTP、FTP 等，且支持自定义的协议。</li>\n<li>可扩展性：Netty 的设计允许用户自定义和扩展各种组件，包括编解码器、处理器、事件监听器等。</li>\n</ol>\n<h3 id=\"缺点：\"><a href=\"#缺点：\" class=\"headerlink\" title=\"缺点：\"></a>缺点：</h3><ol>\n<li>学习成本相对较高：Netty 是一个底层的网络应用程序框架，需要具备一定的网络编程和 Java 编程的基础知识，学习起来相对较为困难。</li>\n<li>细节较多：Netty 的设计和使用需要注意一些细节问题，如线程安全、连接管理、性能优化等方面的问题，需要开发人员具备一定的经验和技能。</li>\n<li>部署和维护相对较为复杂：Netty 的底层网络编程需要具备一定的系统调优和网络架构设计的知识，部署和维护相对较为复杂。</li>\n</ol>\n<h2 id=\"应用程场景？\"><a href=\"#应用程场景？\" class=\"headerlink\" title=\"应用程场景？\"></a>应用程场景？</h2><p>应用场景：</p>\n<p>Netty 可以应用于各种网络应用程序的开发，包括客户端和服务器端应用程序，如网络协议服务器、Web 服务、高性能代理服务器、游戏服务器等。具体来说，Netty 可以用于以下场景：</p>\n<ol>\n<li>高性能的网络协议服务器：Netty 的异步、事件驱动的设计模式和非阻塞 I/O 模型，使得它非常适合用于开发高性能的网络协议服务器，如 HTTP 服务器、WebSocket 服务器等。</li>\n<li>高并发的网络代理服务器：Netty 的异步和事件驱动的设计模式，以及其可扩展的编解码器和处理器，使得它非常适合用于开发高并发的网络代理服务器，如反向代理服务器、负载均衡服务器等。</li>\n<li>高效的游戏服务器：Netty 的高性能和异步的设计模式，使得它非常适合用于开发高效的游戏服务器，如实时多人在线游戏服务器、游戏聊天服务器等。</li>\n<li>高可用的分布式系统：Netty 的可扩展性和灵活性，使得它非常适合用于开发高可用的分布式系统，如分布式存储系统、分布式缓存系统等。</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"什么是Netty\"><a href=\"#什么是Netty\" class=\"headerlink\" title=\"什么是Netty\"></a>什么是Netty</h1><h2 id=\"是什么？\"><a href=\"#是什么？\" class=\"headerlink\" title=\"是什么？\"></a>是什么？</h2><p>Netty 是一个开源的、高性能的、异步的、事件驱动的网络应用程序框架，它基于 Java NIO（Non-blocking I/O）技术，提供了简单易用的 API，可用于开发各种网络应用程序，包括客户端和服务器端应用程序，如网络协议服务器、Web 服务、高性能代理服务器、游戏服务器等。</p>\n<h2 id=\"优缺点？\"><a href=\"#优缺点？\" class=\"headerlink\" title=\"优缺点？\"></a>优缺点？</h2><h3 id=\"优点：\"><a href=\"#优点：\" class=\"headerlink\" title=\"优点：\"></a>优点：</h3><ol>\n<li>高性能和可伸缩性：Netty 基于 Java NIO 技术，使用非阻塞 I/O 模型，具有更好的性能和可伸缩性，可以处理大量的并发连接。</li>\n<li>异步和事件驱动：Netty 使用事件驱动的设计模式，通过异步的方式处理网络 I/O 事件，提高了应用程序的并发处理能力。</li>\n<li>简单易用的 API：Netty 提供了简单易用、灵活可扩展的 API，使得开发网络应用程序更加容易和快速。</li>\n<li>支持多种协议：Netty 支持多种主流的网络协议，如 HTTP、WebSocket、TCP、UDP、SMTP、FTP 等，且支持自定义的协议。</li>\n<li>可扩展性：Netty 的设计允许用户自定义和扩展各种组件，包括编解码器、处理器、事件监听器等。</li>\n</ol>\n<h3 id=\"缺点：\"><a href=\"#缺点：\" class=\"headerlink\" title=\"缺点：\"></a>缺点：</h3><ol>\n<li>学习成本相对较高：Netty 是一个底层的网络应用程序框架，需要具备一定的网络编程和 Java 编程的基础知识，学习起来相对较为困难。</li>\n<li>细节较多：Netty 的设计和使用需要注意一些细节问题，如线程安全、连接管理、性能优化等方面的问题，需要开发人员具备一定的经验和技能。</li>\n<li>部署和维护相对较为复杂：Netty 的底层网络编程需要具备一定的系统调优和网络架构设计的知识，部署和维护相对较为复杂。</li>\n</ol>\n<h2 id=\"应用程场景？\"><a href=\"#应用程场景？\" class=\"headerlink\" title=\"应用程场景？\"></a>应用程场景？</h2><p>应用场景：</p>\n<p>Netty 可以应用于各种网络应用程序的开发，包括客户端和服务器端应用程序，如网络协议服务器、Web 服务、高性能代理服务器、游戏服务器等。具体来说，Netty 可以用于以下场景：</p>\n<ol>\n<li>高性能的网络协议服务器：Netty 的异步、事件驱动的设计模式和非阻塞 I/O 模型，使得它非常适合用于开发高性能的网络协议服务器，如 HTTP 服务器、WebSocket 服务器等。</li>\n<li>高并发的网络代理服务器：Netty 的异步和事件驱动的设计模式，以及其可扩展的编解码器和处理器，使得它非常适合用于开发高并发的网络代理服务器，如反向代理服务器、负载均衡服务器等。</li>\n<li>高效的游戏服务器：Netty 的高性能和异步的设计模式，使得它非常适合用于开发高效的游戏服务器，如实时多人在线游戏服务器、游戏聊天服务器等。</li>\n<li>高可用的分布式系统：Netty 的可扩展性和灵活性，使得它非常适合用于开发高可用的分布式系统，如分布式存储系统、分布式缓存系统等。</li>\n</ol>\n"},{"title":"JavaObject","index_img":"https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202309120835293.png","abbrlink":18850,"date":"2022-01-03T10:29:02.000Z","_content":"# Object类\n\n* 对象比较\n\n  hashCode()\n  \n  equals(Object obj)\n\n* 对象拷贝\n\n​\t\tclone()\n\n* 对象转字符串\n\n​\t\ttoString()\n\n* 多线程调度\n\n​\t\twait()\n\n​\t\twait(long timeout)\n\n​\t\twait(long timeout, int nanos)\n\n​\t\tnotify()\n\n​\t\tnotifyAll()\n\n* 反射\n\n​\t\tgetClass()\n\n* 垃圾回收\n\n​\t\tfinalize()\n\n## JDK8新特性\n\n![](https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/javase-37.png)\n\n\n\n![](https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/javase-38.png)\n\n\n\n![](https://img.shields.io/badge/Gitee-wlei224.gitee.io-brightgreen?link=http://www.baidu.com&link=http://www.tencent.com&logo=Gitee)","source":"_posts/object.md","raw":"---\ntitle: JavaObject\nindex_img: >-\n  https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202309120835293.png\ncategories:\n  - Java notes\ntags:\n  - Object类\nabbrlink: 18850\ndate: 2022-01-03 18:29:02\n---\n# Object类\n\n* 对象比较\n\n  hashCode()\n  \n  equals(Object obj)\n\n* 对象拷贝\n\n​\t\tclone()\n\n* 对象转字符串\n\n​\t\ttoString()\n\n* 多线程调度\n\n​\t\twait()\n\n​\t\twait(long timeout)\n\n​\t\twait(long timeout, int nanos)\n\n​\t\tnotify()\n\n​\t\tnotifyAll()\n\n* 反射\n\n​\t\tgetClass()\n\n* 垃圾回收\n\n​\t\tfinalize()\n\n## JDK8新特性\n\n![](https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/javase-37.png)\n\n\n\n![](https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/javase-38.png)\n\n\n\n![](https://img.shields.io/badge/Gitee-wlei224.gitee.io-brightgreen?link=http://www.baidu.com&link=http://www.tencent.com&logo=Gitee)","slug":"object","published":1,"updated":"2023-10-16T06:58:59.303Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clpkiczjg0032fkfo2tw5b6dy","content":"<h1 id=\"Object类\"><a href=\"#Object类\" class=\"headerlink\" title=\"Object类\"></a>Object类</h1><ul>\n<li><p>对象比较</p>\n<p>hashCode()</p>\n<p>equals(Object obj)</p>\n</li>\n<li><p>对象拷贝</p>\n</li>\n</ul>\n<p>​        clone()</p>\n<ul>\n<li>对象转字符串</li>\n</ul>\n<p>​        toString()</p>\n<ul>\n<li>多线程调度</li>\n</ul>\n<p>​        wait()</p>\n<p>​        wait(long timeout)</p>\n<p>​        wait(long timeout, int nanos)</p>\n<p>​        notify()</p>\n<p>​        notifyAll()</p>\n<ul>\n<li>反射</li>\n</ul>\n<p>​        getClass()</p>\n<ul>\n<li>垃圾回收</li>\n</ul>\n<p>​        finalize()</p>\n<h2 id=\"JDK8新特性\"><a href=\"#JDK8新特性\" class=\"headerlink\" title=\"JDK8新特性\"></a>JDK8新特性</h2><p><img src=\"https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/javase-37.png\"></p>\n<p><img src=\"https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/javase-38.png\"></p>\n<p><img src=\"https://img.shields.io/badge/Gitee-wlei224.gitee.io-brightgreen?link=http://www.baidu.com&link=http://www.tencent.com&logo=Gitee\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Object类\"><a href=\"#Object类\" class=\"headerlink\" title=\"Object类\"></a>Object类</h1><ul>\n<li><p>对象比较</p>\n<p>hashCode()</p>\n<p>equals(Object obj)</p>\n</li>\n<li><p>对象拷贝</p>\n</li>\n</ul>\n<p>​        clone()</p>\n<ul>\n<li>对象转字符串</li>\n</ul>\n<p>​        toString()</p>\n<ul>\n<li>多线程调度</li>\n</ul>\n<p>​        wait()</p>\n<p>​        wait(long timeout)</p>\n<p>​        wait(long timeout, int nanos)</p>\n<p>​        notify()</p>\n<p>​        notifyAll()</p>\n<ul>\n<li>反射</li>\n</ul>\n<p>​        getClass()</p>\n<ul>\n<li>垃圾回收</li>\n</ul>\n<p>​        finalize()</p>\n<h2 id=\"JDK8新特性\"><a href=\"#JDK8新特性\" class=\"headerlink\" title=\"JDK8新特性\"></a>JDK8新特性</h2><p><img src=\"https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/javase-37.png\"></p>\n<p><img src=\"https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/javase-38.png\"></p>\n<p><img src=\"https://img.shields.io/badge/Gitee-wlei224.gitee.io-brightgreen?link=http://www.baidu.com&link=http://www.tencent.com&logo=Gitee\"></p>\n"},{"title":"基于Spring Boot的在线编程判题系统","index_img":"https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311151627634.png","banner_img":"https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311151640352.png","hide":true,"abbrlink":6280,"date":"2023-08-21T00:12:32.000Z","_content":"\n# Smart OJ\n\n> ## 复习一下项目开发流程\n>\n> 1. 项目简介、项目调研、项目需求分析\n>\n> 2. 核心业务流程\n>\n> 3. 项目功能模块\n>\n> 4. 技术选型\n>\n> 5. 项目初始化\n>\n> 6. 项目开发\n>\n> 7. 测试\n>\n> 8. 优化\n>\n>    （代码提交、代码审核、产品验收）\n>\n> 9. 上线\n>\n> 在此过程中，也是要不断写文档、持续调研、沉淀知识的\n\n\n\n## 项目简介\n\nOJ ： Online Judge（在线判题评测系统）\n\n用户可以选择题目练习，在线编写代码，测试代码，提交代码，系统会根据设置好的答案对用户提交的代码进行评测，给出评测结果！\n\n#### 项目亮点\n\n1. 项目新颖，重复度低，写简历有区分度\n2. 区别于常见的`CRUD`项目，偏向于架构设计、编程思想之类的知识\n3. 项目复杂度高，可扩展性强\n\n#### OJ系统的常用概念\n\nac 表示你的题目通过，结果正确\n题目限制：时间限制、内存限制\n题目介绍\n题目输入\n题目输出\n题目输入用例\n题目输出用例\n\n#### **难点**:判题系统\n\n普通测评：管理员设置题目的输入和输出用例，比如我输入 A，你要输出 B 才是正确的；交给判题机去执行用户的代码，给用户的代码喂输入用例，比如 A，看用户程序的执行结果是否和标准答案的输出一致。\n（比对用例文件）\n\n特殊测评（SPJ）：管理员设置题目的输入和输出，比如我输入 1，用户的答案只要是 > 0 或 < 2 都是正确的；特判程序，不是通过对比用例文件是否一致这种死板的程序来检验，而是要专门根据这道题目写一个特殊的判断程序，程序接收题目的输入（1）、标准输出用例（2）、用户的结果（1.5） ，特判程序根据这些值来比较是否正确。\n\n交互测评：让用户输入一个例子，就给一个输出结果，交互比较灵活，没办法通过简单的、死板的输入输出文件来搞定\n\n***不能让用户随便引入包、随便遍历、暴力破解，需要使用正确的算法。 => 安全性***\n\n***判题过程是异步的 => 异步化***\n\n***提交之后，会生成一个提交记录，有运行的结果以及运行信息（时间限制、内存限制）***\n\n\n\n## 项目调研\n\nhttps://github.com/HimitZH/HOJ(适合学习)\nhttps://github.com/QingdaoU/OnlineJudge(python,不好学，很成熟)\nhttps://github.com/hzxie/Noj(星星没那么多，没那么成熟，但相对好学)\nhttps://github.com/vfleaking,/uoj(php实现的)\n\n\n\n## 项目需求分析\n\n\n\n#### 实现核心\n\n1. 权限校验\n\n2. 代码沙箱（安全沙箱 -- 防止代码藏毒）\n\n   代码安全：设置安全的、隔离的沙箱，以确保用户的代码不会影响到系统的安全\n\n   \n\n3. 判题规则\n\n   题目用例的比对，结果的验证\n\n4. 任务调度\n\n   资源分配：防止用户疯狂占用资源，措施：异步化处理，服务资源有限，按照用户提交顺序进行判题\n\n#### 核心业务流程\n\n![image-20231122184857284](https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311221849444.png)\n\n时序图：\n\n![image-20231115164047376](https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311151640352.png)\n\n#### 功能\n\n1. 题目模块\n\n   a. 管理员：创建、删除、修改\n\n   b. 用户：搜索题目\n\n   c. 在线做题、提交题目代码\n\n2. 用户模块\n\n   a. 注册与登录\n\n3. 判题模块\n\n   a. 提交判题（结果是否正确与错误）\n\n   b. 错误处理（内存溢出、安全性、超时）\n\n   c. 自主实现代码沙箱（安全、隔离的一个环境）\n\n   d. 开放接口\n\n\n\n#### 扩展思路\n\n1. 支持多种语言\n2. 远程评测\n3. 完善的评测功能：普通评测、特殊评测、交互评测、在线自测、文件IO\n4. 统计分析判题记录\n5. 权限校验\n\n\n\n## 技术选型\n\n#### 前端：\n\n`Vue3、手撸Umi项目模板、AcroDesign组件库、在线代码编辑器、在线文档浏览`\n\n#### 后端：\n\n`Java进程控制、Java安全管理、部分JVM知识点、虚拟机、Docker、Spring Cloud微服务、消息队列`\n\n## 架构设计\n\n采用分层架构：用户层、接入层、业务层、服务层、存储层、资源层\n\n![image-20231122192355366](E:/Master/TyporaImages/oj/image-20231122192355366.png)\n\n## 项目排期\n\n1. 项目简介、项目调研、需求分析、技术选型、架构设计、现有`OJ`主流实现方案\n2. 前后端项目初始化、前端通用项目模板的搭建\n3. 主业务流程的前后端开发（争取把代码沙箱之外的全部搞定）\n4. 专攻代码沙箱（自主实现，不止一种实现方案，层层递进，通过实战用例来进行安全优化）\n5. 系统优化（微服务改造、系统扩展思路）\n\n\n\n## 主流OJ实现方案\n\n1. 用现成的`OJ`系统 \n\n网上有很多开源的`OJ`项目，比如`青岛OJ`、`HustOJ`等，可以直接下载开源代码自己部署。\n\n比较推荐的是`judge0`，这是一个非常成熟的`商业OJ`项目，支持 60 多种编程语言！\n\n> 代码：https://github.com/judge0/judge0\n\n2. 用现成的服务 \n\n如果你不希望完整部署一套大而全的代码，只是想复用他人已经实现的、最复杂的判题逻辑，那么可以直接使用现成的 判题`API`、或者现成的 代码沙箱 等服务。\n\n比如`judge0`提供的`判题API`，非常方便易用。只需要通过 HTTP 调用`submissions`判题接口，把用户的代码、输入值、预期的执行结果作为请求参数发送给`judge0`的服务器，它就能自动帮你编译执行程序，并且返回程序的运行结果。\n\n`API`的作用：接受代码、返回执行结果\n\n> `Judge0 API`地址：https://rapidapi.com/judge0-official/api/judge0-ce\n>\n> 官方文档：https://ce.judge0.com/#submissions-submission-post\n\n>  流程 \n>\n> 1先注册\n>\n> 2再开通订阅\n>\n> 3然后测试 language 接口\n>\n> 4测试执行代码接口 submissions\n\n3. **自主开发**✨✨✨--我的方案\n\n自主实现判题服务和代码沙箱，适合学习，但不适用于商业项目。\n\n\n\n4. 把 AI 来当做代码沙箱 \n\n现在 AI 的能力已经十分强大了，我们可以把各种本来很复杂的功能直接交给 AI 来实现。\n\n只要脑洞够大，AI + 编程 = 无限的可能~\n\n\n\n5. 移花接木 \n\n这种方式最有意思、也最 “缺德”。很多同学估计想不到。\n\n那就是可以通过让程序来操作模拟浏览器的方式，用别人已经开发好的 OJ 系统来帮咱们判题。\n\n比如使用 Puppeteer + 无头浏览器，把咱们系统用户提交的代码，像人一样输入到别人的 OJ 网页中，让程序点击提交按钮，并且等别人的 OJ 系统返回判题结果后，再把这个结果返回给我们自己的用户。\n\n这种方式的缺点就是把核心流程交给了别人，如果别人服务挂了，你的服务也就挂了；而且别人 OJ 系统不支持的题目，可能你也支持不了。\n\n\n","source":"_posts/oj.md","raw":"---\ntitle: 基于Spring Boot的在线编程判题系统\nindex_img: https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311151627634.png\nbanner_img: https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311151640352.png\nhide: true\ncategories:\n  - Project\ntags:\n  - Spring Boot\n  - MySQL\nabbrlink: 6280\ndate: 2023-08-21 08:12:32\n---\n\n# Smart OJ\n\n> ## 复习一下项目开发流程\n>\n> 1. 项目简介、项目调研、项目需求分析\n>\n> 2. 核心业务流程\n>\n> 3. 项目功能模块\n>\n> 4. 技术选型\n>\n> 5. 项目初始化\n>\n> 6. 项目开发\n>\n> 7. 测试\n>\n> 8. 优化\n>\n>    （代码提交、代码审核、产品验收）\n>\n> 9. 上线\n>\n> 在此过程中，也是要不断写文档、持续调研、沉淀知识的\n\n\n\n## 项目简介\n\nOJ ： Online Judge（在线判题评测系统）\n\n用户可以选择题目练习，在线编写代码，测试代码，提交代码，系统会根据设置好的答案对用户提交的代码进行评测，给出评测结果！\n\n#### 项目亮点\n\n1. 项目新颖，重复度低，写简历有区分度\n2. 区别于常见的`CRUD`项目，偏向于架构设计、编程思想之类的知识\n3. 项目复杂度高，可扩展性强\n\n#### OJ系统的常用概念\n\nac 表示你的题目通过，结果正确\n题目限制：时间限制、内存限制\n题目介绍\n题目输入\n题目输出\n题目输入用例\n题目输出用例\n\n#### **难点**:判题系统\n\n普通测评：管理员设置题目的输入和输出用例，比如我输入 A，你要输出 B 才是正确的；交给判题机去执行用户的代码，给用户的代码喂输入用例，比如 A，看用户程序的执行结果是否和标准答案的输出一致。\n（比对用例文件）\n\n特殊测评（SPJ）：管理员设置题目的输入和输出，比如我输入 1，用户的答案只要是 > 0 或 < 2 都是正确的；特判程序，不是通过对比用例文件是否一致这种死板的程序来检验，而是要专门根据这道题目写一个特殊的判断程序，程序接收题目的输入（1）、标准输出用例（2）、用户的结果（1.5） ，特判程序根据这些值来比较是否正确。\n\n交互测评：让用户输入一个例子，就给一个输出结果，交互比较灵活，没办法通过简单的、死板的输入输出文件来搞定\n\n***不能让用户随便引入包、随便遍历、暴力破解，需要使用正确的算法。 => 安全性***\n\n***判题过程是异步的 => 异步化***\n\n***提交之后，会生成一个提交记录，有运行的结果以及运行信息（时间限制、内存限制）***\n\n\n\n## 项目调研\n\nhttps://github.com/HimitZH/HOJ(适合学习)\nhttps://github.com/QingdaoU/OnlineJudge(python,不好学，很成熟)\nhttps://github.com/hzxie/Noj(星星没那么多，没那么成熟，但相对好学)\nhttps://github.com/vfleaking,/uoj(php实现的)\n\n\n\n## 项目需求分析\n\n\n\n#### 实现核心\n\n1. 权限校验\n\n2. 代码沙箱（安全沙箱 -- 防止代码藏毒）\n\n   代码安全：设置安全的、隔离的沙箱，以确保用户的代码不会影响到系统的安全\n\n   \n\n3. 判题规则\n\n   题目用例的比对，结果的验证\n\n4. 任务调度\n\n   资源分配：防止用户疯狂占用资源，措施：异步化处理，服务资源有限，按照用户提交顺序进行判题\n\n#### 核心业务流程\n\n![image-20231122184857284](https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311221849444.png)\n\n时序图：\n\n![image-20231115164047376](https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311151640352.png)\n\n#### 功能\n\n1. 题目模块\n\n   a. 管理员：创建、删除、修改\n\n   b. 用户：搜索题目\n\n   c. 在线做题、提交题目代码\n\n2. 用户模块\n\n   a. 注册与登录\n\n3. 判题模块\n\n   a. 提交判题（结果是否正确与错误）\n\n   b. 错误处理（内存溢出、安全性、超时）\n\n   c. 自主实现代码沙箱（安全、隔离的一个环境）\n\n   d. 开放接口\n\n\n\n#### 扩展思路\n\n1. 支持多种语言\n2. 远程评测\n3. 完善的评测功能：普通评测、特殊评测、交互评测、在线自测、文件IO\n4. 统计分析判题记录\n5. 权限校验\n\n\n\n## 技术选型\n\n#### 前端：\n\n`Vue3、手撸Umi项目模板、AcroDesign组件库、在线代码编辑器、在线文档浏览`\n\n#### 后端：\n\n`Java进程控制、Java安全管理、部分JVM知识点、虚拟机、Docker、Spring Cloud微服务、消息队列`\n\n## 架构设计\n\n采用分层架构：用户层、接入层、业务层、服务层、存储层、资源层\n\n![image-20231122192355366](E:/Master/TyporaImages/oj/image-20231122192355366.png)\n\n## 项目排期\n\n1. 项目简介、项目调研、需求分析、技术选型、架构设计、现有`OJ`主流实现方案\n2. 前后端项目初始化、前端通用项目模板的搭建\n3. 主业务流程的前后端开发（争取把代码沙箱之外的全部搞定）\n4. 专攻代码沙箱（自主实现，不止一种实现方案，层层递进，通过实战用例来进行安全优化）\n5. 系统优化（微服务改造、系统扩展思路）\n\n\n\n## 主流OJ实现方案\n\n1. 用现成的`OJ`系统 \n\n网上有很多开源的`OJ`项目，比如`青岛OJ`、`HustOJ`等，可以直接下载开源代码自己部署。\n\n比较推荐的是`judge0`，这是一个非常成熟的`商业OJ`项目，支持 60 多种编程语言！\n\n> 代码：https://github.com/judge0/judge0\n\n2. 用现成的服务 \n\n如果你不希望完整部署一套大而全的代码，只是想复用他人已经实现的、最复杂的判题逻辑，那么可以直接使用现成的 判题`API`、或者现成的 代码沙箱 等服务。\n\n比如`judge0`提供的`判题API`，非常方便易用。只需要通过 HTTP 调用`submissions`判题接口，把用户的代码、输入值、预期的执行结果作为请求参数发送给`judge0`的服务器，它就能自动帮你编译执行程序，并且返回程序的运行结果。\n\n`API`的作用：接受代码、返回执行结果\n\n> `Judge0 API`地址：https://rapidapi.com/judge0-official/api/judge0-ce\n>\n> 官方文档：https://ce.judge0.com/#submissions-submission-post\n\n>  流程 \n>\n> 1先注册\n>\n> 2再开通订阅\n>\n> 3然后测试 language 接口\n>\n> 4测试执行代码接口 submissions\n\n3. **自主开发**✨✨✨--我的方案\n\n自主实现判题服务和代码沙箱，适合学习，但不适用于商业项目。\n\n\n\n4. 把 AI 来当做代码沙箱 \n\n现在 AI 的能力已经十分强大了，我们可以把各种本来很复杂的功能直接交给 AI 来实现。\n\n只要脑洞够大，AI + 编程 = 无限的可能~\n\n\n\n5. 移花接木 \n\n这种方式最有意思、也最 “缺德”。很多同学估计想不到。\n\n那就是可以通过让程序来操作模拟浏览器的方式，用别人已经开发好的 OJ 系统来帮咱们判题。\n\n比如使用 Puppeteer + 无头浏览器，把咱们系统用户提交的代码，像人一样输入到别人的 OJ 网页中，让程序点击提交按钮，并且等别人的 OJ 系统返回判题结果后，再把这个结果返回给我们自己的用户。\n\n这种方式的缺点就是把核心流程交给了别人，如果别人服务挂了，你的服务也就挂了；而且别人 OJ 系统不支持的题目，可能你也支持不了。\n\n\n","slug":"oj","published":1,"updated":"2023-11-22T12:03:30.702Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clpkiczjh0034fkfoeb0chvon","content":"<h1 id=\"Smart-OJ\"><a href=\"#Smart-OJ\" class=\"headerlink\" title=\"Smart OJ\"></a>Smart OJ</h1><blockquote>\n<h2 id=\"复习一下项目开发流程\"><a href=\"#复习一下项目开发流程\" class=\"headerlink\" title=\"复习一下项目开发流程\"></a>复习一下项目开发流程</h2><ol>\n<li><p>项目简介、项目调研、项目需求分析</p>\n</li>\n<li><p>核心业务流程</p>\n</li>\n<li><p>项目功能模块</p>\n</li>\n<li><p>技术选型</p>\n</li>\n<li><p>项目初始化</p>\n</li>\n<li><p>项目开发</p>\n</li>\n<li><p>测试</p>\n</li>\n<li><p>优化</p>\n<p>（代码提交、代码审核、产品验收）</p>\n</li>\n<li><p>上线</p>\n</li>\n</ol>\n<p>在此过程中，也是要不断写文档、持续调研、沉淀知识的</p>\n</blockquote>\n<h2 id=\"项目简介\"><a href=\"#项目简介\" class=\"headerlink\" title=\"项目简介\"></a>项目简介</h2><p>OJ ： Online Judge（在线判题评测系统）</p>\n<p>用户可以选择题目练习，在线编写代码，测试代码，提交代码，系统会根据设置好的答案对用户提交的代码进行评测，给出评测结果！</p>\n<h4 id=\"项目亮点\"><a href=\"#项目亮点\" class=\"headerlink\" title=\"项目亮点\"></a>项目亮点</h4><ol>\n<li>项目新颖，重复度低，写简历有区分度</li>\n<li>区别于常见的<code>CRUD</code>项目，偏向于架构设计、编程思想之类的知识</li>\n<li>项目复杂度高，可扩展性强</li>\n</ol>\n<h4 id=\"OJ系统的常用概念\"><a href=\"#OJ系统的常用概念\" class=\"headerlink\" title=\"OJ系统的常用概念\"></a>OJ系统的常用概念</h4><p>ac 表示你的题目通过，结果正确<br>题目限制：时间限制、内存限制<br>题目介绍<br>题目输入<br>题目输出<br>题目输入用例<br>题目输出用例</p>\n<h4 id=\"难点-判题系统\"><a href=\"#难点-判题系统\" class=\"headerlink\" title=\"难点:判题系统\"></a><strong>难点</strong>:判题系统</h4><p>普通测评：管理员设置题目的输入和输出用例，比如我输入 A，你要输出 B 才是正确的；交给判题机去执行用户的代码，给用户的代码喂输入用例，比如 A，看用户程序的执行结果是否和标准答案的输出一致。<br>（比对用例文件）</p>\n<p>特殊测评（SPJ）：管理员设置题目的输入和输出，比如我输入 1，用户的答案只要是 &gt; 0 或 &lt; 2 都是正确的；特判程序，不是通过对比用例文件是否一致这种死板的程序来检验，而是要专门根据这道题目写一个特殊的判断程序，程序接收题目的输入（1）、标准输出用例（2）、用户的结果（1.5） ，特判程序根据这些值来比较是否正确。</p>\n<p>交互测评：让用户输入一个例子，就给一个输出结果，交互比较灵活，没办法通过简单的、死板的输入输出文件来搞定</p>\n<p><em><strong>不能让用户随便引入包、随便遍历、暴力破解，需要使用正确的算法。 =&gt; 安全性</strong></em></p>\n<p><em><strong>判题过程是异步的 =&gt; 异步化</strong></em></p>\n<p><em><strong>提交之后，会生成一个提交记录，有运行的结果以及运行信息（时间限制、内存限制）</strong></em></p>\n<h2 id=\"项目调研\"><a href=\"#项目调研\" class=\"headerlink\" title=\"项目调研\"></a>项目调研</h2><p><a href=\"https://github.com/HimitZH/HOJ(%E9%80%82%E5%90%88%E5%AD%A6%E4%B9%A0)\">https://github.com/HimitZH/HOJ(适合学习)</a><br><a href=\"https://github.com/QingdaoU/OnlineJudge(python,%E4%B8%8D%E5%A5%BD%E5%AD%A6%EF%BC%8C%E5%BE%88%E6%88%90%E7%86%9F)\">https://github.com/QingdaoU/OnlineJudge(python,不好学，很成熟)</a><br><a href=\"https://github.com/hzxie/Noj(%E6%98%9F%E6%98%9F%E6%B2%A1%E9%82%A3%E4%B9%88%E5%A4%9A%EF%BC%8C%E6%B2%A1%E9%82%A3%E4%B9%88%E6%88%90%E7%86%9F%EF%BC%8C%E4%BD%86%E7%9B%B8%E5%AF%B9%E5%A5%BD%E5%AD%A6)\">https://github.com/hzxie/Noj(星星没那么多，没那么成熟，但相对好学)</a><br><a href=\"https://github.com/vfleaking,/uoj(php%E5%AE%9E%E7%8E%B0%E7%9A%84)\">https://github.com/vfleaking,/uoj(php实现的)</a></p>\n<h2 id=\"项目需求分析\"><a href=\"#项目需求分析\" class=\"headerlink\" title=\"项目需求分析\"></a>项目需求分析</h2><h4 id=\"实现核心\"><a href=\"#实现核心\" class=\"headerlink\" title=\"实现核心\"></a>实现核心</h4><ol>\n<li><p>权限校验</p>\n</li>\n<li><p>代码沙箱（安全沙箱 – 防止代码藏毒）</p>\n<p>代码安全：设置安全的、隔离的沙箱，以确保用户的代码不会影响到系统的安全</p>\n</li>\n<li><p>判题规则</p>\n<p>题目用例的比对，结果的验证</p>\n</li>\n<li><p>任务调度</p>\n<p>资源分配：防止用户疯狂占用资源，措施：异步化处理，服务资源有限，按照用户提交顺序进行判题</p>\n</li>\n</ol>\n<h4 id=\"核心业务流程\"><a href=\"#核心业务流程\" class=\"headerlink\" title=\"核心业务流程\"></a>核心业务流程</h4><p><img src=\"https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311221849444.png\" alt=\"image-20231122184857284\"></p>\n<p>时序图：</p>\n<p><img src=\"https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311151640352.png\" alt=\"image-20231115164047376\"></p>\n<h4 id=\"功能\"><a href=\"#功能\" class=\"headerlink\" title=\"功能\"></a>功能</h4><ol>\n<li><p>题目模块</p>\n<p>a. 管理员：创建、删除、修改</p>\n<p>b. 用户：搜索题目</p>\n<p>c. 在线做题、提交题目代码</p>\n</li>\n<li><p>用户模块</p>\n<p>a. 注册与登录</p>\n</li>\n<li><p>判题模块</p>\n<p>a. 提交判题（结果是否正确与错误）</p>\n<p>b. 错误处理（内存溢出、安全性、超时）</p>\n<p>c. 自主实现代码沙箱（安全、隔离的一个环境）</p>\n<p>d. 开放接口</p>\n</li>\n</ol>\n<h4 id=\"扩展思路\"><a href=\"#扩展思路\" class=\"headerlink\" title=\"扩展思路\"></a>扩展思路</h4><ol>\n<li>支持多种语言</li>\n<li>远程评测</li>\n<li>完善的评测功能：普通评测、特殊评测、交互评测、在线自测、文件IO</li>\n<li>统计分析判题记录</li>\n<li>权限校验</li>\n</ol>\n<h2 id=\"技术选型\"><a href=\"#技术选型\" class=\"headerlink\" title=\"技术选型\"></a>技术选型</h2><h4 id=\"前端：\"><a href=\"#前端：\" class=\"headerlink\" title=\"前端：\"></a>前端：</h4><p><code>Vue3、手撸Umi项目模板、AcroDesign组件库、在线代码编辑器、在线文档浏览</code></p>\n<h4 id=\"后端：\"><a href=\"#后端：\" class=\"headerlink\" title=\"后端：\"></a>后端：</h4><p><code>Java进程控制、Java安全管理、部分JVM知识点、虚拟机、Docker、Spring Cloud微服务、消息队列</code></p>\n<h2 id=\"架构设计\"><a href=\"#架构设计\" class=\"headerlink\" title=\"架构设计\"></a>架构设计</h2><p>采用分层架构：用户层、接入层、业务层、服务层、存储层、资源层</p>\n<p><img src=\"E:/Master/TyporaImages/oj/image-20231122192355366.png\" alt=\"image-20231122192355366\"></p>\n<h2 id=\"项目排期\"><a href=\"#项目排期\" class=\"headerlink\" title=\"项目排期\"></a>项目排期</h2><ol>\n<li>项目简介、项目调研、需求分析、技术选型、架构设计、现有<code>OJ</code>主流实现方案</li>\n<li>前后端项目初始化、前端通用项目模板的搭建</li>\n<li>主业务流程的前后端开发（争取把代码沙箱之外的全部搞定）</li>\n<li>专攻代码沙箱（自主实现，不止一种实现方案，层层递进，通过实战用例来进行安全优化）</li>\n<li>系统优化（微服务改造、系统扩展思路）</li>\n</ol>\n<h2 id=\"主流OJ实现方案\"><a href=\"#主流OJ实现方案\" class=\"headerlink\" title=\"主流OJ实现方案\"></a>主流OJ实现方案</h2><ol>\n<li>用现成的<code>OJ</code>系统 </li>\n</ol>\n<p>网上有很多开源的<code>OJ</code>项目，比如<code>青岛OJ</code>、<code>HustOJ</code>等，可以直接下载开源代码自己部署。</p>\n<p>比较推荐的是<code>judge0</code>，这是一个非常成熟的<code>商业OJ</code>项目，支持 60 多种编程语言！</p>\n<blockquote>\n<p>代码：<a href=\"https://github.com/judge0/judge0\">https://github.com/judge0/judge0</a></p>\n</blockquote>\n<ol start=\"2\">\n<li>用现成的服务 </li>\n</ol>\n<p>如果你不希望完整部署一套大而全的代码，只是想复用他人已经实现的、最复杂的判题逻辑，那么可以直接使用现成的 判题<code>API</code>、或者现成的 代码沙箱 等服务。</p>\n<p>比如<code>judge0</code>提供的<code>判题API</code>，非常方便易用。只需要通过 HTTP 调用<code>submissions</code>判题接口，把用户的代码、输入值、预期的执行结果作为请求参数发送给<code>judge0</code>的服务器，它就能自动帮你编译执行程序，并且返回程序的运行结果。</p>\n<p><code>API</code>的作用：接受代码、返回执行结果</p>\n<blockquote>\n<p><code>Judge0 API</code>地址：<a href=\"https://rapidapi.com/judge0-official/api/judge0-ce\">https://rapidapi.com/judge0-official/api/judge0-ce</a></p>\n<p>官方文档：<a href=\"https://ce.judge0.com/#submissions-submission-post\">https://ce.judge0.com/#submissions-submission-post</a></p>\n</blockquote>\n<blockquote>\n<p> 流程 </p>\n<p>1先注册</p>\n<p>2再开通订阅</p>\n<p>3然后测试 language 接口</p>\n<p>4测试执行代码接口 submissions</p>\n</blockquote>\n<ol start=\"3\">\n<li><strong>自主开发</strong>✨✨✨–我的方案</li>\n</ol>\n<p>自主实现判题服务和代码沙箱，适合学习，但不适用于商业项目。</p>\n<ol start=\"4\">\n<li>把 AI 来当做代码沙箱 </li>\n</ol>\n<p>现在 AI 的能力已经十分强大了，我们可以把各种本来很复杂的功能直接交给 AI 来实现。</p>\n<p>只要脑洞够大，AI + 编程 = 无限的可能~</p>\n<ol start=\"5\">\n<li>移花接木 </li>\n</ol>\n<p>这种方式最有意思、也最 “缺德”。很多同学估计想不到。</p>\n<p>那就是可以通过让程序来操作模拟浏览器的方式，用别人已经开发好的 OJ 系统来帮咱们判题。</p>\n<p>比如使用 Puppeteer + 无头浏览器，把咱们系统用户提交的代码，像人一样输入到别人的 OJ 网页中，让程序点击提交按钮，并且等别人的 OJ 系统返回判题结果后，再把这个结果返回给我们自己的用户。</p>\n<p>这种方式的缺点就是把核心流程交给了别人，如果别人服务挂了，你的服务也就挂了；而且别人 OJ 系统不支持的题目，可能你也支持不了。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Smart-OJ\"><a href=\"#Smart-OJ\" class=\"headerlink\" title=\"Smart OJ\"></a>Smart OJ</h1><blockquote>\n<h2 id=\"复习一下项目开发流程\"><a href=\"#复习一下项目开发流程\" class=\"headerlink\" title=\"复习一下项目开发流程\"></a>复习一下项目开发流程</h2><ol>\n<li><p>项目简介、项目调研、项目需求分析</p>\n</li>\n<li><p>核心业务流程</p>\n</li>\n<li><p>项目功能模块</p>\n</li>\n<li><p>技术选型</p>\n</li>\n<li><p>项目初始化</p>\n</li>\n<li><p>项目开发</p>\n</li>\n<li><p>测试</p>\n</li>\n<li><p>优化</p>\n<p>（代码提交、代码审核、产品验收）</p>\n</li>\n<li><p>上线</p>\n</li>\n</ol>\n<p>在此过程中，也是要不断写文档、持续调研、沉淀知识的</p>\n</blockquote>\n<h2 id=\"项目简介\"><a href=\"#项目简介\" class=\"headerlink\" title=\"项目简介\"></a>项目简介</h2><p>OJ ： Online Judge（在线判题评测系统）</p>\n<p>用户可以选择题目练习，在线编写代码，测试代码，提交代码，系统会根据设置好的答案对用户提交的代码进行评测，给出评测结果！</p>\n<h4 id=\"项目亮点\"><a href=\"#项目亮点\" class=\"headerlink\" title=\"项目亮点\"></a>项目亮点</h4><ol>\n<li>项目新颖，重复度低，写简历有区分度</li>\n<li>区别于常见的<code>CRUD</code>项目，偏向于架构设计、编程思想之类的知识</li>\n<li>项目复杂度高，可扩展性强</li>\n</ol>\n<h4 id=\"OJ系统的常用概念\"><a href=\"#OJ系统的常用概念\" class=\"headerlink\" title=\"OJ系统的常用概念\"></a>OJ系统的常用概念</h4><p>ac 表示你的题目通过，结果正确<br>题目限制：时间限制、内存限制<br>题目介绍<br>题目输入<br>题目输出<br>题目输入用例<br>题目输出用例</p>\n<h4 id=\"难点-判题系统\"><a href=\"#难点-判题系统\" class=\"headerlink\" title=\"难点:判题系统\"></a><strong>难点</strong>:判题系统</h4><p>普通测评：管理员设置题目的输入和输出用例，比如我输入 A，你要输出 B 才是正确的；交给判题机去执行用户的代码，给用户的代码喂输入用例，比如 A，看用户程序的执行结果是否和标准答案的输出一致。<br>（比对用例文件）</p>\n<p>特殊测评（SPJ）：管理员设置题目的输入和输出，比如我输入 1，用户的答案只要是 &gt; 0 或 &lt; 2 都是正确的；特判程序，不是通过对比用例文件是否一致这种死板的程序来检验，而是要专门根据这道题目写一个特殊的判断程序，程序接收题目的输入（1）、标准输出用例（2）、用户的结果（1.5） ，特判程序根据这些值来比较是否正确。</p>\n<p>交互测评：让用户输入一个例子，就给一个输出结果，交互比较灵活，没办法通过简单的、死板的输入输出文件来搞定</p>\n<p><em><strong>不能让用户随便引入包、随便遍历、暴力破解，需要使用正确的算法。 =&gt; 安全性</strong></em></p>\n<p><em><strong>判题过程是异步的 =&gt; 异步化</strong></em></p>\n<p><em><strong>提交之后，会生成一个提交记录，有运行的结果以及运行信息（时间限制、内存限制）</strong></em></p>\n<h2 id=\"项目调研\"><a href=\"#项目调研\" class=\"headerlink\" title=\"项目调研\"></a>项目调研</h2><p><a href=\"https://github.com/HimitZH/HOJ(%E9%80%82%E5%90%88%E5%AD%A6%E4%B9%A0)\">https://github.com/HimitZH/HOJ(适合学习)</a><br><a href=\"https://github.com/QingdaoU/OnlineJudge(python,%E4%B8%8D%E5%A5%BD%E5%AD%A6%EF%BC%8C%E5%BE%88%E6%88%90%E7%86%9F)\">https://github.com/QingdaoU/OnlineJudge(python,不好学，很成熟)</a><br><a href=\"https://github.com/hzxie/Noj(%E6%98%9F%E6%98%9F%E6%B2%A1%E9%82%A3%E4%B9%88%E5%A4%9A%EF%BC%8C%E6%B2%A1%E9%82%A3%E4%B9%88%E6%88%90%E7%86%9F%EF%BC%8C%E4%BD%86%E7%9B%B8%E5%AF%B9%E5%A5%BD%E5%AD%A6)\">https://github.com/hzxie/Noj(星星没那么多，没那么成熟，但相对好学)</a><br><a href=\"https://github.com/vfleaking,/uoj(php%E5%AE%9E%E7%8E%B0%E7%9A%84)\">https://github.com/vfleaking,/uoj(php实现的)</a></p>\n<h2 id=\"项目需求分析\"><a href=\"#项目需求分析\" class=\"headerlink\" title=\"项目需求分析\"></a>项目需求分析</h2><h4 id=\"实现核心\"><a href=\"#实现核心\" class=\"headerlink\" title=\"实现核心\"></a>实现核心</h4><ol>\n<li><p>权限校验</p>\n</li>\n<li><p>代码沙箱（安全沙箱 – 防止代码藏毒）</p>\n<p>代码安全：设置安全的、隔离的沙箱，以确保用户的代码不会影响到系统的安全</p>\n</li>\n<li><p>判题规则</p>\n<p>题目用例的比对，结果的验证</p>\n</li>\n<li><p>任务调度</p>\n<p>资源分配：防止用户疯狂占用资源，措施：异步化处理，服务资源有限，按照用户提交顺序进行判题</p>\n</li>\n</ol>\n<h4 id=\"核心业务流程\"><a href=\"#核心业务流程\" class=\"headerlink\" title=\"核心业务流程\"></a>核心业务流程</h4><p><img src=\"https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311221849444.png\" alt=\"image-20231122184857284\"></p>\n<p>时序图：</p>\n<p><img src=\"https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311151640352.png\" alt=\"image-20231115164047376\"></p>\n<h4 id=\"功能\"><a href=\"#功能\" class=\"headerlink\" title=\"功能\"></a>功能</h4><ol>\n<li><p>题目模块</p>\n<p>a. 管理员：创建、删除、修改</p>\n<p>b. 用户：搜索题目</p>\n<p>c. 在线做题、提交题目代码</p>\n</li>\n<li><p>用户模块</p>\n<p>a. 注册与登录</p>\n</li>\n<li><p>判题模块</p>\n<p>a. 提交判题（结果是否正确与错误）</p>\n<p>b. 错误处理（内存溢出、安全性、超时）</p>\n<p>c. 自主实现代码沙箱（安全、隔离的一个环境）</p>\n<p>d. 开放接口</p>\n</li>\n</ol>\n<h4 id=\"扩展思路\"><a href=\"#扩展思路\" class=\"headerlink\" title=\"扩展思路\"></a>扩展思路</h4><ol>\n<li>支持多种语言</li>\n<li>远程评测</li>\n<li>完善的评测功能：普通评测、特殊评测、交互评测、在线自测、文件IO</li>\n<li>统计分析判题记录</li>\n<li>权限校验</li>\n</ol>\n<h2 id=\"技术选型\"><a href=\"#技术选型\" class=\"headerlink\" title=\"技术选型\"></a>技术选型</h2><h4 id=\"前端：\"><a href=\"#前端：\" class=\"headerlink\" title=\"前端：\"></a>前端：</h4><p><code>Vue3、手撸Umi项目模板、AcroDesign组件库、在线代码编辑器、在线文档浏览</code></p>\n<h4 id=\"后端：\"><a href=\"#后端：\" class=\"headerlink\" title=\"后端：\"></a>后端：</h4><p><code>Java进程控制、Java安全管理、部分JVM知识点、虚拟机、Docker、Spring Cloud微服务、消息队列</code></p>\n<h2 id=\"架构设计\"><a href=\"#架构设计\" class=\"headerlink\" title=\"架构设计\"></a>架构设计</h2><p>采用分层架构：用户层、接入层、业务层、服务层、存储层、资源层</p>\n<p><img src=\"E:/Master/TyporaImages/oj/image-20231122192355366.png\" alt=\"image-20231122192355366\"></p>\n<h2 id=\"项目排期\"><a href=\"#项目排期\" class=\"headerlink\" title=\"项目排期\"></a>项目排期</h2><ol>\n<li>项目简介、项目调研、需求分析、技术选型、架构设计、现有<code>OJ</code>主流实现方案</li>\n<li>前后端项目初始化、前端通用项目模板的搭建</li>\n<li>主业务流程的前后端开发（争取把代码沙箱之外的全部搞定）</li>\n<li>专攻代码沙箱（自主实现，不止一种实现方案，层层递进，通过实战用例来进行安全优化）</li>\n<li>系统优化（微服务改造、系统扩展思路）</li>\n</ol>\n<h2 id=\"主流OJ实现方案\"><a href=\"#主流OJ实现方案\" class=\"headerlink\" title=\"主流OJ实现方案\"></a>主流OJ实现方案</h2><ol>\n<li>用现成的<code>OJ</code>系统 </li>\n</ol>\n<p>网上有很多开源的<code>OJ</code>项目，比如<code>青岛OJ</code>、<code>HustOJ</code>等，可以直接下载开源代码自己部署。</p>\n<p>比较推荐的是<code>judge0</code>，这是一个非常成熟的<code>商业OJ</code>项目，支持 60 多种编程语言！</p>\n<blockquote>\n<p>代码：<a href=\"https://github.com/judge0/judge0\">https://github.com/judge0/judge0</a></p>\n</blockquote>\n<ol start=\"2\">\n<li>用现成的服务 </li>\n</ol>\n<p>如果你不希望完整部署一套大而全的代码，只是想复用他人已经实现的、最复杂的判题逻辑，那么可以直接使用现成的 判题<code>API</code>、或者现成的 代码沙箱 等服务。</p>\n<p>比如<code>judge0</code>提供的<code>判题API</code>，非常方便易用。只需要通过 HTTP 调用<code>submissions</code>判题接口，把用户的代码、输入值、预期的执行结果作为请求参数发送给<code>judge0</code>的服务器，它就能自动帮你编译执行程序，并且返回程序的运行结果。</p>\n<p><code>API</code>的作用：接受代码、返回执行结果</p>\n<blockquote>\n<p><code>Judge0 API</code>地址：<a href=\"https://rapidapi.com/judge0-official/api/judge0-ce\">https://rapidapi.com/judge0-official/api/judge0-ce</a></p>\n<p>官方文档：<a href=\"https://ce.judge0.com/#submissions-submission-post\">https://ce.judge0.com/#submissions-submission-post</a></p>\n</blockquote>\n<blockquote>\n<p> 流程 </p>\n<p>1先注册</p>\n<p>2再开通订阅</p>\n<p>3然后测试 language 接口</p>\n<p>4测试执行代码接口 submissions</p>\n</blockquote>\n<ol start=\"3\">\n<li><strong>自主开发</strong>✨✨✨–我的方案</li>\n</ol>\n<p>自主实现判题服务和代码沙箱，适合学习，但不适用于商业项目。</p>\n<ol start=\"4\">\n<li>把 AI 来当做代码沙箱 </li>\n</ol>\n<p>现在 AI 的能力已经十分强大了，我们可以把各种本来很复杂的功能直接交给 AI 来实现。</p>\n<p>只要脑洞够大，AI + 编程 = 无限的可能~</p>\n<ol start=\"5\">\n<li>移花接木 </li>\n</ol>\n<p>这种方式最有意思、也最 “缺德”。很多同学估计想不到。</p>\n<p>那就是可以通过让程序来操作模拟浏览器的方式，用别人已经开发好的 OJ 系统来帮咱们判题。</p>\n<p>比如使用 Puppeteer + 无头浏览器，把咱们系统用户提交的代码，像人一样输入到别人的 OJ 网页中，让程序点击提交按钮，并且等别人的 OJ 系统返回判题结果后，再把这个结果返回给我们自己的用户。</p>\n<p>这种方式的缺点就是把核心流程交给了别人，如果别人服务挂了，你的服务也就挂了；而且别人 OJ 系统不支持的题目，可能你也支持不了。</p>\n"},{"title":"plan-a","abbrlink":41017,"date":"2023-08-24T11:55:57.000Z","_content":"\n# 我的计划\n\n![image-20230824195744464](https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202308241957304.png)\n\n## 云上博客问题\n\n博客域名一直配置不成功原因：\n\n服务器：华为云\n\n域名：腾讯云\n\n猜想：因为域名解析的问题，所以暂时放弃域名的绑定，等入手新的华为云服务器与域名了再说\n\n果真，来看ChatGPT的回答：\n\n![image-20230824200659385](https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202308242007222.png)\n\n我去了，你猜怎么着，鹅厂的域名解析的记录值当选择创建A记录时，记录值只能选择本平台购买的云资源，如图：\n\n![image-20230824200857847](https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202308242008956.png)\n\n不知其他平台也是如此，于是我们可以选择以下方案：\n\n![image-20230824201042315](https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202308242010823.png)\n\n于是，本人骂骂咧咧的关掉了页面，玩什么花活，老老实实的用IP访问吧！\n\n### 备选方案\n\n测试！！！\n\n**腾讯云服务器**部署**阿里云购买的域名**时，提示需要在阿里云域名解析中添加有关腾讯云的信息：\n\n<img src=\"https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202308232016802.png\" alt=\"image-20230823201603447\" style=\"zoom:50%;\" />\n\n<img src=\"https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202308232016852.png\" alt=\"image-20230823201612501\" style=\"zoom:50%;\" />\n\n有待验证... ...\n\n## 项目上线问题\n\n发现使用`docker`来进行上线项目极为便捷，上线步骤，为项目编写`Dockerfile`和`nginx`配置文件，然后构建镜像、创建容器，直接运行！\n\n具体上线方案，参考下面这篇文章！\n\n[如何上线自己的项目？必须要氪金买云服务器吗？（保姆级教程！）](https://wl2o2o.github.io/2023/06/03/api/#%E4%B8%89%E3%80%81docker%E9%83%A8%E7%BD%B2)\n","source":"_posts/plan-a.md","raw":"---\ntitle: plan-a\ntags: plan\nabbrlink: 41017\ndate: 2023-08-24 19:55:57\n---\n\n# 我的计划\n\n![image-20230824195744464](https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202308241957304.png)\n\n## 云上博客问题\n\n博客域名一直配置不成功原因：\n\n服务器：华为云\n\n域名：腾讯云\n\n猜想：因为域名解析的问题，所以暂时放弃域名的绑定，等入手新的华为云服务器与域名了再说\n\n果真，来看ChatGPT的回答：\n\n![image-20230824200659385](https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202308242007222.png)\n\n我去了，你猜怎么着，鹅厂的域名解析的记录值当选择创建A记录时，记录值只能选择本平台购买的云资源，如图：\n\n![image-20230824200857847](https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202308242008956.png)\n\n不知其他平台也是如此，于是我们可以选择以下方案：\n\n![image-20230824201042315](https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202308242010823.png)\n\n于是，本人骂骂咧咧的关掉了页面，玩什么花活，老老实实的用IP访问吧！\n\n### 备选方案\n\n测试！！！\n\n**腾讯云服务器**部署**阿里云购买的域名**时，提示需要在阿里云域名解析中添加有关腾讯云的信息：\n\n<img src=\"https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202308232016802.png\" alt=\"image-20230823201603447\" style=\"zoom:50%;\" />\n\n<img src=\"https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202308232016852.png\" alt=\"image-20230823201612501\" style=\"zoom:50%;\" />\n\n有待验证... ...\n\n## 项目上线问题\n\n发现使用`docker`来进行上线项目极为便捷，上线步骤，为项目编写`Dockerfile`和`nginx`配置文件，然后构建镜像、创建容器，直接运行！\n\n具体上线方案，参考下面这篇文章！\n\n[如何上线自己的项目？必须要氪金买云服务器吗？（保姆级教程！）](https://wl2o2o.github.io/2023/06/03/api/#%E4%B8%89%E3%80%81docker%E9%83%A8%E7%BD%B2)\n","slug":"plan-a","published":1,"updated":"2023-10-16T06:58:59.307Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clpkiczji0037fkfocygd3y8h","content":"<h1 id=\"我的计划\"><a href=\"#我的计划\" class=\"headerlink\" title=\"我的计划\"></a>我的计划</h1><p><img src=\"https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202308241957304.png\" alt=\"image-20230824195744464\"></p>\n<h2 id=\"云上博客问题\"><a href=\"#云上博客问题\" class=\"headerlink\" title=\"云上博客问题\"></a>云上博客问题</h2><p>博客域名一直配置不成功原因：</p>\n<p>服务器：华为云</p>\n<p>域名：腾讯云</p>\n<p>猜想：因为域名解析的问题，所以暂时放弃域名的绑定，等入手新的华为云服务器与域名了再说</p>\n<p>果真，来看ChatGPT的回答：</p>\n<p><img src=\"https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202308242007222.png\" alt=\"image-20230824200659385\"></p>\n<p>我去了，你猜怎么着，鹅厂的域名解析的记录值当选择创建A记录时，记录值只能选择本平台购买的云资源，如图：</p>\n<p><img src=\"https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202308242008956.png\" alt=\"image-20230824200857847\"></p>\n<p>不知其他平台也是如此，于是我们可以选择以下方案：</p>\n<p><img src=\"https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202308242010823.png\" alt=\"image-20230824201042315\"></p>\n<p>于是，本人骂骂咧咧的关掉了页面，玩什么花活，老老实实的用IP访问吧！</p>\n<h3 id=\"备选方案\"><a href=\"#备选方案\" class=\"headerlink\" title=\"备选方案\"></a>备选方案</h3><p>测试！！！</p>\n<p><strong>腾讯云服务器</strong>部署<strong>阿里云购买的域名</strong>时，提示需要在阿里云域名解析中添加有关腾讯云的信息：</p>\n<img src=\"https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202308232016802.png\" alt=\"image-20230823201603447\" style=\"zoom:50%;\" />\n\n<img src=\"https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202308232016852.png\" alt=\"image-20230823201612501\" style=\"zoom:50%;\" />\n\n<p>有待验证… …</p>\n<h2 id=\"项目上线问题\"><a href=\"#项目上线问题\" class=\"headerlink\" title=\"项目上线问题\"></a>项目上线问题</h2><p>发现使用<code>docker</code>来进行上线项目极为便捷，上线步骤，为项目编写<code>Dockerfile</code>和<code>nginx</code>配置文件，然后构建镜像、创建容器，直接运行！</p>\n<p>具体上线方案，参考下面这篇文章！</p>\n<p><a href=\"https://wl2o2o.github.io/2023/06/03/api/#%E4%B8%89%E3%80%81docker%E9%83%A8%E7%BD%B2\">如何上线自己的项目？必须要氪金买云服务器吗？（保姆级教程！）</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"我的计划\"><a href=\"#我的计划\" class=\"headerlink\" title=\"我的计划\"></a>我的计划</h1><p><img src=\"https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202308241957304.png\" alt=\"image-20230824195744464\"></p>\n<h2 id=\"云上博客问题\"><a href=\"#云上博客问题\" class=\"headerlink\" title=\"云上博客问题\"></a>云上博客问题</h2><p>博客域名一直配置不成功原因：</p>\n<p>服务器：华为云</p>\n<p>域名：腾讯云</p>\n<p>猜想：因为域名解析的问题，所以暂时放弃域名的绑定，等入手新的华为云服务器与域名了再说</p>\n<p>果真，来看ChatGPT的回答：</p>\n<p><img src=\"https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202308242007222.png\" alt=\"image-20230824200659385\"></p>\n<p>我去了，你猜怎么着，鹅厂的域名解析的记录值当选择创建A记录时，记录值只能选择本平台购买的云资源，如图：</p>\n<p><img src=\"https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202308242008956.png\" alt=\"image-20230824200857847\"></p>\n<p>不知其他平台也是如此，于是我们可以选择以下方案：</p>\n<p><img src=\"https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202308242010823.png\" alt=\"image-20230824201042315\"></p>\n<p>于是，本人骂骂咧咧的关掉了页面，玩什么花活，老老实实的用IP访问吧！</p>\n<h3 id=\"备选方案\"><a href=\"#备选方案\" class=\"headerlink\" title=\"备选方案\"></a>备选方案</h3><p>测试！！！</p>\n<p><strong>腾讯云服务器</strong>部署<strong>阿里云购买的域名</strong>时，提示需要在阿里云域名解析中添加有关腾讯云的信息：</p>\n<img src=\"https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202308232016802.png\" alt=\"image-20230823201603447\" style=\"zoom:50%;\" />\n\n<img src=\"https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202308232016852.png\" alt=\"image-20230823201612501\" style=\"zoom:50%;\" />\n\n<p>有待验证… …</p>\n<h2 id=\"项目上线问题\"><a href=\"#项目上线问题\" class=\"headerlink\" title=\"项目上线问题\"></a>项目上线问题</h2><p>发现使用<code>docker</code>来进行上线项目极为便捷，上线步骤，为项目编写<code>Dockerfile</code>和<code>nginx</code>配置文件，然后构建镜像、创建容器，直接运行！</p>\n<p>具体上线方案，参考下面这篇文章！</p>\n<p><a href=\"https://wl2o2o.github.io/2023/06/03/api/#%E4%B8%89%E3%80%81docker%E9%83%A8%E7%BD%B2\">如何上线自己的项目？必须要氪金买云服务器吗？（保姆级教程！）</a></p>\n"},{"title":"尚医通","index_img":"https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311151627634.png","banner_img":"https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311151644178.png","abbrlink":47316,"date":"2022-05-31T03:23:42.000Z","_content":"\n\n> 欢迎观看我的医院预约挂号平台项目笔记\n>\n> axiba,图片在typora软件更新时被意外删除了！！！\n>\n> ![测试一下](https://cdn.jsdelivr.net/gh/wl2o2o/blogCdn/img/202306211602425.png)\n\n# 尚医通学习笔记\n\n*前言：按照计划跟做项目，发现仍有一些令人不解的坑，为了解决问题耗费了更多的事件，通过手写和电子笔记以此列举学习成果，以便更好的复习。*\n\n> ## 项目介绍篇\n\n是一个预约挂号，就医问诊，解决患者就医难看病难的平台。\n\n平台：用户前台（用户预约挂号）、管理员后台、医院管理后台（上传医院信息）\n\n> ## 技术框架\n\n微服务：使用`Docker`作为微服务的部署，启动中间件\n\n​      `Spring Cloud` 作为整体框架\n\n​\t  `nacos`注册中心\n\n​\t  `feign`远程调用\n\n​\t  `Spring Cloud GateWay`网关\n\n数据库：\n\n​\t  `MongoDB`、`MySQL`作为数据库\n\n中间件：\n\n​\t  `Rabbitmq`消息队列、`redis`\n\n功能性类库：\n\n​\t  `JWT`登录验证、`EasyExcell`数据库导入导出\n\n![架构图](https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311151644178.png)\n\n> ## 业务流程\n\n医院通过医院管理后台上传医院的基本信息、预约规则信息、科室信息、排班信息。然后又管理平台进行审核，通过后预约挂号平台进行展示，用户就可以进行根据需求选择挂号，会调用医院挂号接口进行挂号，挂号成功之后，进行支付，取号，同时也可以取消预约，对应的预约状态也会进行实时更新。\n\n> ## 项目亮点\n\n真实全面、贴合实际\n\n\n\n什么是服务端渲染？\n\n服务器先把数据请求好，并且拼接到恩安政的页面当中，再返回给客户端。\n\n从何处请求数据呢？答：从后端，所以运行项目的时候，要先运行后端，否则会报错！\n\n\n\n数据库是怎么划分的？\n\n数据库分为MySQL和MongoDB，其中MySQL是关系型数据库，用来存储用户、订单、预约等关系型数据，MongoDB是一个介于关系数据库和非关系数据库之间的产品,是非关系数据库当中功能最丰富,最像关系数据库的,它支持的数据结构非常松散,是类似json的bson格式,因此可以存储比较复杂的数据类型。因为大多数数据操作在内存中进行，所以效率较高。本项目中用来存储一些医院本身的信息和一些不固定的信息，比较灵活!\n\n后端亮点：\n\n> ## 项目启动\n\n后端\n\n启动服务：\n\nnacos\n\n> 可以用来管理微服务，提供服务的注册与发现，作为配置中心管理动态配置\n\n\n\n\n\n> ## 简历部分\n\n前端：使用webpack来减小项目体积以及运行速度\n\n## P64 redis\n\nredis连接不上，贴一篇文章，包含conf文件的配置与redis.cli客户端的运行命令\n\n[redis虚拟机与本地连接](https://blog.csdn.net/magicproblem/article/details/113238030)\n\n[虚拟机运行redis](https://www.runoob.com/redis/redis-install.html)\n\n## P65 配置nginx\n\n## P66 `MongoDB`\n\n```dockerfile\ndocker run -d --restart=always -p 27017:27017 --name mymongo -v /data/db:/data/db -d mongo\ndocker exec -it mongo bash\n```\n\n\n\n```TXT\n1、 Help查看命令提示 \ndb.help();\n2、 切换/创建数据库\nuse test\n如果数据库不存在，则创建数据库，否则切换到指定数据库\n3、 查询所有数据库 \nshow dbs;\n4、 删除当前使用数据库 \ndb.dropDatabase();\n5、 查看当前使用的数据库 \ndb.getName();\n6、 显示当前db状态 \ndb.stats();\n7、 当前db版本 \ndb.version();\n8、 查看当前db的链接机器地址 \ndb.getMongo〇;\n```\n\n通过下图实例，我们也可以更直观的的了解Mongo中的一些概念：\n\n\n\n## P67 —— P72 SpringBoot整合MongoDB\n\nmongo Template CRUD实现方法：\n\n```txt\n常用方法\nmongoTemplate.findAll(User.class): 查询User文档的全部数据\nmongoTemplate.findById(<id>, User.class): 查询User文档id为id的数据\nmongoTemplate.find(query, User.class);: 根据query内的查询条件查询\nmongoTemplate.upsert(query, update, User.class): 修改\nmongoTemplate.remove(query, User.class): 删除\nmongoTemplate.insert(User): 新增\nQuery对象\n1、创建一个query对象（用来封装所有条件对象)，再创建一个criteria对象（用来构建条件）\n2、 精准条件：criteria.and(“key”).is(“条件”)\n模糊条件：criteria.and(“key”).regex(“条件”)\n3、封装条件：query.addCriteria(criteria)\n4、大于（创建新的criteria）：Criteria gt = Criteria.where(“key”).gt（“条件”）\n小于（创建新的criteria）：Criteria lt = Criteria.where(“key”).lt（“条件”）\n5、Query.addCriteria(new Criteria().andOperator(gt,lt));\n6、一个query中只能有一个andOperator()。其参数也可以是Criteria数组。\n7、排序 ：query.with（new Sort(Sort.Direction.ASC, \"age\"). and(new Sort(Sort.Direction.DESC, \"date\")))\n```\n\n模糊查询方法：\n\n> ```Java\n> //模糊查询\n>  @Test\n>  public void findUsersLikeName() {\n>      String name = \"est\";\n>      String regex = String.format(\"%s%s%s\", \"^.*\", name, \".*$\");\n>      //regex正则表达式\n>      Pattern pattern = Pattern.compile(regex, Pattern.CASE_INSENSITIVE);\n>      Query query = new Query(Criteria.where(\"name\").regex(pattern));\n>      List<User> userList = mongoTemplate.find(query, User.class);\n>      System.out.println(userList);\n>  }\n> ```\n\nmongo repository CURD 实现方法：\n\n总结一波，方法调用来说，整体差不多，都挺麻烦，但是不难看出，MongoTemplate更加灵活，MongoRepogistory简单一些。\n\n\n\n## P73 数据接口-上传医院接口\n\n需求和准备——>基础类创建——>初步实现\n\n涉及：json转换工具(JSONObject:map->字符串->对象）\n\n\n\n## P79 mongodb模糊查询（带分页）\n\n> ```Java\n> @Override\n>  public Page<Department> findPageDepartment(int page, int limit, DepartmentQueryVo departmentQueryVo) {\n>      //创建PageABLE对象，设置当前页与记录数\n>      Pageable pageable = PageRequest.of(page-1,limit);\n> \n>      //将QueryVo对象转换成department对象\n>      Department department = new Department();\n>      BeanUtils.copyProperties(departmentQueryVo,department);\n>      //创建example对象,这是mongodb中模糊查询的规则\n>      ExampleMatcher matcher = ExampleMatcher.matching()\n>              .withStringMatcher(ExampleMatcher.StringMatcher.CONTAINING)\n>              .withIgnoreCase(true);\n>      Example<Department> example = Example.of(department,matcher);\n>      Page<Department> all = departmentRepository.findAll(example, pageable);\n>      return all;\n>  }\n> ```\n\n**踩坑记录：**\n\n```txt\n访问mongo:\n\t环境：部署在虚拟机中的docker\n\t问题：navicat无法远程连接mongo——>?\n\t\t解决：1、开启管理员root模式、重启docker：systemctl restart docker、进入mongo容器：docker exec -it /bin/bash、虚拟机配置文件bindIp设置为：0.0.0.0（可远程访问）\n\t\t\n\t问题：控制台空指针异常、前端显示数据异常——>?\n\t\t解决：因为部署在虚拟机中，IP地址会改变，yygh_hosp中需要将配置文件更改为正确的IP。\n```\n\ngit许久未用，可能之前踩坑埋雷了，用以下方法得以解决：\n\n\n\n\n\n\n\n## P80 后台系统-医院管理-需求和nacos启动\n\n```html\nnacos访问地址：http://虚拟机IP:8848/nacos\n```\n\n记录一下：nacos（注册中心）可以远程调用两个springBoot项目，为什么要远程调用，因为项目的开发微服务可能部署在不同的服务器之上，因此需要注册中心nacos来管理。\n\n> 重点记忆，需要和熟练！！！\n>\n> ```Java\n> //mongodb的条件查询带分页\n> \n> Controller:\n> \n> //医院列表(条件查询带分页)\n>  //因为本方法是通过路径传递当前页值与记录数值，所以方法体中需要通过@PathVariable注解将值取到；\n>  //又因为本方法设计条件查询，条件已经被封装到Vo类中，所以方法体中需要传入Vo类。\n>  @PostMapping(\"list/{page}/{limit}\")\n>  public Result listHosp(@PathVariable Integer page,\n>                         @PathVariable Integer limit,\n>                         HospitalQueryVo hospitalQueryVo) {\n>      Page<Hospital> pageModel = hospitalService.selectHospPage(page,limit,hospitalQueryVo);\n>      return Result.ok(pageModel);\n>  }\n> \n> service：\n> \n> //条件查询医院列表分页\n>  Page<Hospital> selectHospPage(Integer page, Integer limit, HospitalQueryVo hospitalQueryVo);\n> \n> service实现类：\n> \n> //医院列表（条件查询分页）  以下三个步骤是查询MOngoDB中的步骤\n>  @Override\n>  public Page<Hospital> selectHospPage(Integer page, Integer limit, HospitalQueryVo hospitalQueryVo) {\n>      //创建pageable对象\n>      Pageable pageable = PageRequest.of(page-1,limit);\n>      //创建条件查询匹配器\n>      ExampleMatcher matcher = ExampleMatcher.matching()\n>              .withStringMatcher(ExampleMatcher.StringMatcher.CONTAINING)\n>              .withIgnoreCase(true);\n>      //对象转换 Vo->hospital\n>      Hospital hospital = new Hospital();\n>      //通过bean工具类 直接进行对象转换 Vo->hospital\n>      BeanUtils.copyProperties(hospitalQueryVo,hospital);\n>      //创建example实例对象\n>      Example<Hospital> example = Example.of(hospital,matcher);\n>      //调用方法\n>      Page<Hospital> all = hospitalRepository.findAll(example, pageable);\n>      return all;\n>  }\n> ```\n>\n> \n\n\n\n## P88 医院列表，前端整合\n\n**踩大坑记录：**\n\n```txt\n大坑！项目停滞！\n\t1、nacos、redis连接不上，拒绝连接的问题\n    \t解决方案：虚拟机本地redis->docker安装redis容器，并实现自启动、使用shell远程连接vm更加便捷！\n    \t\t\t若还是connect refused，就查看防火墙是否开放端口，若是使用的云服务器，则配置安全组开放端口。\n    2、跨域问题：域名路径、域名端口、提交方式（get、post）都会造成跨域问题！\n    \t解决方案：idea中分页listHosp方法写成PostMapping，改成GetMapping即可!\n```\n\n```linux\nLinux相关命令：\n\t#docker pull之后，使用如下命令进行创建和启动容器，因为懒的配置，所以使用默认配置。\n\t\tdocker run -itd --name redis -p 6379:6379 redis\n\t#docker ps：查看运行中的CONTAINER\n\t#docker进入容器\n\t\tdocker exec -it mymongo /bin/bash\n\t#这个是使容器处于docker运行便自启动\n\t\tdocker update redis --restart=always \n\t#docker重启命令\n\t\tsystemctl restart docker\n\t#容器重启命令\n\t\tdocker restart redis(自己命的名字或者CONTAINER ID)\n```\n\n```linux\nfirewalled相关命令：\n\t(1)允许TCP的443端口到internal区域\n   \t\tfirewall-cmd --zone=internal --add-port=443/tcp\n   \t\tfirewall-cmd --list-all --zone=internal\n \n\t(2)从internal区域将TCP的443端口移除\n   \t\tfirewall-cmd --zone=internal --remove-port=443/tcp\n \n\t(3)允许UDP的2048-2050端口到默认区域\n   \t\tfirewall-cmd --add-port=2048-2050/udp\n   \t\tfirewall-cmd --list-all\n   \t\t\n   \t\t\n启动systemctl start firewalld\n关闭systemctl stop firewalld\n查看状态systemctl status firewalld\n查看状态firewall-cmd --state\n开机启用systemctl enable firewalld\n开机禁用systemctl disable firewalld\n查看端口\n   \t\tfirewall-cmd --zone=public --list-ports\n\n添加端口\n      firewall-cmd --add-port=443/tcp --permanent //永久添加443端口,协议为tcp \n重新加载\n      firewall-cmd --reload //重新加载\n\n删除端口\n      firewall-cmd --zone=public --remove-port=80/tcp --permanent //删除tcp下的80端口\n\n参数介绍：\nfirewall-cmd：是Linux提供的操作firewall的一个工具(注意没有字母“d”)；\n--permanent：表示设置为持久；\n--add-port：标识添加的端口\n--remove-port:标识删除的端口\n```\n\n下一步p89：实现更新医院上线状态功能。\n\n## P89-P90医院的上线以及查看详细信息的功能\n\n过程：常规的Controller->Service->ServiceImpl\n\n问题：隐藏路由跳转真实路由：\n\n```html\nthis.$router.push({ path: '/hospSet/list' })\n```\n\n## P91排班管理\n\n这块代码逻辑比较复杂，可以借此锻炼自己的需求分析+逻辑实现。\n\n> 赶进度，代码逻辑已经实现，从本初开始cv代码！！！P92\n>\n> ```TXT\n> 以下代码必须整理明白，搞清楚其中的逻辑，需求如何实现！\n> ```\n>\n> \n\n```Java\n//根据医院编号，查询医院所有科室列表P92\n    @Override\n    public List<DepartmentVo> findDeptTree(String hoscode) {\n        //创建list集合，用于最终数据封装\n        List<DepartmentVo> result = new ArrayList<>();\n\n        //根据医院编号，查询医院所有科室信息\n        Department departmentQuery = new Department();\n        departmentQuery.setHoscode(hoscode);\n        Example example = Example.of(departmentQuery);\n\n        List<Department> departmentList = departmentRepository.findAll(example);\n        /**\n         * 从本处开始cv\n         * P92\n         */\n        //根据大科室编号  bigcode 分组，获取每个大科室里面下级子科室\n        Map<String, List<Department>> deparmentMap =\n                departmentList.stream().collect(Collectors.groupingBy(Department::getBigcode));\n        //遍历map集合 deparmentMap\n        for(Map.Entry<String,List<Department>> entry : deparmentMap.entrySet()) {\n            //大科室编号\n            String bigcode = entry.getKey();\n            //大科室编号对应的全局数据\n            List<Department> deparment1List = entry.getValue();\n            //封装大科室\n            DepartmentVo departmentVo1 = new DepartmentVo();\n            departmentVo1.setDepcode(bigcode);\n            departmentVo1.setDepname(deparment1List.get(0).getBigname());\n\n            //封装小科室\n            List<DepartmentVo> children = new ArrayList<>();\n            for(Department department: deparment1List) {\n                DepartmentVo departmentVo2 =  new DepartmentVo();\n                departmentVo2.setDepcode(department.getDepcode());\n                departmentVo2.setDepname(department.getDepname());\n                //封装到list集合\n                children.add(departmentVo2);\n            }\n            //把小科室list集合放到大科室children里面\n            departmentVo1.setChildren(children);\n            //放到最终result里面\n            result.add(departmentVo1);\n        }\n        //返回\n        return result;\n\n    }\n```\n\n## P93显示科室的前端整合\n\n一些基础的前端隐藏路由-》界面elemenUI+信息显示\n\n完成科室信息树形结构显示\n\n## P94\n\n接下来完成每个科室的树形结构排版信息显示。\n\n涉及到信息的统计、分析与聚合（分组之后的数据）\n\n## P95科室排班的分页信息显示\n\n注意此处的代码逻辑书写，自己找时间练习\n\n## P98\n\n遇到了排班详细信息不显示的问题，暂未解决！\n\n\n\n\n\n## 简历写法\n\n基于Vue+SpringBoot+SpringCloud+MongoDB+RabbitMQ+Gateway实现的问诊预约系统，用户可以进行微信单点登录、预约挂号、支付订单，管理员可以会员管理、订单管理、统计管理以及对数据字典的导入导出\n\n一个前后端分离的在线预约挂号系统。用户可以预约挂号支付订单，管理员可以管理订单，医院        可以管理数据。使用Spring Cloud微服务框架，数据存储使用MongoDB和MySQL，中间件使用Redis和         RabbitMQ\n\n同时还整合了定时任务,实现就医提醒功能,\n\n综合应用了阿里云OSS,短信服务\n\n以及微信登录、\n\n微信支付,\n\n同时增加了微信退款功能","source":"_posts/shangyitong.md","raw":"---\ntitle: 尚医通\nindex_img: https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311151627634.png\nbanner_img: https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311151644178.png\ncategories:\n  - Project\ntags:\n  - Spring Boot\n  - Spring Cloud GateWay\n  - feign\n  - nacos\n  - MongoDB\n  - Redis\n  - MySQL\n  - JWT\n  - EasyExcell\nabbrlink: 47316\ndate: 2022-05-31 11:23:42\n---\n\n\n> 欢迎观看我的医院预约挂号平台项目笔记\n>\n> axiba,图片在typora软件更新时被意外删除了！！！\n>\n> ![测试一下](https://cdn.jsdelivr.net/gh/wl2o2o/blogCdn/img/202306211602425.png)\n\n# 尚医通学习笔记\n\n*前言：按照计划跟做项目，发现仍有一些令人不解的坑，为了解决问题耗费了更多的事件，通过手写和电子笔记以此列举学习成果，以便更好的复习。*\n\n> ## 项目介绍篇\n\n是一个预约挂号，就医问诊，解决患者就医难看病难的平台。\n\n平台：用户前台（用户预约挂号）、管理员后台、医院管理后台（上传医院信息）\n\n> ## 技术框架\n\n微服务：使用`Docker`作为微服务的部署，启动中间件\n\n​      `Spring Cloud` 作为整体框架\n\n​\t  `nacos`注册中心\n\n​\t  `feign`远程调用\n\n​\t  `Spring Cloud GateWay`网关\n\n数据库：\n\n​\t  `MongoDB`、`MySQL`作为数据库\n\n中间件：\n\n​\t  `Rabbitmq`消息队列、`redis`\n\n功能性类库：\n\n​\t  `JWT`登录验证、`EasyExcell`数据库导入导出\n\n![架构图](https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311151644178.png)\n\n> ## 业务流程\n\n医院通过医院管理后台上传医院的基本信息、预约规则信息、科室信息、排班信息。然后又管理平台进行审核，通过后预约挂号平台进行展示，用户就可以进行根据需求选择挂号，会调用医院挂号接口进行挂号，挂号成功之后，进行支付，取号，同时也可以取消预约，对应的预约状态也会进行实时更新。\n\n> ## 项目亮点\n\n真实全面、贴合实际\n\n\n\n什么是服务端渲染？\n\n服务器先把数据请求好，并且拼接到恩安政的页面当中，再返回给客户端。\n\n从何处请求数据呢？答：从后端，所以运行项目的时候，要先运行后端，否则会报错！\n\n\n\n数据库是怎么划分的？\n\n数据库分为MySQL和MongoDB，其中MySQL是关系型数据库，用来存储用户、订单、预约等关系型数据，MongoDB是一个介于关系数据库和非关系数据库之间的产品,是非关系数据库当中功能最丰富,最像关系数据库的,它支持的数据结构非常松散,是类似json的bson格式,因此可以存储比较复杂的数据类型。因为大多数数据操作在内存中进行，所以效率较高。本项目中用来存储一些医院本身的信息和一些不固定的信息，比较灵活!\n\n后端亮点：\n\n> ## 项目启动\n\n后端\n\n启动服务：\n\nnacos\n\n> 可以用来管理微服务，提供服务的注册与发现，作为配置中心管理动态配置\n\n\n\n\n\n> ## 简历部分\n\n前端：使用webpack来减小项目体积以及运行速度\n\n## P64 redis\n\nredis连接不上，贴一篇文章，包含conf文件的配置与redis.cli客户端的运行命令\n\n[redis虚拟机与本地连接](https://blog.csdn.net/magicproblem/article/details/113238030)\n\n[虚拟机运行redis](https://www.runoob.com/redis/redis-install.html)\n\n## P65 配置nginx\n\n## P66 `MongoDB`\n\n```dockerfile\ndocker run -d --restart=always -p 27017:27017 --name mymongo -v /data/db:/data/db -d mongo\ndocker exec -it mongo bash\n```\n\n\n\n```TXT\n1、 Help查看命令提示 \ndb.help();\n2、 切换/创建数据库\nuse test\n如果数据库不存在，则创建数据库，否则切换到指定数据库\n3、 查询所有数据库 \nshow dbs;\n4、 删除当前使用数据库 \ndb.dropDatabase();\n5、 查看当前使用的数据库 \ndb.getName();\n6、 显示当前db状态 \ndb.stats();\n7、 当前db版本 \ndb.version();\n8、 查看当前db的链接机器地址 \ndb.getMongo〇;\n```\n\n通过下图实例，我们也可以更直观的的了解Mongo中的一些概念：\n\n\n\n## P67 —— P72 SpringBoot整合MongoDB\n\nmongo Template CRUD实现方法：\n\n```txt\n常用方法\nmongoTemplate.findAll(User.class): 查询User文档的全部数据\nmongoTemplate.findById(<id>, User.class): 查询User文档id为id的数据\nmongoTemplate.find(query, User.class);: 根据query内的查询条件查询\nmongoTemplate.upsert(query, update, User.class): 修改\nmongoTemplate.remove(query, User.class): 删除\nmongoTemplate.insert(User): 新增\nQuery对象\n1、创建一个query对象（用来封装所有条件对象)，再创建一个criteria对象（用来构建条件）\n2、 精准条件：criteria.and(“key”).is(“条件”)\n模糊条件：criteria.and(“key”).regex(“条件”)\n3、封装条件：query.addCriteria(criteria)\n4、大于（创建新的criteria）：Criteria gt = Criteria.where(“key”).gt（“条件”）\n小于（创建新的criteria）：Criteria lt = Criteria.where(“key”).lt（“条件”）\n5、Query.addCriteria(new Criteria().andOperator(gt,lt));\n6、一个query中只能有一个andOperator()。其参数也可以是Criteria数组。\n7、排序 ：query.with（new Sort(Sort.Direction.ASC, \"age\"). and(new Sort(Sort.Direction.DESC, \"date\")))\n```\n\n模糊查询方法：\n\n> ```Java\n> //模糊查询\n>  @Test\n>  public void findUsersLikeName() {\n>      String name = \"est\";\n>      String regex = String.format(\"%s%s%s\", \"^.*\", name, \".*$\");\n>      //regex正则表达式\n>      Pattern pattern = Pattern.compile(regex, Pattern.CASE_INSENSITIVE);\n>      Query query = new Query(Criteria.where(\"name\").regex(pattern));\n>      List<User> userList = mongoTemplate.find(query, User.class);\n>      System.out.println(userList);\n>  }\n> ```\n\nmongo repository CURD 实现方法：\n\n总结一波，方法调用来说，整体差不多，都挺麻烦，但是不难看出，MongoTemplate更加灵活，MongoRepogistory简单一些。\n\n\n\n## P73 数据接口-上传医院接口\n\n需求和准备——>基础类创建——>初步实现\n\n涉及：json转换工具(JSONObject:map->字符串->对象）\n\n\n\n## P79 mongodb模糊查询（带分页）\n\n> ```Java\n> @Override\n>  public Page<Department> findPageDepartment(int page, int limit, DepartmentQueryVo departmentQueryVo) {\n>      //创建PageABLE对象，设置当前页与记录数\n>      Pageable pageable = PageRequest.of(page-1,limit);\n> \n>      //将QueryVo对象转换成department对象\n>      Department department = new Department();\n>      BeanUtils.copyProperties(departmentQueryVo,department);\n>      //创建example对象,这是mongodb中模糊查询的规则\n>      ExampleMatcher matcher = ExampleMatcher.matching()\n>              .withStringMatcher(ExampleMatcher.StringMatcher.CONTAINING)\n>              .withIgnoreCase(true);\n>      Example<Department> example = Example.of(department,matcher);\n>      Page<Department> all = departmentRepository.findAll(example, pageable);\n>      return all;\n>  }\n> ```\n\n**踩坑记录：**\n\n```txt\n访问mongo:\n\t环境：部署在虚拟机中的docker\n\t问题：navicat无法远程连接mongo——>?\n\t\t解决：1、开启管理员root模式、重启docker：systemctl restart docker、进入mongo容器：docker exec -it /bin/bash、虚拟机配置文件bindIp设置为：0.0.0.0（可远程访问）\n\t\t\n\t问题：控制台空指针异常、前端显示数据异常——>?\n\t\t解决：因为部署在虚拟机中，IP地址会改变，yygh_hosp中需要将配置文件更改为正确的IP。\n```\n\ngit许久未用，可能之前踩坑埋雷了，用以下方法得以解决：\n\n\n\n\n\n\n\n## P80 后台系统-医院管理-需求和nacos启动\n\n```html\nnacos访问地址：http://虚拟机IP:8848/nacos\n```\n\n记录一下：nacos（注册中心）可以远程调用两个springBoot项目，为什么要远程调用，因为项目的开发微服务可能部署在不同的服务器之上，因此需要注册中心nacos来管理。\n\n> 重点记忆，需要和熟练！！！\n>\n> ```Java\n> //mongodb的条件查询带分页\n> \n> Controller:\n> \n> //医院列表(条件查询带分页)\n>  //因为本方法是通过路径传递当前页值与记录数值，所以方法体中需要通过@PathVariable注解将值取到；\n>  //又因为本方法设计条件查询，条件已经被封装到Vo类中，所以方法体中需要传入Vo类。\n>  @PostMapping(\"list/{page}/{limit}\")\n>  public Result listHosp(@PathVariable Integer page,\n>                         @PathVariable Integer limit,\n>                         HospitalQueryVo hospitalQueryVo) {\n>      Page<Hospital> pageModel = hospitalService.selectHospPage(page,limit,hospitalQueryVo);\n>      return Result.ok(pageModel);\n>  }\n> \n> service：\n> \n> //条件查询医院列表分页\n>  Page<Hospital> selectHospPage(Integer page, Integer limit, HospitalQueryVo hospitalQueryVo);\n> \n> service实现类：\n> \n> //医院列表（条件查询分页）  以下三个步骤是查询MOngoDB中的步骤\n>  @Override\n>  public Page<Hospital> selectHospPage(Integer page, Integer limit, HospitalQueryVo hospitalQueryVo) {\n>      //创建pageable对象\n>      Pageable pageable = PageRequest.of(page-1,limit);\n>      //创建条件查询匹配器\n>      ExampleMatcher matcher = ExampleMatcher.matching()\n>              .withStringMatcher(ExampleMatcher.StringMatcher.CONTAINING)\n>              .withIgnoreCase(true);\n>      //对象转换 Vo->hospital\n>      Hospital hospital = new Hospital();\n>      //通过bean工具类 直接进行对象转换 Vo->hospital\n>      BeanUtils.copyProperties(hospitalQueryVo,hospital);\n>      //创建example实例对象\n>      Example<Hospital> example = Example.of(hospital,matcher);\n>      //调用方法\n>      Page<Hospital> all = hospitalRepository.findAll(example, pageable);\n>      return all;\n>  }\n> ```\n>\n> \n\n\n\n## P88 医院列表，前端整合\n\n**踩大坑记录：**\n\n```txt\n大坑！项目停滞！\n\t1、nacos、redis连接不上，拒绝连接的问题\n    \t解决方案：虚拟机本地redis->docker安装redis容器，并实现自启动、使用shell远程连接vm更加便捷！\n    \t\t\t若还是connect refused，就查看防火墙是否开放端口，若是使用的云服务器，则配置安全组开放端口。\n    2、跨域问题：域名路径、域名端口、提交方式（get、post）都会造成跨域问题！\n    \t解决方案：idea中分页listHosp方法写成PostMapping，改成GetMapping即可!\n```\n\n```linux\nLinux相关命令：\n\t#docker pull之后，使用如下命令进行创建和启动容器，因为懒的配置，所以使用默认配置。\n\t\tdocker run -itd --name redis -p 6379:6379 redis\n\t#docker ps：查看运行中的CONTAINER\n\t#docker进入容器\n\t\tdocker exec -it mymongo /bin/bash\n\t#这个是使容器处于docker运行便自启动\n\t\tdocker update redis --restart=always \n\t#docker重启命令\n\t\tsystemctl restart docker\n\t#容器重启命令\n\t\tdocker restart redis(自己命的名字或者CONTAINER ID)\n```\n\n```linux\nfirewalled相关命令：\n\t(1)允许TCP的443端口到internal区域\n   \t\tfirewall-cmd --zone=internal --add-port=443/tcp\n   \t\tfirewall-cmd --list-all --zone=internal\n \n\t(2)从internal区域将TCP的443端口移除\n   \t\tfirewall-cmd --zone=internal --remove-port=443/tcp\n \n\t(3)允许UDP的2048-2050端口到默认区域\n   \t\tfirewall-cmd --add-port=2048-2050/udp\n   \t\tfirewall-cmd --list-all\n   \t\t\n   \t\t\n启动systemctl start firewalld\n关闭systemctl stop firewalld\n查看状态systemctl status firewalld\n查看状态firewall-cmd --state\n开机启用systemctl enable firewalld\n开机禁用systemctl disable firewalld\n查看端口\n   \t\tfirewall-cmd --zone=public --list-ports\n\n添加端口\n      firewall-cmd --add-port=443/tcp --permanent //永久添加443端口,协议为tcp \n重新加载\n      firewall-cmd --reload //重新加载\n\n删除端口\n      firewall-cmd --zone=public --remove-port=80/tcp --permanent //删除tcp下的80端口\n\n参数介绍：\nfirewall-cmd：是Linux提供的操作firewall的一个工具(注意没有字母“d”)；\n--permanent：表示设置为持久；\n--add-port：标识添加的端口\n--remove-port:标识删除的端口\n```\n\n下一步p89：实现更新医院上线状态功能。\n\n## P89-P90医院的上线以及查看详细信息的功能\n\n过程：常规的Controller->Service->ServiceImpl\n\n问题：隐藏路由跳转真实路由：\n\n```html\nthis.$router.push({ path: '/hospSet/list' })\n```\n\n## P91排班管理\n\n这块代码逻辑比较复杂，可以借此锻炼自己的需求分析+逻辑实现。\n\n> 赶进度，代码逻辑已经实现，从本初开始cv代码！！！P92\n>\n> ```TXT\n> 以下代码必须整理明白，搞清楚其中的逻辑，需求如何实现！\n> ```\n>\n> \n\n```Java\n//根据医院编号，查询医院所有科室列表P92\n    @Override\n    public List<DepartmentVo> findDeptTree(String hoscode) {\n        //创建list集合，用于最终数据封装\n        List<DepartmentVo> result = new ArrayList<>();\n\n        //根据医院编号，查询医院所有科室信息\n        Department departmentQuery = new Department();\n        departmentQuery.setHoscode(hoscode);\n        Example example = Example.of(departmentQuery);\n\n        List<Department> departmentList = departmentRepository.findAll(example);\n        /**\n         * 从本处开始cv\n         * P92\n         */\n        //根据大科室编号  bigcode 分组，获取每个大科室里面下级子科室\n        Map<String, List<Department>> deparmentMap =\n                departmentList.stream().collect(Collectors.groupingBy(Department::getBigcode));\n        //遍历map集合 deparmentMap\n        for(Map.Entry<String,List<Department>> entry : deparmentMap.entrySet()) {\n            //大科室编号\n            String bigcode = entry.getKey();\n            //大科室编号对应的全局数据\n            List<Department> deparment1List = entry.getValue();\n            //封装大科室\n            DepartmentVo departmentVo1 = new DepartmentVo();\n            departmentVo1.setDepcode(bigcode);\n            departmentVo1.setDepname(deparment1List.get(0).getBigname());\n\n            //封装小科室\n            List<DepartmentVo> children = new ArrayList<>();\n            for(Department department: deparment1List) {\n                DepartmentVo departmentVo2 =  new DepartmentVo();\n                departmentVo2.setDepcode(department.getDepcode());\n                departmentVo2.setDepname(department.getDepname());\n                //封装到list集合\n                children.add(departmentVo2);\n            }\n            //把小科室list集合放到大科室children里面\n            departmentVo1.setChildren(children);\n            //放到最终result里面\n            result.add(departmentVo1);\n        }\n        //返回\n        return result;\n\n    }\n```\n\n## P93显示科室的前端整合\n\n一些基础的前端隐藏路由-》界面elemenUI+信息显示\n\n完成科室信息树形结构显示\n\n## P94\n\n接下来完成每个科室的树形结构排版信息显示。\n\n涉及到信息的统计、分析与聚合（分组之后的数据）\n\n## P95科室排班的分页信息显示\n\n注意此处的代码逻辑书写，自己找时间练习\n\n## P98\n\n遇到了排班详细信息不显示的问题，暂未解决！\n\n\n\n\n\n## 简历写法\n\n基于Vue+SpringBoot+SpringCloud+MongoDB+RabbitMQ+Gateway实现的问诊预约系统，用户可以进行微信单点登录、预约挂号、支付订单，管理员可以会员管理、订单管理、统计管理以及对数据字典的导入导出\n\n一个前后端分离的在线预约挂号系统。用户可以预约挂号支付订单，管理员可以管理订单，医院        可以管理数据。使用Spring Cloud微服务框架，数据存储使用MongoDB和MySQL，中间件使用Redis和         RabbitMQ\n\n同时还整合了定时任务,实现就医提醒功能,\n\n综合应用了阿里云OSS,短信服务\n\n以及微信登录、\n\n微信支付,\n\n同时增加了微信退款功能","slug":"shangyitong","published":1,"updated":"2023-11-15T08:44:51.632Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clpkiczjj003afkfo87tta7mc","content":"<blockquote>\n<p>欢迎观看我的医院预约挂号平台项目笔记</p>\n<p>axiba,图片在typora软件更新时被意外删除了！！！</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/wl2o2o/blogCdn/img/202306211602425.png\" alt=\"测试一下\"></p>\n</blockquote>\n<h1 id=\"尚医通学习笔记\"><a href=\"#尚医通学习笔记\" class=\"headerlink\" title=\"尚医通学习笔记\"></a>尚医通学习笔记</h1><p><em>前言：按照计划跟做项目，发现仍有一些令人不解的坑，为了解决问题耗费了更多的事件，通过手写和电子笔记以此列举学习成果，以便更好的复习。</em></p>\n<blockquote>\n<h2 id=\"项目介绍篇\"><a href=\"#项目介绍篇\" class=\"headerlink\" title=\"项目介绍篇\"></a>项目介绍篇</h2></blockquote>\n<p>是一个预约挂号，就医问诊，解决患者就医难看病难的平台。</p>\n<p>平台：用户前台（用户预约挂号）、管理员后台、医院管理后台（上传医院信息）</p>\n<blockquote>\n<h2 id=\"技术框架\"><a href=\"#技术框架\" class=\"headerlink\" title=\"技术框架\"></a>技术框架</h2></blockquote>\n<p>微服务：使用<code>Docker</code>作为微服务的部署，启动中间件</p>\n<p>​      <code>Spring Cloud</code> 作为整体框架</p>\n<p>​      <code>nacos</code>注册中心</p>\n<p>​      <code>feign</code>远程调用</p>\n<p>​      <code>Spring Cloud GateWay</code>网关</p>\n<p>数据库：</p>\n<p>​      <code>MongoDB</code>、<code>MySQL</code>作为数据库</p>\n<p>中间件：</p>\n<p>​      <code>Rabbitmq</code>消息队列、<code>redis</code></p>\n<p>功能性类库：</p>\n<p>​      <code>JWT</code>登录验证、<code>EasyExcell</code>数据库导入导出</p>\n<p><img src=\"https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311151644178.png\" alt=\"架构图\"></p>\n<blockquote>\n<h2 id=\"业务流程\"><a href=\"#业务流程\" class=\"headerlink\" title=\"业务流程\"></a>业务流程</h2></blockquote>\n<p>医院通过医院管理后台上传医院的基本信息、预约规则信息、科室信息、排班信息。然后又管理平台进行审核，通过后预约挂号平台进行展示，用户就可以进行根据需求选择挂号，会调用医院挂号接口进行挂号，挂号成功之后，进行支付，取号，同时也可以取消预约，对应的预约状态也会进行实时更新。</p>\n<blockquote>\n<h2 id=\"项目亮点\"><a href=\"#项目亮点\" class=\"headerlink\" title=\"项目亮点\"></a>项目亮点</h2></blockquote>\n<p>真实全面、贴合实际</p>\n<p>什么是服务端渲染？</p>\n<p>服务器先把数据请求好，并且拼接到恩安政的页面当中，再返回给客户端。</p>\n<p>从何处请求数据呢？答：从后端，所以运行项目的时候，要先运行后端，否则会报错！</p>\n<p>数据库是怎么划分的？</p>\n<p>数据库分为MySQL和MongoDB，其中MySQL是关系型数据库，用来存储用户、订单、预约等关系型数据，MongoDB是一个介于关系数据库和非关系数据库之间的产品,是非关系数据库当中功能最丰富,最像关系数据库的,它支持的数据结构非常松散,是类似json的bson格式,因此可以存储比较复杂的数据类型。因为大多数数据操作在内存中进行，所以效率较高。本项目中用来存储一些医院本身的信息和一些不固定的信息，比较灵活!</p>\n<p>后端亮点：</p>\n<blockquote>\n<h2 id=\"项目启动\"><a href=\"#项目启动\" class=\"headerlink\" title=\"项目启动\"></a>项目启动</h2></blockquote>\n<p>后端</p>\n<p>启动服务：</p>\n<p>nacos</p>\n<blockquote>\n<p>可以用来管理微服务，提供服务的注册与发现，作为配置中心管理动态配置</p>\n</blockquote>\n<blockquote>\n<h2 id=\"简历部分\"><a href=\"#简历部分\" class=\"headerlink\" title=\"简历部分\"></a>简历部分</h2></blockquote>\n<p>前端：使用webpack来减小项目体积以及运行速度</p>\n<h2 id=\"P64-redis\"><a href=\"#P64-redis\" class=\"headerlink\" title=\"P64 redis\"></a>P64 redis</h2><p>redis连接不上，贴一篇文章，包含conf文件的配置与redis.cli客户端的运行命令</p>\n<p><a href=\"https://blog.csdn.net/magicproblem/article/details/113238030\">redis虚拟机与本地连接</a></p>\n<p><a href=\"https://www.runoob.com/redis/redis-install.html\">虚拟机运行redis</a></p>\n<h2 id=\"P65-配置nginx\"><a href=\"#P65-配置nginx\" class=\"headerlink\" title=\"P65 配置nginx\"></a>P65 配置nginx</h2><h2 id=\"P66-MongoDB\"><a href=\"#P66-MongoDB\" class=\"headerlink\" title=\"P66 MongoDB\"></a>P66 <code>MongoDB</code></h2><figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs dockerfile\">docker <span class=\"hljs-keyword\">run</span><span class=\"language-bash\"> -d --restart=always -p 27017:27017 --name mymongo -v /data/db:/data/db -d mongo</span><br>docker exec -it mongo bash<br></code></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight txt\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs TXT\">1、 Help查看命令提示 <br>db.help();<br>2、 切换/创建数据库<br>use test<br>如果数据库不存在，则创建数据库，否则切换到指定数据库<br>3、 查询所有数据库 <br>show dbs;<br>4、 删除当前使用数据库 <br>db.dropDatabase();<br>5、 查看当前使用的数据库 <br>db.getName();<br>6、 显示当前db状态 <br>db.stats();<br>7、 当前db版本 <br>db.version();<br>8、 查看当前db的链接机器地址 <br>db.getMongo〇;<br></code></pre></td></tr></table></figure>\n\n<p>通过下图实例，我们也可以更直观的的了解Mongo中的一些概念：</p>\n<h2 id=\"P67-——-P72-SpringBoot整合MongoDB\"><a href=\"#P67-——-P72-SpringBoot整合MongoDB\" class=\"headerlink\" title=\"P67 —— P72 SpringBoot整合MongoDB\"></a>P67 —— P72 SpringBoot整合MongoDB</h2><p>mongo Template CRUD实现方法：</p>\n<figure class=\"highlight txt\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs txt\">常用方法<br>mongoTemplate.findAll(User.class): 查询User文档的全部数据<br>mongoTemplate.findById(&lt;id&gt;, User.class): 查询User文档id为id的数据<br>mongoTemplate.find(query, User.class);: 根据query内的查询条件查询<br>mongoTemplate.upsert(query, update, User.class): 修改<br>mongoTemplate.remove(query, User.class): 删除<br>mongoTemplate.insert(User): 新增<br>Query对象<br>1、创建一个query对象（用来封装所有条件对象)，再创建一个criteria对象（用来构建条件）<br>2、 精准条件：criteria.and(“key”).is(“条件”)<br>模糊条件：criteria.and(“key”).regex(“条件”)<br>3、封装条件：query.addCriteria(criteria)<br>4、大于（创建新的criteria）：Criteria gt = Criteria.where(“key”).gt（“条件”）<br>小于（创建新的criteria）：Criteria lt = Criteria.where(“key”).lt（“条件”）<br>5、Query.addCriteria(new Criteria().andOperator(gt,lt));<br>6、一个query中只能有一个andOperator()。其参数也可以是Criteria数组。<br>7、排序 ：query.with（new Sort(Sort.Direction.ASC, &quot;age&quot;). and(new Sort(Sort.Direction.DESC, &quot;date&quot;)))<br></code></pre></td></tr></table></figure>\n\n<p>模糊查询方法：</p>\n<blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Java\"><span class=\"hljs-comment\">//模糊查询</span><br> <span class=\"hljs-meta\">@Test</span><br> <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">findUsersLikeName</span><span class=\"hljs-params\">()</span> &#123;<br>     <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">name</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;est&quot;</span>;<br>     <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">regex</span> <span class=\"hljs-operator\">=</span> String.format(<span class=\"hljs-string\">&quot;%s%s%s&quot;</span>, <span class=\"hljs-string\">&quot;^.*&quot;</span>, name, <span class=\"hljs-string\">&quot;.*$&quot;</span>);<br>     <span class=\"hljs-comment\">//regex正则表达式</span><br>     <span class=\"hljs-type\">Pattern</span> <span class=\"hljs-variable\">pattern</span> <span class=\"hljs-operator\">=</span> Pattern.compile(regex, Pattern.CASE_INSENSITIVE);<br>     <span class=\"hljs-type\">Query</span> <span class=\"hljs-variable\">query</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Query</span>(Criteria.where(<span class=\"hljs-string\">&quot;name&quot;</span>).regex(pattern));<br>     List&lt;User&gt; userList = mongoTemplate.find(query, User.class);<br>     System.out.println(userList);<br> &#125;<br></code></pre></td></tr></table></figure>\n</blockquote>\n<p>mongo repository CURD 实现方法：</p>\n<p>总结一波，方法调用来说，整体差不多，都挺麻烦，但是不难看出，MongoTemplate更加灵活，MongoRepogistory简单一些。</p>\n<h2 id=\"P73-数据接口-上传医院接口\"><a href=\"#P73-数据接口-上传医院接口\" class=\"headerlink\" title=\"P73 数据接口-上传医院接口\"></a>P73 数据接口-上传医院接口</h2><p>需求和准备——&gt;基础类创建——&gt;初步实现</p>\n<p>涉及：json转换工具(JSONObject:map-&gt;字符串-&gt;对象）</p>\n<h2 id=\"P79-mongodb模糊查询（带分页）\"><a href=\"#P79-mongodb模糊查询（带分页）\" class=\"headerlink\" title=\"P79 mongodb模糊查询（带分页）\"></a>P79 mongodb模糊查询（带分页）</h2><blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Java\"><span class=\"hljs-meta\">@Override</span><br> <span class=\"hljs-keyword\">public</span> Page&lt;Department&gt; <span class=\"hljs-title function_\">findPageDepartment</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> page, <span class=\"hljs-type\">int</span> limit, DepartmentQueryVo departmentQueryVo)</span> &#123;<br>     <span class=\"hljs-comment\">//创建PageABLE对象，设置当前页与记录数</span><br>     <span class=\"hljs-type\">Pageable</span> <span class=\"hljs-variable\">pageable</span> <span class=\"hljs-operator\">=</span> PageRequest.of(page-<span class=\"hljs-number\">1</span>,limit);<br><br>     <span class=\"hljs-comment\">//将QueryVo对象转换成department对象</span><br>     <span class=\"hljs-type\">Department</span> <span class=\"hljs-variable\">department</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Department</span>();<br>     BeanUtils.copyProperties(departmentQueryVo,department);<br>     <span class=\"hljs-comment\">//创建example对象,这是mongodb中模糊查询的规则</span><br>     <span class=\"hljs-type\">ExampleMatcher</span> <span class=\"hljs-variable\">matcher</span> <span class=\"hljs-operator\">=</span> ExampleMatcher.matching()<br>             .withStringMatcher(ExampleMatcher.StringMatcher.CONTAINING)<br>             .withIgnoreCase(<span class=\"hljs-literal\">true</span>);<br>     Example&lt;Department&gt; example = Example.of(department,matcher);<br>     Page&lt;Department&gt; all = departmentRepository.findAll(example, pageable);<br>     <span class=\"hljs-keyword\">return</span> all;<br> &#125;<br></code></pre></td></tr></table></figure>\n</blockquote>\n<p><strong>踩坑记录：</strong></p>\n<figure class=\"highlight txt\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs txt\">访问mongo:<br>\t环境：部署在虚拟机中的docker<br>\t问题：navicat无法远程连接mongo——&gt;?<br>\t\t解决：1、开启管理员root模式、重启docker：systemctl restart docker、进入mongo容器：docker exec -it /bin/bash、虚拟机配置文件bindIp设置为：0.0.0.0（可远程访问）<br>\t\t<br>\t问题：控制台空指针异常、前端显示数据异常——&gt;?<br>\t\t解决：因为部署在虚拟机中，IP地址会改变，yygh_hosp中需要将配置文件更改为正确的IP。<br></code></pre></td></tr></table></figure>\n\n<p>git许久未用，可能之前踩坑埋雷了，用以下方法得以解决：</p>\n<h2 id=\"P80-后台系统-医院管理-需求和nacos启动\"><a href=\"#P80-后台系统-医院管理-需求和nacos启动\" class=\"headerlink\" title=\"P80 后台系统-医院管理-需求和nacos启动\"></a>P80 后台系统-医院管理-需求和nacos启动</h2><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\">nacos访问地址：http://虚拟机IP:8848/nacos<br></code></pre></td></tr></table></figure>\n\n<p>记录一下：nacos（注册中心）可以远程调用两个springBoot项目，为什么要远程调用，因为项目的开发微服务可能部署在不同的服务器之上，因此需要注册中心nacos来管理。</p>\n<blockquote>\n<p>重点记忆，需要和熟练！！！</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Java\"><span class=\"hljs-comment\">//mongodb的条件查询带分页</span><br><br>Controller:<br><br><span class=\"hljs-comment\">//医院列表(条件查询带分页)</span><br> <span class=\"hljs-comment\">//因为本方法是通过路径传递当前页值与记录数值，所以方法体中需要通过@PathVariable注解将值取到；</span><br> <span class=\"hljs-comment\">//又因为本方法设计条件查询，条件已经被封装到Vo类中，所以方法体中需要传入Vo类。</span><br> <span class=\"hljs-meta\">@PostMapping(&quot;list/&#123;page&#125;/&#123;limit&#125;&quot;)</span><br> <span class=\"hljs-keyword\">public</span> Result <span class=\"hljs-title function_\">listHosp</span><span class=\"hljs-params\">(<span class=\"hljs-meta\">@PathVariable</span> Integer page,</span><br><span class=\"hljs-params\">                        <span class=\"hljs-meta\">@PathVariable</span> Integer limit,</span><br><span class=\"hljs-params\">                        HospitalQueryVo hospitalQueryVo)</span> &#123;<br>     Page&lt;Hospital&gt; pageModel = hospitalService.selectHospPage(page,limit,hospitalQueryVo);<br>     <span class=\"hljs-keyword\">return</span> Result.ok(pageModel);<br> &#125;<br><br>service：<br><br><span class=\"hljs-comment\">//条件查询医院列表分页</span><br> Page&lt;Hospital&gt; <span class=\"hljs-title function_\">selectHospPage</span><span class=\"hljs-params\">(Integer page, Integer limit, HospitalQueryVo hospitalQueryVo)</span>;<br><br>service实现类：<br><br><span class=\"hljs-comment\">//医院列表（条件查询分页）  以下三个步骤是查询MOngoDB中的步骤</span><br> <span class=\"hljs-meta\">@Override</span><br> <span class=\"hljs-keyword\">public</span> Page&lt;Hospital&gt; <span class=\"hljs-title function_\">selectHospPage</span><span class=\"hljs-params\">(Integer page, Integer limit, HospitalQueryVo hospitalQueryVo)</span> &#123;<br>     <span class=\"hljs-comment\">//创建pageable对象</span><br>     <span class=\"hljs-type\">Pageable</span> <span class=\"hljs-variable\">pageable</span> <span class=\"hljs-operator\">=</span> PageRequest.of(page-<span class=\"hljs-number\">1</span>,limit);<br>     <span class=\"hljs-comment\">//创建条件查询匹配器</span><br>     <span class=\"hljs-type\">ExampleMatcher</span> <span class=\"hljs-variable\">matcher</span> <span class=\"hljs-operator\">=</span> ExampleMatcher.matching()<br>             .withStringMatcher(ExampleMatcher.StringMatcher.CONTAINING)<br>             .withIgnoreCase(<span class=\"hljs-literal\">true</span>);<br>     <span class=\"hljs-comment\">//对象转换 Vo-&gt;hospital</span><br>     <span class=\"hljs-type\">Hospital</span> <span class=\"hljs-variable\">hospital</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Hospital</span>();<br>     <span class=\"hljs-comment\">//通过bean工具类 直接进行对象转换 Vo-&gt;hospital</span><br>     BeanUtils.copyProperties(hospitalQueryVo,hospital);<br>     <span class=\"hljs-comment\">//创建example实例对象</span><br>     Example&lt;Hospital&gt; example = Example.of(hospital,matcher);<br>     <span class=\"hljs-comment\">//调用方法</span><br>     Page&lt;Hospital&gt; all = hospitalRepository.findAll(example, pageable);<br>     <span class=\"hljs-keyword\">return</span> all;<br> &#125;<br></code></pre></td></tr></table></figure>\n\n\n</blockquote>\n<h2 id=\"P88-医院列表，前端整合\"><a href=\"#P88-医院列表，前端整合\" class=\"headerlink\" title=\"P88 医院列表，前端整合\"></a>P88 医院列表，前端整合</h2><p><strong>踩大坑记录：</strong></p>\n<figure class=\"highlight txt\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs txt\">大坑！项目停滞！<br>\t1、nacos、redis连接不上，拒绝连接的问题<br>    \t解决方案：虚拟机本地redis-&gt;docker安装redis容器，并实现自启动、使用shell远程连接vm更加便捷！<br>    \t\t\t若还是connect refused，就查看防火墙是否开放端口，若是使用的云服务器，则配置安全组开放端口。<br>    2、跨域问题：域名路径、域名端口、提交方式（get、post）都会造成跨域问题！<br>    \t解决方案：idea中分页listHosp方法写成PostMapping，改成GetMapping即可!<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs linux\">Linux相关命令：<br>\t#docker pull之后，使用如下命令进行创建和启动容器，因为懒的配置，所以使用默认配置。<br>\t\tdocker run -itd --name redis -p 6379:6379 redis<br>\t#docker ps：查看运行中的CONTAINER<br>\t#docker进入容器<br>\t\tdocker exec -it mymongo /bin/bash<br>\t#这个是使容器处于docker运行便自启动<br>\t\tdocker update redis --restart=always <br>\t#docker重启命令<br>\t\tsystemctl restart docker<br>\t#容器重启命令<br>\t\tdocker restart redis(自己命的名字或者CONTAINER ID)<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs linux\">firewalled相关命令：<br>\t(1)允许TCP的443端口到internal区域<br>   \t\tfirewall-cmd --zone=internal --add-port=443/tcp<br>   \t\tfirewall-cmd --list-all --zone=internal<br> <br>\t(2)从internal区域将TCP的443端口移除<br>   \t\tfirewall-cmd --zone=internal --remove-port=443/tcp<br> <br>\t(3)允许UDP的2048-2050端口到默认区域<br>   \t\tfirewall-cmd --add-port=2048-2050/udp<br>   \t\tfirewall-cmd --list-all<br>   \t\t<br>   \t\t<br>启动systemctl start firewalld<br>关闭systemctl stop firewalld<br>查看状态systemctl status firewalld<br>查看状态firewall-cmd --state<br>开机启用systemctl enable firewalld<br>开机禁用systemctl disable firewalld<br>查看端口<br>   \t\tfirewall-cmd --zone=public --list-ports<br><br>添加端口<br>      firewall-cmd --add-port=443/tcp --permanent //永久添加443端口,协议为tcp <br>重新加载<br>      firewall-cmd --reload //重新加载<br><br>删除端口<br>      firewall-cmd --zone=public --remove-port=80/tcp --permanent //删除tcp下的80端口<br><br>参数介绍：<br>firewall-cmd：是Linux提供的操作firewall的一个工具(注意没有字母“d”)；<br>--permanent：表示设置为持久；<br>--add-port：标识添加的端口<br>--remove-port:标识删除的端口<br></code></pre></td></tr></table></figure>\n\n<p>下一步p89：实现更新医院上线状态功能。</p>\n<h2 id=\"P89-P90医院的上线以及查看详细信息的功能\"><a href=\"#P89-P90医院的上线以及查看详细信息的功能\" class=\"headerlink\" title=\"P89-P90医院的上线以及查看详细信息的功能\"></a>P89-P90医院的上线以及查看详细信息的功能</h2><p>过程：常规的Controller-&gt;Service-&gt;ServiceImpl</p>\n<p>问题：隐藏路由跳转真实路由：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\">this.$router.push(&#123; path: &#x27;/hospSet/list&#x27; &#125;)<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"P91排班管理\"><a href=\"#P91排班管理\" class=\"headerlink\" title=\"P91排班管理\"></a>P91排班管理</h2><p>这块代码逻辑比较复杂，可以借此锻炼自己的需求分析+逻辑实现。</p>\n<blockquote>\n<p>赶进度，代码逻辑已经实现，从本初开始cv代码！！！P92</p>\n<figure class=\"highlight txt\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs TXT\">以下代码必须整理明白，搞清楚其中的逻辑，需求如何实现！<br></code></pre></td></tr></table></figure>\n\n\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Java\"><span class=\"hljs-comment\">//根据医院编号，查询医院所有科室列表P92</span><br>    <span class=\"hljs-meta\">@Override</span><br>    <span class=\"hljs-keyword\">public</span> List&lt;DepartmentVo&gt; <span class=\"hljs-title function_\">findDeptTree</span><span class=\"hljs-params\">(String hoscode)</span> &#123;<br>        <span class=\"hljs-comment\">//创建list集合，用于最终数据封装</span><br>        List&lt;DepartmentVo&gt; result = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ArrayList</span>&lt;&gt;();<br><br>        <span class=\"hljs-comment\">//根据医院编号，查询医院所有科室信息</span><br>        <span class=\"hljs-type\">Department</span> <span class=\"hljs-variable\">departmentQuery</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Department</span>();<br>        departmentQuery.setHoscode(hoscode);<br>        <span class=\"hljs-type\">Example</span> <span class=\"hljs-variable\">example</span> <span class=\"hljs-operator\">=</span> Example.of(departmentQuery);<br><br>        List&lt;Department&gt; departmentList = departmentRepository.findAll(example);<br>        <span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">         * 从本处开始cv</span><br><span class=\"hljs-comment\">         * P92</span><br><span class=\"hljs-comment\">         */</span><br>        <span class=\"hljs-comment\">//根据大科室编号  bigcode 分组，获取每个大科室里面下级子科室</span><br>        Map&lt;String, List&lt;Department&gt;&gt; deparmentMap =<br>                departmentList.stream().collect(Collectors.groupingBy(Department::getBigcode));<br>        <span class=\"hljs-comment\">//遍历map集合 deparmentMap</span><br>        <span class=\"hljs-keyword\">for</span>(Map.Entry&lt;String,List&lt;Department&gt;&gt; entry : deparmentMap.entrySet()) &#123;<br>            <span class=\"hljs-comment\">//大科室编号</span><br>            <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">bigcode</span> <span class=\"hljs-operator\">=</span> entry.getKey();<br>            <span class=\"hljs-comment\">//大科室编号对应的全局数据</span><br>            List&lt;Department&gt; deparment1List = entry.getValue();<br>            <span class=\"hljs-comment\">//封装大科室</span><br>            <span class=\"hljs-type\">DepartmentVo</span> <span class=\"hljs-variable\">departmentVo1</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">DepartmentVo</span>();<br>            departmentVo1.setDepcode(bigcode);<br>            departmentVo1.setDepname(deparment1List.get(<span class=\"hljs-number\">0</span>).getBigname());<br><br>            <span class=\"hljs-comment\">//封装小科室</span><br>            List&lt;DepartmentVo&gt; children = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ArrayList</span>&lt;&gt;();<br>            <span class=\"hljs-keyword\">for</span>(Department department: deparment1List) &#123;<br>                <span class=\"hljs-type\">DepartmentVo</span> <span class=\"hljs-variable\">departmentVo2</span> <span class=\"hljs-operator\">=</span>  <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">DepartmentVo</span>();<br>                departmentVo2.setDepcode(department.getDepcode());<br>                departmentVo2.setDepname(department.getDepname());<br>                <span class=\"hljs-comment\">//封装到list集合</span><br>                children.add(departmentVo2);<br>            &#125;<br>            <span class=\"hljs-comment\">//把小科室list集合放到大科室children里面</span><br>            departmentVo1.setChildren(children);<br>            <span class=\"hljs-comment\">//放到最终result里面</span><br>            result.add(departmentVo1);<br>        &#125;<br>        <span class=\"hljs-comment\">//返回</span><br>        <span class=\"hljs-keyword\">return</span> result;<br><br>    &#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"P93显示科室的前端整合\"><a href=\"#P93显示科室的前端整合\" class=\"headerlink\" title=\"P93显示科室的前端整合\"></a>P93显示科室的前端整合</h2><p>一些基础的前端隐藏路由-》界面elemenUI+信息显示</p>\n<p>完成科室信息树形结构显示</p>\n<h2 id=\"P94\"><a href=\"#P94\" class=\"headerlink\" title=\"P94\"></a>P94</h2><p>接下来完成每个科室的树形结构排版信息显示。</p>\n<p>涉及到信息的统计、分析与聚合（分组之后的数据）</p>\n<h2 id=\"P95科室排班的分页信息显示\"><a href=\"#P95科室排班的分页信息显示\" class=\"headerlink\" title=\"P95科室排班的分页信息显示\"></a>P95科室排班的分页信息显示</h2><p>注意此处的代码逻辑书写，自己找时间练习</p>\n<h2 id=\"P98\"><a href=\"#P98\" class=\"headerlink\" title=\"P98\"></a>P98</h2><p>遇到了排班详细信息不显示的问题，暂未解决！</p>\n<h2 id=\"简历写法\"><a href=\"#简历写法\" class=\"headerlink\" title=\"简历写法\"></a>简历写法</h2><p>基于Vue+SpringBoot+SpringCloud+MongoDB+RabbitMQ+Gateway实现的问诊预约系统，用户可以进行微信单点登录、预约挂号、支付订单，管理员可以会员管理、订单管理、统计管理以及对数据字典的导入导出</p>\n<p>一个前后端分离的在线预约挂号系统。用户可以预约挂号支付订单，管理员可以管理订单，医院        可以管理数据。使用Spring Cloud微服务框架，数据存储使用MongoDB和MySQL，中间件使用Redis和         RabbitMQ</p>\n<p>同时还整合了定时任务,实现就医提醒功能,</p>\n<p>综合应用了阿里云OSS,短信服务</p>\n<p>以及微信登录、</p>\n<p>微信支付,</p>\n<p>同时增加了微信退款功能</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>欢迎观看我的医院预约挂号平台项目笔记</p>\n<p>axiba,图片在typora软件更新时被意外删除了！！！</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/wl2o2o/blogCdn/img/202306211602425.png\" alt=\"测试一下\"></p>\n</blockquote>\n<h1 id=\"尚医通学习笔记\"><a href=\"#尚医通学习笔记\" class=\"headerlink\" title=\"尚医通学习笔记\"></a>尚医通学习笔记</h1><p><em>前言：按照计划跟做项目，发现仍有一些令人不解的坑，为了解决问题耗费了更多的事件，通过手写和电子笔记以此列举学习成果，以便更好的复习。</em></p>\n<blockquote>\n<h2 id=\"项目介绍篇\"><a href=\"#项目介绍篇\" class=\"headerlink\" title=\"项目介绍篇\"></a>项目介绍篇</h2></blockquote>\n<p>是一个预约挂号，就医问诊，解决患者就医难看病难的平台。</p>\n<p>平台：用户前台（用户预约挂号）、管理员后台、医院管理后台（上传医院信息）</p>\n<blockquote>\n<h2 id=\"技术框架\"><a href=\"#技术框架\" class=\"headerlink\" title=\"技术框架\"></a>技术框架</h2></blockquote>\n<p>微服务：使用<code>Docker</code>作为微服务的部署，启动中间件</p>\n<p>​      <code>Spring Cloud</code> 作为整体框架</p>\n<p>​      <code>nacos</code>注册中心</p>\n<p>​      <code>feign</code>远程调用</p>\n<p>​      <code>Spring Cloud GateWay</code>网关</p>\n<p>数据库：</p>\n<p>​      <code>MongoDB</code>、<code>MySQL</code>作为数据库</p>\n<p>中间件：</p>\n<p>​      <code>Rabbitmq</code>消息队列、<code>redis</code></p>\n<p>功能性类库：</p>\n<p>​      <code>JWT</code>登录验证、<code>EasyExcell</code>数据库导入导出</p>\n<p><img src=\"https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311151644178.png\" alt=\"架构图\"></p>\n<blockquote>\n<h2 id=\"业务流程\"><a href=\"#业务流程\" class=\"headerlink\" title=\"业务流程\"></a>业务流程</h2></blockquote>\n<p>医院通过医院管理后台上传医院的基本信息、预约规则信息、科室信息、排班信息。然后又管理平台进行审核，通过后预约挂号平台进行展示，用户就可以进行根据需求选择挂号，会调用医院挂号接口进行挂号，挂号成功之后，进行支付，取号，同时也可以取消预约，对应的预约状态也会进行实时更新。</p>\n<blockquote>\n<h2 id=\"项目亮点\"><a href=\"#项目亮点\" class=\"headerlink\" title=\"项目亮点\"></a>项目亮点</h2></blockquote>\n<p>真实全面、贴合实际</p>\n<p>什么是服务端渲染？</p>\n<p>服务器先把数据请求好，并且拼接到恩安政的页面当中，再返回给客户端。</p>\n<p>从何处请求数据呢？答：从后端，所以运行项目的时候，要先运行后端，否则会报错！</p>\n<p>数据库是怎么划分的？</p>\n<p>数据库分为MySQL和MongoDB，其中MySQL是关系型数据库，用来存储用户、订单、预约等关系型数据，MongoDB是一个介于关系数据库和非关系数据库之间的产品,是非关系数据库当中功能最丰富,最像关系数据库的,它支持的数据结构非常松散,是类似json的bson格式,因此可以存储比较复杂的数据类型。因为大多数数据操作在内存中进行，所以效率较高。本项目中用来存储一些医院本身的信息和一些不固定的信息，比较灵活!</p>\n<p>后端亮点：</p>\n<blockquote>\n<h2 id=\"项目启动\"><a href=\"#项目启动\" class=\"headerlink\" title=\"项目启动\"></a>项目启动</h2></blockquote>\n<p>后端</p>\n<p>启动服务：</p>\n<p>nacos</p>\n<blockquote>\n<p>可以用来管理微服务，提供服务的注册与发现，作为配置中心管理动态配置</p>\n</blockquote>\n<blockquote>\n<h2 id=\"简历部分\"><a href=\"#简历部分\" class=\"headerlink\" title=\"简历部分\"></a>简历部分</h2></blockquote>\n<p>前端：使用webpack来减小项目体积以及运行速度</p>\n<h2 id=\"P64-redis\"><a href=\"#P64-redis\" class=\"headerlink\" title=\"P64 redis\"></a>P64 redis</h2><p>redis连接不上，贴一篇文章，包含conf文件的配置与redis.cli客户端的运行命令</p>\n<p><a href=\"https://blog.csdn.net/magicproblem/article/details/113238030\">redis虚拟机与本地连接</a></p>\n<p><a href=\"https://www.runoob.com/redis/redis-install.html\">虚拟机运行redis</a></p>\n<h2 id=\"P65-配置nginx\"><a href=\"#P65-配置nginx\" class=\"headerlink\" title=\"P65 配置nginx\"></a>P65 配置nginx</h2><h2 id=\"P66-MongoDB\"><a href=\"#P66-MongoDB\" class=\"headerlink\" title=\"P66 MongoDB\"></a>P66 <code>MongoDB</code></h2><figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs dockerfile\">docker <span class=\"hljs-keyword\">run</span><span class=\"language-bash\"> -d --restart=always -p 27017:27017 --name mymongo -v /data/db:/data/db -d mongo</span><br>docker exec -it mongo bash<br></code></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight txt\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs TXT\">1、 Help查看命令提示 <br>db.help();<br>2、 切换/创建数据库<br>use test<br>如果数据库不存在，则创建数据库，否则切换到指定数据库<br>3、 查询所有数据库 <br>show dbs;<br>4、 删除当前使用数据库 <br>db.dropDatabase();<br>5、 查看当前使用的数据库 <br>db.getName();<br>6、 显示当前db状态 <br>db.stats();<br>7、 当前db版本 <br>db.version();<br>8、 查看当前db的链接机器地址 <br>db.getMongo〇;<br></code></pre></td></tr></table></figure>\n\n<p>通过下图实例，我们也可以更直观的的了解Mongo中的一些概念：</p>\n<h2 id=\"P67-——-P72-SpringBoot整合MongoDB\"><a href=\"#P67-——-P72-SpringBoot整合MongoDB\" class=\"headerlink\" title=\"P67 —— P72 SpringBoot整合MongoDB\"></a>P67 —— P72 SpringBoot整合MongoDB</h2><p>mongo Template CRUD实现方法：</p>\n<figure class=\"highlight txt\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs txt\">常用方法<br>mongoTemplate.findAll(User.class): 查询User文档的全部数据<br>mongoTemplate.findById(&lt;id&gt;, User.class): 查询User文档id为id的数据<br>mongoTemplate.find(query, User.class);: 根据query内的查询条件查询<br>mongoTemplate.upsert(query, update, User.class): 修改<br>mongoTemplate.remove(query, User.class): 删除<br>mongoTemplate.insert(User): 新增<br>Query对象<br>1、创建一个query对象（用来封装所有条件对象)，再创建一个criteria对象（用来构建条件）<br>2、 精准条件：criteria.and(“key”).is(“条件”)<br>模糊条件：criteria.and(“key”).regex(“条件”)<br>3、封装条件：query.addCriteria(criteria)<br>4、大于（创建新的criteria）：Criteria gt = Criteria.where(“key”).gt（“条件”）<br>小于（创建新的criteria）：Criteria lt = Criteria.where(“key”).lt（“条件”）<br>5、Query.addCriteria(new Criteria().andOperator(gt,lt));<br>6、一个query中只能有一个andOperator()。其参数也可以是Criteria数组。<br>7、排序 ：query.with（new Sort(Sort.Direction.ASC, &quot;age&quot;). and(new Sort(Sort.Direction.DESC, &quot;date&quot;)))<br></code></pre></td></tr></table></figure>\n\n<p>模糊查询方法：</p>\n<blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Java\"><span class=\"hljs-comment\">//模糊查询</span><br> <span class=\"hljs-meta\">@Test</span><br> <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">findUsersLikeName</span><span class=\"hljs-params\">()</span> &#123;<br>     <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">name</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;est&quot;</span>;<br>     <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">regex</span> <span class=\"hljs-operator\">=</span> String.format(<span class=\"hljs-string\">&quot;%s%s%s&quot;</span>, <span class=\"hljs-string\">&quot;^.*&quot;</span>, name, <span class=\"hljs-string\">&quot;.*$&quot;</span>);<br>     <span class=\"hljs-comment\">//regex正则表达式</span><br>     <span class=\"hljs-type\">Pattern</span> <span class=\"hljs-variable\">pattern</span> <span class=\"hljs-operator\">=</span> Pattern.compile(regex, Pattern.CASE_INSENSITIVE);<br>     <span class=\"hljs-type\">Query</span> <span class=\"hljs-variable\">query</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Query</span>(Criteria.where(<span class=\"hljs-string\">&quot;name&quot;</span>).regex(pattern));<br>     List&lt;User&gt; userList = mongoTemplate.find(query, User.class);<br>     System.out.println(userList);<br> &#125;<br></code></pre></td></tr></table></figure>\n</blockquote>\n<p>mongo repository CURD 实现方法：</p>\n<p>总结一波，方法调用来说，整体差不多，都挺麻烦，但是不难看出，MongoTemplate更加灵活，MongoRepogistory简单一些。</p>\n<h2 id=\"P73-数据接口-上传医院接口\"><a href=\"#P73-数据接口-上传医院接口\" class=\"headerlink\" title=\"P73 数据接口-上传医院接口\"></a>P73 数据接口-上传医院接口</h2><p>需求和准备——&gt;基础类创建——&gt;初步实现</p>\n<p>涉及：json转换工具(JSONObject:map-&gt;字符串-&gt;对象）</p>\n<h2 id=\"P79-mongodb模糊查询（带分页）\"><a href=\"#P79-mongodb模糊查询（带分页）\" class=\"headerlink\" title=\"P79 mongodb模糊查询（带分页）\"></a>P79 mongodb模糊查询（带分页）</h2><blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Java\"><span class=\"hljs-meta\">@Override</span><br> <span class=\"hljs-keyword\">public</span> Page&lt;Department&gt; <span class=\"hljs-title function_\">findPageDepartment</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> page, <span class=\"hljs-type\">int</span> limit, DepartmentQueryVo departmentQueryVo)</span> &#123;<br>     <span class=\"hljs-comment\">//创建PageABLE对象，设置当前页与记录数</span><br>     <span class=\"hljs-type\">Pageable</span> <span class=\"hljs-variable\">pageable</span> <span class=\"hljs-operator\">=</span> PageRequest.of(page-<span class=\"hljs-number\">1</span>,limit);<br><br>     <span class=\"hljs-comment\">//将QueryVo对象转换成department对象</span><br>     <span class=\"hljs-type\">Department</span> <span class=\"hljs-variable\">department</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Department</span>();<br>     BeanUtils.copyProperties(departmentQueryVo,department);<br>     <span class=\"hljs-comment\">//创建example对象,这是mongodb中模糊查询的规则</span><br>     <span class=\"hljs-type\">ExampleMatcher</span> <span class=\"hljs-variable\">matcher</span> <span class=\"hljs-operator\">=</span> ExampleMatcher.matching()<br>             .withStringMatcher(ExampleMatcher.StringMatcher.CONTAINING)<br>             .withIgnoreCase(<span class=\"hljs-literal\">true</span>);<br>     Example&lt;Department&gt; example = Example.of(department,matcher);<br>     Page&lt;Department&gt; all = departmentRepository.findAll(example, pageable);<br>     <span class=\"hljs-keyword\">return</span> all;<br> &#125;<br></code></pre></td></tr></table></figure>\n</blockquote>\n<p><strong>踩坑记录：</strong></p>\n<figure class=\"highlight txt\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs txt\">访问mongo:<br>\t环境：部署在虚拟机中的docker<br>\t问题：navicat无法远程连接mongo——&gt;?<br>\t\t解决：1、开启管理员root模式、重启docker：systemctl restart docker、进入mongo容器：docker exec -it /bin/bash、虚拟机配置文件bindIp设置为：0.0.0.0（可远程访问）<br>\t\t<br>\t问题：控制台空指针异常、前端显示数据异常——&gt;?<br>\t\t解决：因为部署在虚拟机中，IP地址会改变，yygh_hosp中需要将配置文件更改为正确的IP。<br></code></pre></td></tr></table></figure>\n\n<p>git许久未用，可能之前踩坑埋雷了，用以下方法得以解决：</p>\n<h2 id=\"P80-后台系统-医院管理-需求和nacos启动\"><a href=\"#P80-后台系统-医院管理-需求和nacos启动\" class=\"headerlink\" title=\"P80 后台系统-医院管理-需求和nacos启动\"></a>P80 后台系统-医院管理-需求和nacos启动</h2><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\">nacos访问地址：http://虚拟机IP:8848/nacos<br></code></pre></td></tr></table></figure>\n\n<p>记录一下：nacos（注册中心）可以远程调用两个springBoot项目，为什么要远程调用，因为项目的开发微服务可能部署在不同的服务器之上，因此需要注册中心nacos来管理。</p>\n<blockquote>\n<p>重点记忆，需要和熟练！！！</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Java\"><span class=\"hljs-comment\">//mongodb的条件查询带分页</span><br><br>Controller:<br><br><span class=\"hljs-comment\">//医院列表(条件查询带分页)</span><br> <span class=\"hljs-comment\">//因为本方法是通过路径传递当前页值与记录数值，所以方法体中需要通过@PathVariable注解将值取到；</span><br> <span class=\"hljs-comment\">//又因为本方法设计条件查询，条件已经被封装到Vo类中，所以方法体中需要传入Vo类。</span><br> <span class=\"hljs-meta\">@PostMapping(&quot;list/&#123;page&#125;/&#123;limit&#125;&quot;)</span><br> <span class=\"hljs-keyword\">public</span> Result <span class=\"hljs-title function_\">listHosp</span><span class=\"hljs-params\">(<span class=\"hljs-meta\">@PathVariable</span> Integer page,</span><br><span class=\"hljs-params\">                        <span class=\"hljs-meta\">@PathVariable</span> Integer limit,</span><br><span class=\"hljs-params\">                        HospitalQueryVo hospitalQueryVo)</span> &#123;<br>     Page&lt;Hospital&gt; pageModel = hospitalService.selectHospPage(page,limit,hospitalQueryVo);<br>     <span class=\"hljs-keyword\">return</span> Result.ok(pageModel);<br> &#125;<br><br>service：<br><br><span class=\"hljs-comment\">//条件查询医院列表分页</span><br> Page&lt;Hospital&gt; <span class=\"hljs-title function_\">selectHospPage</span><span class=\"hljs-params\">(Integer page, Integer limit, HospitalQueryVo hospitalQueryVo)</span>;<br><br>service实现类：<br><br><span class=\"hljs-comment\">//医院列表（条件查询分页）  以下三个步骤是查询MOngoDB中的步骤</span><br> <span class=\"hljs-meta\">@Override</span><br> <span class=\"hljs-keyword\">public</span> Page&lt;Hospital&gt; <span class=\"hljs-title function_\">selectHospPage</span><span class=\"hljs-params\">(Integer page, Integer limit, HospitalQueryVo hospitalQueryVo)</span> &#123;<br>     <span class=\"hljs-comment\">//创建pageable对象</span><br>     <span class=\"hljs-type\">Pageable</span> <span class=\"hljs-variable\">pageable</span> <span class=\"hljs-operator\">=</span> PageRequest.of(page-<span class=\"hljs-number\">1</span>,limit);<br>     <span class=\"hljs-comment\">//创建条件查询匹配器</span><br>     <span class=\"hljs-type\">ExampleMatcher</span> <span class=\"hljs-variable\">matcher</span> <span class=\"hljs-operator\">=</span> ExampleMatcher.matching()<br>             .withStringMatcher(ExampleMatcher.StringMatcher.CONTAINING)<br>             .withIgnoreCase(<span class=\"hljs-literal\">true</span>);<br>     <span class=\"hljs-comment\">//对象转换 Vo-&gt;hospital</span><br>     <span class=\"hljs-type\">Hospital</span> <span class=\"hljs-variable\">hospital</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Hospital</span>();<br>     <span class=\"hljs-comment\">//通过bean工具类 直接进行对象转换 Vo-&gt;hospital</span><br>     BeanUtils.copyProperties(hospitalQueryVo,hospital);<br>     <span class=\"hljs-comment\">//创建example实例对象</span><br>     Example&lt;Hospital&gt; example = Example.of(hospital,matcher);<br>     <span class=\"hljs-comment\">//调用方法</span><br>     Page&lt;Hospital&gt; all = hospitalRepository.findAll(example, pageable);<br>     <span class=\"hljs-keyword\">return</span> all;<br> &#125;<br></code></pre></td></tr></table></figure>\n\n\n</blockquote>\n<h2 id=\"P88-医院列表，前端整合\"><a href=\"#P88-医院列表，前端整合\" class=\"headerlink\" title=\"P88 医院列表，前端整合\"></a>P88 医院列表，前端整合</h2><p><strong>踩大坑记录：</strong></p>\n<figure class=\"highlight txt\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs txt\">大坑！项目停滞！<br>\t1、nacos、redis连接不上，拒绝连接的问题<br>    \t解决方案：虚拟机本地redis-&gt;docker安装redis容器，并实现自启动、使用shell远程连接vm更加便捷！<br>    \t\t\t若还是connect refused，就查看防火墙是否开放端口，若是使用的云服务器，则配置安全组开放端口。<br>    2、跨域问题：域名路径、域名端口、提交方式（get、post）都会造成跨域问题！<br>    \t解决方案：idea中分页listHosp方法写成PostMapping，改成GetMapping即可!<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs linux\">Linux相关命令：<br>\t#docker pull之后，使用如下命令进行创建和启动容器，因为懒的配置，所以使用默认配置。<br>\t\tdocker run -itd --name redis -p 6379:6379 redis<br>\t#docker ps：查看运行中的CONTAINER<br>\t#docker进入容器<br>\t\tdocker exec -it mymongo /bin/bash<br>\t#这个是使容器处于docker运行便自启动<br>\t\tdocker update redis --restart=always <br>\t#docker重启命令<br>\t\tsystemctl restart docker<br>\t#容器重启命令<br>\t\tdocker restart redis(自己命的名字或者CONTAINER ID)<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs linux\">firewalled相关命令：<br>\t(1)允许TCP的443端口到internal区域<br>   \t\tfirewall-cmd --zone=internal --add-port=443/tcp<br>   \t\tfirewall-cmd --list-all --zone=internal<br> <br>\t(2)从internal区域将TCP的443端口移除<br>   \t\tfirewall-cmd --zone=internal --remove-port=443/tcp<br> <br>\t(3)允许UDP的2048-2050端口到默认区域<br>   \t\tfirewall-cmd --add-port=2048-2050/udp<br>   \t\tfirewall-cmd --list-all<br>   \t\t<br>   \t\t<br>启动systemctl start firewalld<br>关闭systemctl stop firewalld<br>查看状态systemctl status firewalld<br>查看状态firewall-cmd --state<br>开机启用systemctl enable firewalld<br>开机禁用systemctl disable firewalld<br>查看端口<br>   \t\tfirewall-cmd --zone=public --list-ports<br><br>添加端口<br>      firewall-cmd --add-port=443/tcp --permanent //永久添加443端口,协议为tcp <br>重新加载<br>      firewall-cmd --reload //重新加载<br><br>删除端口<br>      firewall-cmd --zone=public --remove-port=80/tcp --permanent //删除tcp下的80端口<br><br>参数介绍：<br>firewall-cmd：是Linux提供的操作firewall的一个工具(注意没有字母“d”)；<br>--permanent：表示设置为持久；<br>--add-port：标识添加的端口<br>--remove-port:标识删除的端口<br></code></pre></td></tr></table></figure>\n\n<p>下一步p89：实现更新医院上线状态功能。</p>\n<h2 id=\"P89-P90医院的上线以及查看详细信息的功能\"><a href=\"#P89-P90医院的上线以及查看详细信息的功能\" class=\"headerlink\" title=\"P89-P90医院的上线以及查看详细信息的功能\"></a>P89-P90医院的上线以及查看详细信息的功能</h2><p>过程：常规的Controller-&gt;Service-&gt;ServiceImpl</p>\n<p>问题：隐藏路由跳转真实路由：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\">this.$router.push(&#123; path: &#x27;/hospSet/list&#x27; &#125;)<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"P91排班管理\"><a href=\"#P91排班管理\" class=\"headerlink\" title=\"P91排班管理\"></a>P91排班管理</h2><p>这块代码逻辑比较复杂，可以借此锻炼自己的需求分析+逻辑实现。</p>\n<blockquote>\n<p>赶进度，代码逻辑已经实现，从本初开始cv代码！！！P92</p>\n<figure class=\"highlight txt\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs TXT\">以下代码必须整理明白，搞清楚其中的逻辑，需求如何实现！<br></code></pre></td></tr></table></figure>\n\n\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Java\"><span class=\"hljs-comment\">//根据医院编号，查询医院所有科室列表P92</span><br>    <span class=\"hljs-meta\">@Override</span><br>    <span class=\"hljs-keyword\">public</span> List&lt;DepartmentVo&gt; <span class=\"hljs-title function_\">findDeptTree</span><span class=\"hljs-params\">(String hoscode)</span> &#123;<br>        <span class=\"hljs-comment\">//创建list集合，用于最终数据封装</span><br>        List&lt;DepartmentVo&gt; result = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ArrayList</span>&lt;&gt;();<br><br>        <span class=\"hljs-comment\">//根据医院编号，查询医院所有科室信息</span><br>        <span class=\"hljs-type\">Department</span> <span class=\"hljs-variable\">departmentQuery</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Department</span>();<br>        departmentQuery.setHoscode(hoscode);<br>        <span class=\"hljs-type\">Example</span> <span class=\"hljs-variable\">example</span> <span class=\"hljs-operator\">=</span> Example.of(departmentQuery);<br><br>        List&lt;Department&gt; departmentList = departmentRepository.findAll(example);<br>        <span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">         * 从本处开始cv</span><br><span class=\"hljs-comment\">         * P92</span><br><span class=\"hljs-comment\">         */</span><br>        <span class=\"hljs-comment\">//根据大科室编号  bigcode 分组，获取每个大科室里面下级子科室</span><br>        Map&lt;String, List&lt;Department&gt;&gt; deparmentMap =<br>                departmentList.stream().collect(Collectors.groupingBy(Department::getBigcode));<br>        <span class=\"hljs-comment\">//遍历map集合 deparmentMap</span><br>        <span class=\"hljs-keyword\">for</span>(Map.Entry&lt;String,List&lt;Department&gt;&gt; entry : deparmentMap.entrySet()) &#123;<br>            <span class=\"hljs-comment\">//大科室编号</span><br>            <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">bigcode</span> <span class=\"hljs-operator\">=</span> entry.getKey();<br>            <span class=\"hljs-comment\">//大科室编号对应的全局数据</span><br>            List&lt;Department&gt; deparment1List = entry.getValue();<br>            <span class=\"hljs-comment\">//封装大科室</span><br>            <span class=\"hljs-type\">DepartmentVo</span> <span class=\"hljs-variable\">departmentVo1</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">DepartmentVo</span>();<br>            departmentVo1.setDepcode(bigcode);<br>            departmentVo1.setDepname(deparment1List.get(<span class=\"hljs-number\">0</span>).getBigname());<br><br>            <span class=\"hljs-comment\">//封装小科室</span><br>            List&lt;DepartmentVo&gt; children = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ArrayList</span>&lt;&gt;();<br>            <span class=\"hljs-keyword\">for</span>(Department department: deparment1List) &#123;<br>                <span class=\"hljs-type\">DepartmentVo</span> <span class=\"hljs-variable\">departmentVo2</span> <span class=\"hljs-operator\">=</span>  <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">DepartmentVo</span>();<br>                departmentVo2.setDepcode(department.getDepcode());<br>                departmentVo2.setDepname(department.getDepname());<br>                <span class=\"hljs-comment\">//封装到list集合</span><br>                children.add(departmentVo2);<br>            &#125;<br>            <span class=\"hljs-comment\">//把小科室list集合放到大科室children里面</span><br>            departmentVo1.setChildren(children);<br>            <span class=\"hljs-comment\">//放到最终result里面</span><br>            result.add(departmentVo1);<br>        &#125;<br>        <span class=\"hljs-comment\">//返回</span><br>        <span class=\"hljs-keyword\">return</span> result;<br><br>    &#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"P93显示科室的前端整合\"><a href=\"#P93显示科室的前端整合\" class=\"headerlink\" title=\"P93显示科室的前端整合\"></a>P93显示科室的前端整合</h2><p>一些基础的前端隐藏路由-》界面elemenUI+信息显示</p>\n<p>完成科室信息树形结构显示</p>\n<h2 id=\"P94\"><a href=\"#P94\" class=\"headerlink\" title=\"P94\"></a>P94</h2><p>接下来完成每个科室的树形结构排版信息显示。</p>\n<p>涉及到信息的统计、分析与聚合（分组之后的数据）</p>\n<h2 id=\"P95科室排班的分页信息显示\"><a href=\"#P95科室排班的分页信息显示\" class=\"headerlink\" title=\"P95科室排班的分页信息显示\"></a>P95科室排班的分页信息显示</h2><p>注意此处的代码逻辑书写，自己找时间练习</p>\n<h2 id=\"P98\"><a href=\"#P98\" class=\"headerlink\" title=\"P98\"></a>P98</h2><p>遇到了排班详细信息不显示的问题，暂未解决！</p>\n<h2 id=\"简历写法\"><a href=\"#简历写法\" class=\"headerlink\" title=\"简历写法\"></a>简历写法</h2><p>基于Vue+SpringBoot+SpringCloud+MongoDB+RabbitMQ+Gateway实现的问诊预约系统，用户可以进行微信单点登录、预约挂号、支付订单，管理员可以会员管理、订单管理、统计管理以及对数据字典的导入导出</p>\n<p>一个前后端分离的在线预约挂号系统。用户可以预约挂号支付订单，管理员可以管理订单，医院        可以管理数据。使用Spring Cloud微服务框架，数据存储使用MongoDB和MySQL，中间件使用Redis和         RabbitMQ</p>\n<p>同时还整合了定时任务,实现就医提醒功能,</p>\n<p>综合应用了阿里云OSS,短信服务</p>\n<p>以及微信登录、</p>\n<p>微信支付,</p>\n<p>同时增加了微信退款功能</p>\n"},{"title":"Tip 常用小技巧","description":"IDEA快捷键技巧分享！","abbrlink":55031,"date":"2022-09-07T00:58:32.000Z","_content":"\n# 小技巧分享\n\n* `IDEA`\n  * tip小技巧：复制一段代码，选择包直接粘贴，会自动创建一个类！方便的很！\n  * ![IDEA快捷键：ctrl + alt + t](https://cdn.jsdelivr.net/gh/wl2o2o/blogCdn/img/202308031918523.png)\n\n","source":"_posts/tip.md","raw":"---\ntitle: Tip 常用小技巧\ncategories:\n  - Java notes\ntags:\n  - 快捷键\n  - 技巧\ndescription: IDEA快捷键技巧分享！\nabbrlink: 55031\ndate: 2022-09-07 08:58:32\n---\n\n# 小技巧分享\n\n* `IDEA`\n  * tip小技巧：复制一段代码，选择包直接粘贴，会自动创建一个类！方便的很！\n  * ![IDEA快捷键：ctrl + alt + t](https://cdn.jsdelivr.net/gh/wl2o2o/blogCdn/img/202308031918523.png)\n\n","slug":"tip","published":1,"updated":"2023-11-25T11:41:06.082Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clpkiczjk003efkfog5r9dqtf","content":"<h1 id=\"小技巧分享\"><a href=\"#小技巧分享\" class=\"headerlink\" title=\"小技巧分享\"></a>小技巧分享</h1><ul>\n<li><code>IDEA</code><ul>\n<li>tip小技巧：复制一段代码，选择包直接粘贴，会自动创建一个类！方便的很！</li>\n<li><img src=\"https://cdn.jsdelivr.net/gh/wl2o2o/blogCdn/img/202308031918523.png\" alt=\"IDEA快捷键：ctrl + alt + t\"></li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"小技巧分享\"><a href=\"#小技巧分享\" class=\"headerlink\" title=\"小技巧分享\"></a>小技巧分享</h1><ul>\n<li><code>IDEA</code><ul>\n<li>tip小技巧：复制一段代码，选择包直接粘贴，会自动创建一个类！方便的很！</li>\n<li><img src=\"https://cdn.jsdelivr.net/gh/wl2o2o/blogCdn/img/202308031918523.png\" alt=\"IDEA快捷键：ctrl + alt + t\"></li>\n</ul>\n</li>\n</ul>\n"},{"title":"MySQL事务","index_img":"https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311151627638.png","abbrlink":23119,"date":"2023-02-23T12:52:27.000Z","_content":"## 事务\n\n> #### 一、什么是事务\n\n1.事务定义\n事务:事务是一个最小的不可在分的工作单元;通常一个事务对应一个完整的业务(例如银行账户转账业务，该业务是一个最小的T元)\n一个完整的业务需要批量的DML(inset、update、 delete)语句共同联合完成\n事务只和DML语句有关，或者说DML语句才有事务。这个和业务逻辑有关，业务逻辑不同，DML语句的个数不同0\n2.事务是什么?\n多个操作同时进行.那么同时成功，那么同时失败。这就是事务\n事务有四个特性:一致性、持久性、原子性、隔离性\n比如有一个订单业务\n\t1.订单表当中添加一条记录 \n\t2.商品数量数据更新(减少)\n\t3.当多个任务同时进行操作的时候，这些任务只能同时成功，或者同时失败.\n4.事务的四大性质\n\t1.原子性:事务是一个不可分割的工作单位，要么同时成功，要么同时失败。例:当两个人发起转账业务时，如果A转账发起，而B因为一些原因不能成功接受，事务最终将不会提交，则A和B的请求最终不会成功。\n\t2.持久性:一旦事务提交，他对数据库的改变就是永久的。注:只要提交了事务，将会对数据库的数据进行永久性刷新。\n\t3.隔离性:多个事务之间相互隔离的，互不干扰\n\t4.一致性: 事务执行接收之后，数据库完整性不被破坏\n\t注意:只有当前三条性质都满足了，才能保证事务的一致性\n\n​\t在mysql中，事务是一种机制、一个操作序列，是访问和更新数据库的程序执行单元。事务中包含一个或多个数据库操作命令，会把所有的命令作为一个整体一起向系统提交或撤销操作请求，即这一组数据库命令要么都执行，要么都不执行。例如：银行取钱\n注意mysql的事务是自动提交的\n​\toracle的关系数据库范例的实现通过第一个DML语句隐式开始执行某个事务，事务一直延续到COMMIT或ROLLBACK语句执行为止SAVEPOINT命令不是SQL标准的一部分，实际上是编程人员反向撤销一些语句的简便方式。不需要单独考虑它，它不终止事务。\n​\t**所谓的“自动提交：**\n​\t在结束对提交处理的讨论之前，我们有必要阐明一下经常被提及的“自动提交”(有时候也被称为隐式提交)。您经常会听到这样的说法:Orade在某些情况下可以进行“自动提交”。执行DDL语句就是其中一种情况，退出某个用户进程(SQLPus)则是另一种情况。自动提交”纯子虚写有。执行某条DDL语句时，实现这个DDL命令的源代妈包含了一个完全正规的COMMIT令。但是，退出用户进程时的情况是怎样呢?如果在WINDOWS终端上使用SQL*Plus并执行一条DML语句，然后再执行“退出\"命令，就会提交事务。这是因为SQL*Plus中的“退出“命令嵌入了一条COMMIT语句。但是，单击SQL*Plus商口的右上角会出现怎样的情况呢? 此时，关团SQLPlus爱，如果再次登录SQLPlus，您会发现已回滚了事务，这是因为为Microsoft Windows编写SQL*Plus的编程人员在关团SQL*Plus窗口的代中嵌入了一条ROLLBACK语自。SQL*PLUS在其他平台上的行为可能有所不同，唯一的确认方法是测试。因此，以不同方式退出。\n\n#### 二、转账案例\n\n##### \t2.1  创建user表\n\n##### \t2.2 转账操作\n\ncreate table account\n(\n    id int auto_increment primary key,\n    name varchar(20),\n    money int\n);\n用于恢复数据\n\tUPDATE account SET money = 2000 where   name = '张三'  or NAME ='李四'\n\n1、将张三账户余额-1000\n\tUPDATE account SET  money = money-1000 WHERE NAME = '张三';\n\tSELECT * from account WHERE NAME = '张三'\n\n2、将李四账户余额+1000\n\tUPDATE account SET  money = money+2000 WHERE NAME = '李四';\n\tSELECT * from account WHERE NAME = '李四'\n\n#### 三、事务的操作\n\n##### \t3.1查看事务提交方式\n\n  SELECT @@autocommit \n\n  set @@autocommit = 0\n\n  表示手动提交，即使用 MySQL 客户端执行 SQL 命令后必须使用commit命令执行事务，否则所执行的 SQL 命令无效，如果想撤销事务则使用 rollback 命令。1 表示自动提交，即在 MySQL 客户端不在需要手动执行 commit 命令。\n\n##### \t3.2提交事务\n\n  COMMIT \n\n​\t1.COMMIT命令\n许多人(甚至某些经验丰富的DBA) 在提交处理这个环节上都会出现不完全或者完全错误的理解oracle体系结构的情况。执行COMMIT命令时发生的所有物理操作时LGWR进程将日志缓中区的内容刷新到磁盘。DBWn进程完全没有执行任何操作。对于oracle数据库来说，这是一个非常重要的性能特性。\n​\t注意:执行COMMIT命令时，DBWn进程不会进行任何操作作。为了使某个事务持久，所需的全部工作是将组成这个事务的变更写入磁盘(不必使实际表数据存在于磁盘的数据文件上)。如果变更以多重重做日志文件的形式存在于磁盘上，那么在出现使数据库受损的事件时，通过从数据库受损前所做的备份中还原数据文件以及应用重做日志文件中的变更，就可以重新实例化事务。\n\n##### \t3.3回滚事务\n\n  ROLLBACK\n  事务回滚就是如果没有操作成功，所有的sql就会倒序重新把数据恢复到原来得样子，这样保证数据不会出错\n  2.ROLLBACK命令\n在事务处理过程中，Oracle会保存事务处理之前数据的映像。在事务处理过程中，会将这个映像提供给查询数据的其他会话。如果出现错误，或者会话故意请求回滚，那么它也可以用来自动回滚事务。回滚之前数据的状态是，数据已经改变，但反转这些变更所需的信息是可用的。为了满足隔离性原则，会将这些信息提供给其他所有会话。回滚会恢复数据改变之前的映像，从而抛弃所有变更;事务插入的所有行都会删除，事务删除的所有行都会重新插入表中，已经更新的行会回到原始状态。其他会话根本不知道发生了什么，它们绝对看不到这些变更，处理事务的会话现在会将数据看做事务开始之前的数据。\n\n##### \t3.4开启事务\n\n  START TRANSACTION 或  BEGIN\n\n  oracle:\n  事务的开始和结束\n会话开始事务的时间从它发出DML命令时开始。事务持续执行任何数量的DML命令，知道会话发出COMMIT或者ROLLBACK语向为止。只有提交的变更才会变的永久，才会对其他会话可见。不可能嵌套事务，SQL标准不允许用户启动一个事务，然后在终止第一个事务之前再启动另一个事务。使用PL/SQL (Oracle专有的第三代语言)可以这样做，但它不是行业标准的SQL。显示事务控制语句有COMMIT、ROLLBACK SAVEPOINT。除了用户发出的COMMIT或者ROLLBACK之外，还有一些情况会隐式终止事务:\n1.发出DDL或DCL语句\n2.退出用户工具 (SQL*PLUS、SQL Developer或者其他工具)\n3.客户会话终止\n4.系统崩溃\n\t如果用户发出DDL (CREATE、ALTER或DROP) 或者DCL (GRANT或REVOKE) 命令，就会提交正在处理的事务(如果有的话):会让它变的永久，并且对其他所有用户都可见。这是因为DDL和DCL命令本身都是是事务。因为在SQL中不可能损套事务，所以如果用户已经在运行事务，就会提交用户已经运行的语句，以及组成DDL和DCL的语句。如果用户通过发出DML命今来启动事务，然后在没有显示发出COMMIT或者ROLLBACK命令的情况下退出正在使用的工具，事务就会终上-但是使用COMMIT终上还是ROLLBACK终止，则完全取决于如何写工具。许多工具有不同的行为，这取决于退出工具的方式。不营在哪种情况下，都应该是受控制的退出，因此编程人员应该发出COMMIT或ROLLBACK金令。但他们必须进行选择如果客户的会话因为某种原因而失败，那么数据库总是会回滚事务，这种失败可能有多种原因，用户进程终止或者在提作系统级别被终止，到数据库服务器的网络连接中断，或者运行该客户工具的计算机崩溃。在所有这些情况中，都没有依次发出COMMIT或ROLLBACK语句，现在轮到数据库来检测发生的情况。行为是终止会话，回滚活动的事务。如果失败发生在服务器端，其行为也是这样。如果数据库服务器因为某种原因崩溃，那么当它下一次启动时，就会回滚来自所有会话的所有之前正在处理的事务。\n\n\n\n\n\n#### 四、事务的四大特征\n\n1、原子性（Atomicity）\n　　原子性是指事务包含的所有\n　　操作要么全部成功，要么全部失败回滚，因此事务的操作如果成功就必须要完全应用到数据库，如果操作失败则不能对数据库有任何影响。\n\n2、一致性（Consistency）\n　　一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态。\n　　拿转账来说，假设用户A和用户B两者的钱加起来一共是5000，那么不管A和B之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是5000，这就是事务的一致性。\n\n3、隔离性（Isolation）\n　　隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。\n　　即要达到这么一种效果：对于任意两个并发的事务T1和T2，在事务T1看来，T2要么在T1开始之前就已经结束，要么在T1结束之后才开始，这样每个事务都感觉不到有其他事务在并发地执行。\n\n4、持久性（Durability）\n　　持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。\n　　例如我们在使用JDBC操作数据库时，在提交事务方法后，提示用户事务操作完成，当我们程序执行完成直到看到提示后，就可以认定事务以及正确提交，即使这时候数据库出现了问题，也必须要将我们的事务完全执行完成，否则就会造成我们看到提示事务处理完毕，但是数据库因为故障而没有执行事务的重大错误\n\n#### 五、事务隔离基别\n\n```\n读未提交(Read Uncommitted)：\n\t 允许脏读取，但不允许更新丢失。如果一个事务已经开始写数据，则另外一个事务则不允许同时进行写操作，但允许其他事务读此行数据。该隔离级别可以通过“排他写锁”实现。\n\n\t举个例子:小何其实是准备给小美转520元的，但是按岔了成250于是250块钱被转给了小美，当然这个时候小何还没有提交事务。这个时候小美一下看到了账户上面的250，十分的生气，啪的一下子就小何拉黑了。手机扔到了一边。小何在转账的时候也发现了转成了250，连忙回滚事务，将转账金额改成了520后才提交了事务。然后小何开心的拿起手机，发信息给小美，却发现被拉黑了。。。而这个时候，其实小何账上少了520，小美多了520，但是小美手机扔到了一遍，还以为小何给她转了250.而这种错误就叫做脏读(读了未提交事务的数据)。\n\n读提交(Read Committed)：\n 允许不可重复读取，但不允许脏读取。这可以通过“瞬间共享读锁”和“排他写锁”实现。读取数据的事务允许其他事务继续访问该行数据，但是未提交的写事务将会禁止其他事务访问该行。\n\n\t举个例子：小美和小何拿着520的账户去逛街买衣服，小美选了一件500的衣服，支付前，小美的账户上面查看有520元，于是小美升出二维码支付，但是这个时候，学校在绑定的小美的账户上面扣除了300的书本费，并且提交了事务，小美的账户被更新成为了220元，小美这时被告知账上没有足够的前支付。但是小美很纳闷，我刚不是有钱的吗？这就是不可重复读（同一个事务两次读取的内容不一样，读取无法重复）\n\n可重复读取（Repeatable Read）：\n\t禁止不可重复读取和脏读取，但是有时可能出现幻读数据。这可以通过**“共享读锁”和“排他写锁”实现。读取数据的事务将会禁止写事务**（但允许读事务），写事务则禁止任何其他事务。\n\n可重复读比较简单，就是在小美结账时不让其他的UPDATE操作动她的账户，当学校的扣费事务到来时拒绝掉，这个时候你就可以重复读取到相同的账户金额，并且付款成功。但是这种情况可能出现幻读的情况，其实本质原因是因为可重复读只能解决其他的UPDATE事务，对于INSERT操作无能为力。那幻读又是什么？\n\n举个例子：小美被告知账上没钱时，比较惊讶，于是她来到了学校教务处查询自己账户记录。(小美事务开启)小红看到自己的账户上面时被扣了300元书本费，还剩下220元，于是小红提出让老师打印自己的账户记录回家报销，但是在这个时候，好男人小何怕小美伤心又给小美转账了300元，并且完成了事务，提交了小何事务。于是在打印的账户记录出现了300的入账记录，小美十分开心，对着小何说：\"我是不是出现了幻觉，刚刚不是只有220元的吗？怎么多了300元？\"，小何此时深藏功与名，而这个就叫做幻读。\n\n序列化(Serializable)：\n提供严格的事务隔离。它要求事务序列化执行，事务只能一个接着一个地执行，不能并发执行。仅仅通过“行级锁”是无法实现事务序列化的，必须通过其他机制保证新插入的数据不会被刚执行查询操作的事务访问到。\n\n序列化就是按部就班的执行，可以避免脏读、不可重复读与幻读，但是可想而知，这种方式会降低数据库的效率。\n\n在序列化（Serializable）事务隔离级别下，所有的事务都会按照顺序逐个执行，而且每个事务都会读取到其他事务提交前的数据快照，因此在事务 T1 执行期间，如果事务 T2 插入了新的数据并提交了事务，那么这些新的数据对事务 T1 是不可见的，因此事务 T1 不会查询到事务 T2 插入的数据。\n\n具体来说，如果事务 T1 先查询了数据表信息，然后事务 T2 插入了一条新的数据并提交了事务，那么在事务 T1 执行期间，这些新的数据对事务 T1 是不可见的，即使在事务 T2 提交事务之后，事务 T1 也不会查询到这些新的数据。\n\n需要注意的是，在序列化隔离级别下，事务会被强制串行执行，即使有多个事务并发执行，也会保证它们能够按照顺序执行，从而避免了幻读、不可重复读等问题。因此，在这个隔离级别下，事务 T1 和事务 T2 插入或更新的数据虽然可能存在冲突，但是它们不会相互影响，也不会互相读取对方提交的数据。\n\n```\n\n#### 六、查看事务隔离级别\n\n```\n#查看事务隔离级别\n\t5.7之前\nSELECT @@transaction_isolation\n\n#设置事务隔离级别\nset session transaction isolation level   填写以下几个事务  ;\n读未提交(Read Uncommitted)：\n读提交(Read Committed)：\n可重复读取（Repeatable Read）：\n序列化(Serializable)：\n\n\nsession：当前会话，也就是当前连接。\n\nglobal：全局，不包含当前连接，之后新获取的连接都会生效。\n```\n\n![1685861365330](https://cdn.jsdelivr.net/gh/wl2o2o/blogCdn/img/202306051100898.png)\n\n```\n设置事务隔离级别为   read uncommitted    并开启事务    演示脏读数据\n要一起打开两个第一个设置事务隔离级别和开启事务start transaction\n第二个也要开启事务start transaction，这几个级别都这样\n然后开启下一个级别的情况下两边都要进行提交commit；\n```\n\n![1685861569904](https://cdn.jsdelivr.net/gh/wl2o2o/blogCdn/img/202306051100900.png)![1685861842042](https://cdn.jsdelivr.net/gh/wl2o2o/blogCdn/img/202306051100902.png)\n\n```\n设置事务隔离级别为   read committed    并开启事务    演示脏读数据\n```\n\n![1685862300090](https://cdn.jsdelivr.net/gh/wl2o2o/blogCdn/img/202306051100903.png)\n\n![1685862320137](https://cdn.jsdelivr.net/gh/wl2o2o/blogCdn/img/202306051100904.png)\n\n```\n设置事务隔离级别为   read committed    并开启事务    演示不可重复读数据\n```\n\n![1685865723425](https://cdn.jsdelivr.net/gh/wl2o2o/blogCdn/img/202306051100905.png)![1685865734957](https://cdn.jsdelivr.net/gh/wl2o2o/blogCdn/img/202306051100906.png)\n\n```\n什么是幻读\n```\n\n![1685866356451](https://cdn.jsdelivr.net/gh/wl2o2o/blogCdn/img/202306051100907.png)![1685866370205](https://cdn.jsdelivr.net/gh/wl2o2o/blogCdn/img/202306051100908.png)\n\n```\n解决幻读问题\n设置事务隔离级别为  serializable 可以规避全部的并发事务问题但性能最差\n注意：事务级别越高，数据越安全，但性能越差，反之亦然\n```\n\n![1685866707034](https://cdn.jsdelivr.net/gh/wl2o2o/blogCdn/img/202306051100909.png)\n\n![1685866720304](https://cdn.jsdelivr.net/gh/wl2o2o/blogCdn/img/202306051100910.png)\n\n","source":"_posts/transaction.md","raw":"---\ntitle: MySQL事务\nindex_img: https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311151627638.png\ncategories:\n  - Database\ntags:\n  - MySQL\nabbrlink: 23119\ndate: 2023-02-23 20:52:27\n---\n## 事务\n\n> #### 一、什么是事务\n\n1.事务定义\n事务:事务是一个最小的不可在分的工作单元;通常一个事务对应一个完整的业务(例如银行账户转账业务，该业务是一个最小的T元)\n一个完整的业务需要批量的DML(inset、update、 delete)语句共同联合完成\n事务只和DML语句有关，或者说DML语句才有事务。这个和业务逻辑有关，业务逻辑不同，DML语句的个数不同0\n2.事务是什么?\n多个操作同时进行.那么同时成功，那么同时失败。这就是事务\n事务有四个特性:一致性、持久性、原子性、隔离性\n比如有一个订单业务\n\t1.订单表当中添加一条记录 \n\t2.商品数量数据更新(减少)\n\t3.当多个任务同时进行操作的时候，这些任务只能同时成功，或者同时失败.\n4.事务的四大性质\n\t1.原子性:事务是一个不可分割的工作单位，要么同时成功，要么同时失败。例:当两个人发起转账业务时，如果A转账发起，而B因为一些原因不能成功接受，事务最终将不会提交，则A和B的请求最终不会成功。\n\t2.持久性:一旦事务提交，他对数据库的改变就是永久的。注:只要提交了事务，将会对数据库的数据进行永久性刷新。\n\t3.隔离性:多个事务之间相互隔离的，互不干扰\n\t4.一致性: 事务执行接收之后，数据库完整性不被破坏\n\t注意:只有当前三条性质都满足了，才能保证事务的一致性\n\n​\t在mysql中，事务是一种机制、一个操作序列，是访问和更新数据库的程序执行单元。事务中包含一个或多个数据库操作命令，会把所有的命令作为一个整体一起向系统提交或撤销操作请求，即这一组数据库命令要么都执行，要么都不执行。例如：银行取钱\n注意mysql的事务是自动提交的\n​\toracle的关系数据库范例的实现通过第一个DML语句隐式开始执行某个事务，事务一直延续到COMMIT或ROLLBACK语句执行为止SAVEPOINT命令不是SQL标准的一部分，实际上是编程人员反向撤销一些语句的简便方式。不需要单独考虑它，它不终止事务。\n​\t**所谓的“自动提交：**\n​\t在结束对提交处理的讨论之前，我们有必要阐明一下经常被提及的“自动提交”(有时候也被称为隐式提交)。您经常会听到这样的说法:Orade在某些情况下可以进行“自动提交”。执行DDL语句就是其中一种情况，退出某个用户进程(SQLPus)则是另一种情况。自动提交”纯子虚写有。执行某条DDL语句时，实现这个DDL命令的源代妈包含了一个完全正规的COMMIT令。但是，退出用户进程时的情况是怎样呢?如果在WINDOWS终端上使用SQL*Plus并执行一条DML语句，然后再执行“退出\"命令，就会提交事务。这是因为SQL*Plus中的“退出“命令嵌入了一条COMMIT语句。但是，单击SQL*Plus商口的右上角会出现怎样的情况呢? 此时，关团SQLPlus爱，如果再次登录SQLPlus，您会发现已回滚了事务，这是因为为Microsoft Windows编写SQL*Plus的编程人员在关团SQL*Plus窗口的代中嵌入了一条ROLLBACK语自。SQL*PLUS在其他平台上的行为可能有所不同，唯一的确认方法是测试。因此，以不同方式退出。\n\n#### 二、转账案例\n\n##### \t2.1  创建user表\n\n##### \t2.2 转账操作\n\ncreate table account\n(\n    id int auto_increment primary key,\n    name varchar(20),\n    money int\n);\n用于恢复数据\n\tUPDATE account SET money = 2000 where   name = '张三'  or NAME ='李四'\n\n1、将张三账户余额-1000\n\tUPDATE account SET  money = money-1000 WHERE NAME = '张三';\n\tSELECT * from account WHERE NAME = '张三'\n\n2、将李四账户余额+1000\n\tUPDATE account SET  money = money+2000 WHERE NAME = '李四';\n\tSELECT * from account WHERE NAME = '李四'\n\n#### 三、事务的操作\n\n##### \t3.1查看事务提交方式\n\n  SELECT @@autocommit \n\n  set @@autocommit = 0\n\n  表示手动提交，即使用 MySQL 客户端执行 SQL 命令后必须使用commit命令执行事务，否则所执行的 SQL 命令无效，如果想撤销事务则使用 rollback 命令。1 表示自动提交，即在 MySQL 客户端不在需要手动执行 commit 命令。\n\n##### \t3.2提交事务\n\n  COMMIT \n\n​\t1.COMMIT命令\n许多人(甚至某些经验丰富的DBA) 在提交处理这个环节上都会出现不完全或者完全错误的理解oracle体系结构的情况。执行COMMIT命令时发生的所有物理操作时LGWR进程将日志缓中区的内容刷新到磁盘。DBWn进程完全没有执行任何操作。对于oracle数据库来说，这是一个非常重要的性能特性。\n​\t注意:执行COMMIT命令时，DBWn进程不会进行任何操作作。为了使某个事务持久，所需的全部工作是将组成这个事务的变更写入磁盘(不必使实际表数据存在于磁盘的数据文件上)。如果变更以多重重做日志文件的形式存在于磁盘上，那么在出现使数据库受损的事件时，通过从数据库受损前所做的备份中还原数据文件以及应用重做日志文件中的变更，就可以重新实例化事务。\n\n##### \t3.3回滚事务\n\n  ROLLBACK\n  事务回滚就是如果没有操作成功，所有的sql就会倒序重新把数据恢复到原来得样子，这样保证数据不会出错\n  2.ROLLBACK命令\n在事务处理过程中，Oracle会保存事务处理之前数据的映像。在事务处理过程中，会将这个映像提供给查询数据的其他会话。如果出现错误，或者会话故意请求回滚，那么它也可以用来自动回滚事务。回滚之前数据的状态是，数据已经改变，但反转这些变更所需的信息是可用的。为了满足隔离性原则，会将这些信息提供给其他所有会话。回滚会恢复数据改变之前的映像，从而抛弃所有变更;事务插入的所有行都会删除，事务删除的所有行都会重新插入表中，已经更新的行会回到原始状态。其他会话根本不知道发生了什么，它们绝对看不到这些变更，处理事务的会话现在会将数据看做事务开始之前的数据。\n\n##### \t3.4开启事务\n\n  START TRANSACTION 或  BEGIN\n\n  oracle:\n  事务的开始和结束\n会话开始事务的时间从它发出DML命令时开始。事务持续执行任何数量的DML命令，知道会话发出COMMIT或者ROLLBACK语向为止。只有提交的变更才会变的永久，才会对其他会话可见。不可能嵌套事务，SQL标准不允许用户启动一个事务，然后在终止第一个事务之前再启动另一个事务。使用PL/SQL (Oracle专有的第三代语言)可以这样做，但它不是行业标准的SQL。显示事务控制语句有COMMIT、ROLLBACK SAVEPOINT。除了用户发出的COMMIT或者ROLLBACK之外，还有一些情况会隐式终止事务:\n1.发出DDL或DCL语句\n2.退出用户工具 (SQL*PLUS、SQL Developer或者其他工具)\n3.客户会话终止\n4.系统崩溃\n\t如果用户发出DDL (CREATE、ALTER或DROP) 或者DCL (GRANT或REVOKE) 命令，就会提交正在处理的事务(如果有的话):会让它变的永久，并且对其他所有用户都可见。这是因为DDL和DCL命令本身都是是事务。因为在SQL中不可能损套事务，所以如果用户已经在运行事务，就会提交用户已经运行的语句，以及组成DDL和DCL的语句。如果用户通过发出DML命今来启动事务，然后在没有显示发出COMMIT或者ROLLBACK命令的情况下退出正在使用的工具，事务就会终上-但是使用COMMIT终上还是ROLLBACK终止，则完全取决于如何写工具。许多工具有不同的行为，这取决于退出工具的方式。不营在哪种情况下，都应该是受控制的退出，因此编程人员应该发出COMMIT或ROLLBACK金令。但他们必须进行选择如果客户的会话因为某种原因而失败，那么数据库总是会回滚事务，这种失败可能有多种原因，用户进程终止或者在提作系统级别被终止，到数据库服务器的网络连接中断，或者运行该客户工具的计算机崩溃。在所有这些情况中，都没有依次发出COMMIT或ROLLBACK语句，现在轮到数据库来检测发生的情况。行为是终止会话，回滚活动的事务。如果失败发生在服务器端，其行为也是这样。如果数据库服务器因为某种原因崩溃，那么当它下一次启动时，就会回滚来自所有会话的所有之前正在处理的事务。\n\n\n\n\n\n#### 四、事务的四大特征\n\n1、原子性（Atomicity）\n　　原子性是指事务包含的所有\n　　操作要么全部成功，要么全部失败回滚，因此事务的操作如果成功就必须要完全应用到数据库，如果操作失败则不能对数据库有任何影响。\n\n2、一致性（Consistency）\n　　一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态。\n　　拿转账来说，假设用户A和用户B两者的钱加起来一共是5000，那么不管A和B之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是5000，这就是事务的一致性。\n\n3、隔离性（Isolation）\n　　隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。\n　　即要达到这么一种效果：对于任意两个并发的事务T1和T2，在事务T1看来，T2要么在T1开始之前就已经结束，要么在T1结束之后才开始，这样每个事务都感觉不到有其他事务在并发地执行。\n\n4、持久性（Durability）\n　　持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。\n　　例如我们在使用JDBC操作数据库时，在提交事务方法后，提示用户事务操作完成，当我们程序执行完成直到看到提示后，就可以认定事务以及正确提交，即使这时候数据库出现了问题，也必须要将我们的事务完全执行完成，否则就会造成我们看到提示事务处理完毕，但是数据库因为故障而没有执行事务的重大错误\n\n#### 五、事务隔离基别\n\n```\n读未提交(Read Uncommitted)：\n\t 允许脏读取，但不允许更新丢失。如果一个事务已经开始写数据，则另外一个事务则不允许同时进行写操作，但允许其他事务读此行数据。该隔离级别可以通过“排他写锁”实现。\n\n\t举个例子:小何其实是准备给小美转520元的，但是按岔了成250于是250块钱被转给了小美，当然这个时候小何还没有提交事务。这个时候小美一下看到了账户上面的250，十分的生气，啪的一下子就小何拉黑了。手机扔到了一边。小何在转账的时候也发现了转成了250，连忙回滚事务，将转账金额改成了520后才提交了事务。然后小何开心的拿起手机，发信息给小美，却发现被拉黑了。。。而这个时候，其实小何账上少了520，小美多了520，但是小美手机扔到了一遍，还以为小何给她转了250.而这种错误就叫做脏读(读了未提交事务的数据)。\n\n读提交(Read Committed)：\n 允许不可重复读取，但不允许脏读取。这可以通过“瞬间共享读锁”和“排他写锁”实现。读取数据的事务允许其他事务继续访问该行数据，但是未提交的写事务将会禁止其他事务访问该行。\n\n\t举个例子：小美和小何拿着520的账户去逛街买衣服，小美选了一件500的衣服，支付前，小美的账户上面查看有520元，于是小美升出二维码支付，但是这个时候，学校在绑定的小美的账户上面扣除了300的书本费，并且提交了事务，小美的账户被更新成为了220元，小美这时被告知账上没有足够的前支付。但是小美很纳闷，我刚不是有钱的吗？这就是不可重复读（同一个事务两次读取的内容不一样，读取无法重复）\n\n可重复读取（Repeatable Read）：\n\t禁止不可重复读取和脏读取，但是有时可能出现幻读数据。这可以通过**“共享读锁”和“排他写锁”实现。读取数据的事务将会禁止写事务**（但允许读事务），写事务则禁止任何其他事务。\n\n可重复读比较简单，就是在小美结账时不让其他的UPDATE操作动她的账户，当学校的扣费事务到来时拒绝掉，这个时候你就可以重复读取到相同的账户金额，并且付款成功。但是这种情况可能出现幻读的情况，其实本质原因是因为可重复读只能解决其他的UPDATE事务，对于INSERT操作无能为力。那幻读又是什么？\n\n举个例子：小美被告知账上没钱时，比较惊讶，于是她来到了学校教务处查询自己账户记录。(小美事务开启)小红看到自己的账户上面时被扣了300元书本费，还剩下220元，于是小红提出让老师打印自己的账户记录回家报销，但是在这个时候，好男人小何怕小美伤心又给小美转账了300元，并且完成了事务，提交了小何事务。于是在打印的账户记录出现了300的入账记录，小美十分开心，对着小何说：\"我是不是出现了幻觉，刚刚不是只有220元的吗？怎么多了300元？\"，小何此时深藏功与名，而这个就叫做幻读。\n\n序列化(Serializable)：\n提供严格的事务隔离。它要求事务序列化执行，事务只能一个接着一个地执行，不能并发执行。仅仅通过“行级锁”是无法实现事务序列化的，必须通过其他机制保证新插入的数据不会被刚执行查询操作的事务访问到。\n\n序列化就是按部就班的执行，可以避免脏读、不可重复读与幻读，但是可想而知，这种方式会降低数据库的效率。\n\n在序列化（Serializable）事务隔离级别下，所有的事务都会按照顺序逐个执行，而且每个事务都会读取到其他事务提交前的数据快照，因此在事务 T1 执行期间，如果事务 T2 插入了新的数据并提交了事务，那么这些新的数据对事务 T1 是不可见的，因此事务 T1 不会查询到事务 T2 插入的数据。\n\n具体来说，如果事务 T1 先查询了数据表信息，然后事务 T2 插入了一条新的数据并提交了事务，那么在事务 T1 执行期间，这些新的数据对事务 T1 是不可见的，即使在事务 T2 提交事务之后，事务 T1 也不会查询到这些新的数据。\n\n需要注意的是，在序列化隔离级别下，事务会被强制串行执行，即使有多个事务并发执行，也会保证它们能够按照顺序执行，从而避免了幻读、不可重复读等问题。因此，在这个隔离级别下，事务 T1 和事务 T2 插入或更新的数据虽然可能存在冲突，但是它们不会相互影响，也不会互相读取对方提交的数据。\n\n```\n\n#### 六、查看事务隔离级别\n\n```\n#查看事务隔离级别\n\t5.7之前\nSELECT @@transaction_isolation\n\n#设置事务隔离级别\nset session transaction isolation level   填写以下几个事务  ;\n读未提交(Read Uncommitted)：\n读提交(Read Committed)：\n可重复读取（Repeatable Read）：\n序列化(Serializable)：\n\n\nsession：当前会话，也就是当前连接。\n\nglobal：全局，不包含当前连接，之后新获取的连接都会生效。\n```\n\n![1685861365330](https://cdn.jsdelivr.net/gh/wl2o2o/blogCdn/img/202306051100898.png)\n\n```\n设置事务隔离级别为   read uncommitted    并开启事务    演示脏读数据\n要一起打开两个第一个设置事务隔离级别和开启事务start transaction\n第二个也要开启事务start transaction，这几个级别都这样\n然后开启下一个级别的情况下两边都要进行提交commit；\n```\n\n![1685861569904](https://cdn.jsdelivr.net/gh/wl2o2o/blogCdn/img/202306051100900.png)![1685861842042](https://cdn.jsdelivr.net/gh/wl2o2o/blogCdn/img/202306051100902.png)\n\n```\n设置事务隔离级别为   read committed    并开启事务    演示脏读数据\n```\n\n![1685862300090](https://cdn.jsdelivr.net/gh/wl2o2o/blogCdn/img/202306051100903.png)\n\n![1685862320137](https://cdn.jsdelivr.net/gh/wl2o2o/blogCdn/img/202306051100904.png)\n\n```\n设置事务隔离级别为   read committed    并开启事务    演示不可重复读数据\n```\n\n![1685865723425](https://cdn.jsdelivr.net/gh/wl2o2o/blogCdn/img/202306051100905.png)![1685865734957](https://cdn.jsdelivr.net/gh/wl2o2o/blogCdn/img/202306051100906.png)\n\n```\n什么是幻读\n```\n\n![1685866356451](https://cdn.jsdelivr.net/gh/wl2o2o/blogCdn/img/202306051100907.png)![1685866370205](https://cdn.jsdelivr.net/gh/wl2o2o/blogCdn/img/202306051100908.png)\n\n```\n解决幻读问题\n设置事务隔离级别为  serializable 可以规避全部的并发事务问题但性能最差\n注意：事务级别越高，数据越安全，但性能越差，反之亦然\n```\n\n![1685866707034](https://cdn.jsdelivr.net/gh/wl2o2o/blogCdn/img/202306051100909.png)\n\n![1685866720304](https://cdn.jsdelivr.net/gh/wl2o2o/blogCdn/img/202306051100910.png)\n\n","slug":"transaction","published":1,"updated":"2023-11-15T08:45:51.992Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clpkiczjl003hfkfo8j7ia6vr","content":"<h2 id=\"事务\"><a href=\"#事务\" class=\"headerlink\" title=\"事务\"></a>事务</h2><blockquote>\n<h4 id=\"一、什么是事务\"><a href=\"#一、什么是事务\" class=\"headerlink\" title=\"一、什么是事务\"></a>一、什么是事务</h4></blockquote>\n<p>1.事务定义<br>事务:事务是一个最小的不可在分的工作单元;通常一个事务对应一个完整的业务(例如银行账户转账业务，该业务是一个最小的T元)<br>一个完整的业务需要批量的DML(inset、update、 delete)语句共同联合完成<br>事务只和DML语句有关，或者说DML语句才有事务。这个和业务逻辑有关，业务逻辑不同，DML语句的个数不同0<br>2.事务是什么?<br>多个操作同时进行.那么同时成功，那么同时失败。这就是事务<br>事务有四个特性:一致性、持久性、原子性、隔离性<br>比如有一个订单业务<br>    1.订单表当中添加一条记录<br>    2.商品数量数据更新(减少)<br>    3.当多个任务同时进行操作的时候，这些任务只能同时成功，或者同时失败.<br>4.事务的四大性质<br>    1.原子性:事务是一个不可分割的工作单位，要么同时成功，要么同时失败。例:当两个人发起转账业务时，如果A转账发起，而B因为一些原因不能成功接受，事务最终将不会提交，则A和B的请求最终不会成功。<br>    2.持久性:一旦事务提交，他对数据库的改变就是永久的。注:只要提交了事务，将会对数据库的数据进行永久性刷新。<br>    3.隔离性:多个事务之间相互隔离的，互不干扰<br>    4.一致性: 事务执行接收之后，数据库完整性不被破坏<br>    注意:只有当前三条性质都满足了，才能保证事务的一致性</p>\n<p>​    在mysql中，事务是一种机制、一个操作序列，是访问和更新数据库的程序执行单元。事务中包含一个或多个数据库操作命令，会把所有的命令作为一个整体一起向系统提交或撤销操作请求，即这一组数据库命令要么都执行，要么都不执行。例如：银行取钱<br>注意mysql的事务是自动提交的<br>​    oracle的关系数据库范例的实现通过第一个DML语句隐式开始执行某个事务，事务一直延续到COMMIT或ROLLBACK语句执行为止SAVEPOINT命令不是SQL标准的一部分，实际上是编程人员反向撤销一些语句的简便方式。不需要单独考虑它，它不终止事务。<br>​    <strong>所谓的“自动提交：</strong><br>​    在结束对提交处理的讨论之前，我们有必要阐明一下经常被提及的“自动提交”(有时候也被称为隐式提交)。您经常会听到这样的说法:Orade在某些情况下可以进行“自动提交”。执行DDL语句就是其中一种情况，退出某个用户进程(SQLPus)则是另一种情况。自动提交”纯子虚写有。执行某条DDL语句时，实现这个DDL命令的源代妈包含了一个完全正规的COMMIT令。但是，退出用户进程时的情况是怎样呢?如果在WINDOWS终端上使用SQL<em>Plus并执行一条DML语句，然后再执行“退出”命令，就会提交事务。这是因为SQL</em>Plus中的“退出“命令嵌入了一条COMMIT语句。但是，单击SQL<em>Plus商口的右上角会出现怎样的情况呢? 此时，关团SQLPlus爱，如果再次登录SQLPlus，您会发现已回滚了事务，这是因为为Microsoft Windows编写SQL</em>Plus的编程人员在关团SQL<em>Plus窗口的代中嵌入了一条ROLLBACK语自。SQL</em>PLUS在其他平台上的行为可能有所不同，唯一的确认方法是测试。因此，以不同方式退出。</p>\n<h4 id=\"二、转账案例\"><a href=\"#二、转账案例\" class=\"headerlink\" title=\"二、转账案例\"></a>二、转账案例</h4><h5 id=\"2-1-创建user表\"><a href=\"#2-1-创建user表\" class=\"headerlink\" title=\"2.1  创建user表\"></a>2.1  创建user表</h5><h5 id=\"2-2-转账操作\"><a href=\"#2-2-转账操作\" class=\"headerlink\" title=\"2.2 转账操作\"></a>2.2 转账操作</h5><p>create table account<br>(<br>    id int auto_increment primary key,<br>    name varchar(20),<br>    money int<br>);<br>用于恢复数据<br>    UPDATE account SET money = 2000 where   name = ‘张三’  or NAME =’李四’</p>\n<p>1、将张三账户余额-1000<br>    UPDATE account SET  money = money-1000 WHERE NAME = ‘张三’;<br>    SELECT * from account WHERE NAME = ‘张三’</p>\n<p>2、将李四账户余额+1000<br>    UPDATE account SET  money = money+2000 WHERE NAME = ‘李四’;<br>    SELECT * from account WHERE NAME = ‘李四’</p>\n<h4 id=\"三、事务的操作\"><a href=\"#三、事务的操作\" class=\"headerlink\" title=\"三、事务的操作\"></a>三、事务的操作</h4><h5 id=\"3-1查看事务提交方式\"><a href=\"#3-1查看事务提交方式\" class=\"headerlink\" title=\"3.1查看事务提交方式\"></a>3.1查看事务提交方式</h5><p>  SELECT @@autocommit </p>\n<p>  set @@autocommit = 0</p>\n<p>  表示手动提交，即使用 MySQL 客户端执行 SQL 命令后必须使用commit命令执行事务，否则所执行的 SQL 命令无效，如果想撤销事务则使用 rollback 命令。1 表示自动提交，即在 MySQL 客户端不在需要手动执行 commit 命令。</p>\n<h5 id=\"3-2提交事务\"><a href=\"#3-2提交事务\" class=\"headerlink\" title=\"3.2提交事务\"></a>3.2提交事务</h5><p>  COMMIT </p>\n<p>​    1.COMMIT命令<br>许多人(甚至某些经验丰富的DBA) 在提交处理这个环节上都会出现不完全或者完全错误的理解oracle体系结构的情况。执行COMMIT命令时发生的所有物理操作时LGWR进程将日志缓中区的内容刷新到磁盘。DBWn进程完全没有执行任何操作。对于oracle数据库来说，这是一个非常重要的性能特性。<br>​    注意:执行COMMIT命令时，DBWn进程不会进行任何操作作。为了使某个事务持久，所需的全部工作是将组成这个事务的变更写入磁盘(不必使实际表数据存在于磁盘的数据文件上)。如果变更以多重重做日志文件的形式存在于磁盘上，那么在出现使数据库受损的事件时，通过从数据库受损前所做的备份中还原数据文件以及应用重做日志文件中的变更，就可以重新实例化事务。</p>\n<h5 id=\"3-3回滚事务\"><a href=\"#3-3回滚事务\" class=\"headerlink\" title=\"3.3回滚事务\"></a>3.3回滚事务</h5><p>  ROLLBACK<br>  事务回滚就是如果没有操作成功，所有的sql就会倒序重新把数据恢复到原来得样子，这样保证数据不会出错<br>  2.ROLLBACK命令<br>在事务处理过程中，Oracle会保存事务处理之前数据的映像。在事务处理过程中，会将这个映像提供给查询数据的其他会话。如果出现错误，或者会话故意请求回滚，那么它也可以用来自动回滚事务。回滚之前数据的状态是，数据已经改变，但反转这些变更所需的信息是可用的。为了满足隔离性原则，会将这些信息提供给其他所有会话。回滚会恢复数据改变之前的映像，从而抛弃所有变更;事务插入的所有行都会删除，事务删除的所有行都会重新插入表中，已经更新的行会回到原始状态。其他会话根本不知道发生了什么，它们绝对看不到这些变更，处理事务的会话现在会将数据看做事务开始之前的数据。</p>\n<h5 id=\"3-4开启事务\"><a href=\"#3-4开启事务\" class=\"headerlink\" title=\"3.4开启事务\"></a>3.4开启事务</h5><p>  START TRANSACTION 或  BEGIN</p>\n<p>  oracle:<br>  事务的开始和结束<br>会话开始事务的时间从它发出DML命令时开始。事务持续执行任何数量的DML命令，知道会话发出COMMIT或者ROLLBACK语向为止。只有提交的变更才会变的永久，才会对其他会话可见。不可能嵌套事务，SQL标准不允许用户启动一个事务，然后在终止第一个事务之前再启动另一个事务。使用PL/SQL (Oracle专有的第三代语言)可以这样做，但它不是行业标准的SQL。显示事务控制语句有COMMIT、ROLLBACK SAVEPOINT。除了用户发出的COMMIT或者ROLLBACK之外，还有一些情况会隐式终止事务:<br>1.发出DDL或DCL语句<br>2.退出用户工具 (SQL*PLUS、SQL Developer或者其他工具)<br>3.客户会话终止<br>4.系统崩溃<br>    如果用户发出DDL (CREATE、ALTER或DROP) 或者DCL (GRANT或REVOKE) 命令，就会提交正在处理的事务(如果有的话):会让它变的永久，并且对其他所有用户都可见。这是因为DDL和DCL命令本身都是是事务。因为在SQL中不可能损套事务，所以如果用户已经在运行事务，就会提交用户已经运行的语句，以及组成DDL和DCL的语句。如果用户通过发出DML命今来启动事务，然后在没有显示发出COMMIT或者ROLLBACK命令的情况下退出正在使用的工具，事务就会终上-但是使用COMMIT终上还是ROLLBACK终止，则完全取决于如何写工具。许多工具有不同的行为，这取决于退出工具的方式。不营在哪种情况下，都应该是受控制的退出，因此编程人员应该发出COMMIT或ROLLBACK金令。但他们必须进行选择如果客户的会话因为某种原因而失败，那么数据库总是会回滚事务，这种失败可能有多种原因，用户进程终止或者在提作系统级别被终止，到数据库服务器的网络连接中断，或者运行该客户工具的计算机崩溃。在所有这些情况中，都没有依次发出COMMIT或ROLLBACK语句，现在轮到数据库来检测发生的情况。行为是终止会话，回滚活动的事务。如果失败发生在服务器端，其行为也是这样。如果数据库服务器因为某种原因崩溃，那么当它下一次启动时，就会回滚来自所有会话的所有之前正在处理的事务。</p>\n<h4 id=\"四、事务的四大特征\"><a href=\"#四、事务的四大特征\" class=\"headerlink\" title=\"四、事务的四大特征\"></a>四、事务的四大特征</h4><p>1、原子性（Atomicity）<br>　　原子性是指事务包含的所有<br>　　操作要么全部成功，要么全部失败回滚，因此事务的操作如果成功就必须要完全应用到数据库，如果操作失败则不能对数据库有任何影响。</p>\n<p>2、一致性（Consistency）<br>　　一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态。<br>　　拿转账来说，假设用户A和用户B两者的钱加起来一共是5000，那么不管A和B之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是5000，这就是事务的一致性。</p>\n<p>3、隔离性（Isolation）<br>　　隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。<br>　　即要达到这么一种效果：对于任意两个并发的事务T1和T2，在事务T1看来，T2要么在T1开始之前就已经结束，要么在T1结束之后才开始，这样每个事务都感觉不到有其他事务在并发地执行。</p>\n<p>4、持久性（Durability）<br>　　持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。<br>　　例如我们在使用JDBC操作数据库时，在提交事务方法后，提示用户事务操作完成，当我们程序执行完成直到看到提示后，就可以认定事务以及正确提交，即使这时候数据库出现了问题，也必须要将我们的事务完全执行完成，否则就会造成我们看到提示事务处理完毕，但是数据库因为故障而没有执行事务的重大错误</p>\n<h4 id=\"五、事务隔离基别\"><a href=\"#五、事务隔离基别\" class=\"headerlink\" title=\"五、事务隔离基别\"></a>五、事务隔离基别</h4><figure class=\"highlight mipsasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mipsasm\">读未提交(Read Uncommitted)：<br>\t 允许脏读取，但不允许更新丢失。如果一个事务已经开始写数据，则另外一个事务则不允许同时进行写操作，但允许其他事务读此行数据。该隔离级别可以通过“排他写锁”实现。<br><br>\t举个例子:小何其实是准备给小美转<span class=\"hljs-number\">520</span>元的，但是按岔了成<span class=\"hljs-number\">250</span>于是<span class=\"hljs-number\">250</span>块钱被转给了小美，当然这个时候小何还没有提交事务。这个时候小美一下看到了账户上面的<span class=\"hljs-number\">250</span>，十分的生气，啪的一下子就小何拉黑了。手机扔到了一边。小何在转账的时候也发现了转成了<span class=\"hljs-number\">250</span>，连忙回滚事务，将转账金额改成了<span class=\"hljs-number\">520</span>后才提交了事务。然后小何开心的拿起手机，发信息给小美，却发现被拉黑了。。。而这个时候，其实小何账上少了<span class=\"hljs-number\">520</span>，小美多了<span class=\"hljs-number\">520</span>，但是小美手机扔到了一遍，还以为小何给她转了<span class=\"hljs-number\">250</span>.而这种错误就叫做脏读(读了未提交事务的数据)。<br><br>读提交(Read Committed)：<br> 允许不可重复读取，但不允许脏读取。这可以通过“瞬间共享读锁”和“排他写锁”实现。读取数据的事务允许其他事务继续访问该行数据，但是未提交的写事务将会禁止其他事务访问该行。<br><br>\t举个例子：小美和小何拿着<span class=\"hljs-number\">520</span>的账户去逛街买衣服，小美选了一件<span class=\"hljs-number\">500</span>的衣服，支付前，小美的账户上面查看有<span class=\"hljs-number\">520</span>元，于是小美升出二维码支付，但是这个时候，学校在绑定的小美的账户上面扣除了<span class=\"hljs-number\">300</span>的书本费，并且提交了事务，小美的账户被更新成为了<span class=\"hljs-number\">220</span>元，小美这时被告知账上没有足够的前支付。但是小美很纳闷，我刚不是有钱的吗？这就是不可重复读（同一个事务两次读取的内容不一样，读取无法重复）<br><br>可重复读取（Repeatable Read）：<br>\t禁止不可重复读取和脏读取，但是有时可能出现幻读数据。这可以通过**“共享读锁”和“排他写锁”实现。读取数据的事务将会禁止写事务**（但允许读事务），写事务则禁止任何其他事务。<br><br>可重复读比较简单，就是在小美结账时不让其他的UPDATE操作动她的账户，当学校的扣费事务到来时拒绝掉，这个时候你就可以重复读取到相同的账户金额，并且付款成功。但是这种情况可能出现幻读的情况，其实本质原因是因为可重复读只能解决其他的UPDATE事务，对于<span class=\"hljs-keyword\">INSERT操作无能为力。那幻读又是什么？</span><br><span class=\"hljs-keyword\"></span><br>举个例子：小美被告知账上没钱时，比较惊讶，于是她来到了学校教务处查询自己账户记录。(小美事务开启)小红看到自己的账户上面时被扣了<span class=\"hljs-number\">300</span>元书本费，还剩下<span class=\"hljs-number\">220</span>元，于是小红提出让老师打印自己的账户记录回家报销，但是在这个时候，好男人小何怕小美伤心又给小美转账了<span class=\"hljs-number\">300</span>元，并且完成了事务，提交了小何事务。于是在打印的账户记录出现了<span class=\"hljs-number\">300</span>的入账记录，小美十分开心，对着小何说：<span class=\"hljs-string\">&quot;我是不是出现了幻觉，刚刚不是只有220元的吗？怎么多了300元？&quot;</span>，小何此时深藏功与名，而这个就叫做幻读。<br><br>序列化(Serializable)：<br>提供严格的事务隔离。它要求事务序列化执行，事务只能一个接着一个地执行，不能并发执行。仅仅通过“行级锁”是无法实现事务序列化的，必须通过其他机制保证新插入的数据不会被刚执行查询操作的事务访问到。<br><br>序列化就是按部就班的执行，可以避免脏读、不可重复读与幻读，但是可想而知，这种方式会降低数据库的效率。<br><br>在序列化（Serializable）事务隔离级别下，所有的事务都会按照顺序逐个执行，而且每个事务都会读取到其他事务提交前的数据快照，因此在事务 <span class=\"hljs-built_in\">T1</span> 执行期间，如果事务 <span class=\"hljs-built_in\">T2</span> 插入了新的数据并提交了事务，那么这些新的数据对事务 <span class=\"hljs-built_in\">T1</span> 是不可见的，因此事务 <span class=\"hljs-built_in\">T1</span> 不会查询到事务 <span class=\"hljs-built_in\">T2</span> 插入的数据。<br><br>具体来说，如果事务 <span class=\"hljs-built_in\">T1</span> 先查询了数据表信息，然后事务 <span class=\"hljs-built_in\">T2</span> 插入了一条新的数据并提交了事务，那么在事务 <span class=\"hljs-built_in\">T1</span> 执行期间，这些新的数据对事务 <span class=\"hljs-built_in\">T1</span> 是不可见的，即使在事务 <span class=\"hljs-built_in\">T2</span> 提交事务之后，事务 <span class=\"hljs-built_in\">T1</span> 也不会查询到这些新的数据。<br><br>需要注意的是，在序列化隔离级别下，事务会被强制串行执行，即使有多个事务并发执行，也会保证它们能够按照顺序执行，从而避免了幻读、不可重复读等问题。因此，在这个隔离级别下，事务 <span class=\"hljs-built_in\">T1</span> 和事务 <span class=\"hljs-built_in\">T2</span> 插入或更新的数据虽然可能存在冲突，但是它们不会相互影响，也不会互相读取对方提交的数据。<br><br></code></pre></td></tr></table></figure>\n\n<h4 id=\"六、查看事务隔离级别\"><a href=\"#六、查看事务隔离级别\" class=\"headerlink\" title=\"六、查看事务隔离级别\"></a>六、查看事务隔离级别</h4><figure class=\"highlight pgsql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs pgsql\">#查看事务隔离级别<br>\t<span class=\"hljs-number\">5.7</span>之前<br><span class=\"hljs-keyword\">SELECT</span> @@transaction_isolation<br><br>#设置事务隔离级别<br><span class=\"hljs-keyword\">set</span> <span class=\"hljs-keyword\">session</span> <span class=\"hljs-keyword\">transaction</span> <span class=\"hljs-keyword\">isolation</span> <span class=\"hljs-keyword\">level</span>   填写以下几个事务  ;<br>读未提交(<span class=\"hljs-keyword\">Read</span> <span class=\"hljs-keyword\">Uncommitted</span>)：<br>读提交(<span class=\"hljs-keyword\">Read</span> <span class=\"hljs-keyword\">Committed</span>)：<br>可重复读取（<span class=\"hljs-keyword\">Repeatable</span> <span class=\"hljs-keyword\">Read</span>）：<br>序列化(<span class=\"hljs-keyword\">Serializable</span>)：<br><br><br><span class=\"hljs-keyword\">session</span>：当前会话，也就是当前连接。<br><br><span class=\"hljs-keyword\">global</span>：全局，不包含当前连接，之后新获取的连接都会生效。<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://cdn.jsdelivr.net/gh/wl2o2o/blogCdn/img/202306051100898.png\" alt=\"1685861365330\"></p>\n<figure class=\"highlight pgsql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs pgsql\">设置事务隔离级别为   <span class=\"hljs-keyword\">read</span> <span class=\"hljs-keyword\">uncommitted</span>    并开启事务    演示脏读数据<br>要一起打开两个第一个设置事务隔离级别和开启事务<span class=\"hljs-keyword\">start</span> <span class=\"hljs-keyword\">transaction</span><br>第二个也要开启事务<span class=\"hljs-keyword\">start</span> <span class=\"hljs-keyword\">transaction</span>，这几个级别都这样<br>然后开启下一个级别的情况下两边都要进行提交<span class=\"hljs-keyword\">commit</span>；<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://cdn.jsdelivr.net/gh/wl2o2o/blogCdn/img/202306051100900.png\" alt=\"1685861569904\"><img src=\"https://cdn.jsdelivr.net/gh/wl2o2o/blogCdn/img/202306051100902.png\" alt=\"1685861842042\"></p>\n<figure class=\"highlight pgsql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs pgsql\">设置事务隔离级别为   <span class=\"hljs-keyword\">read</span> <span class=\"hljs-keyword\">committed</span>    并开启事务    演示脏读数据<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://cdn.jsdelivr.net/gh/wl2o2o/blogCdn/img/202306051100903.png\" alt=\"1685862300090\"></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/wl2o2o/blogCdn/img/202306051100904.png\" alt=\"1685862320137\"></p>\n<figure class=\"highlight pgsql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs pgsql\">设置事务隔离级别为   <span class=\"hljs-keyword\">read</span> <span class=\"hljs-keyword\">committed</span>    并开启事务    演示不可重复读数据<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://cdn.jsdelivr.net/gh/wl2o2o/blogCdn/img/202306051100905.png\" alt=\"1685865723425\"><img src=\"https://cdn.jsdelivr.net/gh/wl2o2o/blogCdn/img/202306051100906.png\" alt=\"1685865734957\"></p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs\">什么是幻读<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://cdn.jsdelivr.net/gh/wl2o2o/blogCdn/img/202306051100907.png\" alt=\"1685866356451\"><img src=\"https://cdn.jsdelivr.net/gh/wl2o2o/blogCdn/img/202306051100908.png\" alt=\"1685866370205\"></p>\n<figure class=\"highlight pgsql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs pgsql\">解决幻读问题<br>设置事务隔离级别为  <span class=\"hljs-keyword\">serializable</span> 可以规避全部的并发事务问题但性能最差<br>注意：事务级别越高，数据越安全，但性能越差，反之亦然<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://cdn.jsdelivr.net/gh/wl2o2o/blogCdn/img/202306051100909.png\" alt=\"1685866707034\"></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/wl2o2o/blogCdn/img/202306051100910.png\" alt=\"1685866720304\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"事务\"><a href=\"#事务\" class=\"headerlink\" title=\"事务\"></a>事务</h2><blockquote>\n<h4 id=\"一、什么是事务\"><a href=\"#一、什么是事务\" class=\"headerlink\" title=\"一、什么是事务\"></a>一、什么是事务</h4></blockquote>\n<p>1.事务定义<br>事务:事务是一个最小的不可在分的工作单元;通常一个事务对应一个完整的业务(例如银行账户转账业务，该业务是一个最小的T元)<br>一个完整的业务需要批量的DML(inset、update、 delete)语句共同联合完成<br>事务只和DML语句有关，或者说DML语句才有事务。这个和业务逻辑有关，业务逻辑不同，DML语句的个数不同0<br>2.事务是什么?<br>多个操作同时进行.那么同时成功，那么同时失败。这就是事务<br>事务有四个特性:一致性、持久性、原子性、隔离性<br>比如有一个订单业务<br>    1.订单表当中添加一条记录<br>    2.商品数量数据更新(减少)<br>    3.当多个任务同时进行操作的时候，这些任务只能同时成功，或者同时失败.<br>4.事务的四大性质<br>    1.原子性:事务是一个不可分割的工作单位，要么同时成功，要么同时失败。例:当两个人发起转账业务时，如果A转账发起，而B因为一些原因不能成功接受，事务最终将不会提交，则A和B的请求最终不会成功。<br>    2.持久性:一旦事务提交，他对数据库的改变就是永久的。注:只要提交了事务，将会对数据库的数据进行永久性刷新。<br>    3.隔离性:多个事务之间相互隔离的，互不干扰<br>    4.一致性: 事务执行接收之后，数据库完整性不被破坏<br>    注意:只有当前三条性质都满足了，才能保证事务的一致性</p>\n<p>​    在mysql中，事务是一种机制、一个操作序列，是访问和更新数据库的程序执行单元。事务中包含一个或多个数据库操作命令，会把所有的命令作为一个整体一起向系统提交或撤销操作请求，即这一组数据库命令要么都执行，要么都不执行。例如：银行取钱<br>注意mysql的事务是自动提交的<br>​    oracle的关系数据库范例的实现通过第一个DML语句隐式开始执行某个事务，事务一直延续到COMMIT或ROLLBACK语句执行为止SAVEPOINT命令不是SQL标准的一部分，实际上是编程人员反向撤销一些语句的简便方式。不需要单独考虑它，它不终止事务。<br>​    <strong>所谓的“自动提交：</strong><br>​    在结束对提交处理的讨论之前，我们有必要阐明一下经常被提及的“自动提交”(有时候也被称为隐式提交)。您经常会听到这样的说法:Orade在某些情况下可以进行“自动提交”。执行DDL语句就是其中一种情况，退出某个用户进程(SQLPus)则是另一种情况。自动提交”纯子虚写有。执行某条DDL语句时，实现这个DDL命令的源代妈包含了一个完全正规的COMMIT令。但是，退出用户进程时的情况是怎样呢?如果在WINDOWS终端上使用SQL<em>Plus并执行一条DML语句，然后再执行“退出”命令，就会提交事务。这是因为SQL</em>Plus中的“退出“命令嵌入了一条COMMIT语句。但是，单击SQL<em>Plus商口的右上角会出现怎样的情况呢? 此时，关团SQLPlus爱，如果再次登录SQLPlus，您会发现已回滚了事务，这是因为为Microsoft Windows编写SQL</em>Plus的编程人员在关团SQL<em>Plus窗口的代中嵌入了一条ROLLBACK语自。SQL</em>PLUS在其他平台上的行为可能有所不同，唯一的确认方法是测试。因此，以不同方式退出。</p>\n<h4 id=\"二、转账案例\"><a href=\"#二、转账案例\" class=\"headerlink\" title=\"二、转账案例\"></a>二、转账案例</h4><h5 id=\"2-1-创建user表\"><a href=\"#2-1-创建user表\" class=\"headerlink\" title=\"2.1  创建user表\"></a>2.1  创建user表</h5><h5 id=\"2-2-转账操作\"><a href=\"#2-2-转账操作\" class=\"headerlink\" title=\"2.2 转账操作\"></a>2.2 转账操作</h5><p>create table account<br>(<br>    id int auto_increment primary key,<br>    name varchar(20),<br>    money int<br>);<br>用于恢复数据<br>    UPDATE account SET money = 2000 where   name = ‘张三’  or NAME =’李四’</p>\n<p>1、将张三账户余额-1000<br>    UPDATE account SET  money = money-1000 WHERE NAME = ‘张三’;<br>    SELECT * from account WHERE NAME = ‘张三’</p>\n<p>2、将李四账户余额+1000<br>    UPDATE account SET  money = money+2000 WHERE NAME = ‘李四’;<br>    SELECT * from account WHERE NAME = ‘李四’</p>\n<h4 id=\"三、事务的操作\"><a href=\"#三、事务的操作\" class=\"headerlink\" title=\"三、事务的操作\"></a>三、事务的操作</h4><h5 id=\"3-1查看事务提交方式\"><a href=\"#3-1查看事务提交方式\" class=\"headerlink\" title=\"3.1查看事务提交方式\"></a>3.1查看事务提交方式</h5><p>  SELECT @@autocommit </p>\n<p>  set @@autocommit = 0</p>\n<p>  表示手动提交，即使用 MySQL 客户端执行 SQL 命令后必须使用commit命令执行事务，否则所执行的 SQL 命令无效，如果想撤销事务则使用 rollback 命令。1 表示自动提交，即在 MySQL 客户端不在需要手动执行 commit 命令。</p>\n<h5 id=\"3-2提交事务\"><a href=\"#3-2提交事务\" class=\"headerlink\" title=\"3.2提交事务\"></a>3.2提交事务</h5><p>  COMMIT </p>\n<p>​    1.COMMIT命令<br>许多人(甚至某些经验丰富的DBA) 在提交处理这个环节上都会出现不完全或者完全错误的理解oracle体系结构的情况。执行COMMIT命令时发生的所有物理操作时LGWR进程将日志缓中区的内容刷新到磁盘。DBWn进程完全没有执行任何操作。对于oracle数据库来说，这是一个非常重要的性能特性。<br>​    注意:执行COMMIT命令时，DBWn进程不会进行任何操作作。为了使某个事务持久，所需的全部工作是将组成这个事务的变更写入磁盘(不必使实际表数据存在于磁盘的数据文件上)。如果变更以多重重做日志文件的形式存在于磁盘上，那么在出现使数据库受损的事件时，通过从数据库受损前所做的备份中还原数据文件以及应用重做日志文件中的变更，就可以重新实例化事务。</p>\n<h5 id=\"3-3回滚事务\"><a href=\"#3-3回滚事务\" class=\"headerlink\" title=\"3.3回滚事务\"></a>3.3回滚事务</h5><p>  ROLLBACK<br>  事务回滚就是如果没有操作成功，所有的sql就会倒序重新把数据恢复到原来得样子，这样保证数据不会出错<br>  2.ROLLBACK命令<br>在事务处理过程中，Oracle会保存事务处理之前数据的映像。在事务处理过程中，会将这个映像提供给查询数据的其他会话。如果出现错误，或者会话故意请求回滚，那么它也可以用来自动回滚事务。回滚之前数据的状态是，数据已经改变，但反转这些变更所需的信息是可用的。为了满足隔离性原则，会将这些信息提供给其他所有会话。回滚会恢复数据改变之前的映像，从而抛弃所有变更;事务插入的所有行都会删除，事务删除的所有行都会重新插入表中，已经更新的行会回到原始状态。其他会话根本不知道发生了什么，它们绝对看不到这些变更，处理事务的会话现在会将数据看做事务开始之前的数据。</p>\n<h5 id=\"3-4开启事务\"><a href=\"#3-4开启事务\" class=\"headerlink\" title=\"3.4开启事务\"></a>3.4开启事务</h5><p>  START TRANSACTION 或  BEGIN</p>\n<p>  oracle:<br>  事务的开始和结束<br>会话开始事务的时间从它发出DML命令时开始。事务持续执行任何数量的DML命令，知道会话发出COMMIT或者ROLLBACK语向为止。只有提交的变更才会变的永久，才会对其他会话可见。不可能嵌套事务，SQL标准不允许用户启动一个事务，然后在终止第一个事务之前再启动另一个事务。使用PL/SQL (Oracle专有的第三代语言)可以这样做，但它不是行业标准的SQL。显示事务控制语句有COMMIT、ROLLBACK SAVEPOINT。除了用户发出的COMMIT或者ROLLBACK之外，还有一些情况会隐式终止事务:<br>1.发出DDL或DCL语句<br>2.退出用户工具 (SQL*PLUS、SQL Developer或者其他工具)<br>3.客户会话终止<br>4.系统崩溃<br>    如果用户发出DDL (CREATE、ALTER或DROP) 或者DCL (GRANT或REVOKE) 命令，就会提交正在处理的事务(如果有的话):会让它变的永久，并且对其他所有用户都可见。这是因为DDL和DCL命令本身都是是事务。因为在SQL中不可能损套事务，所以如果用户已经在运行事务，就会提交用户已经运行的语句，以及组成DDL和DCL的语句。如果用户通过发出DML命今来启动事务，然后在没有显示发出COMMIT或者ROLLBACK命令的情况下退出正在使用的工具，事务就会终上-但是使用COMMIT终上还是ROLLBACK终止，则完全取决于如何写工具。许多工具有不同的行为，这取决于退出工具的方式。不营在哪种情况下，都应该是受控制的退出，因此编程人员应该发出COMMIT或ROLLBACK金令。但他们必须进行选择如果客户的会话因为某种原因而失败，那么数据库总是会回滚事务，这种失败可能有多种原因，用户进程终止或者在提作系统级别被终止，到数据库服务器的网络连接中断，或者运行该客户工具的计算机崩溃。在所有这些情况中，都没有依次发出COMMIT或ROLLBACK语句，现在轮到数据库来检测发生的情况。行为是终止会话，回滚活动的事务。如果失败发生在服务器端，其行为也是这样。如果数据库服务器因为某种原因崩溃，那么当它下一次启动时，就会回滚来自所有会话的所有之前正在处理的事务。</p>\n<h4 id=\"四、事务的四大特征\"><a href=\"#四、事务的四大特征\" class=\"headerlink\" title=\"四、事务的四大特征\"></a>四、事务的四大特征</h4><p>1、原子性（Atomicity）<br>　　原子性是指事务包含的所有<br>　　操作要么全部成功，要么全部失败回滚，因此事务的操作如果成功就必须要完全应用到数据库，如果操作失败则不能对数据库有任何影响。</p>\n<p>2、一致性（Consistency）<br>　　一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态。<br>　　拿转账来说，假设用户A和用户B两者的钱加起来一共是5000，那么不管A和B之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是5000，这就是事务的一致性。</p>\n<p>3、隔离性（Isolation）<br>　　隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。<br>　　即要达到这么一种效果：对于任意两个并发的事务T1和T2，在事务T1看来，T2要么在T1开始之前就已经结束，要么在T1结束之后才开始，这样每个事务都感觉不到有其他事务在并发地执行。</p>\n<p>4、持久性（Durability）<br>　　持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。<br>　　例如我们在使用JDBC操作数据库时，在提交事务方法后，提示用户事务操作完成，当我们程序执行完成直到看到提示后，就可以认定事务以及正确提交，即使这时候数据库出现了问题，也必须要将我们的事务完全执行完成，否则就会造成我们看到提示事务处理完毕，但是数据库因为故障而没有执行事务的重大错误</p>\n<h4 id=\"五、事务隔离基别\"><a href=\"#五、事务隔离基别\" class=\"headerlink\" title=\"五、事务隔离基别\"></a>五、事务隔离基别</h4><figure class=\"highlight mipsasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mipsasm\">读未提交(Read Uncommitted)：<br>\t 允许脏读取，但不允许更新丢失。如果一个事务已经开始写数据，则另外一个事务则不允许同时进行写操作，但允许其他事务读此行数据。该隔离级别可以通过“排他写锁”实现。<br><br>\t举个例子:小何其实是准备给小美转<span class=\"hljs-number\">520</span>元的，但是按岔了成<span class=\"hljs-number\">250</span>于是<span class=\"hljs-number\">250</span>块钱被转给了小美，当然这个时候小何还没有提交事务。这个时候小美一下看到了账户上面的<span class=\"hljs-number\">250</span>，十分的生气，啪的一下子就小何拉黑了。手机扔到了一边。小何在转账的时候也发现了转成了<span class=\"hljs-number\">250</span>，连忙回滚事务，将转账金额改成了<span class=\"hljs-number\">520</span>后才提交了事务。然后小何开心的拿起手机，发信息给小美，却发现被拉黑了。。。而这个时候，其实小何账上少了<span class=\"hljs-number\">520</span>，小美多了<span class=\"hljs-number\">520</span>，但是小美手机扔到了一遍，还以为小何给她转了<span class=\"hljs-number\">250</span>.而这种错误就叫做脏读(读了未提交事务的数据)。<br><br>读提交(Read Committed)：<br> 允许不可重复读取，但不允许脏读取。这可以通过“瞬间共享读锁”和“排他写锁”实现。读取数据的事务允许其他事务继续访问该行数据，但是未提交的写事务将会禁止其他事务访问该行。<br><br>\t举个例子：小美和小何拿着<span class=\"hljs-number\">520</span>的账户去逛街买衣服，小美选了一件<span class=\"hljs-number\">500</span>的衣服，支付前，小美的账户上面查看有<span class=\"hljs-number\">520</span>元，于是小美升出二维码支付，但是这个时候，学校在绑定的小美的账户上面扣除了<span class=\"hljs-number\">300</span>的书本费，并且提交了事务，小美的账户被更新成为了<span class=\"hljs-number\">220</span>元，小美这时被告知账上没有足够的前支付。但是小美很纳闷，我刚不是有钱的吗？这就是不可重复读（同一个事务两次读取的内容不一样，读取无法重复）<br><br>可重复读取（Repeatable Read）：<br>\t禁止不可重复读取和脏读取，但是有时可能出现幻读数据。这可以通过**“共享读锁”和“排他写锁”实现。读取数据的事务将会禁止写事务**（但允许读事务），写事务则禁止任何其他事务。<br><br>可重复读比较简单，就是在小美结账时不让其他的UPDATE操作动她的账户，当学校的扣费事务到来时拒绝掉，这个时候你就可以重复读取到相同的账户金额，并且付款成功。但是这种情况可能出现幻读的情况，其实本质原因是因为可重复读只能解决其他的UPDATE事务，对于<span class=\"hljs-keyword\">INSERT操作无能为力。那幻读又是什么？</span><br><span class=\"hljs-keyword\"></span><br>举个例子：小美被告知账上没钱时，比较惊讶，于是她来到了学校教务处查询自己账户记录。(小美事务开启)小红看到自己的账户上面时被扣了<span class=\"hljs-number\">300</span>元书本费，还剩下<span class=\"hljs-number\">220</span>元，于是小红提出让老师打印自己的账户记录回家报销，但是在这个时候，好男人小何怕小美伤心又给小美转账了<span class=\"hljs-number\">300</span>元，并且完成了事务，提交了小何事务。于是在打印的账户记录出现了<span class=\"hljs-number\">300</span>的入账记录，小美十分开心，对着小何说：<span class=\"hljs-string\">&quot;我是不是出现了幻觉，刚刚不是只有220元的吗？怎么多了300元？&quot;</span>，小何此时深藏功与名，而这个就叫做幻读。<br><br>序列化(Serializable)：<br>提供严格的事务隔离。它要求事务序列化执行，事务只能一个接着一个地执行，不能并发执行。仅仅通过“行级锁”是无法实现事务序列化的，必须通过其他机制保证新插入的数据不会被刚执行查询操作的事务访问到。<br><br>序列化就是按部就班的执行，可以避免脏读、不可重复读与幻读，但是可想而知，这种方式会降低数据库的效率。<br><br>在序列化（Serializable）事务隔离级别下，所有的事务都会按照顺序逐个执行，而且每个事务都会读取到其他事务提交前的数据快照，因此在事务 <span class=\"hljs-built_in\">T1</span> 执行期间，如果事务 <span class=\"hljs-built_in\">T2</span> 插入了新的数据并提交了事务，那么这些新的数据对事务 <span class=\"hljs-built_in\">T1</span> 是不可见的，因此事务 <span class=\"hljs-built_in\">T1</span> 不会查询到事务 <span class=\"hljs-built_in\">T2</span> 插入的数据。<br><br>具体来说，如果事务 <span class=\"hljs-built_in\">T1</span> 先查询了数据表信息，然后事务 <span class=\"hljs-built_in\">T2</span> 插入了一条新的数据并提交了事务，那么在事务 <span class=\"hljs-built_in\">T1</span> 执行期间，这些新的数据对事务 <span class=\"hljs-built_in\">T1</span> 是不可见的，即使在事务 <span class=\"hljs-built_in\">T2</span> 提交事务之后，事务 <span class=\"hljs-built_in\">T1</span> 也不会查询到这些新的数据。<br><br>需要注意的是，在序列化隔离级别下，事务会被强制串行执行，即使有多个事务并发执行，也会保证它们能够按照顺序执行，从而避免了幻读、不可重复读等问题。因此，在这个隔离级别下，事务 <span class=\"hljs-built_in\">T1</span> 和事务 <span class=\"hljs-built_in\">T2</span> 插入或更新的数据虽然可能存在冲突，但是它们不会相互影响，也不会互相读取对方提交的数据。<br><br></code></pre></td></tr></table></figure>\n\n<h4 id=\"六、查看事务隔离级别\"><a href=\"#六、查看事务隔离级别\" class=\"headerlink\" title=\"六、查看事务隔离级别\"></a>六、查看事务隔离级别</h4><figure class=\"highlight pgsql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs pgsql\">#查看事务隔离级别<br>\t<span class=\"hljs-number\">5.7</span>之前<br><span class=\"hljs-keyword\">SELECT</span> @@transaction_isolation<br><br>#设置事务隔离级别<br><span class=\"hljs-keyword\">set</span> <span class=\"hljs-keyword\">session</span> <span class=\"hljs-keyword\">transaction</span> <span class=\"hljs-keyword\">isolation</span> <span class=\"hljs-keyword\">level</span>   填写以下几个事务  ;<br>读未提交(<span class=\"hljs-keyword\">Read</span> <span class=\"hljs-keyword\">Uncommitted</span>)：<br>读提交(<span class=\"hljs-keyword\">Read</span> <span class=\"hljs-keyword\">Committed</span>)：<br>可重复读取（<span class=\"hljs-keyword\">Repeatable</span> <span class=\"hljs-keyword\">Read</span>）：<br>序列化(<span class=\"hljs-keyword\">Serializable</span>)：<br><br><br><span class=\"hljs-keyword\">session</span>：当前会话，也就是当前连接。<br><br><span class=\"hljs-keyword\">global</span>：全局，不包含当前连接，之后新获取的连接都会生效。<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://cdn.jsdelivr.net/gh/wl2o2o/blogCdn/img/202306051100898.png\" alt=\"1685861365330\"></p>\n<figure class=\"highlight pgsql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs pgsql\">设置事务隔离级别为   <span class=\"hljs-keyword\">read</span> <span class=\"hljs-keyword\">uncommitted</span>    并开启事务    演示脏读数据<br>要一起打开两个第一个设置事务隔离级别和开启事务<span class=\"hljs-keyword\">start</span> <span class=\"hljs-keyword\">transaction</span><br>第二个也要开启事务<span class=\"hljs-keyword\">start</span> <span class=\"hljs-keyword\">transaction</span>，这几个级别都这样<br>然后开启下一个级别的情况下两边都要进行提交<span class=\"hljs-keyword\">commit</span>；<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://cdn.jsdelivr.net/gh/wl2o2o/blogCdn/img/202306051100900.png\" alt=\"1685861569904\"><img src=\"https://cdn.jsdelivr.net/gh/wl2o2o/blogCdn/img/202306051100902.png\" alt=\"1685861842042\"></p>\n<figure class=\"highlight pgsql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs pgsql\">设置事务隔离级别为   <span class=\"hljs-keyword\">read</span> <span class=\"hljs-keyword\">committed</span>    并开启事务    演示脏读数据<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://cdn.jsdelivr.net/gh/wl2o2o/blogCdn/img/202306051100903.png\" alt=\"1685862300090\"></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/wl2o2o/blogCdn/img/202306051100904.png\" alt=\"1685862320137\"></p>\n<figure class=\"highlight pgsql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs pgsql\">设置事务隔离级别为   <span class=\"hljs-keyword\">read</span> <span class=\"hljs-keyword\">committed</span>    并开启事务    演示不可重复读数据<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://cdn.jsdelivr.net/gh/wl2o2o/blogCdn/img/202306051100905.png\" alt=\"1685865723425\"><img src=\"https://cdn.jsdelivr.net/gh/wl2o2o/blogCdn/img/202306051100906.png\" alt=\"1685865734957\"></p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs\">什么是幻读<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://cdn.jsdelivr.net/gh/wl2o2o/blogCdn/img/202306051100907.png\" alt=\"1685866356451\"><img src=\"https://cdn.jsdelivr.net/gh/wl2o2o/blogCdn/img/202306051100908.png\" alt=\"1685866370205\"></p>\n<figure class=\"highlight pgsql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs pgsql\">解决幻读问题<br>设置事务隔离级别为  <span class=\"hljs-keyword\">serializable</span> 可以规避全部的并发事务问题但性能最差<br>注意：事务级别越高，数据越安全，但性能越差，反之亦然<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://cdn.jsdelivr.net/gh/wl2o2o/blogCdn/img/202306051100909.png\" alt=\"1685866707034\"></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/wl2o2o/blogCdn/img/202306051100910.png\" alt=\"1685866720304\"></p>\n"},{"title":"头歌实践教学平台-Linux网络实战（一）-DNS配置（Ubuntu系统）","index_img":"https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311151627632.png","expert":"头歌实践教学平台-Linux网络实战（一）-DNS配置（Ubuntu系统）,别划走！！！这篇博客就是你要找的头歌教学实践平台上的：第四关：DNS服务器配置的保姆级通关步骤。","abbrlink":14983,"date":"2022-05-04T07:30:37.000Z","_content":"\n# 通关前的啰嗦（属于知识补充，不想看就跳过）\n\n> ## 小广告：\n>\n> ***见者有缘，欢迎大家访问我的博客【CS_GUIDER】：\n> [https://wlei224.gitee.io](https://wlei224.gitee.io/) （建议访问这个，速度极快）\n> [https://wl2o2o.github.io](https://wl2o2o.github.io/)（github托管，可能访问慢）***\n>\n> 我的开源博客涵盖了**八股文**、**Java基础**、**JVM**、**MySQL**、**Linux**、**框架技术**、**算法**以及其他领域的文章，如果你想搭建自己的博客，或者是想沉淀知识，欢迎访问我的网站，长期不定时更新连载我的博客搭建版本记录以及搭建踩坑记录，以及基于原 fluid 主题增加的功能，欢迎大家访问和咨询。\n>\n> ![博客文章](https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311210931702.png)\n\n\n\n> ## 写在前面\n>\n> 别划走！！！这篇博客就是你要找的头歌教学实践平台上的：第四关：DNS服务器配置的保姆级通关步骤。\n>\n> ![头歌实践教学平台-Linux网络实战（一）第四关](https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311210935053.png)\n> ![成功图](https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311210935591.png) 如上图所示，本关题解笔者已经通过，并测验了多次，为避免出错，可以先按照如下步骤，直接复制即可，通关后想了解原理，再回过头来一步一步进行，如果遇到什么问题，欢迎在评论区进行讨论！\n# \n## 相关知识背景\n**域名**：`Internet`上某一台计算机或计算机组的名称，是`IP地址`的映射。域名解析实际上就是把域名映射回`IP地址`。\n\n**域名解析的过程**：当一个浏览者在浏览器地址框中打入某一个域名，或者从其他网站点击了链接来到了这个域名，浏览器向这个用户的上网接入商发出域名请求，接入商的`DNS服务器`要查询域名数据库，看这个域名的`DNS服务器`是什么。然后到`DNS服务器`中抓取`DNS记录`，也就是获取这个域名指向哪一个`IP地址`。在获得这个`IP信息`后，接入商的服务器就去这个`IP地址`所对应的服务器上抓取网页内容，然后传输给发出请求的浏览器。\nLinux中`/etc/resolv.conf`文件是`DNS客户机`配置文件，用于设置`DNS服务器`的`IP地址`及`DNS域名`，还包含了主机的域名搜索顺序。\n\n**正解与反解的Zone意义**：\n`DNS系统`最主要的功能就是互查主机名与`IP`，由于计算机在网络上只认识`IP地址`，所以，一般来说，我们称由主机名查找`IP`的过程为正解，由`IP`查询得到主机名为反解。\n\nZone(区域)：一个正解或反解的设置就是一个zone，通常一个配置文件就是一个zone。\n\n# 通关保姆级步骤（点击直达）\nTips：头歌平台的环境是ubantu版本的Linux系统，在Linux系统下可以通过Ctrl+insert进行复制，Shift+insert进行粘贴。\n## 安装DNS服务器并开启服务\n\n> 注意：严格**按照如下**两个步骤的**顺序**进行 bind 任务环境的安装与初始化。\n>\n> | 1、更新安装源后、安装DNS服务器（共两个命令） | apt-get update          | apt-get install bind9 |\n> | :------------------------------------------- | ----------------------- | --------------------- |\n> | **2、开启DNS服务**                           | **service bind9 start** |                       |\n>\n> 具体编程要求如下：\n> 先有域名test.com，然后将该域名与IP地址：10.40.211.244相绑定在一起。\n\n**避雷器提醒**：准备bind和host环境时，一定要先下载bind，再下载host！否则会影响映射成功，原因待补充... ...\n\n补充原因：\n\n> 在配置DNS服务器时，需要先下载BIND软件包，因为BIND是一种开源的DNS服务器软件，它实现了域名解析服务，可以将域名转换为IP地址。如果没有安装BIND软件包，则无法实现DNS服务器的基本功能。\n>\n> 下载HOST软件包是为了建立本地域名解析服务，可以将本地主机名映射到IP地址。如果先下载HOST软件包而没有安装BIND软件包，则无法将域名解析请求转发到DNS服务器，这会导致域名无法解析成功。因此，在配置DNS服务器时，需要先安装BIND软件包，再安装HOST软件包，以确保域名解析服务能够正常运行。\n\n\n\n## 一、标题配置域名和IP的正解与反解zone：\n\n命令：\n\n```cmd\nvi /etc/bind/named.conf.default-zones\n```\n\n\n添加如下:\n\n\n```javascript\nzone \"test.com\"{  \n    type master;  \n    file \"/etc/bind/db.test.com\";  \n};\t\t//正向解析\n\nzone \"211.40.10.in-addr.arpa\"{  \n    type master;\n    file \"/etc/bind/db.10\";  \n};  \t//反向解析\n```\n\n\n\n## 二、新建/etc/bind/db.test.com文件\n命令：\n\n```cmd\nvi /etc/bind/db.test.com\n```\n\n添加如下:\n\n\n```javascript\n;  \n; BIND data file for local loopback interface  \n;  \n$TTL    604800  \n@       IN      SOA     test.com. root.test.com. (  \n                                     2         ; Serial  \n   \t                            604800         ; Refresh  \n\t                             86400         ; Retry  \n\t                           2419200         ; Expire  \n\t                            604800 )       ; Negative Cache TTL\n;  \n@       IN      NS      test.com.  \n@       IN      A       10.40.211.244  \n```\n\n\n## 三、新建/etc/bind/db.10文件\n命令：\n\n```cmd\nvi /etc/bind/db.10\n```\n\n添加如下:\n\n\n```javascript\n;  \n; BIND reverse data file for local loopback interface  \n;  \n$TTL    604800  \n@       IN      SOA     test.com. root.test.com. (  \n                                    1         ; Serial  \n                               604800         ; Refresh  \n                                86400         ; Retry  \n                              2419200         ; Expire  \n                               604800 )       ; Negative Cache TTL  \n;  \n@       IN      NS      test.com.  \n244      IN      PTR     test.com. \n```\n\n\n## 四、修改DNS服务器搜索顺序，将本地作为DNS搜索的第一搜索目录\n命令：\n\n```cmd\nvim /etc/resolv.conf\n```\n\n打开/etc/resolv.conf文件后添加到第一行：\n\n```cmd\nnameserver 127.0.0.1 \n```\n\n![使用vi命令打开文件后添加一行：nameserver 127.0.0.1](https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311210936377.png)\n\n## 五、不要忘记重新启动bind服务器\n```cmd\nservice bind9 restart\n```\n\n\n## 六、最后安装host命令\n```cmd\napt-get install host\n```\n\n\n## 七、查询域名和IP是否关联\n第一步：\n```cmd\nhost test.com\n```\n第二步：\n```cmd\nhost 10.40.211.244\n```\n\n结束！\n直接开始评测！\n\n## 头歌课程网址\n头歌实践教学平台：https://www.educoder.net/shixuns/qpmhnsiy/challenges\n\n> ## 写在最后\n>\n> 无论你是计算机小白，还是佬儿，或者是考研党，或者是摸鱼翁，能在此相遇即是缘分，欢迎大家访问我的博客，链接见下面，如果你对写博文很感兴趣，或者说想加入我一起打造这个小网站，你可以在博客的评论区，或者本文的评论区联系我，总之，话不多说，一起努力！沉淀的知识都是自己的财富！\n>\n> 送给大家八个字：慢下来，走好每一步！\n>\n> CS_GUIDER博客链接：\n>\n> [https://wlei224.gitee.io](https://wlei224.gitee.io)（建议访问这个，速度极快）\n> [https://wl2o2o.github.io](https://wl2o2o.github.io)（github托管，可能访问慢）![我的Hexo静态博客](https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311210936718.png)\n> 我的开源博客涵盖了**八股文**、Java基础、JVM、MySQL、Linux、框架技术、算法以及其他领域的文章，如果你对建站比较感兴趣，你也想沉淀自己的知识，欢迎访问我的网站，不定时更新连载我的博客搭建版本记录，踩坑记录或者是我基于hexo的fluid主题增加的小功能，欢迎大家访问和咨询。\n> ![article categories](https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311210936197.png)\n","source":"_posts/头歌实践教学平台-Linux网络实战（一）-DNS配置（Ubuntu系统）.md","raw":"---\ntitle: 头歌实践教学平台-Linux网络实战（一）-DNS配置（Ubuntu系统）\nindex_img: https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311151627632.png\nexpert: 头歌实践教学平台-Linux网络实战（一）-DNS配置（Ubuntu系统）,别划走！！！这篇博客就是你要找的头歌教学实践平台上的：第四关：DNS服务器配置的保姆级通关步骤。\ncategories:\n  - Linux\ntags:\n  - Linux DNS\n  - educoder\nabbrlink: 14983\ndate: 2022-05-04 15:30:37\n---\n\n# 通关前的啰嗦（属于知识补充，不想看就跳过）\n\n> ## 小广告：\n>\n> ***见者有缘，欢迎大家访问我的博客【CS_GUIDER】：\n> [https://wlei224.gitee.io](https://wlei224.gitee.io/) （建议访问这个，速度极快）\n> [https://wl2o2o.github.io](https://wl2o2o.github.io/)（github托管，可能访问慢）***\n>\n> 我的开源博客涵盖了**八股文**、**Java基础**、**JVM**、**MySQL**、**Linux**、**框架技术**、**算法**以及其他领域的文章，如果你想搭建自己的博客，或者是想沉淀知识，欢迎访问我的网站，长期不定时更新连载我的博客搭建版本记录以及搭建踩坑记录，以及基于原 fluid 主题增加的功能，欢迎大家访问和咨询。\n>\n> ![博客文章](https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311210931702.png)\n\n\n\n> ## 写在前面\n>\n> 别划走！！！这篇博客就是你要找的头歌教学实践平台上的：第四关：DNS服务器配置的保姆级通关步骤。\n>\n> ![头歌实践教学平台-Linux网络实战（一）第四关](https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311210935053.png)\n> ![成功图](https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311210935591.png) 如上图所示，本关题解笔者已经通过，并测验了多次，为避免出错，可以先按照如下步骤，直接复制即可，通关后想了解原理，再回过头来一步一步进行，如果遇到什么问题，欢迎在评论区进行讨论！\n# \n## 相关知识背景\n**域名**：`Internet`上某一台计算机或计算机组的名称，是`IP地址`的映射。域名解析实际上就是把域名映射回`IP地址`。\n\n**域名解析的过程**：当一个浏览者在浏览器地址框中打入某一个域名，或者从其他网站点击了链接来到了这个域名，浏览器向这个用户的上网接入商发出域名请求，接入商的`DNS服务器`要查询域名数据库，看这个域名的`DNS服务器`是什么。然后到`DNS服务器`中抓取`DNS记录`，也就是获取这个域名指向哪一个`IP地址`。在获得这个`IP信息`后，接入商的服务器就去这个`IP地址`所对应的服务器上抓取网页内容，然后传输给发出请求的浏览器。\nLinux中`/etc/resolv.conf`文件是`DNS客户机`配置文件，用于设置`DNS服务器`的`IP地址`及`DNS域名`，还包含了主机的域名搜索顺序。\n\n**正解与反解的Zone意义**：\n`DNS系统`最主要的功能就是互查主机名与`IP`，由于计算机在网络上只认识`IP地址`，所以，一般来说，我们称由主机名查找`IP`的过程为正解，由`IP`查询得到主机名为反解。\n\nZone(区域)：一个正解或反解的设置就是一个zone，通常一个配置文件就是一个zone。\n\n# 通关保姆级步骤（点击直达）\nTips：头歌平台的环境是ubantu版本的Linux系统，在Linux系统下可以通过Ctrl+insert进行复制，Shift+insert进行粘贴。\n## 安装DNS服务器并开启服务\n\n> 注意：严格**按照如下**两个步骤的**顺序**进行 bind 任务环境的安装与初始化。\n>\n> | 1、更新安装源后、安装DNS服务器（共两个命令） | apt-get update          | apt-get install bind9 |\n> | :------------------------------------------- | ----------------------- | --------------------- |\n> | **2、开启DNS服务**                           | **service bind9 start** |                       |\n>\n> 具体编程要求如下：\n> 先有域名test.com，然后将该域名与IP地址：10.40.211.244相绑定在一起。\n\n**避雷器提醒**：准备bind和host环境时，一定要先下载bind，再下载host！否则会影响映射成功，原因待补充... ...\n\n补充原因：\n\n> 在配置DNS服务器时，需要先下载BIND软件包，因为BIND是一种开源的DNS服务器软件，它实现了域名解析服务，可以将域名转换为IP地址。如果没有安装BIND软件包，则无法实现DNS服务器的基本功能。\n>\n> 下载HOST软件包是为了建立本地域名解析服务，可以将本地主机名映射到IP地址。如果先下载HOST软件包而没有安装BIND软件包，则无法将域名解析请求转发到DNS服务器，这会导致域名无法解析成功。因此，在配置DNS服务器时，需要先安装BIND软件包，再安装HOST软件包，以确保域名解析服务能够正常运行。\n\n\n\n## 一、标题配置域名和IP的正解与反解zone：\n\n命令：\n\n```cmd\nvi /etc/bind/named.conf.default-zones\n```\n\n\n添加如下:\n\n\n```javascript\nzone \"test.com\"{  \n    type master;  \n    file \"/etc/bind/db.test.com\";  \n};\t\t//正向解析\n\nzone \"211.40.10.in-addr.arpa\"{  \n    type master;\n    file \"/etc/bind/db.10\";  \n};  \t//反向解析\n```\n\n\n\n## 二、新建/etc/bind/db.test.com文件\n命令：\n\n```cmd\nvi /etc/bind/db.test.com\n```\n\n添加如下:\n\n\n```javascript\n;  \n; BIND data file for local loopback interface  \n;  \n$TTL    604800  \n@       IN      SOA     test.com. root.test.com. (  \n                                     2         ; Serial  \n   \t                            604800         ; Refresh  \n\t                             86400         ; Retry  \n\t                           2419200         ; Expire  \n\t                            604800 )       ; Negative Cache TTL\n;  \n@       IN      NS      test.com.  \n@       IN      A       10.40.211.244  \n```\n\n\n## 三、新建/etc/bind/db.10文件\n命令：\n\n```cmd\nvi /etc/bind/db.10\n```\n\n添加如下:\n\n\n```javascript\n;  \n; BIND reverse data file for local loopback interface  \n;  \n$TTL    604800  \n@       IN      SOA     test.com. root.test.com. (  \n                                    1         ; Serial  \n                               604800         ; Refresh  \n                                86400         ; Retry  \n                              2419200         ; Expire  \n                               604800 )       ; Negative Cache TTL  \n;  \n@       IN      NS      test.com.  \n244      IN      PTR     test.com. \n```\n\n\n## 四、修改DNS服务器搜索顺序，将本地作为DNS搜索的第一搜索目录\n命令：\n\n```cmd\nvim /etc/resolv.conf\n```\n\n打开/etc/resolv.conf文件后添加到第一行：\n\n```cmd\nnameserver 127.0.0.1 \n```\n\n![使用vi命令打开文件后添加一行：nameserver 127.0.0.1](https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311210936377.png)\n\n## 五、不要忘记重新启动bind服务器\n```cmd\nservice bind9 restart\n```\n\n\n## 六、最后安装host命令\n```cmd\napt-get install host\n```\n\n\n## 七、查询域名和IP是否关联\n第一步：\n```cmd\nhost test.com\n```\n第二步：\n```cmd\nhost 10.40.211.244\n```\n\n结束！\n直接开始评测！\n\n## 头歌课程网址\n头歌实践教学平台：https://www.educoder.net/shixuns/qpmhnsiy/challenges\n\n> ## 写在最后\n>\n> 无论你是计算机小白，还是佬儿，或者是考研党，或者是摸鱼翁，能在此相遇即是缘分，欢迎大家访问我的博客，链接见下面，如果你对写博文很感兴趣，或者说想加入我一起打造这个小网站，你可以在博客的评论区，或者本文的评论区联系我，总之，话不多说，一起努力！沉淀的知识都是自己的财富！\n>\n> 送给大家八个字：慢下来，走好每一步！\n>\n> CS_GUIDER博客链接：\n>\n> [https://wlei224.gitee.io](https://wlei224.gitee.io)（建议访问这个，速度极快）\n> [https://wl2o2o.github.io](https://wl2o2o.github.io)（github托管，可能访问慢）![我的Hexo静态博客](https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311210936718.png)\n> 我的开源博客涵盖了**八股文**、Java基础、JVM、MySQL、Linux、框架技术、算法以及其他领域的文章，如果你对建站比较感兴趣，你也想沉淀自己的知识，欢迎访问我的网站，不定时更新连载我的博客搭建版本记录，踩坑记录或者是我基于hexo的fluid主题增加的小功能，欢迎大家访问和咨询。\n> ![article categories](https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311210936197.png)\n","slug":"头歌实践教学平台-Linux网络实战（一）-DNS配置（Ubuntu系统）","published":1,"updated":"2023-11-30T01:19:07.700Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clpkiczjl003lfkfobyvs1fgc","content":"<h1 id=\"通关前的啰嗦（属于知识补充，不想看就跳过）\"><a href=\"#通关前的啰嗦（属于知识补充，不想看就跳过）\" class=\"headerlink\" title=\"通关前的啰嗦（属于知识补充，不想看就跳过）\"></a>通关前的啰嗦（属于知识补充，不想看就跳过）</h1><blockquote>\n<h2 id=\"小广告：\"><a href=\"#小广告：\" class=\"headerlink\" title=\"小广告：\"></a>小广告：</h2><p><em><strong>见者有缘，欢迎大家访问我的博客【CS_GUIDER】：<br><a href=\"https://wlei224.gitee.io/\">https://wlei224.gitee.io</a> （建议访问这个，速度极快）<br><a href=\"https://wl2o2o.github.io/\">https://wl2o2o.github.io</a>（github托管，可能访问慢）</strong></em></p>\n<p>我的开源博客涵盖了<strong>八股文</strong>、<strong>Java基础</strong>、<strong>JVM</strong>、<strong>MySQL</strong>、<strong>Linux</strong>、<strong>框架技术</strong>、<strong>算法</strong>以及其他领域的文章，如果你想搭建自己的博客，或者是想沉淀知识，欢迎访问我的网站，长期不定时更新连载我的博客搭建版本记录以及搭建踩坑记录，以及基于原 fluid 主题增加的功能，欢迎大家访问和咨询。</p>\n<p><img src=\"https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311210931702.png\" alt=\"博客文章\"></p>\n</blockquote>\n<blockquote>\n<h2 id=\"写在前面\"><a href=\"#写在前面\" class=\"headerlink\" title=\"写在前面\"></a>写在前面</h2><p>别划走！！！这篇博客就是你要找的头歌教学实践平台上的：第四关：DNS服务器配置的保姆级通关步骤。</p>\n<p><img src=\"https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311210935053.png\" alt=\"头歌实践教学平台-Linux网络实战（一）第四关\"><br><img src=\"https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311210935591.png\" alt=\"成功图\"> 如上图所示，本关题解笔者已经通过，并测验了多次，为避免出错，可以先按照如下步骤，直接复制即可，通关后想了解原理，再回过头来一步一步进行，如果遇到什么问题，欢迎在评论区进行讨论！</p>\n</blockquote>\n<h1 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h1><h2 id=\"相关知识背景\"><a href=\"#相关知识背景\" class=\"headerlink\" title=\"相关知识背景\"></a>相关知识背景</h2><p><strong>域名</strong>：<code>Internet</code>上某一台计算机或计算机组的名称，是<code>IP地址</code>的映射。域名解析实际上就是把域名映射回<code>IP地址</code>。</p>\n<p><strong>域名解析的过程</strong>：当一个浏览者在浏览器地址框中打入某一个域名，或者从其他网站点击了链接来到了这个域名，浏览器向这个用户的上网接入商发出域名请求，接入商的<code>DNS服务器</code>要查询域名数据库，看这个域名的<code>DNS服务器</code>是什么。然后到<code>DNS服务器</code>中抓取<code>DNS记录</code>，也就是获取这个域名指向哪一个<code>IP地址</code>。在获得这个<code>IP信息</code>后，接入商的服务器就去这个<code>IP地址</code>所对应的服务器上抓取网页内容，然后传输给发出请求的浏览器。<br>Linux中<code>/etc/resolv.conf</code>文件是<code>DNS客户机</code>配置文件，用于设置<code>DNS服务器</code>的<code>IP地址</code>及<code>DNS域名</code>，还包含了主机的域名搜索顺序。</p>\n<p><strong>正解与反解的Zone意义</strong>：<br><code>DNS系统</code>最主要的功能就是互查主机名与<code>IP</code>，由于计算机在网络上只认识<code>IP地址</code>，所以，一般来说，我们称由主机名查找<code>IP</code>的过程为正解，由<code>IP</code>查询得到主机名为反解。</p>\n<p>Zone(区域)：一个正解或反解的设置就是一个zone，通常一个配置文件就是一个zone。</p>\n<h1 id=\"通关保姆级步骤（点击直达）\"><a href=\"#通关保姆级步骤（点击直达）\" class=\"headerlink\" title=\"通关保姆级步骤（点击直达）\"></a>通关保姆级步骤（点击直达）</h1><p>Tips：头歌平台的环境是ubantu版本的Linux系统，在Linux系统下可以通过Ctrl+insert进行复制，Shift+insert进行粘贴。</p>\n<h2 id=\"安装DNS服务器并开启服务\"><a href=\"#安装DNS服务器并开启服务\" class=\"headerlink\" title=\"安装DNS服务器并开启服务\"></a>安装DNS服务器并开启服务</h2><blockquote>\n<p>注意：严格<strong>按照如下</strong>两个步骤的<strong>顺序</strong>进行 bind 任务环境的安装与初始化。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">1、更新安装源后、安装DNS服务器（共两个命令）</th>\n<th>apt-get update</th>\n<th>apt-get install bind9</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><strong>2、开启DNS服务</strong></td>\n<td><strong>service bind9 start</strong></td>\n<td></td>\n</tr>\n</tbody></table>\n<p>具体编程要求如下：<br>先有域名test.com，然后将该域名与IP地址：10.40.211.244相绑定在一起。</p>\n</blockquote>\n<p><strong>避雷器提醒</strong>：准备bind和host环境时，一定要先下载bind，再下载host！否则会影响映射成功，原因待补充… …</p>\n<p>补充原因：</p>\n<blockquote>\n<p>在配置DNS服务器时，需要先下载BIND软件包，因为BIND是一种开源的DNS服务器软件，它实现了域名解析服务，可以将域名转换为IP地址。如果没有安装BIND软件包，则无法实现DNS服务器的基本功能。</p>\n<p>下载HOST软件包是为了建立本地域名解析服务，可以将本地主机名映射到IP地址。如果先下载HOST软件包而没有安装BIND软件包，则无法将域名解析请求转发到DNS服务器，这会导致域名无法解析成功。因此，在配置DNS服务器时，需要先安装BIND软件包，再安装HOST软件包，以确保域名解析服务能够正常运行。</p>\n</blockquote>\n<h2 id=\"一、标题配置域名和IP的正解与反解zone：\"><a href=\"#一、标题配置域名和IP的正解与反解zone：\" class=\"headerlink\" title=\"一、标题配置域名和IP的正解与反解zone：\"></a>一、标题配置域名和IP的正解与反解zone：</h2><p>命令：</p>\n<figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmd\">vi /etc/bind/named.conf.default-zones<br></code></pre></td></tr></table></figure>\n\n\n<p>添加如下:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">zone <span class=\"hljs-string\">&quot;test.com&quot;</span>&#123;  <br>    type master;  <br>    file <span class=\"hljs-string\">&quot;/etc/bind/db.test.com&quot;</span>;  <br>&#125;;\t\t<span class=\"hljs-comment\">//正向解析</span><br><br>zone <span class=\"hljs-string\">&quot;211.40.10.in-addr.arpa&quot;</span>&#123;  <br>    type master;<br>    file <span class=\"hljs-string\">&quot;/etc/bind/db.10&quot;</span>;  <br>&#125;;  \t<span class=\"hljs-comment\">//反向解析</span><br></code></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"二、新建-etc-bind-db-test-com文件\"><a href=\"#二、新建-etc-bind-db-test-com文件\" class=\"headerlink\" title=\"二、新建/etc/bind/db.test.com文件\"></a>二、新建/etc/bind/db.test.com文件</h2><p>命令：</p>\n<figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmd\">vi /etc/bind/db.test.com<br></code></pre></td></tr></table></figure>\n\n<p>添加如下:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">;  <br>; <span class=\"hljs-variable constant_\">BIND</span> data file <span class=\"hljs-keyword\">for</span> local loopback interface  <br>;  <br>$TTL    <span class=\"hljs-number\">604800</span>  <br>@       <span class=\"hljs-variable constant_\">IN</span>      <span class=\"hljs-variable constant_\">SOA</span>     test.<span class=\"hljs-property\">com</span>. root.<span class=\"hljs-property\">test</span>.<span class=\"hljs-property\">com</span>. (  <br>                                     <span class=\"hljs-number\">2</span>         ; <span class=\"hljs-title class_\">Serial</span>  <br>   \t                            <span class=\"hljs-number\">604800</span>         ; <span class=\"hljs-title class_\">Refresh</span>  <br>\t                             <span class=\"hljs-number\">86400</span>         ; <span class=\"hljs-title class_\">Retry</span>  <br>\t                           <span class=\"hljs-number\">2419200</span>         ; <span class=\"hljs-title class_\">Expire</span>  <br>\t                            <span class=\"hljs-number\">604800</span> )       ; <span class=\"hljs-title class_\">Negative</span> <span class=\"hljs-title class_\">Cache</span> <span class=\"hljs-variable constant_\">TTL</span><br>;  <br>@       <span class=\"hljs-variable constant_\">IN</span>      <span class=\"hljs-variable constant_\">NS</span>      test.<span class=\"hljs-property\">com</span>.  <br>@       <span class=\"hljs-variable constant_\">IN</span>      A       <span class=\"hljs-number\">10.40</span><span class=\"hljs-number\">.211</span><span class=\"hljs-number\">.244</span>  <br></code></pre></td></tr></table></figure>\n\n\n<h2 id=\"三、新建-etc-bind-db-10文件\"><a href=\"#三、新建-etc-bind-db-10文件\" class=\"headerlink\" title=\"三、新建/etc/bind/db.10文件\"></a>三、新建/etc/bind/db.10文件</h2><p>命令：</p>\n<figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmd\">vi /etc/bind/db.<span class=\"hljs-number\">10</span><br></code></pre></td></tr></table></figure>\n\n<p>添加如下:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">;  <br>; <span class=\"hljs-variable constant_\">BIND</span> reverse data file <span class=\"hljs-keyword\">for</span> local loopback interface  <br>;  <br>$TTL    <span class=\"hljs-number\">604800</span>  <br>@       <span class=\"hljs-variable constant_\">IN</span>      <span class=\"hljs-variable constant_\">SOA</span>     test.<span class=\"hljs-property\">com</span>. root.<span class=\"hljs-property\">test</span>.<span class=\"hljs-property\">com</span>. (  <br>                                    <span class=\"hljs-number\">1</span>         ; <span class=\"hljs-title class_\">Serial</span>  <br>                               <span class=\"hljs-number\">604800</span>         ; <span class=\"hljs-title class_\">Refresh</span>  <br>                                <span class=\"hljs-number\">86400</span>         ; <span class=\"hljs-title class_\">Retry</span>  <br>                              <span class=\"hljs-number\">2419200</span>         ; <span class=\"hljs-title class_\">Expire</span>  <br>                               <span class=\"hljs-number\">604800</span> )       ; <span class=\"hljs-title class_\">Negative</span> <span class=\"hljs-title class_\">Cache</span> <span class=\"hljs-variable constant_\">TTL</span>  <br>;  <br>@       <span class=\"hljs-variable constant_\">IN</span>      <span class=\"hljs-variable constant_\">NS</span>      test.<span class=\"hljs-property\">com</span>.  <br><span class=\"hljs-number\">244</span>      <span class=\"hljs-variable constant_\">IN</span>      <span class=\"hljs-variable constant_\">PTR</span>     test.<span class=\"hljs-property\">com</span>. <br></code></pre></td></tr></table></figure>\n\n\n<h2 id=\"四、修改DNS服务器搜索顺序，将本地作为DNS搜索的第一搜索目录\"><a href=\"#四、修改DNS服务器搜索顺序，将本地作为DNS搜索的第一搜索目录\" class=\"headerlink\" title=\"四、修改DNS服务器搜索顺序，将本地作为DNS搜索的第一搜索目录\"></a>四、修改DNS服务器搜索顺序，将本地作为DNS搜索的第一搜索目录</h2><p>命令：</p>\n<figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmd\">vim /etc/resolv.conf<br></code></pre></td></tr></table></figure>\n\n<p>打开/etc/resolv.conf文件后添加到第一行：</p>\n<figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmd\">nameserver <span class=\"hljs-number\">127</span>.<span class=\"hljs-number\">0</span>.<span class=\"hljs-number\">0</span>.<span class=\"hljs-number\">1</span> <br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311210936377.png\" alt=\"使用vi命令打开文件后添加一行：nameserver 127.0.0.1\"></p>\n<h2 id=\"五、不要忘记重新启动bind服务器\"><a href=\"#五、不要忘记重新启动bind服务器\" class=\"headerlink\" title=\"五、不要忘记重新启动bind服务器\"></a>五、不要忘记重新启动bind服务器</h2><figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmd\">service bind9 restart<br></code></pre></td></tr></table></figure>\n\n\n<h2 id=\"六、最后安装host命令\"><a href=\"#六、最后安装host命令\" class=\"headerlink\" title=\"六、最后安装host命令\"></a>六、最后安装host命令</h2><figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmd\">apt-get install host<br></code></pre></td></tr></table></figure>\n\n\n<h2 id=\"七、查询域名和IP是否关联\"><a href=\"#七、查询域名和IP是否关联\" class=\"headerlink\" title=\"七、查询域名和IP是否关联\"></a>七、查询域名和IP是否关联</h2><p>第一步：</p>\n<figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmd\">host test.com<br></code></pre></td></tr></table></figure>\n<p>第二步：</p>\n<figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmd\">host <span class=\"hljs-number\">10</span>.<span class=\"hljs-number\">40</span>.<span class=\"hljs-number\">211</span>.<span class=\"hljs-number\">244</span><br></code></pre></td></tr></table></figure>\n\n<p>结束！<br>直接开始评测！</p>\n<h2 id=\"头歌课程网址\"><a href=\"#头歌课程网址\" class=\"headerlink\" title=\"头歌课程网址\"></a>头歌课程网址</h2><p>头歌实践教学平台：<a href=\"https://www.educoder.net/shixuns/qpmhnsiy/challenges\">https://www.educoder.net/shixuns/qpmhnsiy/challenges</a></p>\n<blockquote>\n<h2 id=\"写在最后\"><a href=\"#写在最后\" class=\"headerlink\" title=\"写在最后\"></a>写在最后</h2><p>无论你是计算机小白，还是佬儿，或者是考研党，或者是摸鱼翁，能在此相遇即是缘分，欢迎大家访问我的博客，链接见下面，如果你对写博文很感兴趣，或者说想加入我一起打造这个小网站，你可以在博客的评论区，或者本文的评论区联系我，总之，话不多说，一起努力！沉淀的知识都是自己的财富！</p>\n<p>送给大家八个字：慢下来，走好每一步！</p>\n<p>CS_GUIDER博客链接：</p>\n<p><a href=\"https://wlei224.gitee.io/\">https://wlei224.gitee.io</a>（建议访问这个，速度极快）<br><a href=\"https://wl2o2o.github.io/\">https://wl2o2o.github.io</a>（github托管，可能访问慢）<img src=\"https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311210936718.png\" alt=\"我的Hexo静态博客\"><br>我的开源博客涵盖了<strong>八股文</strong>、Java基础、JVM、MySQL、Linux、框架技术、算法以及其他领域的文章，如果你对建站比较感兴趣，你也想沉淀自己的知识，欢迎访问我的网站，不定时更新连载我的博客搭建版本记录，踩坑记录或者是我基于hexo的fluid主题增加的小功能，欢迎大家访问和咨询。<br><img src=\"https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311210936197.png\" alt=\"article categories\"></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"通关前的啰嗦（属于知识补充，不想看就跳过）\"><a href=\"#通关前的啰嗦（属于知识补充，不想看就跳过）\" class=\"headerlink\" title=\"通关前的啰嗦（属于知识补充，不想看就跳过）\"></a>通关前的啰嗦（属于知识补充，不想看就跳过）</h1><blockquote>\n<h2 id=\"小广告：\"><a href=\"#小广告：\" class=\"headerlink\" title=\"小广告：\"></a>小广告：</h2><p><em><strong>见者有缘，欢迎大家访问我的博客【CS_GUIDER】：<br><a href=\"https://wlei224.gitee.io/\">https://wlei224.gitee.io</a> （建议访问这个，速度极快）<br><a href=\"https://wl2o2o.github.io/\">https://wl2o2o.github.io</a>（github托管，可能访问慢）</strong></em></p>\n<p>我的开源博客涵盖了<strong>八股文</strong>、<strong>Java基础</strong>、<strong>JVM</strong>、<strong>MySQL</strong>、<strong>Linux</strong>、<strong>框架技术</strong>、<strong>算法</strong>以及其他领域的文章，如果你想搭建自己的博客，或者是想沉淀知识，欢迎访问我的网站，长期不定时更新连载我的博客搭建版本记录以及搭建踩坑记录，以及基于原 fluid 主题增加的功能，欢迎大家访问和咨询。</p>\n<p><img src=\"https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311210931702.png\" alt=\"博客文章\"></p>\n</blockquote>\n<blockquote>\n<h2 id=\"写在前面\"><a href=\"#写在前面\" class=\"headerlink\" title=\"写在前面\"></a>写在前面</h2><p>别划走！！！这篇博客就是你要找的头歌教学实践平台上的：第四关：DNS服务器配置的保姆级通关步骤。</p>\n<p><img src=\"https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311210935053.png\" alt=\"头歌实践教学平台-Linux网络实战（一）第四关\"><br><img src=\"https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311210935591.png\" alt=\"成功图\"> 如上图所示，本关题解笔者已经通过，并测验了多次，为避免出错，可以先按照如下步骤，直接复制即可，通关后想了解原理，再回过头来一步一步进行，如果遇到什么问题，欢迎在评论区进行讨论！</p>\n</blockquote>\n<h1 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h1><h2 id=\"相关知识背景\"><a href=\"#相关知识背景\" class=\"headerlink\" title=\"相关知识背景\"></a>相关知识背景</h2><p><strong>域名</strong>：<code>Internet</code>上某一台计算机或计算机组的名称，是<code>IP地址</code>的映射。域名解析实际上就是把域名映射回<code>IP地址</code>。</p>\n<p><strong>域名解析的过程</strong>：当一个浏览者在浏览器地址框中打入某一个域名，或者从其他网站点击了链接来到了这个域名，浏览器向这个用户的上网接入商发出域名请求，接入商的<code>DNS服务器</code>要查询域名数据库，看这个域名的<code>DNS服务器</code>是什么。然后到<code>DNS服务器</code>中抓取<code>DNS记录</code>，也就是获取这个域名指向哪一个<code>IP地址</code>。在获得这个<code>IP信息</code>后，接入商的服务器就去这个<code>IP地址</code>所对应的服务器上抓取网页内容，然后传输给发出请求的浏览器。<br>Linux中<code>/etc/resolv.conf</code>文件是<code>DNS客户机</code>配置文件，用于设置<code>DNS服务器</code>的<code>IP地址</code>及<code>DNS域名</code>，还包含了主机的域名搜索顺序。</p>\n<p><strong>正解与反解的Zone意义</strong>：<br><code>DNS系统</code>最主要的功能就是互查主机名与<code>IP</code>，由于计算机在网络上只认识<code>IP地址</code>，所以，一般来说，我们称由主机名查找<code>IP</code>的过程为正解，由<code>IP</code>查询得到主机名为反解。</p>\n<p>Zone(区域)：一个正解或反解的设置就是一个zone，通常一个配置文件就是一个zone。</p>\n<h1 id=\"通关保姆级步骤（点击直达）\"><a href=\"#通关保姆级步骤（点击直达）\" class=\"headerlink\" title=\"通关保姆级步骤（点击直达）\"></a>通关保姆级步骤（点击直达）</h1><p>Tips：头歌平台的环境是ubantu版本的Linux系统，在Linux系统下可以通过Ctrl+insert进行复制，Shift+insert进行粘贴。</p>\n<h2 id=\"安装DNS服务器并开启服务\"><a href=\"#安装DNS服务器并开启服务\" class=\"headerlink\" title=\"安装DNS服务器并开启服务\"></a>安装DNS服务器并开启服务</h2><blockquote>\n<p>注意：严格<strong>按照如下</strong>两个步骤的<strong>顺序</strong>进行 bind 任务环境的安装与初始化。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">1、更新安装源后、安装DNS服务器（共两个命令）</th>\n<th>apt-get update</th>\n<th>apt-get install bind9</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><strong>2、开启DNS服务</strong></td>\n<td><strong>service bind9 start</strong></td>\n<td></td>\n</tr>\n</tbody></table>\n<p>具体编程要求如下：<br>先有域名test.com，然后将该域名与IP地址：10.40.211.244相绑定在一起。</p>\n</blockquote>\n<p><strong>避雷器提醒</strong>：准备bind和host环境时，一定要先下载bind，再下载host！否则会影响映射成功，原因待补充… …</p>\n<p>补充原因：</p>\n<blockquote>\n<p>在配置DNS服务器时，需要先下载BIND软件包，因为BIND是一种开源的DNS服务器软件，它实现了域名解析服务，可以将域名转换为IP地址。如果没有安装BIND软件包，则无法实现DNS服务器的基本功能。</p>\n<p>下载HOST软件包是为了建立本地域名解析服务，可以将本地主机名映射到IP地址。如果先下载HOST软件包而没有安装BIND软件包，则无法将域名解析请求转发到DNS服务器，这会导致域名无法解析成功。因此，在配置DNS服务器时，需要先安装BIND软件包，再安装HOST软件包，以确保域名解析服务能够正常运行。</p>\n</blockquote>\n<h2 id=\"一、标题配置域名和IP的正解与反解zone：\"><a href=\"#一、标题配置域名和IP的正解与反解zone：\" class=\"headerlink\" title=\"一、标题配置域名和IP的正解与反解zone：\"></a>一、标题配置域名和IP的正解与反解zone：</h2><p>命令：</p>\n<figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmd\">vi /etc/bind/named.conf.default-zones<br></code></pre></td></tr></table></figure>\n\n\n<p>添加如下:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">zone <span class=\"hljs-string\">&quot;test.com&quot;</span>&#123;  <br>    type master;  <br>    file <span class=\"hljs-string\">&quot;/etc/bind/db.test.com&quot;</span>;  <br>&#125;;\t\t<span class=\"hljs-comment\">//正向解析</span><br><br>zone <span class=\"hljs-string\">&quot;211.40.10.in-addr.arpa&quot;</span>&#123;  <br>    type master;<br>    file <span class=\"hljs-string\">&quot;/etc/bind/db.10&quot;</span>;  <br>&#125;;  \t<span class=\"hljs-comment\">//反向解析</span><br></code></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"二、新建-etc-bind-db-test-com文件\"><a href=\"#二、新建-etc-bind-db-test-com文件\" class=\"headerlink\" title=\"二、新建/etc/bind/db.test.com文件\"></a>二、新建/etc/bind/db.test.com文件</h2><p>命令：</p>\n<figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmd\">vi /etc/bind/db.test.com<br></code></pre></td></tr></table></figure>\n\n<p>添加如下:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">;  <br>; <span class=\"hljs-variable constant_\">BIND</span> data file <span class=\"hljs-keyword\">for</span> local loopback interface  <br>;  <br>$TTL    <span class=\"hljs-number\">604800</span>  <br>@       <span class=\"hljs-variable constant_\">IN</span>      <span class=\"hljs-variable constant_\">SOA</span>     test.<span class=\"hljs-property\">com</span>. root.<span class=\"hljs-property\">test</span>.<span class=\"hljs-property\">com</span>. (  <br>                                     <span class=\"hljs-number\">2</span>         ; <span class=\"hljs-title class_\">Serial</span>  <br>   \t                            <span class=\"hljs-number\">604800</span>         ; <span class=\"hljs-title class_\">Refresh</span>  <br>\t                             <span class=\"hljs-number\">86400</span>         ; <span class=\"hljs-title class_\">Retry</span>  <br>\t                           <span class=\"hljs-number\">2419200</span>         ; <span class=\"hljs-title class_\">Expire</span>  <br>\t                            <span class=\"hljs-number\">604800</span> )       ; <span class=\"hljs-title class_\">Negative</span> <span class=\"hljs-title class_\">Cache</span> <span class=\"hljs-variable constant_\">TTL</span><br>;  <br>@       <span class=\"hljs-variable constant_\">IN</span>      <span class=\"hljs-variable constant_\">NS</span>      test.<span class=\"hljs-property\">com</span>.  <br>@       <span class=\"hljs-variable constant_\">IN</span>      A       <span class=\"hljs-number\">10.40</span><span class=\"hljs-number\">.211</span><span class=\"hljs-number\">.244</span>  <br></code></pre></td></tr></table></figure>\n\n\n<h2 id=\"三、新建-etc-bind-db-10文件\"><a href=\"#三、新建-etc-bind-db-10文件\" class=\"headerlink\" title=\"三、新建/etc/bind/db.10文件\"></a>三、新建/etc/bind/db.10文件</h2><p>命令：</p>\n<figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmd\">vi /etc/bind/db.<span class=\"hljs-number\">10</span><br></code></pre></td></tr></table></figure>\n\n<p>添加如下:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">;  <br>; <span class=\"hljs-variable constant_\">BIND</span> reverse data file <span class=\"hljs-keyword\">for</span> local loopback interface  <br>;  <br>$TTL    <span class=\"hljs-number\">604800</span>  <br>@       <span class=\"hljs-variable constant_\">IN</span>      <span class=\"hljs-variable constant_\">SOA</span>     test.<span class=\"hljs-property\">com</span>. root.<span class=\"hljs-property\">test</span>.<span class=\"hljs-property\">com</span>. (  <br>                                    <span class=\"hljs-number\">1</span>         ; <span class=\"hljs-title class_\">Serial</span>  <br>                               <span class=\"hljs-number\">604800</span>         ; <span class=\"hljs-title class_\">Refresh</span>  <br>                                <span class=\"hljs-number\">86400</span>         ; <span class=\"hljs-title class_\">Retry</span>  <br>                              <span class=\"hljs-number\">2419200</span>         ; <span class=\"hljs-title class_\">Expire</span>  <br>                               <span class=\"hljs-number\">604800</span> )       ; <span class=\"hljs-title class_\">Negative</span> <span class=\"hljs-title class_\">Cache</span> <span class=\"hljs-variable constant_\">TTL</span>  <br>;  <br>@       <span class=\"hljs-variable constant_\">IN</span>      <span class=\"hljs-variable constant_\">NS</span>      test.<span class=\"hljs-property\">com</span>.  <br><span class=\"hljs-number\">244</span>      <span class=\"hljs-variable constant_\">IN</span>      <span class=\"hljs-variable constant_\">PTR</span>     test.<span class=\"hljs-property\">com</span>. <br></code></pre></td></tr></table></figure>\n\n\n<h2 id=\"四、修改DNS服务器搜索顺序，将本地作为DNS搜索的第一搜索目录\"><a href=\"#四、修改DNS服务器搜索顺序，将本地作为DNS搜索的第一搜索目录\" class=\"headerlink\" title=\"四、修改DNS服务器搜索顺序，将本地作为DNS搜索的第一搜索目录\"></a>四、修改DNS服务器搜索顺序，将本地作为DNS搜索的第一搜索目录</h2><p>命令：</p>\n<figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmd\">vim /etc/resolv.conf<br></code></pre></td></tr></table></figure>\n\n<p>打开/etc/resolv.conf文件后添加到第一行：</p>\n<figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmd\">nameserver <span class=\"hljs-number\">127</span>.<span class=\"hljs-number\">0</span>.<span class=\"hljs-number\">0</span>.<span class=\"hljs-number\">1</span> <br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311210936377.png\" alt=\"使用vi命令打开文件后添加一行：nameserver 127.0.0.1\"></p>\n<h2 id=\"五、不要忘记重新启动bind服务器\"><a href=\"#五、不要忘记重新启动bind服务器\" class=\"headerlink\" title=\"五、不要忘记重新启动bind服务器\"></a>五、不要忘记重新启动bind服务器</h2><figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmd\">service bind9 restart<br></code></pre></td></tr></table></figure>\n\n\n<h2 id=\"六、最后安装host命令\"><a href=\"#六、最后安装host命令\" class=\"headerlink\" title=\"六、最后安装host命令\"></a>六、最后安装host命令</h2><figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmd\">apt-get install host<br></code></pre></td></tr></table></figure>\n\n\n<h2 id=\"七、查询域名和IP是否关联\"><a href=\"#七、查询域名和IP是否关联\" class=\"headerlink\" title=\"七、查询域名和IP是否关联\"></a>七、查询域名和IP是否关联</h2><p>第一步：</p>\n<figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmd\">host test.com<br></code></pre></td></tr></table></figure>\n<p>第二步：</p>\n<figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmd\">host <span class=\"hljs-number\">10</span>.<span class=\"hljs-number\">40</span>.<span class=\"hljs-number\">211</span>.<span class=\"hljs-number\">244</span><br></code></pre></td></tr></table></figure>\n\n<p>结束！<br>直接开始评测！</p>\n<h2 id=\"头歌课程网址\"><a href=\"#头歌课程网址\" class=\"headerlink\" title=\"头歌课程网址\"></a>头歌课程网址</h2><p>头歌实践教学平台：<a href=\"https://www.educoder.net/shixuns/qpmhnsiy/challenges\">https://www.educoder.net/shixuns/qpmhnsiy/challenges</a></p>\n<blockquote>\n<h2 id=\"写在最后\"><a href=\"#写在最后\" class=\"headerlink\" title=\"写在最后\"></a>写在最后</h2><p>无论你是计算机小白，还是佬儿，或者是考研党，或者是摸鱼翁，能在此相遇即是缘分，欢迎大家访问我的博客，链接见下面，如果你对写博文很感兴趣，或者说想加入我一起打造这个小网站，你可以在博客的评论区，或者本文的评论区联系我，总之，话不多说，一起努力！沉淀的知识都是自己的财富！</p>\n<p>送给大家八个字：慢下来，走好每一步！</p>\n<p>CS_GUIDER博客链接：</p>\n<p><a href=\"https://wlei224.gitee.io/\">https://wlei224.gitee.io</a>（建议访问这个，速度极快）<br><a href=\"https://wl2o2o.github.io/\">https://wl2o2o.github.io</a>（github托管，可能访问慢）<img src=\"https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311210936718.png\" alt=\"我的Hexo静态博客\"><br>我的开源博客涵盖了<strong>八股文</strong>、Java基础、JVM、MySQL、Linux、框架技术、算法以及其他领域的文章，如果你对建站比较感兴趣，你也想沉淀自己的知识，欢迎访问我的网站，不定时更新连载我的博客搭建版本记录，踩坑记录或者是我基于hexo的fluid主题增加的小功能，欢迎大家访问和咨询。<br><img src=\"https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311210936197.png\" alt=\"article categories\"></p>\n</blockquote>\n"},{"title":"CSGUIDER'S八股文（连载中！）","index_img":"https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311161446867.png","excerpt":"MySQL形象八股文，不形象你打我","abbrlink":23390,"date":"2023-11-16T06:33:14.000Z","_content":"\n- [x] 基础篇\n- [x] 架构篇\n- [x] 存储引擎\n- [ ] 日志管理\n- [ ] SQL调优\n- [ ] 索引\n- [ ] 锁\n- [ ] 事务\n- [ ] 高可用/性能\n- [ ] 运维\n\n# MySQL形象八股文，不形象你打我\n\n*首先，自我洗脑：MySQL不难！MySQL不难！MySQL不难！！！*\n\n> 学习 MySQL 之前，我们先问问自己什么是 MySQL ？他是一个关系型数据库（**R-DBMS：relational database manage system**），顾名思义就是用于存放数据的。\n>\n> 为什么大家都学 MySQL ，有什么优点？用我的屁股想一想，首先肯定稳定、好用、免费，再加其他的优点，所以就被广泛使用了。\n>\n> 🆗，那我们就话不多说，下面围绕 MySQL 就是一个存放数据的房子的理念（什么？放数据的房子？那么就是快递驿站吗），浅析 MySQL！\n\n## 基础篇\n\n> Q：什么是数据库第一二三范式？\n\n  A：\n\n- 第一范式：又称专一范式，字段不能再拆分；\n- 第二范式：又称 MySQL 家规，必须完全依赖顺从主键，若有与主键无关字段者，设置为联合主键；\n- 第三范式：又称恋爱脑范式，遵守家规，远离小三。\n\n![img](https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311181056209.jpeg)\n\n一般来说，“`小企`”这个渣男（也可能不止`小企`）在日常开发中都是违反`范式家规`标准的，要为了性能，通过一些冗余的数据，空间换时间。\n\n> Q：MySQL 有几种字段类型？\n\n  A：字段类型大致可以分为三类：数值类型、字符类型、时间类型\n\n- 数值类型：\n\n  - 整数类型：微小TYNYINT、小SMALLINT、中等MEDIUMINT、INT、大整型BIGINT；\n\n  - 小数类型：FLOAT、DUBBLE、DECIMAL、NUMERIC\n\n- 字符类型：（还有好几种）\n\n  - CHAR\n\n  - VARCHAR\n  - BINARY\n  - VARBINARY\n  - BLOB\t\t\n    - 二进制大对象类型，用于存储二进制数据（如文档、图像、音频等），有两个分支，小TINYBLOB和长LONGBLOB\n\n  - TEXT\n    - 文本类型，不许预设长度，可根据需要动态划分空间。也分为 TINYTEXT 和 LONGTEXT，以适应不同大小的文本数据\n\n  - ENUM\n\n    - 枚举类型，限制了字段存储的值\n\n  - SET\n\n    - 集合类型，不可重复\n\n- 日期/时间类型\n\n  - DATE\n  - TIME\t\n  - DATETIME\n  - TIMESTAMP\n\n> Q：CHAR 和 VARCHAR 字符类型的区别?\n\n  A：\n\n- `char`长度固定，所以存取速度快，甚至快varchar一半；如果长度没有达到预设值，用空格补充。因为定长，所以浪费一些空间，属于空间换时间。最多可存`255`个字符；\n- `varchar`字符长度可变，所以不浪费空间，属于时间换空间。最多可存放`65532`个字符串，至于为什么是`65532`，那就需要看相关存储引擎`InnoDB`的知识了。\n\n> Q：说一说两个**时间类型**的区别\n\n  A：\n\n- 时间起始范围不同，`TIMESTAMP`为`1970-2028`，`datetime`为`1000-9999`\n- 存储空间不同，`TIMESTAMP`存储空间为`4字节`，`DATETIME`存储空间为`8字节`\n- 时区，`TIMESTAMP`存储时间依赖于时区显示，`DATETIME`存储时间与时区无关\n- 默认值，`TIMESTAMP`不为空，后者为空\n\n> Q：什么类型可以用于存储二进制数据？\n\nA：blob，Blob常常是数据库中用来存储二进制文件的字段类型。通常用于存储大量的数据，例如音频、视频、图片等文件，由于它们的大小，必须使用特殊的方式来处理（例如：上传、下载或者存放到一个数据库）。\n\n> Q：怎么存储`emoji`表情？\n\nA：\n\n> Q：你了解 SQL 的执行流程吗？\n\nA：为了更加直观，借用`三元表达式`的语法来描述一条 SQL 执行的流程。\n\n1. 首先检查 SQL 是否有执行的权限？ 查询结果缓存 ：返回报错信息；\n2. 是否有缓存？ 直接返回结果 ：检查 SQL 是否有语法错误；\n3. 语法正确？ MySQL 的服务器对语句进行优化，确定执行方案 ：\n4. 确定方案？调用数据库引擎接口，执行方案，返回执行结果。\n\n> Q：什么是 DDL 与 DML ?\n\nA：是 DBMS 中的不同类型的语言指令集。\n\n- DDL：database definition language，定义或修改数据库结构的命令，例如：CREAT、ALTER、DROP、TRUNCATE(截断，命令用于快速删除表中的所有数据但不删除表本身。)\n- DML：database manipulation language，用于操作数据库中的数据的命令，例如CURD\n\n## 架构篇\n\n首先，收起你自认为架构篇很难理解的想法，我们还是从 MySQL 是一个房子入手。\n\n> Q：你是怎么理解 MySQL 的架构的？\n\nA：MySQL 就相当于一个档案室，存放不同的档案，一个数据库好用，肯定有原因，架构也就是构成。那么一个快递驿站肯定包括下面这三部分：\n\n- 快递驿站APP--客户端（与用户交互的关键）\n- 工作人员--存储引擎（我 MySQL 学的不好，我猜应该是与存储规则相关的）\n- 快递货架--服务层（堆放数据，索引数据）\n\n`{{{{{{待画图！！！}}}}}}`\n\nMySQL 逻辑架构图主要分为三层：客户端、存储引擎、服务层\n\n1. 客户端层：这是与 MySQL 服务器交互的接口，它提供了用户与服务器进行通信的手段。客户端层处理连接请求、处理查询请求、认证用户权限以及执行与服务器之间的通信。此外，这一层还负责处理与服务相关的各种任务，例如管理连接、处理错误、诊断和调试等。\n2. Server 层：这一层是 MySQL 的核心，它包含了大多数 MySQL 的服务功能。这包括解析查询语句、分析查询计划、优化查询计划以及执行查询计划等。此外，Server 层还负责处理内置函数，如日期、时间、数学和加密函数等。对于跨存储引擎的功能，如存储过程、触发器和视图等，也都在这一层实现。这些功能对于整个数据库系统来说是至关重要的。\n3. 存储引擎层：这一层负责数据的存储和提取。存储引擎负责与底层操作系统交互，管理数据的存储位置、文件格式和索引等。不同的存储引擎具有不同的特点和性能，可以根据应用的需求选择适合的存储引擎。MySQL 支持多种存储引擎，如 InnoDB、MyISAM、Memory 等。存储引擎通过 API 与 Server 层进行通信，这些接口屏蔽了不同存储引擎之间的差异，使得上层的应用程序可以透明地访问底层的数据存储方式。\n\n![img](https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311201957518.png)\n\n\n\n> Q：数据库调优，你是怎么做的\n\nA：以下回答来自文心一言，待优化，回答要结合MySQL的**架构以及存储引擎**来说，以及自己的见解\n\n数据库调优的方法有很多，以下是一些常见的调优方法：\n\n1. 定期优化重建数据库：定期对数据库进行优化和重建，可以消除数据库中的碎片和冗余数据，提高数据库的性能和稳定性。\n2. 减少磁盘写入操作：通过使用缓存技术、优化数据插入和更新操作、避免频繁的磁盘操作等手段，可以减少磁盘的写入操作，提高数据库的性能。\n3. 合理使用索引：索引是提高查询速度的重要手段，通过添加合适的索引可以加速查询操作。需要根据查询语句和表结构来确定需要添加的索引。\n4. 优化SQL语句：通过优化SQL语句，可以减少数据库的负载和提高查询效率。例如，避免使用SELECT * 语句，只查询需要的数据字段；避免在查询中使用复杂的子查询和连接查询等。\n5. 调整数据库参数：根据实际需求和性能测试结果，调整数据库的参数可以提高数据库的性能和响应速度。\n6. 使用存储过程和触发器：存储过程和触发器可以减少数据库的负载和提高数据处理效率。通过将常用的数据处理逻辑封装到存储过程和触发器中，可以减少对数据库的频繁操作。\n7. 数据库分区：对于大型数据库，可以采用分区技术将数据分散到不同的磁盘上，提高I/O处理能力和并发性能。\n8. 使用RAID技术：RAID技术可以提供高性能、高可靠性和高容错的存储系统，通过将数据分散到多个磁盘上，可以提高I/O处理能力和数据安全性。\n9. 使用缓存技术：缓存技术可以减少磁盘访问次数和提高数据处理速度。例如，使用内存缓存来存储经常访问的数据，减少对磁盘的访问次数。\n10. 定期备份数据：定期备份数据可以防止数据丢失和灾难性故障，同时也可以提高数据处理效率和安全性。\n\n这些方法可以根据实际情况选择使用，但需要注意的是，数据库调优是一个复杂的过程，需要综合考虑系统硬件、应用程序和数据等方面的因素。因此，在进行数据库调优时，建议根据实际情况进行测试和评估，以确保达到最佳的效果。\n\n> Q：你知道三种存储引擎的区别吗？\n\nA：\n\n| 功能         | MlSAM | MEMORY | InnoDB |\n| ------------ | ----- | ------ | ------ |\n| 存储限制     | 256TB | RAM    | 64TB   |\n| 支持事务     | No    | No     | Yes    |\n| 支持全文索引 | Yes   | No     | Yes    |\n| 支持树索引   | Yes   | Yes    | Yes    |\n| 支持哈希索引 | No    | Yes    | Yes    |\n| 支持数据缓存 | No    | N/A    | Yes    |\n| 支持外键     | No    | No     | Yes    |\n\n怎么选择存储引擎的使用？\n\n1. 想用事务安全，并要求实现并发控制，用InnoDB\n2. 主要用来查询与插入记录，用MyISAM\n3. 临时存放数据，不考虑安全，用MEMORY\n\n**tips：存储引擎是基于数据表**的，所以一个数据库的多个表**可以根据实际业务**，来**使用不同的存储引擎**，以此**提高**整个数据库的**性能**。\n\n| 区别       | MyISAM                                                       | InnoDB                                                       |\n| ---------- | ------------------------------------------------------------ | ------------------------------------------------------------ |\n| 存储结构   | 每个表存储成3个文件：表定义文件（.frm）数据文件（.MYD）索引文件（.MYI） | 所有表存放于同一数据文件，也可能多个文件或者独立的表空间文件，表的大小一般为2G |\n| 事务       | 不支持                                                       | 支持                                                         |\n| 最小锁粒度 | 表级锁，更新会锁表，导致其他查询与插入阻塞                   | 行级锁                                                       |\n| 索引类型   | 非聚簇索引，B树                                              | 聚簇索引，B+树                                               |\n| 主键       | 可无                                                         | 如未设置，自动生成（用户不可见）                             |\n| 外键       | 不支持                                                       | 支持                                                         |\n| 表行数     | 存有缓存，直接取出                                           | 需要遍历整个表                                               |\n\n*🆗架构篇就到这里，有没发现，似乎MySQL的基础架构也就这回事，也没啥难点。最后强调一点，当我们试图学会一门知识的时候，不要机械记忆，重要的是融会贯通（内心OS：啥子贯通？不就是理论翻译成人话吗？），找到适合自己记忆的方法。*\n\n","source":"_posts/面渣八股.md","raw":"---\ntitle: CSGUIDER'S八股文（连载中！）\nindex_img: >-\n  https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311161446867.png\nexcerpt: MySQL形象八股文，不形象你打我\ncategories:\n  - Java notes\ntags:\n  - 八股文\n  - 面渣逆袭\nabbrlink: 23390\ndate: 2023-11-16 14:33:14 \n---\n\n- [x] 基础篇\n- [x] 架构篇\n- [x] 存储引擎\n- [ ] 日志管理\n- [ ] SQL调优\n- [ ] 索引\n- [ ] 锁\n- [ ] 事务\n- [ ] 高可用/性能\n- [ ] 运维\n\n# MySQL形象八股文，不形象你打我\n\n*首先，自我洗脑：MySQL不难！MySQL不难！MySQL不难！！！*\n\n> 学习 MySQL 之前，我们先问问自己什么是 MySQL ？他是一个关系型数据库（**R-DBMS：relational database manage system**），顾名思义就是用于存放数据的。\n>\n> 为什么大家都学 MySQL ，有什么优点？用我的屁股想一想，首先肯定稳定、好用、免费，再加其他的优点，所以就被广泛使用了。\n>\n> 🆗，那我们就话不多说，下面围绕 MySQL 就是一个存放数据的房子的理念（什么？放数据的房子？那么就是快递驿站吗），浅析 MySQL！\n\n## 基础篇\n\n> Q：什么是数据库第一二三范式？\n\n  A：\n\n- 第一范式：又称专一范式，字段不能再拆分；\n- 第二范式：又称 MySQL 家规，必须完全依赖顺从主键，若有与主键无关字段者，设置为联合主键；\n- 第三范式：又称恋爱脑范式，遵守家规，远离小三。\n\n![img](https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311181056209.jpeg)\n\n一般来说，“`小企`”这个渣男（也可能不止`小企`）在日常开发中都是违反`范式家规`标准的，要为了性能，通过一些冗余的数据，空间换时间。\n\n> Q：MySQL 有几种字段类型？\n\n  A：字段类型大致可以分为三类：数值类型、字符类型、时间类型\n\n- 数值类型：\n\n  - 整数类型：微小TYNYINT、小SMALLINT、中等MEDIUMINT、INT、大整型BIGINT；\n\n  - 小数类型：FLOAT、DUBBLE、DECIMAL、NUMERIC\n\n- 字符类型：（还有好几种）\n\n  - CHAR\n\n  - VARCHAR\n  - BINARY\n  - VARBINARY\n  - BLOB\t\t\n    - 二进制大对象类型，用于存储二进制数据（如文档、图像、音频等），有两个分支，小TINYBLOB和长LONGBLOB\n\n  - TEXT\n    - 文本类型，不许预设长度，可根据需要动态划分空间。也分为 TINYTEXT 和 LONGTEXT，以适应不同大小的文本数据\n\n  - ENUM\n\n    - 枚举类型，限制了字段存储的值\n\n  - SET\n\n    - 集合类型，不可重复\n\n- 日期/时间类型\n\n  - DATE\n  - TIME\t\n  - DATETIME\n  - TIMESTAMP\n\n> Q：CHAR 和 VARCHAR 字符类型的区别?\n\n  A：\n\n- `char`长度固定，所以存取速度快，甚至快varchar一半；如果长度没有达到预设值，用空格补充。因为定长，所以浪费一些空间，属于空间换时间。最多可存`255`个字符；\n- `varchar`字符长度可变，所以不浪费空间，属于时间换空间。最多可存放`65532`个字符串，至于为什么是`65532`，那就需要看相关存储引擎`InnoDB`的知识了。\n\n> Q：说一说两个**时间类型**的区别\n\n  A：\n\n- 时间起始范围不同，`TIMESTAMP`为`1970-2028`，`datetime`为`1000-9999`\n- 存储空间不同，`TIMESTAMP`存储空间为`4字节`，`DATETIME`存储空间为`8字节`\n- 时区，`TIMESTAMP`存储时间依赖于时区显示，`DATETIME`存储时间与时区无关\n- 默认值，`TIMESTAMP`不为空，后者为空\n\n> Q：什么类型可以用于存储二进制数据？\n\nA：blob，Blob常常是数据库中用来存储二进制文件的字段类型。通常用于存储大量的数据，例如音频、视频、图片等文件，由于它们的大小，必须使用特殊的方式来处理（例如：上传、下载或者存放到一个数据库）。\n\n> Q：怎么存储`emoji`表情？\n\nA：\n\n> Q：你了解 SQL 的执行流程吗？\n\nA：为了更加直观，借用`三元表达式`的语法来描述一条 SQL 执行的流程。\n\n1. 首先检查 SQL 是否有执行的权限？ 查询结果缓存 ：返回报错信息；\n2. 是否有缓存？ 直接返回结果 ：检查 SQL 是否有语法错误；\n3. 语法正确？ MySQL 的服务器对语句进行优化，确定执行方案 ：\n4. 确定方案？调用数据库引擎接口，执行方案，返回执行结果。\n\n> Q：什么是 DDL 与 DML ?\n\nA：是 DBMS 中的不同类型的语言指令集。\n\n- DDL：database definition language，定义或修改数据库结构的命令，例如：CREAT、ALTER、DROP、TRUNCATE(截断，命令用于快速删除表中的所有数据但不删除表本身。)\n- DML：database manipulation language，用于操作数据库中的数据的命令，例如CURD\n\n## 架构篇\n\n首先，收起你自认为架构篇很难理解的想法，我们还是从 MySQL 是一个房子入手。\n\n> Q：你是怎么理解 MySQL 的架构的？\n\nA：MySQL 就相当于一个档案室，存放不同的档案，一个数据库好用，肯定有原因，架构也就是构成。那么一个快递驿站肯定包括下面这三部分：\n\n- 快递驿站APP--客户端（与用户交互的关键）\n- 工作人员--存储引擎（我 MySQL 学的不好，我猜应该是与存储规则相关的）\n- 快递货架--服务层（堆放数据，索引数据）\n\n`{{{{{{待画图！！！}}}}}}`\n\nMySQL 逻辑架构图主要分为三层：客户端、存储引擎、服务层\n\n1. 客户端层：这是与 MySQL 服务器交互的接口，它提供了用户与服务器进行通信的手段。客户端层处理连接请求、处理查询请求、认证用户权限以及执行与服务器之间的通信。此外，这一层还负责处理与服务相关的各种任务，例如管理连接、处理错误、诊断和调试等。\n2. Server 层：这一层是 MySQL 的核心，它包含了大多数 MySQL 的服务功能。这包括解析查询语句、分析查询计划、优化查询计划以及执行查询计划等。此外，Server 层还负责处理内置函数，如日期、时间、数学和加密函数等。对于跨存储引擎的功能，如存储过程、触发器和视图等，也都在这一层实现。这些功能对于整个数据库系统来说是至关重要的。\n3. 存储引擎层：这一层负责数据的存储和提取。存储引擎负责与底层操作系统交互，管理数据的存储位置、文件格式和索引等。不同的存储引擎具有不同的特点和性能，可以根据应用的需求选择适合的存储引擎。MySQL 支持多种存储引擎，如 InnoDB、MyISAM、Memory 等。存储引擎通过 API 与 Server 层进行通信，这些接口屏蔽了不同存储引擎之间的差异，使得上层的应用程序可以透明地访问底层的数据存储方式。\n\n![img](https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311201957518.png)\n\n\n\n> Q：数据库调优，你是怎么做的\n\nA：以下回答来自文心一言，待优化，回答要结合MySQL的**架构以及存储引擎**来说，以及自己的见解\n\n数据库调优的方法有很多，以下是一些常见的调优方法：\n\n1. 定期优化重建数据库：定期对数据库进行优化和重建，可以消除数据库中的碎片和冗余数据，提高数据库的性能和稳定性。\n2. 减少磁盘写入操作：通过使用缓存技术、优化数据插入和更新操作、避免频繁的磁盘操作等手段，可以减少磁盘的写入操作，提高数据库的性能。\n3. 合理使用索引：索引是提高查询速度的重要手段，通过添加合适的索引可以加速查询操作。需要根据查询语句和表结构来确定需要添加的索引。\n4. 优化SQL语句：通过优化SQL语句，可以减少数据库的负载和提高查询效率。例如，避免使用SELECT * 语句，只查询需要的数据字段；避免在查询中使用复杂的子查询和连接查询等。\n5. 调整数据库参数：根据实际需求和性能测试结果，调整数据库的参数可以提高数据库的性能和响应速度。\n6. 使用存储过程和触发器：存储过程和触发器可以减少数据库的负载和提高数据处理效率。通过将常用的数据处理逻辑封装到存储过程和触发器中，可以减少对数据库的频繁操作。\n7. 数据库分区：对于大型数据库，可以采用分区技术将数据分散到不同的磁盘上，提高I/O处理能力和并发性能。\n8. 使用RAID技术：RAID技术可以提供高性能、高可靠性和高容错的存储系统，通过将数据分散到多个磁盘上，可以提高I/O处理能力和数据安全性。\n9. 使用缓存技术：缓存技术可以减少磁盘访问次数和提高数据处理速度。例如，使用内存缓存来存储经常访问的数据，减少对磁盘的访问次数。\n10. 定期备份数据：定期备份数据可以防止数据丢失和灾难性故障，同时也可以提高数据处理效率和安全性。\n\n这些方法可以根据实际情况选择使用，但需要注意的是，数据库调优是一个复杂的过程，需要综合考虑系统硬件、应用程序和数据等方面的因素。因此，在进行数据库调优时，建议根据实际情况进行测试和评估，以确保达到最佳的效果。\n\n> Q：你知道三种存储引擎的区别吗？\n\nA：\n\n| 功能         | MlSAM | MEMORY | InnoDB |\n| ------------ | ----- | ------ | ------ |\n| 存储限制     | 256TB | RAM    | 64TB   |\n| 支持事务     | No    | No     | Yes    |\n| 支持全文索引 | Yes   | No     | Yes    |\n| 支持树索引   | Yes   | Yes    | Yes    |\n| 支持哈希索引 | No    | Yes    | Yes    |\n| 支持数据缓存 | No    | N/A    | Yes    |\n| 支持外键     | No    | No     | Yes    |\n\n怎么选择存储引擎的使用？\n\n1. 想用事务安全，并要求实现并发控制，用InnoDB\n2. 主要用来查询与插入记录，用MyISAM\n3. 临时存放数据，不考虑安全，用MEMORY\n\n**tips：存储引擎是基于数据表**的，所以一个数据库的多个表**可以根据实际业务**，来**使用不同的存储引擎**，以此**提高**整个数据库的**性能**。\n\n| 区别       | MyISAM                                                       | InnoDB                                                       |\n| ---------- | ------------------------------------------------------------ | ------------------------------------------------------------ |\n| 存储结构   | 每个表存储成3个文件：表定义文件（.frm）数据文件（.MYD）索引文件（.MYI） | 所有表存放于同一数据文件，也可能多个文件或者独立的表空间文件，表的大小一般为2G |\n| 事务       | 不支持                                                       | 支持                                                         |\n| 最小锁粒度 | 表级锁，更新会锁表，导致其他查询与插入阻塞                   | 行级锁                                                       |\n| 索引类型   | 非聚簇索引，B树                                              | 聚簇索引，B+树                                               |\n| 主键       | 可无                                                         | 如未设置，自动生成（用户不可见）                             |\n| 外键       | 不支持                                                       | 支持                                                         |\n| 表行数     | 存有缓存，直接取出                                           | 需要遍历整个表                                               |\n\n*🆗架构篇就到这里，有没发现，似乎MySQL的基础架构也就这回事，也没啥难点。最后强调一点，当我们试图学会一门知识的时候，不要机械记忆，重要的是融会贯通（内心OS：啥子贯通？不就是理论翻译成人话吗？），找到适合自己记忆的方法。*\n\n","slug":"面渣八股","published":1,"updated":"2023-11-20T14:54:57.009Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clpkiczjm003ofkfo4eqi1v8n","content":"<ul>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> 基础篇</li>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> 架构篇</li>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> 存储引擎</li>\n<li><input disabled=\"\" type=\"checkbox\"> 日志管理</li>\n<li><input disabled=\"\" type=\"checkbox\"> SQL调优</li>\n<li><input disabled=\"\" type=\"checkbox\"> 索引</li>\n<li><input disabled=\"\" type=\"checkbox\"> 锁</li>\n<li><input disabled=\"\" type=\"checkbox\"> 事务</li>\n<li><input disabled=\"\" type=\"checkbox\"> 高可用/性能</li>\n<li><input disabled=\"\" type=\"checkbox\"> 运维</li>\n</ul>\n<h1 id=\"MySQL形象八股文，不形象你打我\"><a href=\"#MySQL形象八股文，不形象你打我\" class=\"headerlink\" title=\"MySQL形象八股文，不形象你打我\"></a>MySQL形象八股文，不形象你打我</h1><p><em>首先，自我洗脑：MySQL不难！MySQL不难！MySQL不难！！！</em></p>\n<blockquote>\n<p>学习 MySQL 之前，我们先问问自己什么是 MySQL ？他是一个关系型数据库（<strong>R-DBMS：relational database manage system</strong>），顾名思义就是用于存放数据的。</p>\n<p>为什么大家都学 MySQL ，有什么优点？用我的屁股想一想，首先肯定稳定、好用、免费，再加其他的优点，所以就被广泛使用了。</p>\n<p>🆗，那我们就话不多说，下面围绕 MySQL 就是一个存放数据的房子的理念（什么？放数据的房子？那么就是快递驿站吗），浅析 MySQL！</p>\n</blockquote>\n<h2 id=\"基础篇\"><a href=\"#基础篇\" class=\"headerlink\" title=\"基础篇\"></a>基础篇</h2><blockquote>\n<p>Q：什么是数据库第一二三范式？</p>\n</blockquote>\n<p>  A：</p>\n<ul>\n<li>第一范式：又称专一范式，字段不能再拆分；</li>\n<li>第二范式：又称 MySQL 家规，必须完全依赖顺从主键，若有与主键无关字段者，设置为联合主键；</li>\n<li>第三范式：又称恋爱脑范式，遵守家规，远离小三。</li>\n</ul>\n<p><img src=\"https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311181056209.jpeg\" alt=\"img\"></p>\n<p>一般来说，“<code>小企</code>”这个渣男（也可能不止<code>小企</code>）在日常开发中都是违反<code>范式家规</code>标准的，要为了性能，通过一些冗余的数据，空间换时间。</p>\n<blockquote>\n<p>Q：MySQL 有几种字段类型？</p>\n</blockquote>\n<p>  A：字段类型大致可以分为三类：数值类型、字符类型、时间类型</p>\n<ul>\n<li><p>数值类型：</p>\n<ul>\n<li><p>整数类型：微小TYNYINT、小SMALLINT、中等MEDIUMINT、INT、大整型BIGINT；</p>\n</li>\n<li><p>小数类型：FLOAT、DUBBLE、DECIMAL、NUMERIC</p>\n</li>\n</ul>\n</li>\n<li><p>字符类型：（还有好几种）</p>\n<ul>\n<li><p>CHAR</p>\n</li>\n<li><p>VARCHAR</p>\n</li>\n<li><p>BINARY</p>\n</li>\n<li><p>VARBINARY</p>\n</li>\n<li><p>BLOB        </p>\n<ul>\n<li>二进制大对象类型，用于存储二进制数据（如文档、图像、音频等），有两个分支，小TINYBLOB和长LONGBLOB</li>\n</ul>\n</li>\n<li><p>TEXT</p>\n<ul>\n<li>文本类型，不许预设长度，可根据需要动态划分空间。也分为 TINYTEXT 和 LONGTEXT，以适应不同大小的文本数据</li>\n</ul>\n</li>\n<li><p>ENUM</p>\n<ul>\n<li>枚举类型，限制了字段存储的值</li>\n</ul>\n</li>\n<li><p>SET</p>\n<ul>\n<li>集合类型，不可重复</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>日期/时间类型</p>\n<ul>\n<li>DATE</li>\n<li>TIME    </li>\n<li>DATETIME</li>\n<li>TIMESTAMP</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>Q：CHAR 和 VARCHAR 字符类型的区别?</p>\n</blockquote>\n<p>  A：</p>\n<ul>\n<li><code>char</code>长度固定，所以存取速度快，甚至快varchar一半；如果长度没有达到预设值，用空格补充。因为定长，所以浪费一些空间，属于空间换时间。最多可存<code>255</code>个字符；</li>\n<li><code>varchar</code>字符长度可变，所以不浪费空间，属于时间换空间。最多可存放<code>65532</code>个字符串，至于为什么是<code>65532</code>，那就需要看相关存储引擎<code>InnoDB</code>的知识了。</li>\n</ul>\n<blockquote>\n<p>Q：说一说两个<strong>时间类型</strong>的区别</p>\n</blockquote>\n<p>  A：</p>\n<ul>\n<li>时间起始范围不同，<code>TIMESTAMP</code>为<code>1970-2028</code>，<code>datetime</code>为<code>1000-9999</code></li>\n<li>存储空间不同，<code>TIMESTAMP</code>存储空间为<code>4字节</code>，<code>DATETIME</code>存储空间为<code>8字节</code></li>\n<li>时区，<code>TIMESTAMP</code>存储时间依赖于时区显示，<code>DATETIME</code>存储时间与时区无关</li>\n<li>默认值，<code>TIMESTAMP</code>不为空，后者为空</li>\n</ul>\n<blockquote>\n<p>Q：什么类型可以用于存储二进制数据？</p>\n</blockquote>\n<p>A：blob，Blob常常是数据库中用来存储二进制文件的字段类型。通常用于存储大量的数据，例如音频、视频、图片等文件，由于它们的大小，必须使用特殊的方式来处理（例如：上传、下载或者存放到一个数据库）。</p>\n<blockquote>\n<p>Q：怎么存储<code>emoji</code>表情？</p>\n</blockquote>\n<p>A：</p>\n<blockquote>\n<p>Q：你了解 SQL 的执行流程吗？</p>\n</blockquote>\n<p>A：为了更加直观，借用<code>三元表达式</code>的语法来描述一条 SQL 执行的流程。</p>\n<ol>\n<li>首先检查 SQL 是否有执行的权限？ 查询结果缓存 ：返回报错信息；</li>\n<li>是否有缓存？ 直接返回结果 ：检查 SQL 是否有语法错误；</li>\n<li>语法正确？ MySQL 的服务器对语句进行优化，确定执行方案 ：</li>\n<li>确定方案？调用数据库引擎接口，执行方案，返回执行结果。</li>\n</ol>\n<blockquote>\n<p>Q：什么是 DDL 与 DML ?</p>\n</blockquote>\n<p>A：是 DBMS 中的不同类型的语言指令集。</p>\n<ul>\n<li>DDL：database definition language，定义或修改数据库结构的命令，例如：CREAT、ALTER、DROP、TRUNCATE(截断，命令用于快速删除表中的所有数据但不删除表本身。)</li>\n<li>DML：database manipulation language，用于操作数据库中的数据的命令，例如CURD</li>\n</ul>\n<h2 id=\"架构篇\"><a href=\"#架构篇\" class=\"headerlink\" title=\"架构篇\"></a>架构篇</h2><p>首先，收起你自认为架构篇很难理解的想法，我们还是从 MySQL 是一个房子入手。</p>\n<blockquote>\n<p>Q：你是怎么理解 MySQL 的架构的？</p>\n</blockquote>\n<p>A：MySQL 就相当于一个档案室，存放不同的档案，一个数据库好用，肯定有原因，架构也就是构成。那么一个快递驿站肯定包括下面这三部分：</p>\n<ul>\n<li>快递驿站APP–客户端（与用户交互的关键）</li>\n<li>工作人员–存储引擎（我 MySQL 学的不好，我猜应该是与存储规则相关的）</li>\n<li>快递货架–服务层（堆放数据，索引数据）</li>\n</ul>\n<p><code>&#123;&#123;&#123;&#123;&#123;&#123;待画图！！！&#125;&#125;&#125;&#125;&#125;&#125;</code></p>\n<p>MySQL 逻辑架构图主要分为三层：客户端、存储引擎、服务层</p>\n<ol>\n<li>客户端层：这是与 MySQL 服务器交互的接口，它提供了用户与服务器进行通信的手段。客户端层处理连接请求、处理查询请求、认证用户权限以及执行与服务器之间的通信。此外，这一层还负责处理与服务相关的各种任务，例如管理连接、处理错误、诊断和调试等。</li>\n<li>Server 层：这一层是 MySQL 的核心，它包含了大多数 MySQL 的服务功能。这包括解析查询语句、分析查询计划、优化查询计划以及执行查询计划等。此外，Server 层还负责处理内置函数，如日期、时间、数学和加密函数等。对于跨存储引擎的功能，如存储过程、触发器和视图等，也都在这一层实现。这些功能对于整个数据库系统来说是至关重要的。</li>\n<li>存储引擎层：这一层负责数据的存储和提取。存储引擎负责与底层操作系统交互，管理数据的存储位置、文件格式和索引等。不同的存储引擎具有不同的特点和性能，可以根据应用的需求选择适合的存储引擎。MySQL 支持多种存储引擎，如 InnoDB、MyISAM、Memory 等。存储引擎通过 API 与 Server 层进行通信，这些接口屏蔽了不同存储引擎之间的差异，使得上层的应用程序可以透明地访问底层的数据存储方式。</li>\n</ol>\n<p><img src=\"https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311201957518.png\" alt=\"img\"></p>\n<blockquote>\n<p>Q：数据库调优，你是怎么做的</p>\n</blockquote>\n<p>A：以下回答来自文心一言，待优化，回答要结合MySQL的<strong>架构以及存储引擎</strong>来说，以及自己的见解</p>\n<p>数据库调优的方法有很多，以下是一些常见的调优方法：</p>\n<ol>\n<li>定期优化重建数据库：定期对数据库进行优化和重建，可以消除数据库中的碎片和冗余数据，提高数据库的性能和稳定性。</li>\n<li>减少磁盘写入操作：通过使用缓存技术、优化数据插入和更新操作、避免频繁的磁盘操作等手段，可以减少磁盘的写入操作，提高数据库的性能。</li>\n<li>合理使用索引：索引是提高查询速度的重要手段，通过添加合适的索引可以加速查询操作。需要根据查询语句和表结构来确定需要添加的索引。</li>\n<li>优化SQL语句：通过优化SQL语句，可以减少数据库的负载和提高查询效率。例如，避免使用SELECT * 语句，只查询需要的数据字段；避免在查询中使用复杂的子查询和连接查询等。</li>\n<li>调整数据库参数：根据实际需求和性能测试结果，调整数据库的参数可以提高数据库的性能和响应速度。</li>\n<li>使用存储过程和触发器：存储过程和触发器可以减少数据库的负载和提高数据处理效率。通过将常用的数据处理逻辑封装到存储过程和触发器中，可以减少对数据库的频繁操作。</li>\n<li>数据库分区：对于大型数据库，可以采用分区技术将数据分散到不同的磁盘上，提高I/O处理能力和并发性能。</li>\n<li>使用RAID技术：RAID技术可以提供高性能、高可靠性和高容错的存储系统，通过将数据分散到多个磁盘上，可以提高I/O处理能力和数据安全性。</li>\n<li>使用缓存技术：缓存技术可以减少磁盘访问次数和提高数据处理速度。例如，使用内存缓存来存储经常访问的数据，减少对磁盘的访问次数。</li>\n<li>定期备份数据：定期备份数据可以防止数据丢失和灾难性故障，同时也可以提高数据处理效率和安全性。</li>\n</ol>\n<p>这些方法可以根据实际情况选择使用，但需要注意的是，数据库调优是一个复杂的过程，需要综合考虑系统硬件、应用程序和数据等方面的因素。因此，在进行数据库调优时，建议根据实际情况进行测试和评估，以确保达到最佳的效果。</p>\n<blockquote>\n<p>Q：你知道三种存储引擎的区别吗？</p>\n</blockquote>\n<p>A：</p>\n<table>\n<thead>\n<tr>\n<th>功能</th>\n<th>MlSAM</th>\n<th>MEMORY</th>\n<th>InnoDB</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>存储限制</td>\n<td>256TB</td>\n<td>RAM</td>\n<td>64TB</td>\n</tr>\n<tr>\n<td>支持事务</td>\n<td>No</td>\n<td>No</td>\n<td>Yes</td>\n</tr>\n<tr>\n<td>支持全文索引</td>\n<td>Yes</td>\n<td>No</td>\n<td>Yes</td>\n</tr>\n<tr>\n<td>支持树索引</td>\n<td>Yes</td>\n<td>Yes</td>\n<td>Yes</td>\n</tr>\n<tr>\n<td>支持哈希索引</td>\n<td>No</td>\n<td>Yes</td>\n<td>Yes</td>\n</tr>\n<tr>\n<td>支持数据缓存</td>\n<td>No</td>\n<td>N/A</td>\n<td>Yes</td>\n</tr>\n<tr>\n<td>支持外键</td>\n<td>No</td>\n<td>No</td>\n<td>Yes</td>\n</tr>\n</tbody></table>\n<p>怎么选择存储引擎的使用？</p>\n<ol>\n<li>想用事务安全，并要求实现并发控制，用InnoDB</li>\n<li>主要用来查询与插入记录，用MyISAM</li>\n<li>临时存放数据，不考虑安全，用MEMORY</li>\n</ol>\n<p><strong>tips：存储引擎是基于数据表</strong>的，所以一个数据库的多个表<strong>可以根据实际业务</strong>，来<strong>使用不同的存储引擎</strong>，以此<strong>提高</strong>整个数据库的<strong>性能</strong>。</p>\n<table>\n<thead>\n<tr>\n<th>区别</th>\n<th>MyISAM</th>\n<th>InnoDB</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>存储结构</td>\n<td>每个表存储成3个文件：表定义文件（.frm）数据文件（.MYD）索引文件（.MYI）</td>\n<td>所有表存放于同一数据文件，也可能多个文件或者独立的表空间文件，表的大小一般为2G</td>\n</tr>\n<tr>\n<td>事务</td>\n<td>不支持</td>\n<td>支持</td>\n</tr>\n<tr>\n<td>最小锁粒度</td>\n<td>表级锁，更新会锁表，导致其他查询与插入阻塞</td>\n<td>行级锁</td>\n</tr>\n<tr>\n<td>索引类型</td>\n<td>非聚簇索引，B树</td>\n<td>聚簇索引，B+树</td>\n</tr>\n<tr>\n<td>主键</td>\n<td>可无</td>\n<td>如未设置，自动生成（用户不可见）</td>\n</tr>\n<tr>\n<td>外键</td>\n<td>不支持</td>\n<td>支持</td>\n</tr>\n<tr>\n<td>表行数</td>\n<td>存有缓存，直接取出</td>\n<td>需要遍历整个表</td>\n</tr>\n</tbody></table>\n<p><em>🆗架构篇就到这里，有没发现，似乎MySQL的基础架构也就这回事，也没啥难点。最后强调一点，当我们试图学会一门知识的时候，不要机械记忆，重要的是融会贯通（内心OS：啥子贯通？不就是理论翻译成人话吗？），找到适合自己记忆的方法。</em></p>\n","site":{"data":{}},"more":"<ul>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> 基础篇</li>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> 架构篇</li>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> 存储引擎</li>\n<li><input disabled=\"\" type=\"checkbox\"> 日志管理</li>\n<li><input disabled=\"\" type=\"checkbox\"> SQL调优</li>\n<li><input disabled=\"\" type=\"checkbox\"> 索引</li>\n<li><input disabled=\"\" type=\"checkbox\"> 锁</li>\n<li><input disabled=\"\" type=\"checkbox\"> 事务</li>\n<li><input disabled=\"\" type=\"checkbox\"> 高可用/性能</li>\n<li><input disabled=\"\" type=\"checkbox\"> 运维</li>\n</ul>\n<h1 id=\"MySQL形象八股文，不形象你打我\"><a href=\"#MySQL形象八股文，不形象你打我\" class=\"headerlink\" title=\"MySQL形象八股文，不形象你打我\"></a>MySQL形象八股文，不形象你打我</h1><p><em>首先，自我洗脑：MySQL不难！MySQL不难！MySQL不难！！！</em></p>\n<blockquote>\n<p>学习 MySQL 之前，我们先问问自己什么是 MySQL ？他是一个关系型数据库（<strong>R-DBMS：relational database manage system</strong>），顾名思义就是用于存放数据的。</p>\n<p>为什么大家都学 MySQL ，有什么优点？用我的屁股想一想，首先肯定稳定、好用、免费，再加其他的优点，所以就被广泛使用了。</p>\n<p>🆗，那我们就话不多说，下面围绕 MySQL 就是一个存放数据的房子的理念（什么？放数据的房子？那么就是快递驿站吗），浅析 MySQL！</p>\n</blockquote>\n<h2 id=\"基础篇\"><a href=\"#基础篇\" class=\"headerlink\" title=\"基础篇\"></a>基础篇</h2><blockquote>\n<p>Q：什么是数据库第一二三范式？</p>\n</blockquote>\n<p>  A：</p>\n<ul>\n<li>第一范式：又称专一范式，字段不能再拆分；</li>\n<li>第二范式：又称 MySQL 家规，必须完全依赖顺从主键，若有与主键无关字段者，设置为联合主键；</li>\n<li>第三范式：又称恋爱脑范式，遵守家规，远离小三。</li>\n</ul>\n<p><img src=\"https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311181056209.jpeg\" alt=\"img\"></p>\n<p>一般来说，“<code>小企</code>”这个渣男（也可能不止<code>小企</code>）在日常开发中都是违反<code>范式家规</code>标准的，要为了性能，通过一些冗余的数据，空间换时间。</p>\n<blockquote>\n<p>Q：MySQL 有几种字段类型？</p>\n</blockquote>\n<p>  A：字段类型大致可以分为三类：数值类型、字符类型、时间类型</p>\n<ul>\n<li><p>数值类型：</p>\n<ul>\n<li><p>整数类型：微小TYNYINT、小SMALLINT、中等MEDIUMINT、INT、大整型BIGINT；</p>\n</li>\n<li><p>小数类型：FLOAT、DUBBLE、DECIMAL、NUMERIC</p>\n</li>\n</ul>\n</li>\n<li><p>字符类型：（还有好几种）</p>\n<ul>\n<li><p>CHAR</p>\n</li>\n<li><p>VARCHAR</p>\n</li>\n<li><p>BINARY</p>\n</li>\n<li><p>VARBINARY</p>\n</li>\n<li><p>BLOB        </p>\n<ul>\n<li>二进制大对象类型，用于存储二进制数据（如文档、图像、音频等），有两个分支，小TINYBLOB和长LONGBLOB</li>\n</ul>\n</li>\n<li><p>TEXT</p>\n<ul>\n<li>文本类型，不许预设长度，可根据需要动态划分空间。也分为 TINYTEXT 和 LONGTEXT，以适应不同大小的文本数据</li>\n</ul>\n</li>\n<li><p>ENUM</p>\n<ul>\n<li>枚举类型，限制了字段存储的值</li>\n</ul>\n</li>\n<li><p>SET</p>\n<ul>\n<li>集合类型，不可重复</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>日期/时间类型</p>\n<ul>\n<li>DATE</li>\n<li>TIME    </li>\n<li>DATETIME</li>\n<li>TIMESTAMP</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>Q：CHAR 和 VARCHAR 字符类型的区别?</p>\n</blockquote>\n<p>  A：</p>\n<ul>\n<li><code>char</code>长度固定，所以存取速度快，甚至快varchar一半；如果长度没有达到预设值，用空格补充。因为定长，所以浪费一些空间，属于空间换时间。最多可存<code>255</code>个字符；</li>\n<li><code>varchar</code>字符长度可变，所以不浪费空间，属于时间换空间。最多可存放<code>65532</code>个字符串，至于为什么是<code>65532</code>，那就需要看相关存储引擎<code>InnoDB</code>的知识了。</li>\n</ul>\n<blockquote>\n<p>Q：说一说两个<strong>时间类型</strong>的区别</p>\n</blockquote>\n<p>  A：</p>\n<ul>\n<li>时间起始范围不同，<code>TIMESTAMP</code>为<code>1970-2028</code>，<code>datetime</code>为<code>1000-9999</code></li>\n<li>存储空间不同，<code>TIMESTAMP</code>存储空间为<code>4字节</code>，<code>DATETIME</code>存储空间为<code>8字节</code></li>\n<li>时区，<code>TIMESTAMP</code>存储时间依赖于时区显示，<code>DATETIME</code>存储时间与时区无关</li>\n<li>默认值，<code>TIMESTAMP</code>不为空，后者为空</li>\n</ul>\n<blockquote>\n<p>Q：什么类型可以用于存储二进制数据？</p>\n</blockquote>\n<p>A：blob，Blob常常是数据库中用来存储二进制文件的字段类型。通常用于存储大量的数据，例如音频、视频、图片等文件，由于它们的大小，必须使用特殊的方式来处理（例如：上传、下载或者存放到一个数据库）。</p>\n<blockquote>\n<p>Q：怎么存储<code>emoji</code>表情？</p>\n</blockquote>\n<p>A：</p>\n<blockquote>\n<p>Q：你了解 SQL 的执行流程吗？</p>\n</blockquote>\n<p>A：为了更加直观，借用<code>三元表达式</code>的语法来描述一条 SQL 执行的流程。</p>\n<ol>\n<li>首先检查 SQL 是否有执行的权限？ 查询结果缓存 ：返回报错信息；</li>\n<li>是否有缓存？ 直接返回结果 ：检查 SQL 是否有语法错误；</li>\n<li>语法正确？ MySQL 的服务器对语句进行优化，确定执行方案 ：</li>\n<li>确定方案？调用数据库引擎接口，执行方案，返回执行结果。</li>\n</ol>\n<blockquote>\n<p>Q：什么是 DDL 与 DML ?</p>\n</blockquote>\n<p>A：是 DBMS 中的不同类型的语言指令集。</p>\n<ul>\n<li>DDL：database definition language，定义或修改数据库结构的命令，例如：CREAT、ALTER、DROP、TRUNCATE(截断，命令用于快速删除表中的所有数据但不删除表本身。)</li>\n<li>DML：database manipulation language，用于操作数据库中的数据的命令，例如CURD</li>\n</ul>\n<h2 id=\"架构篇\"><a href=\"#架构篇\" class=\"headerlink\" title=\"架构篇\"></a>架构篇</h2><p>首先，收起你自认为架构篇很难理解的想法，我们还是从 MySQL 是一个房子入手。</p>\n<blockquote>\n<p>Q：你是怎么理解 MySQL 的架构的？</p>\n</blockquote>\n<p>A：MySQL 就相当于一个档案室，存放不同的档案，一个数据库好用，肯定有原因，架构也就是构成。那么一个快递驿站肯定包括下面这三部分：</p>\n<ul>\n<li>快递驿站APP–客户端（与用户交互的关键）</li>\n<li>工作人员–存储引擎（我 MySQL 学的不好，我猜应该是与存储规则相关的）</li>\n<li>快递货架–服务层（堆放数据，索引数据）</li>\n</ul>\n<p><code>&#123;&#123;&#123;&#123;&#123;&#123;待画图！！！&#125;&#125;&#125;&#125;&#125;&#125;</code></p>\n<p>MySQL 逻辑架构图主要分为三层：客户端、存储引擎、服务层</p>\n<ol>\n<li>客户端层：这是与 MySQL 服务器交互的接口，它提供了用户与服务器进行通信的手段。客户端层处理连接请求、处理查询请求、认证用户权限以及执行与服务器之间的通信。此外，这一层还负责处理与服务相关的各种任务，例如管理连接、处理错误、诊断和调试等。</li>\n<li>Server 层：这一层是 MySQL 的核心，它包含了大多数 MySQL 的服务功能。这包括解析查询语句、分析查询计划、优化查询计划以及执行查询计划等。此外，Server 层还负责处理内置函数，如日期、时间、数学和加密函数等。对于跨存储引擎的功能，如存储过程、触发器和视图等，也都在这一层实现。这些功能对于整个数据库系统来说是至关重要的。</li>\n<li>存储引擎层：这一层负责数据的存储和提取。存储引擎负责与底层操作系统交互，管理数据的存储位置、文件格式和索引等。不同的存储引擎具有不同的特点和性能，可以根据应用的需求选择适合的存储引擎。MySQL 支持多种存储引擎，如 InnoDB、MyISAM、Memory 等。存储引擎通过 API 与 Server 层进行通信，这些接口屏蔽了不同存储引擎之间的差异，使得上层的应用程序可以透明地访问底层的数据存储方式。</li>\n</ol>\n<p><img src=\"https://cs-wlei224.obs.cn-south-1.myhuaweicloud.com/blog-imgs/202311201957518.png\" alt=\"img\"></p>\n<blockquote>\n<p>Q：数据库调优，你是怎么做的</p>\n</blockquote>\n<p>A：以下回答来自文心一言，待优化，回答要结合MySQL的<strong>架构以及存储引擎</strong>来说，以及自己的见解</p>\n<p>数据库调优的方法有很多，以下是一些常见的调优方法：</p>\n<ol>\n<li>定期优化重建数据库：定期对数据库进行优化和重建，可以消除数据库中的碎片和冗余数据，提高数据库的性能和稳定性。</li>\n<li>减少磁盘写入操作：通过使用缓存技术、优化数据插入和更新操作、避免频繁的磁盘操作等手段，可以减少磁盘的写入操作，提高数据库的性能。</li>\n<li>合理使用索引：索引是提高查询速度的重要手段，通过添加合适的索引可以加速查询操作。需要根据查询语句和表结构来确定需要添加的索引。</li>\n<li>优化SQL语句：通过优化SQL语句，可以减少数据库的负载和提高查询效率。例如，避免使用SELECT * 语句，只查询需要的数据字段；避免在查询中使用复杂的子查询和连接查询等。</li>\n<li>调整数据库参数：根据实际需求和性能测试结果，调整数据库的参数可以提高数据库的性能和响应速度。</li>\n<li>使用存储过程和触发器：存储过程和触发器可以减少数据库的负载和提高数据处理效率。通过将常用的数据处理逻辑封装到存储过程和触发器中，可以减少对数据库的频繁操作。</li>\n<li>数据库分区：对于大型数据库，可以采用分区技术将数据分散到不同的磁盘上，提高I/O处理能力和并发性能。</li>\n<li>使用RAID技术：RAID技术可以提供高性能、高可靠性和高容错的存储系统，通过将数据分散到多个磁盘上，可以提高I/O处理能力和数据安全性。</li>\n<li>使用缓存技术：缓存技术可以减少磁盘访问次数和提高数据处理速度。例如，使用内存缓存来存储经常访问的数据，减少对磁盘的访问次数。</li>\n<li>定期备份数据：定期备份数据可以防止数据丢失和灾难性故障，同时也可以提高数据处理效率和安全性。</li>\n</ol>\n<p>这些方法可以根据实际情况选择使用，但需要注意的是，数据库调优是一个复杂的过程，需要综合考虑系统硬件、应用程序和数据等方面的因素。因此，在进行数据库调优时，建议根据实际情况进行测试和评估，以确保达到最佳的效果。</p>\n<blockquote>\n<p>Q：你知道三种存储引擎的区别吗？</p>\n</blockquote>\n<p>A：</p>\n<table>\n<thead>\n<tr>\n<th>功能</th>\n<th>MlSAM</th>\n<th>MEMORY</th>\n<th>InnoDB</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>存储限制</td>\n<td>256TB</td>\n<td>RAM</td>\n<td>64TB</td>\n</tr>\n<tr>\n<td>支持事务</td>\n<td>No</td>\n<td>No</td>\n<td>Yes</td>\n</tr>\n<tr>\n<td>支持全文索引</td>\n<td>Yes</td>\n<td>No</td>\n<td>Yes</td>\n</tr>\n<tr>\n<td>支持树索引</td>\n<td>Yes</td>\n<td>Yes</td>\n<td>Yes</td>\n</tr>\n<tr>\n<td>支持哈希索引</td>\n<td>No</td>\n<td>Yes</td>\n<td>Yes</td>\n</tr>\n<tr>\n<td>支持数据缓存</td>\n<td>No</td>\n<td>N/A</td>\n<td>Yes</td>\n</tr>\n<tr>\n<td>支持外键</td>\n<td>No</td>\n<td>No</td>\n<td>Yes</td>\n</tr>\n</tbody></table>\n<p>怎么选择存储引擎的使用？</p>\n<ol>\n<li>想用事务安全，并要求实现并发控制，用InnoDB</li>\n<li>主要用来查询与插入记录，用MyISAM</li>\n<li>临时存放数据，不考虑安全，用MEMORY</li>\n</ol>\n<p><strong>tips：存储引擎是基于数据表</strong>的，所以一个数据库的多个表<strong>可以根据实际业务</strong>，来<strong>使用不同的存储引擎</strong>，以此<strong>提高</strong>整个数据库的<strong>性能</strong>。</p>\n<table>\n<thead>\n<tr>\n<th>区别</th>\n<th>MyISAM</th>\n<th>InnoDB</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>存储结构</td>\n<td>每个表存储成3个文件：表定义文件（.frm）数据文件（.MYD）索引文件（.MYI）</td>\n<td>所有表存放于同一数据文件，也可能多个文件或者独立的表空间文件，表的大小一般为2G</td>\n</tr>\n<tr>\n<td>事务</td>\n<td>不支持</td>\n<td>支持</td>\n</tr>\n<tr>\n<td>最小锁粒度</td>\n<td>表级锁，更新会锁表，导致其他查询与插入阻塞</td>\n<td>行级锁</td>\n</tr>\n<tr>\n<td>索引类型</td>\n<td>非聚簇索引，B树</td>\n<td>聚簇索引，B+树</td>\n</tr>\n<tr>\n<td>主键</td>\n<td>可无</td>\n<td>如未设置，自动生成（用户不可见）</td>\n</tr>\n<tr>\n<td>外键</td>\n<td>不支持</td>\n<td>支持</td>\n</tr>\n<tr>\n<td>表行数</td>\n<td>存有缓存，直接取出</td>\n<td>需要遍历整个表</td>\n</tr>\n</tbody></table>\n<p><em>🆗架构篇就到这里，有没发现，似乎MySQL的基础架构也就这回事，也没啥难点。最后强调一点，当我们试图学会一门知识的时候，不要机械记忆，重要的是融会贯通（内心OS：啥子贯通？不就是理论翻译成人话吗？），找到适合自己记忆的方法。</em></p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"clpkiczi50001fkfo0wuc9ogi","category_id":"clpkiczia0003fkfo9m8udeyr","_id":"clpkiczij000dfkfoecfth3ew"},{"post_id":"clpkiczi80002fkfo0qsf326y","category_id":"clpkiczia0003fkfo9m8udeyr","_id":"clpkiczil000ifkfocucyac5m"},{"post_id":"clpkiczik000ffkfo5wgfa3n1","category_id":"clpkiczia0003fkfo9m8udeyr","_id":"clpkiczio000ofkfocoi9150c"},{"post_id":"clpkiczic0005fkfo93zbgbsp","category_id":"clpkiczij000cfkfo9igcfz4l","_id":"clpkicziq000sfkfo6vns040l"},{"post_id":"clpkiczil000hfkfoer3x5oxs","category_id":"clpkiczia0003fkfo9m8udeyr","_id":"clpkiczis000vfkfogq0g0tts"},{"post_id":"clpkiczim000mfkfofp3nae2n","category_id":"clpkiczia0003fkfo9m8udeyr","_id":"clpkiczit0010fkfoepyb8rng"},{"post_id":"clpkiczid0006fkfofnw5et4t","category_id":"clpkiczim000kfkfo1getdz6f","_id":"clpkicziu0013fkfoccukh83r"},{"post_id":"clpkicziq000rfkfo7j3ca748","category_id":"clpkiczia0003fkfo9m8udeyr","_id":"clpkicziv0016fkfoabj3cpjw"},{"post_id":"clpkiczie0007fkfo7qat1aez","category_id":"clpkiczip000qfkfo2plw1u7i","_id":"clpkicziw0019fkfo0bimhv5e"},{"post_id":"clpkiczir000ufkfoe6be08wp","category_id":"clpkiczia0003fkfo9m8udeyr","_id":"clpkicziw001bfkfo9hrqf7aw"},{"post_id":"clpkiczih000afkfo3ex10wnn","category_id":"clpkiczis000yfkfo8jw2aeaz","_id":"clpkicziy001ffkfoeyc1covv"},{"post_id":"clpkicziu0015fkfo6w396mvj","category_id":"clpkiczia0003fkfo9m8udeyr","_id":"clpkicziy001hfkfo7apla7w4"},{"post_id":"clpkicziv0018fkfofwaz5dy1","category_id":"clpkiczis000yfkfo8jw2aeaz","_id":"clpkicziz001mfkfod1icfhsy"},{"post_id":"clpkiczii000bfkfocwkw63wp","category_id":"clpkicziv0017fkfob5nk5op0","_id":"clpkiczj0001ofkfobwa02pde"},{"post_id":"clpkicziw001afkfo4o02gvdc","category_id":"clpkiczis000yfkfo8jw2aeaz","_id":"clpkiczj2001sfkfoa8us66he"},{"post_id":"clpkiczix001efkfoauvdh58t","category_id":"clpkiczis000yfkfo8jw2aeaz","_id":"clpkiczj2001ufkfo0s1q2ker"},{"post_id":"clpkiczio000nfkfofr7yhbc9","category_id":"clpkiczis000yfkfo8jw2aeaz","_id":"clpkiczj4001xfkfo1vko6ss5"},{"post_id":"clpkicziy001gfkfofz08hegw","category_id":"clpkiczim000kfkfo1getdz6f","_id":"clpkiczj5001zfkfo26gcgdow"},{"post_id":"clpkicziz001lfkfo3tjjgjz8","category_id":"clpkiczim000kfkfo1getdz6f","_id":"clpkiczj60022fkfo9lp7cf5t"},{"post_id":"clpkiczis000zfkfo254fdkw5","category_id":"clpkicziy001ifkfo77udby0u","_id":"clpkiczj70026fkfoej7812ij"},{"post_id":"clpkiczj0001nfkfo0m9x2hlg","category_id":"clpkiczis000yfkfo8jw2aeaz","_id":"clpkiczj7002afkfo6zl7amiy"},{"post_id":"clpkiczit0012fkfofud29m9q","category_id":"clpkiczj1001pfkfo7sqpewc7","_id":"clpkiczj9002efkfo3q5d66j5"},{"post_id":"clpkiczj2001tfkfofb7o26a3","category_id":"clpkiczim000kfkfo1getdz6f","_id":"clpkiczja002hfkfo1wae84ii"},{"post_id":"clpkiczj50021fkfo79ap07jw","category_id":"clpkiczj1001pfkfo7sqpewc7","_id":"clpkiczjb002lfkfo0zt53nsm"},{"post_id":"clpkiczj60025fkfogzctee32","category_id":"clpkiczj1001pfkfo7sqpewc7","_id":"clpkiczjc002ofkfo9x4zcagj"},{"post_id":"clpkiczj3001wfkfogw3029ne","category_id":"clpkiczj50020fkfo74jyfpdv","_id":"clpkiczje002tfkfoahzl0aw7"},{"post_id":"clpkiczj8002dfkfof28r4sn7","category_id":"clpkiczim000kfkfo1getdz6f","_id":"clpkiczje002wfkfohpflfs8b"},{"post_id":"clpkiczj4001yfkfo5k4wflkj","category_id":"clpkiczj70029fkfo2sso5bhe","_id":"clpkiczjf002zfkfo9uhz1inv"},{"post_id":"clpkiczj9002gfkfo9c7tc510","category_id":"clpkiczim000kfkfo1getdz6f","_id":"clpkiczjh0033fkfoapxw8m4r"},{"post_id":"clpkiczjc002nfkfo5599dkyd","category_id":"clpkiczip000qfkfo2plw1u7i","_id":"clpkiczjh0035fkfof2669l3p"},{"post_id":"clpkiczje002vfkfohe014v6q","category_id":"clpkiczj1001pfkfo7sqpewc7","_id":"clpkiczji0038fkfo6rko6uvl"},{"post_id":"clpkiczja002kfkfo7j9y7hii","category_id":"clpkiczjd002pfkfo76wk7yus","_id":"clpkiczjj003bfkfo5p4gfebb"},{"post_id":"clpkiczjf002yfkfo3gcge6jj","category_id":"clpkiczjd002pfkfo76wk7yus","_id":"clpkiczjk003ffkfo0gcwbw1l"},{"post_id":"clpkiczjg0032fkfo2tw5b6dy","category_id":"clpkiczis000yfkfo8jw2aeaz","_id":"clpkiczjl003ifkfo893tdnyq"},{"post_id":"clpkiczjh0034fkfoeb0chvon","category_id":"clpkiczim000kfkfo1getdz6f","_id":"clpkiczjm003mfkfo8ghtbe2y"},{"post_id":"clpkiczjj003afkfo87tta7mc","category_id":"clpkiczim000kfkfo1getdz6f","_id":"clpkiczjn003pfkfobi1c649i"},{"post_id":"clpkiczjk003efkfog5r9dqtf","category_id":"clpkiczis000yfkfo8jw2aeaz","_id":"clpkiczjo003rfkfo3p9323jv"},{"post_id":"clpkiczjl003hfkfo8j7ia6vr","category_id":"clpkiczip000qfkfo2plw1u7i","_id":"clpkiczjo003tfkfo2libh4gi"},{"post_id":"clpkiczjl003lfkfobyvs1fgc","category_id":"clpkicziy001ifkfo77udby0u","_id":"clpkiczjp003ufkfochu94rn5"},{"post_id":"clpkiczjm003ofkfo4eqi1v8n","category_id":"clpkiczis000yfkfo8jw2aeaz","_id":"clpkiczjp003xfkfo2tau6rsd"}],"PostTag":[{"post_id":"clpkiczi50001fkfo0wuc9ogi","tag_id":"clpkiczib0004fkfo7c70arif","_id":"clpkiczik000gfkfo2k5gfaeg"},{"post_id":"clpkiczi50001fkfo0wuc9ogi","tag_id":"clpkiczif0009fkfo4qiodfwc","_id":"clpkiczil000jfkfo0pip0bfv"},{"post_id":"clpkiczi80002fkfo0qsf326y","tag_id":"clpkiczib0004fkfo7c70arif","_id":"clpkicziq000tfkfohegj785f"},{"post_id":"clpkiczi80002fkfo0qsf326y","tag_id":"clpkiczif0009fkfo4qiodfwc","_id":"clpkiczis000wfkfo047obrmv"},{"post_id":"clpkiczic0005fkfo93zbgbsp","tag_id":"clpkiczip000pfkfo5fe554b0","_id":"clpkiczit0011fkfo2u192b3y"},{"post_id":"clpkiczix001efkfoauvdh58t","tag_id":"clpkicziw001cfkfo6ljr6pmi","_id":"clpkicziz001kfkfoehlvgey3"},{"post_id":"clpkiczid0006fkfofnw5et4t","tag_id":"clpkiczis000xfkfoepada4oi","_id":"clpkiczj60024fkfo3qby2sdl"},{"post_id":"clpkiczid0006fkfofnw5et4t","tag_id":"clpkicziu0014fkfo9g7w2c9a","_id":"clpkiczj70027fkfo301n1aqj"},{"post_id":"clpkiczid0006fkfofnw5et4t","tag_id":"clpkicziw001cfkfo6ljr6pmi","_id":"clpkiczj8002cfkfof6gi392w"},{"post_id":"clpkiczid0006fkfofnw5et4t","tag_id":"clpkicziz001jfkfo6cr7g3v3","_id":"clpkiczj9002ffkfo8rek8e06"},{"post_id":"clpkiczid0006fkfofnw5et4t","tag_id":"clpkiczj1001qfkfo4drp4xra","_id":"clpkiczja002jfkfo0tup1qdu"},{"post_id":"clpkiczid0006fkfofnw5et4t","tag_id":"clpkiczj3001vfkfod8biagf4","_id":"clpkiczjc002mfkfo1l395xo8"},{"post_id":"clpkiczie0007fkfo7qat1aez","tag_id":"clpkiczj60023fkfo37ftb739","_id":"clpkiczjd002rfkfo57j1ek7i"},{"post_id":"clpkiczih000afkfo3ex10wnn","tag_id":"clpkiczj8002bfkfo4o8r1i5a","_id":"clpkiczje002ufkfo01d51ymh"},{"post_id":"clpkiczii000bfkfocwkw63wp","tag_id":"clpkiczja002ifkfo2kmt180w","_id":"clpkiczjf002xfkfo5zlb5445"},{"post_id":"clpkiczjc002nfkfo5599dkyd","tag_id":"clpkicziz001jfkfo6cr7g3v3","_id":"clpkiczjg0031fkfo2hy37umz"},{"post_id":"clpkiczjh0034fkfoeb0chvon","tag_id":"clpkiczis000xfkfoepada4oi","_id":"clpkiczjj0039fkfoagau6xyx"},{"post_id":"clpkiczjh0034fkfoeb0chvon","tag_id":"clpkicziz001jfkfo6cr7g3v3","_id":"clpkiczjk003dfkfodk4ebdfl"},{"post_id":"clpkiczik000ffkfo5wgfa3n1","tag_id":"clpkiczjd002qfkfo2zbe8o0h","_id":"clpkiczjk003gfkfoa8a93kgr"},{"post_id":"clpkiczik000ffkfo5wgfa3n1","tag_id":"clpkiczjf0030fkfo1x5ff228","_id":"clpkiczjl003jfkfo05il1hld"},{"post_id":"clpkiczik000ffkfo5wgfa3n1","tag_id":"clpkiczji0036fkfofom37977","_id":"clpkiczjm003nfkfohu8r40uk"},{"post_id":"clpkiczjl003hfkfo8j7ia6vr","tag_id":"clpkicziz001jfkfo6cr7g3v3","_id":"clpkiczjn003qfkfo41ok3z7r"},{"post_id":"clpkiczil000hfkfoer3x5oxs","tag_id":"clpkiczjj003cfkfodyyk396n","_id":"clpkiczjp003wfkfo3h8qhe48"},{"post_id":"clpkiczil000hfkfoer3x5oxs","tag_id":"clpkiczjl003kfkfoeoy296n7","_id":"clpkiczjp003yfkfo51co6y8n"},{"post_id":"clpkiczil000hfkfoer3x5oxs","tag_id":"clpkiczjf0030fkfo1x5ff228","_id":"clpkiczjp0040fkfoauqocji9"},{"post_id":"clpkiczim000mfkfofp3nae2n","tag_id":"clpkiczjp003vfkfo4iit0e3x","_id":"clpkiczjq0043fkfo1gj0h03i"},{"post_id":"clpkiczim000mfkfofp3nae2n","tag_id":"clpkiczjp003zfkfo3g2w3tpx","_id":"clpkiczjq0044fkfo1clk1e0x"},{"post_id":"clpkiczim000mfkfofp3nae2n","tag_id":"clpkiczjp0041fkfoc82964ed","_id":"clpkiczjq0046fkfo2qmv5zwx"},{"post_id":"clpkiczio000nfkfofr7yhbc9","tag_id":"clpkiczja002ifkfo2kmt180w","_id":"clpkiczjq0047fkfobzq1azi6"},{"post_id":"clpkicziq000rfkfo7j3ca748","tag_id":"clpkiczjq0045fkfoh68t2qcy","_id":"clpkiczjr004afkfockv96s2p"},{"post_id":"clpkicziq000rfkfo7j3ca748","tag_id":"clpkiczjq0048fkfo00n124x3","_id":"clpkiczjr004bfkfo18uf6ec9"},{"post_id":"clpkiczir000ufkfoe6be08wp","tag_id":"clpkiczjd002qfkfo2zbe8o0h","_id":"clpkiczjs004efkfo47fygk18"},{"post_id":"clpkiczir000ufkfoe6be08wp","tag_id":"clpkiczjf0030fkfo1x5ff228","_id":"clpkiczjs004ffkfo7sf3hdyn"},{"post_id":"clpkiczis000zfkfo254fdkw5","tag_id":"clpkiczjr004dfkfod12d2mgj","_id":"clpkiczjs004hfkfo4zt56w6s"},{"post_id":"clpkiczit0012fkfofud29m9q","tag_id":"clpkiczjs004gfkfoegjvduv8","_id":"clpkiczjs004jfkfo88xz1bjy"},{"post_id":"clpkicziu0015fkfo6w396mvj","tag_id":"clpkiczjs004ifkfo9a5wdq7x","_id":"clpkiczjt004lfkfodgmqe7kd"},{"post_id":"clpkicziv0018fkfofwaz5dy1","tag_id":"clpkiczjs004kfkfo6m2o6sn0","_id":"clpkiczjt004nfkfo7imk8bea"},{"post_id":"clpkicziw001afkfo4o02gvdc","tag_id":"clpkiczja002ifkfo2kmt180w","_id":"clpkiczjt004pfkfo8jlj2i40"},{"post_id":"clpkicziy001gfkfofz08hegw","tag_id":"clpkiczjt004ofkfo8vpmdc6l","_id":"clpkiczjv004vfkfoeh1a8mqs"},{"post_id":"clpkicziy001gfkfofz08hegw","tag_id":"clpkiczju004qfkfo85snhvfe","_id":"clpkiczjv004wfkfo2l2a1svj"},{"post_id":"clpkicziy001gfkfofz08hegw","tag_id":"clpkiczju004rfkfo0afv6nvr","_id":"clpkiczjv004yfkfobymg7gdk"},{"post_id":"clpkicziy001gfkfofz08hegw","tag_id":"clpkiczis000xfkfoepada4oi","_id":"clpkiczjv004zfkfoa88zgcfp"},{"post_id":"clpkicziy001gfkfofz08hegw","tag_id":"clpkicziz001jfkfo6cr7g3v3","_id":"clpkiczjv0051fkfo9pjafagr"},{"post_id":"clpkicziy001gfkfofz08hegw","tag_id":"clpkiczju004tfkfoflyt97qf","_id":"clpkiczjv0052fkfohhlf5gel"},{"post_id":"clpkicziz001lfkfo3tjjgjz8","tag_id":"clpkiczju004ufkfo8rty3l0m","_id":"clpkiczjw0055fkfo40tncrrs"},{"post_id":"clpkicziz001lfkfo3tjjgjz8","tag_id":"clpkiczjv004xfkfocya7hl3u","_id":"clpkiczjw0056fkfofvv8gw1j"},{"post_id":"clpkicziz001lfkfo3tjjgjz8","tag_id":"clpkiczjv0050fkfo671n8a7a","_id":"clpkiczjx0058fkfo71ek2002"},{"post_id":"clpkicziz001lfkfo3tjjgjz8","tag_id":"clpkiczjw0053fkfo9n150zfv","_id":"clpkiczjx0059fkfociaz1wyq"},{"post_id":"clpkiczj0001nfkfo0m9x2hlg","tag_id":"clpkiczja002ifkfo2kmt180w","_id":"clpkiczjy005bfkfo4rdz26dc"},{"post_id":"clpkiczj2001tfkfofb7o26a3","tag_id":"clpkiczjw0057fkfo4tmh8xv3","_id":"clpkiczk0005hfkfof19c025q"},{"post_id":"clpkiczj2001tfkfofb7o26a3","tag_id":"clpkiczjx005afkfo8msd3gkv","_id":"clpkiczk0005ifkfog2bdh6m8"},{"post_id":"clpkiczj2001tfkfofb7o26a3","tag_id":"clpkiczjy005cfkfo6syk8590","_id":"clpkiczk0005kfkfohymk9upa"},{"post_id":"clpkiczj2001tfkfofb7o26a3","tag_id":"clpkiczjy005dfkfo5fmu64tn","_id":"clpkiczk1005lfkfoflvhcjg7"},{"post_id":"clpkiczj2001tfkfofb7o26a3","tag_id":"clpkiczjz005efkfo04h19b5c","_id":"clpkiczk1005nfkfoeszw04qx"},{"post_id":"clpkiczj2001tfkfofb7o26a3","tag_id":"clpkiczis000xfkfoepada4oi","_id":"clpkiczk1005ofkfo3jcebcsn"},{"post_id":"clpkiczj2001tfkfofb7o26a3","tag_id":"clpkiczjz005ffkfo0mdtfcle","_id":"clpkiczk2005qfkfodyto2y9s"},{"post_id":"clpkiczj3001wfkfogw3029ne","tag_id":"clpkiczjz005gfkfoegsc2xzj","_id":"clpkiczk2005rfkfo9nqehuhb"},{"post_id":"clpkiczj4001yfkfo5k4wflkj","tag_id":"clpkiczk0005jfkfoakjp28f7","_id":"clpkiczk3005tfkfo80w99g90"},{"post_id":"clpkiczj50021fkfo79ap07jw","tag_id":"clpkiczk1005mfkfo5gmyf5g3","_id":"clpkiczk3005ufkfohvgo6em9"},{"post_id":"clpkiczj60025fkfogzctee32","tag_id":"clpkiczk1005mfkfo5gmyf5g3","_id":"clpkiczk3005vfkfohaw45on7"},{"post_id":"clpkiczj8002dfkfof28r4sn7","tag_id":"clpkiczk2005sfkfogavf8qgn","_id":"clpkiczk3005xfkfobeckf30u"},{"post_id":"clpkiczj9002gfkfo9c7tc510","tag_id":"clpkiczk3005wfkfofcl92hbw","_id":"clpkiczk3005zfkfohom2f2o7"},{"post_id":"clpkiczja002kfkfo7j9y7hii","tag_id":"clpkiczjv0050fkfo671n8a7a","_id":"clpkiczk40062fkfo0moo55bd"},{"post_id":"clpkiczja002kfkfo7j9y7hii","tag_id":"clpkiczk30060fkfo11j41sdo","_id":"clpkiczk40063fkfobnmugheu"},{"post_id":"clpkiczje002vfkfohe014v6q","tag_id":"clpkiczk1005mfkfo5gmyf5g3","_id":"clpkiczk40065fkfo8335bus7"},{"post_id":"clpkiczjf002yfkfo3gcge6jj","tag_id":"clpkiczk40064fkfody848tf6","_id":"clpkiczk50067fkfo9dq8bktm"},{"post_id":"clpkiczjg0032fkfo2tw5b6dy","tag_id":"clpkiczk40066fkfo9frphy6o","_id":"clpkiczk50069fkfodk8cdui0"},{"post_id":"clpkiczji0037fkfocygd3y8h","tag_id":"clpkiczk50068fkfod3c19a9f","_id":"clpkiczk5006bfkfohlihcw6y"},{"post_id":"clpkiczjj003afkfo87tta7mc","tag_id":"clpkiczis000xfkfoepada4oi","_id":"clpkiczk7006jfkfo5l6pf6mf"},{"post_id":"clpkiczjj003afkfo87tta7mc","tag_id":"clpkiczk5006afkfodq2z07ag","_id":"clpkiczk7006kfkfobv8r6imu"},{"post_id":"clpkiczjj003afkfo87tta7mc","tag_id":"clpkiczk6006cfkfod7ysgkb3","_id":"clpkiczk8006mfkfo7ny20z8s"},{"post_id":"clpkiczjj003afkfo87tta7mc","tag_id":"clpkiczk6006dfkfo5tu75v41","_id":"clpkiczk8006nfkfo50z26uif"},{"post_id":"clpkiczjj003afkfo87tta7mc","tag_id":"clpkiczk6006efkfo0a0a4jlm","_id":"clpkiczk8006pfkfo37uhhkoe"},{"post_id":"clpkiczjj003afkfo87tta7mc","tag_id":"clpkiczjs004kfkfo6m2o6sn0","_id":"clpkiczk8006qfkfo4ute591z"},{"post_id":"clpkiczjj003afkfo87tta7mc","tag_id":"clpkicziz001jfkfo6cr7g3v3","_id":"clpkiczk8006sfkfobmkzb92z"},{"post_id":"clpkiczjj003afkfo87tta7mc","tag_id":"clpkiczk7006gfkfohl92chhg","_id":"clpkiczk8006tfkfof7soce4z"},{"post_id":"clpkiczjj003afkfo87tta7mc","tag_id":"clpkiczk7006hfkfo1xejer5k","_id":"clpkiczk8006ufkfocll371vw"},{"post_id":"clpkiczjk003efkfog5r9dqtf","tag_id":"clpkiczk7006ifkfockp030bb","_id":"clpkiczk9006wfkfo3xbm4pb1"},{"post_id":"clpkiczjk003efkfog5r9dqtf","tag_id":"clpkiczk7006lfkfo0e7v4lph","_id":"clpkiczk9006xfkfo34ts88g1"},{"post_id":"clpkiczjl003lfkfobyvs1fgc","tag_id":"clpkiczk8006ofkfo4n0i2otu","_id":"clpkiczk9006yfkfodrew9t3d"},{"post_id":"clpkiczjl003lfkfobyvs1fgc","tag_id":"clpkiczj8002bfkfo4o8r1i5a","_id":"clpkiczk9006zfkfofqq05yv9"},{"post_id":"clpkiczjm003ofkfo4eqi1v8n","tag_id":"clpkiczk8006rfkfodhixhadp","_id":"clpkiczk90070fkfo003a5ix0"},{"post_id":"clpkiczjm003ofkfo4eqi1v8n","tag_id":"clpkiczk8006vfkfoh1gm0rr2","_id":"clpkiczk90071fkfo6aou07eb"}],"Tag":[{"name":"leetcode","_id":"clpkiczib0004fkfo7c70arif"},{"name":"数组双指针","_id":"clpkiczif0009fkfo4qiodfwc"},{"name":"Bugs","_id":"clpkiczip000pfkfo5fe554b0"},{"name":"Spring Boot","_id":"clpkiczis000xfkfoepada4oi"},{"name":"JSP","_id":"clpkicziu0014fkfo9g7w2c9a"},{"name":"SSM","_id":"clpkicziw001cfkfo6ljr6pmi"},{"name":"MySQL","_id":"clpkicziz001jfkfo6cr7g3v3"},{"name":"jquery","_id":"clpkiczj1001qfkfo4drp4xra"},{"name":"ajax","_id":"clpkiczj3001vfkfod8biagf4"},{"name":"DM","_id":"clpkiczj60023fkfo37ftb739"},{"name":"educoder","_id":"clpkiczj8002bfkfo4o8r1i5a"},{"name":"Java基础","_id":"clpkiczja002ifkfo2kmt180w"},{"name":"链表","_id":"clpkiczjd002qfkfo2zbe8o0h"},{"name":"递归","_id":"clpkiczjf0030fkfo1x5ff228"},{"name":"ArrayList","_id":"clpkiczji0036fkfofom37977"},{"name":"链表反转","_id":"clpkiczjj003cfkfodyyk396n"},{"name":"迭代","_id":"clpkiczjl003kfkfoeoy296n7"},{"name":"BigInteger","_id":"clpkiczjp003vfkfo4iit0e3x"},{"name":"java.math","_id":"clpkiczjp003zfkfo3g2w3tpx"},{"name":"进制转换","_id":"clpkiczjp0041fkfoc82964ed"},{"name":"“&”运算","_id":"clpkiczjq0045fkfoh68t2qcy"},{"name":"位运算","_id":"clpkiczjq0048fkfo00n124x3"},{"name":"Linux","_id":"clpkiczjr004dfkfod12d2mgj"},{"name":"Polymorphism","_id":"clpkiczjs004gfkfoegjvduv8"},{"name":"蓝桥杯","_id":"clpkiczjs004ifkfo9a5wdq7x"},{"name":"Redis","_id":"clpkiczjs004kfkfo6m2o6sn0"},{"name":"Vue","_id":"clpkiczjt004ofkfo8vpmdc6l"},{"name":"Ant Design Vue","_id":"clpkiczju004qfkfo85snhvfe"},{"name":"Lodash","_id":"clpkiczju004rfkfo0afv6nvr"},{"name":"ES","_id":"clpkiczju004tfkfoflyt97qf"},{"name":"SpringBoot","_id":"clpkiczju004ufkfo8rty3l0m"},{"name":"Mysql","_id":"clpkiczjv004xfkfocya7hl3u"},{"name":"MyBatis","_id":"clpkiczjv0050fkfo671n8a7a"},{"name":"Maven","_id":"clpkiczjw0053fkfo9n150zfv"},{"name":"Ant Design Pro","_id":"clpkiczjw0057fkfo4tmh8xv3"},{"name":"React","_id":"clpkiczjx005afkfo8msd3gkv"},{"name":"Ant Design Pro Components","_id":"clpkiczjy005cfkfo6syk8590"},{"name":"Umi","_id":"clpkiczjy005dfkfo5fmu64tn"},{"name":"Umi Request","_id":"clpkiczjz005efkfo04h19b5c"},{"name":"SDK开发","_id":"clpkiczjz005ffkfo0mdtfcle"},{"name":"CSS","_id":"clpkiczjz005gfkfoegsc2xzj"},{"name":"Git","_id":"clpkiczk0005jfkfoakjp28f7"},{"name":"网站搭建","_id":"clpkiczk1005mfkfo5gmyf5g3"},{"name":"架构师","_id":"clpkiczk2005sfkfogavf8qgn"},{"name":"云上书库","_id":"clpkiczk3005wfkfofcl92hbw"},{"name":"Logging Services","_id":"clpkiczk30060fkfo11j41sdo"},{"name":"Netty","_id":"clpkiczk40064fkfody848tf6"},{"name":"Object类","_id":"clpkiczk40066fkfo9frphy6o"},{"name":"plan","_id":"clpkiczk50068fkfod3c19a9f"},{"name":"Spring Cloud GateWay","_id":"clpkiczk5006afkfodq2z07ag"},{"name":"feign","_id":"clpkiczk6006cfkfod7ysgkb3"},{"name":"nacos","_id":"clpkiczk6006dfkfo5tu75v41"},{"name":"MongoDB","_id":"clpkiczk6006efkfo0a0a4jlm"},{"name":"JWT","_id":"clpkiczk7006gfkfohl92chhg"},{"name":"EasyExcell","_id":"clpkiczk7006hfkfo1xejer5k"},{"name":"快捷键","_id":"clpkiczk7006ifkfockp030bb"},{"name":"技巧","_id":"clpkiczk7006lfkfo0e7v4lph"},{"name":"Linux DNS","_id":"clpkiczk8006ofkfo4n0i2otu"},{"name":"八股文","_id":"clpkiczk8006rfkfodhixhadp"},{"name":"面渣逆袭","_id":"clpkiczk8006vfkfoh1gm0rr2"}]}}